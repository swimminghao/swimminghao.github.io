<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-loading-bar.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="swimminghao的学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swimminghao&#39;s blog">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="swimminghao&#39;s blog">
<meta property="og:description" content="swimminghao的学习博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swimminghao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>swimminghao's blog</title>
  




<link rel="dns-prefetch" href="waline-server-nu.vercel.app"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">swimminghao's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">33</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">133</span></a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="swimminghao"
      src="/images/lion.png">
  <p class="site-author-name" itemprop="name">swimminghao</p>
  <div class="site-description" itemprop="description">swimminghao的学习博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/swimminghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swimminghao0@gmail.com" title="E-Mail → mailto:swimminghao0@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/swimminghao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- recent posts -->
    <div class="links-of-blogroll motion-element links-of-blogroll-block">
        <div class="links-of-blogroll-title recent-posts-title">
	    <i class="fa fa-history " aria-hidden="true"></i>
            近期文章
	</div>
	<ul class="links-of-blogroll-list recent-posts-list">
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/a7472f7b/" title="在校外时利用Easy Connect连接西工大校园内网（FTP、内网资源）简易教程" target="">
		    在校外时利用Easy Connect连接西工大校园内网（FTP、内网资源）简易教程
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/b7702d4/" title="glance内存分析工具使用" target="">
		    glance内存分析工具使用
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/6aa1f673/" title="命令行的艺术" target="">
		    命令行的艺术
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/a70bb1ff/" title="手把手教你黑白群晖NAS安装破解版ROON音乐播放器1.6" target="">
		    手把手教你黑白群晖NAS安装破解版ROON音乐播放器1.6
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/61fc1c97/" title="emby-server媒体库硬链接" target="">
		    emby-server媒体库硬链接
		    </a>
		</li>
	</ul>
    </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/638ae112/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/638ae112/" class="post-title-link" itemprop="url">java垃圾回收机制</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/638ae112/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/638ae112/" data-xid="/posts/638ae112/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java垃圾回收"><a href="#java垃圾回收" class="headerlink" title="java垃圾回收"></a>java垃圾回收</h1><h2 id="一、jvm内存结构"><a href="#一、jvm内存结构" class="headerlink" title="一、jvm内存结构"></a>一、jvm内存结构</h2><p>嗯，前面提到了堆分了「新生代」和 「老年代」，「新生代」又分为「Eden」和「Survivor」区，「Survivor」区又分为「From Survivor」和「To Survivor」区</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TOrLy1_20210922150656.png"></p>
<h2 id="二、垃圾回收机制"><a href="#二、垃圾回收机制" class="headerlink" title="二、垃圾回收机制"></a>二、垃圾回收机制</h2><ul>
<li>背景</li>
</ul>
<p>我们使用Java的时候，会创建很多对象，但我们未曾「手动」将这些对象进行清除；<br>而如果用C&#x2F;C++语言的时候，用完是需要自己free（释放）掉的；<br>那为什么在写Java的时候不用我们自己手动释放”垃圾”呢？原因很简单，JVM帮我们做了（自动回收垃圾）</p>
<ul>
<li>垃圾定义</li>
</ul>
<p>我个人对垃圾的定义：只要对象不再被使用了，那我们就认为该对象就是垃圾，对象所占用的空间就可以被回收</p>
<ul>
<li><p>判断垃圾不再被使用</p>
<p>常用算法有2个：引用计数法、可达性分析法</p>
</li>
</ul>
<ol>
<li><p>引用计数法思路很简单：当对象被引用则+1，但对象引用失败则-1。当计数器为0时，说明对象不再被引用，可以被可回收<br><strong>缺点</strong>：引用计数法最明显的缺点就是：如果对象存在循环依赖，那就无法定位该对象是否应该被回收（A依赖B，B依赖A）</p>
</li>
<li><p>另一种就是可达性分析法：它从「GCR oots」开始向下搜索，当对象到「GCRoots」都没有任何引用相连时，说明对象是不可用的，可以被回收。<br>「GC Roots」是一组必须「活跃」的引用。<br>从「GC Root」出发，程序通过直接引用或者间接引用，能够找到可能正在被使用的对象。</p>
<p>例子：比如我们上次不是聊到JVM内存结构中的虚拟机栈吗，虚拟机栈里不是有栈帧吗，栈帧不是有局部变量吗？局部变量不就存储着引用嘛。<br>那如果栈帧位于虚拟机栈的栈顶，是不是说明这个栈帧是活跃的（换言之，是线程正在被调用的）<br>既然是线程正在调用的，那栈帧里的指向「堆」的对象引用，是不是一定是「活跃」的引用？</p>
<p>所以，当前活跃的栈帧指向堆里的对象引用就可以是「GCRoots」</p>
<p>当然，比如类的静态变量引用是「GCRootS」，被「Java本地方法」所引用的对象也是「GCRoots」等等。。。<br><strong>即</strong>：回到理解的重点：「GCRoots」是一组必须「活跃」的「引用」，只要跟「GCRoots」没有直接或者间接引用相连，那就是垃圾<br><strong>JVM用的就是</strong>「可达性分析算法」来判断对象是否为垃圾</p>
</li>
</ol>
<ul>
<li>垃圾回收第一步就是<strong>标记</strong></li>
</ul>
<p>标记哪些没有被「GC Roots」引用的对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/wZPvLi_20210923092156.png"></p>
<ul>
<li><p>标记完后就可以清除了</p>
<ul>
<li><p>标记完之后，我们就可以选择直接「清除」，只要不被「GCRoots」关联的，都可以干掉过程非常简单粗暴。</p>
<p><strong>但也存在很明显的问题</strong><br>直接清除会有「<strong>内存碎片</strong>」的问题：可能我有10M的空余内存，但程序申请9M内存空间却申请不下来（10M的内存空间是垃圾清除后的，不连续的）</p>
</li>
<li><p><strong>那解决「内存碎片」的问题也比较简单粗暴，「标记」完，不直接「清除」</strong><br>我把「标记」存活的对象「复制」到另一块空间，复制完了之后，直接把原有的整块空间给干掉！这样就没有内存碎片的问题了<br><strong>这种做法缺点又很明显</strong>：<strong>内存利用率低</strong>，得有一块新的区域给我复制（移动）过去</p>
</li>
<li><p>还有一种「折中」的办法，我未必要有一块「大的完整空间」才能解决内存碎片的问题，我只要能在「当前区域」内进行移动<br>把存活的对象移到一边，把垃圾移到一边，那再将垃圾一起删除掉，不就没有内存碎片了嘛，专业术语叫做<strong>整理</strong>。</p>
</li>
</ul>
</li>
<li><p>年轻代、老年代<br>「垃圾回收」是会导致「stop the word」 （应用停止访问）<br>理解「stop the word」应该很简单吧：回收垃圾的时候，程序是有短暂的时间不能正常继续运作啊。不然JVM在回收的时候，用户线程还「不停止」继续分配修改引用，JVM怎么搞（：</p>
<p>经过研究表明：大部分对象的生命周期都很短，而只有少部分对象可能会存活很长时间</p>
<ul>
<li><p>为了使「stop the word」持续的时间尽可能短以及提高并发式GC所能应付的内存分配速率<br>在很多的垃圾收集器上都会在「物理」或者「逻辑」上，把这两类对象进行区分司P<br>死得快的对象所占的区域叫做「年轻代」，活得久的对象所占的区域叫做「老年代」</p>
<p>（jdk8及以下分年轻代、老年代；高版本的垃圾收集器ZGC,是没有分代的概念的）</p>
</li>
</ul>
</li>
<li><p>垃圾回收过程：对应几种垃圾回收算法</p>
<p>其实在前面更前面提到了垃圾回收的过程，其实就对应着几种「垃圾回收算法」分别是：<br><strong>标记清除算法、标记复制算法和标记整理算法【「标记」「复制」「整理」】</strong></p>
</li>
<li><p>jdk8生产环境下常见垃圾回收器</p>
<p>「年轻代」的垃圾收集器有：Serial、Parallel Scavenge、 ParNew<br>「老年代」的垃圾收集器有：Serial Old、 Parallel Old、CMS</p>
<ul>
<li>看着垃圾收集器有很多，其实还是非常好理解的。Serial是单线程的，Parallel是多线程</li>
<li>这些垃圾收集器实际上就是「实现了」垃圾回收算法（标记复制、标记整理以及标记清除算法）</li>
<li>CMS是比较新的垃圾收集器，它的特点是能够尽可能减少「stopthe word」时间。在垃圾回收时让用户线程和GC线程能够并发执行！</li>
<li>「年轻代」的垃圾收集器使用的都是「标记复制算法」<br>所以在「堆内存」划分中，将年轻代划分出Survivor区（Survivor From和Survivor To），目的就是为了有一块完整的内存空间供垃圾回收器进行拷贝（移动），而新对象都是放入Eden区的。</li>
<li>我下面重新画下「堆内存」的图，因为它们的大小是有默认的比例的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/E2SJMc_20210923095854.png"></p>
</li>
<li><p>新生代何时会变老年代<br>分2种情况：</p>
<ol>
<li>如果对象太大了，就会直接进入老年代（对象创建时就很大 || Survivor区没办法存下该对象）</li>
<li>如果对象太老了，那就会晋升至老年代（每发生一次MinorGC，存活的对象年龄+1，达到默认值15则晋升老年代 || 动态对象年龄判定可以进入老年代）<ul>
<li>当Eden区空间不足时，就会触发MinorGC</li>
<li>那在「年轻代」GC的时候，从GC Roots出发，那不也会扫描到「老年代」的对象吗？那那那..不就相当于全堆扫描吗？<ul>
<li>这JVM里也有解决办法的。下我的看法<br>HotSpot虚拟机「老的GC」（G1以下） 是要求整个GC堆在连续的地址空间上<br>所以会有一条分界线（一侧是老年代，另一侧是年轻代），所以可以通过「地址」就可以判断对象在哪个分代上如</li>
<li>当做MonorGC的时候，从GCRoots出发，如果发现「老年代」的对象，那就不往下走了（MonorGC对老年代的区域毫无兴趣）</li>
</ul>
</li>
<li>但又有个问题，那如果年轻代」的对象被「老年代」引用了呢？（老年代对象持有年轻代对象的引用），这时候肯定是不能回收掉「年轻代」的对象的?<ul>
<li>HotSpot虚拟机下有「card table」（卡表）来避免全局扫描「老年代」对象</li>
<li>「堆内存」的每一小块区域形成「卡页」，卡表实际上就是卡页的集合。当判断一个卡页中有存在对象的跨代引用时，将这个页标记为「脏页」</li>
<li>那知道了「卡表」之后，就很好办了。每次MinorGC的时候只需要去「卡表」找到「脏页」，找到后加入至GCRoot，而不用去遍历整个「老年代」的对象了。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/211da837/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/211da837/" class="post-title-link" itemprop="url">Java线程池实现原理及其在美团业务中的实践</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/211da837/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/211da837/" data-xid="/posts/211da837/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java线程池实现原理及其在美团业务中的实践"><a href="#Java线程池实现原理及其在美团业务中的实践" class="headerlink" title="Java线程池实现原理及其在美团业务中的实践"></a><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></h1><p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。</p>
<p>本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。</p>
<h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><h3 id="1-1-线程池是什么"><a href="#1-1-线程池是什么" class="headerlink" title="1.1 线程池是什么"></a>1.1 线程池是什么</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p>而本文描述线程池是JDK中提供的ThreadPoolExecutor类。</p>
<p>当然，使用线程池可以带来一系列好处：</p>
<ul>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h3 id="1-2-线程池解决的问题是什么"><a href="#1-2-线程池解决的问题是什么" class="headerlink" title="1.2 线程池解决的问题是什么"></a>1.2 线程池解决的问题是什么</h3><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请&#x2F;销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<ol>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ol>
<p>在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。</p>
<h2 id="二、线程池核心设计与实现"><a href="#二、线程池核心设计与实现" class="headerlink" title="二、线程池核心设计与实现"></a>二、线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。</p>
<h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/h7Yavu_20220216085715.png" alt="图1 ThreadPoolExecutor UML类图"></p>
<center>图1 ThreadPoolExecutor UML类图</center>



<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NyaZL2_20220216085821.png" alt="图2 ThreadPoolExecutor运行流程"></p>
<center>图2 ThreadPoolExecutor运行流程</center>



<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p>
<ol>
<li>线程池如何维护自身状态。</li>
<li>线程池如何管理任务。</li>
<li>线程池如何管理线程。</li>
</ol>
<h3 id="2-2-生命周期管理"><a href="#2-2-生命周期管理" class="headerlink" title="2.2 生命周期管理"></a>2.2 生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor的运行状态有5种，分别为：</p>
<p><img src="https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png" alt="img"></p>
<p>其生命周期转换如下入所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/k5I53e_20220216085930.png" alt="图3 线程池生命周期"></p>
<p>图3 线程池生命周期</p>
<h3 id="2-3-任务执行机制"><a href="#2-3-任务执行机制" class="headerlink" title="2.3 任务执行机制"></a>2.3 任务执行机制</h3><p><strong>2.3.1 任务调度</strong></p>
<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>
<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/nxM486_20220216090005.png" alt="图4 任务调度流程"></p>
<center>图4 任务调度流程</center>



<p><strong>2.3.2 任务缓冲</strong></p>
<p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KcJ1kc_20220216090056.png" alt="图5 阻塞队列"></p>
<center>图5 阻塞队列</center>



<p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/kNOy8F_20220216090204.png" alt="img"></p>
<p><strong>2.3.3 任务申请</strong></p>
<p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/VS4jHX_20220216090252.png" alt="图6 获取任务流程图"></p>
<center>图6 获取任务流程图</center>



<p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<p><strong>2.3.4 任务拒绝</strong></p>
<p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略是一个接口，其设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/WZboNR_20220216090358.png" alt="img"></p>
<p>2.4 Worker线程管理</p>
<p>2.4.1 Worker线程</p>
<p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/r2pblC_20220216090419.png" alt="图7 Worker执行任务"></p>
<center>图7 Worker执行任务</center>



<p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ERpNl9_20220216090526.png" alt="图8 线程池回收过程"></p>
<p>图8 线程池回收过程</p>
<p><strong>2.4.2 Worker线程增加</strong></p>
<p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/LBwxyo_20220216090601.png" alt="图9 申请线程执行流程图"></p>
<p>图9 申请线程执行流程图</p>
<p><strong>2.4.3 Worker线程回收</strong></p>
<p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程回收的工作是在processWorkerExit方法完成的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ediygi_20220216090637.png" alt="图10 线程销毁流程"></p>
<p>图10 线程销毁流程</p>
<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>
<p><strong>2.4.4 Worker线程执行任务</strong></p>
<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<p>1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</p>
<p>执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2RHyDQ_20220216090659.png" alt="图11 执行任务流程"></p>
<p>图11 执行任务流程</p>
<h2 id="三、线程池在业务中的实践"><a href="#三、线程池在业务中的实践" class="headerlink" title="三、线程池在业务中的实践"></a>三、线程池在业务中的实践</h2><h3 id="3-1-业务背景"><a href="#3-1-业务背景" class="headerlink" title="3.1 业务背景"></a>3.1 业务背景</h3><p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p>
<p><strong>场景1：快速响应用户请求</strong></p>
<p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>
<p><strong>分析</strong>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/osaVvY_20220216090717.png" alt="图12 并行执行任务提升任务响应速度"></p>
<p>图12 并行执行任务提升任务响应速度</p>
<p><strong>场景2：快速处理批量任务</strong></p>
<p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/v43OYx_20220216090733.png" alt="图13 并行执行任务提升批量任务执行速度"></p>
<p>图13 并行执行任务提升批量任务执行速度</p>
<h3 id="3-2-实际问题及方案思考"><a href="#3-2-实际问题及方案思考" class="headerlink" title="3.2 实际问题及方案思考"></a>3.2 实际问题及方案思考</h3><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>
<p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p>
<p><strong>Case1</strong>：2018年XX页面展示接口大量调用降级：</p>
<p><strong>事故描述</strong>：XX页面展示接口产生大量调用降级，数量级在几十到上百。</p>
<p><strong>事故原因</strong>：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/dhjkdv_20220216090747.png" alt="图14 线程数核心设置过小引发RejectExecutionException"></p>
<p>图14 线程数核心设置过小引发RejectExecutionException</p>
<p><strong>Case2</strong>：2018年XX业务服务不可用S2级故障</p>
<p><strong>事故描述</strong>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p>
<p><strong>事故原因</strong>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/dLadG2_20220216090804.png" alt="图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"></p>
<p>图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</p>
<p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p>
<p><strong>1. 能否不用线程池?</strong></p>
<p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Zq7L9g_20220216090823.png" alt="img"></p>
<p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p>
<p><strong>2. 追求参数设置合理性？</strong></p>
<p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p>
<p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/45CiX2_20220216090844.png" alt="img"></p>
<p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p>
<p><strong>3. 线程池参数动态化？</strong></p>
<p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lvnfxz_20220216090858.png" alt="图16 动态修改线程池参数新旧流程对比"></p>
<p>图16 动态修改线程池参数新旧流程对比</p>
<p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p>
<h3 id="3-3-动态化线程池"><a href="#3-3-动态化线程池" class="headerlink" title="3.3 动态化线程池"></a>3.3 动态化线程池</h3><p><strong>3.3.1 整体设计</strong></p>
<p>动态化线程池的核心设计包括以下三个方面：</p>
<ol>
<li>简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li>
<li>参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li>
<li>增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ez5lnf_20220216090914.png" alt="图17 动态化线程池整体设计"></p>
<p>图17 动态化线程池整体设计</p>
<p><strong>3.3.2 功能架构</strong></p>
<p>动态化线程池提供如下功能：</p>
<p><strong>动态调参</strong>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 <strong>任务监控</strong>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95&#x2F;99线等。 <strong>负载告警</strong>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 <strong>操作监控</strong>：创建&#x2F;修改和删除线程池都会通知到应用的开发负责人。 <strong>操作日志</strong>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 <strong>权限校验</strong>：只有应用开发负责人才能够修改应用的线程池参数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BZAd4z_20220216090932.png" alt="图18 动态化线程池功能架构"></p>
<p>图18 动态化线程池功能架构</p>
<p><strong>参数动态化</strong></p>
<p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QAFKK8_20220216090950.png" alt="图19 JDK 线程池参数设置接口"></p>
<p>图19 JDK 线程池参数设置接口</p>
<p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/XBPTEo_20220216091010.png" alt="图20 setCorePoolSize方法执行流程"></p>
<p>图20 setCorePoolSize方法执行流程</p>
<p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HNtC74_20220216091036.png" alt="图21 可动态修改线程池参数"></p>
<p>图21 可动态修改线程池参数</p>
<p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p>
<p><strong>线程池监控</strong></p>
<p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p>
<h4 id="1-负载监控和告警"><a href="#1-负载监控和告警" class="headerlink" title="1. 负载监控和告警"></a>1. 负载监控和告警</h4><p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 &#x3D; activeCount&#x2F;maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NBIB1M_20220216091104.png" alt="图22 大象告警通知"></p>
<p>图22 大象告警通知</p>
<h4 id="2-任务级精细化监控"><a href="#2-任务级精细化监控" class="headerlink" title="2. 任务级精细化监控"></a>2. 任务级精细化监控</h4><p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KMkxjh_20220216091140.png" alt="图23 线程池任务执行监控"></p>
<p>图23 线程池任务执行监控</p>
<h4 id="3-运行时状态实时查看"><a href="#3-运行时状态实时查看" class="headerlink" title="3. 运行时状态实时查看"></a>3. 运行时状态实时查看</h4><p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/pKm5Zo_20220216091155.png" alt="图24 线程池实时运行情况"></p>
<p>图24 线程池实时运行情况</p>
<p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Y6a295_20220216091224.png" alt="图25 线程池实时运行情况"></p>
<p>图25 线程池实时运行情况</p>
<h3 id="3-4-实践总结"><a href="#3-4-实践总结" class="headerlink" title="3.4 实践总结"></a>3.4 实践总结</h3><p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ul>
<li>[1] JDK 1.8源码</li>
<li>[2] <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">维基百科-线程池</a></li>
<li>[3] <a target="_blank" rel="noopener" href="https://my.oschina.net/andylucc/blog/648127">更好的使用Java线程池</a></li>
<li>[4] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pooling_(resource_management)">维基百科Pooling(Resource Management)</a></li>
<li>[5] <a target="_blank" rel="noopener" href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a></li>
<li>[6]《Java并发编程实践》</li>
</ul>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/cad299ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/cad299ae/" class="post-title-link" itemprop="url">java学习路线图</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/cad299ae/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/cad299ae/" data-xid="/posts/cad299ae/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java学习路线图"><a href="#java学习路线图" class="headerlink" title="java学习路线图"></a>java学习路线图</h1><p>项目地址：</p>
<ul>
<li>Github地址：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide">Snailclimb&#x2F;JavaGuide</a></li>
<li>Gitee地址： <a href="https://link.zhihu.com/?target=https://gitee.com/SnailClimb/JavaGuide">SnailClimb&#x2F;JavaGuide</a>（Github 无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）</li>
</ul>
<p>这篇回答不会涉及到学习方法以及学习网站的推荐，我不想让篇幅太长，内容太杂，我希望留着下一篇文章专门来谈一谈。</p>
<p>另外，这篇回答也不会涉及到计算机基础，也是为了保证内容的不至于太杂。计算基础相关的内容我也已经写好，预计会在五一同步给小伙伴们。</p>
<p><img src="https://pic2.zhimg.com/50/v2-06c2cdc3e5d417486d1cb92687350ed4_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-06c2cdc3e5d417486d1cb92687350ed4_720w.jpg?source=1940ef5c" alt="img"></p>
<p>多说一句，对于编程初学者，我不太建议上来通过做项目学习。实践确实很重要，如果你没有编程基础的话，直接上手实战，很容易最后学个四不像。</p>
<p>建议你在学习编程的初期尽量多看一些优质视频。跟着视频一步一步走，可以让你少踩很多坑，学习编程的信心也会增加。</p>
<p><strong>概览：</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-62586d6789e1a081cc3dc6efd7bdd289_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-62586d6789e1a081cc3dc6efd7bdd289_720w.jpg?source=1940ef5c" alt="img"></p>
<p>回答中的相关书籍我也已经同步到了 Github和Gitee上（有PDF版本可供下载），欢迎小伙伴们一起完善。</p>
<ul>
<li>Github地址：<a href="https://link.zhihu.com/?target=https://github.com/CodingDocs/awesome-cs">https://github.com/CodingDocs/awesome-cs</a></li>
<li>码云地址：<a href="https://link.zhihu.com/?target=https://gitee.com/SnailClimb/awesome-cs">https://gitee.com/SnailClimb/awesome-cs</a> （Github无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）</li>
</ul>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a><strong>Java 基础</strong></h2><p>如果你之前没有学习过编程的话，我建议你可以看看视频教程。</p>
<p>像尚硅谷的 <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1Kb411W75N">《 Java 基础教程系列》</a>和韩顺平老师的<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1fh411y7R8">《零基础 30 天学会 Java》</a>就很不错。</p>
<p><img src="https://pic4.zhimg.com/50/v2-2217d04b42c6f79aa126432672133c25_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-2217d04b42c6f79aa126432672133c25_720w.jpg?source=1940ef5c" alt="img"></p>
<p>学习过 Java 的朋友，大部分应该都看过韩老师的课程吧！韩老师毕业于清华大学，录制的视频课程质量都非常高。内容易懂，并且不失严谨。</p>
<p>韩老师的<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1fh411y7R8">《零基础 30 天学会 Java》</a>系列不光会教你 Java 基础，还会帮你建立编程思想，让你知道学习了 Java 之后，你可以从事什么工作。</p>
<p>看视频的同时，配套一本好书也是非常有作用的。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/2000732/">《Head First Java》</a></strong> 这本书在是入门 Java 的很不错的书籍 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-d264e3d06d0f86175c542c60a032fea4_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-d264e3d06d0f86175c542c60a032fea4_720w.jpg?source=1940ef5c" alt="img"></p>
<p>《Head First Java》这本书的内容很轻松有趣，可以说是我学习编程初期最喜欢的几本书之一了。同时，这本书也是我的 Java 启蒙书籍。我在学习 Java 的初期多亏了这本书的帮助，自己才算是跨进 Java 语言的大门。</p>
<p>我觉得我在 Java 这块能够坚持下来，这本书有很大的功劳。我身边的的很多朋友学习 Java 初期都是看的这本书。</p>
<p>有很多小伙伴就会问了：<strong>这本书适不适合编程新手阅读呢？</strong></p>
<p>我个人觉得这本书还是挺适合编程新手阅读的，毕竟是 “Head First” 系列。</p>
<p><img src="https://pic2.zhimg.com/50/v2-66d3ede459a86d010402186346189af1_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-66d3ede459a86d010402186346189af1_720w.jpg?source=1940ef5c" alt="img"></p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34898994/">《Java 核心技术卷 1+卷 2》</a></strong> 这两本书也非常不错。不过，这两本书的内容很多，全看的话比较费时间。我现在是把这两本书当做工具书来用，就比如我平时写文章的时候，碰到一些 Java 基础方面的问题，经常就翻看这两本来当做参考！</p>
<p>我当时在大学的时候就买了两本放在寝室，没事的时候就翻翻。建议有点 Java 基础之后再读，介绍的还是比较深入和全面的，非常推荐。</p>
<p><img src="https://pic2.zhimg.com/50/v2-bc98859a3b5e17b38c9d4606c1cd3ffd_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-bc98859a3b5e17b38c9d4606c1cd3ffd_720w.jpg?source=1940ef5c" alt="img"></p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/2130190/">《Java 编程思想 》</a></strong> 这本书被很多人称之为 Java 领域的圣经（*感觉有点过了~~~*）。不太推荐编程初学者阅读，有点劝退的味道，稍微有点基础后阅读更好。</p>
<p>我第一次看的时候还觉得有点枯燥，那时候还在上大二，看了 1&#x2F;3 就没看下去了。</p>
<p><img src="https://pic2.zhimg.com/50/v2-e14d41b9f1dd4c9184466bb94c59401b_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-e14d41b9f1dd4c9184466bb94c59401b_720w.jpg?source=1940ef5c" alt="img"></p>
<p>另外，Java 8 算是一个里程碑式的版本，现在一般企业还是用 Java 8 比较多。掌握 Java 8 的一些新特性比如 Lambda、Strean API 还是挺有必要的。这块的话，我推荐 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26772632/">《Java 8 实战》</a></strong> 这本书。</p>
<p>学完 Java 基础之后，你可以用自己学的东西实现一个简单的 Java 程序，也可以尝试用 Java 解决一些编程问题，以此来将自己学到的东西付诸于实践。</p>
<p>不太建议学习 Java 基础的之后通过做游戏来巩固。为什么培训班喜欢通过这种方式呢？说白点就是为了找到你的 G 点。新手学习完 Java 基础后做游戏一般是不太现实的，还不如找一些简单的程序问题解决一下比如简单的算法题。</p>
<p>记得多总结！打好基础！把自己重要的东西都记录下来。 API 文档放在自己可以看到的地方，以备自己可以随时查阅。为了能让自己写出更优秀的代码，《Effective Java》、《重构》 这两本书没事也可以看</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h2><p>多线程这部分内容稍微会比较难以理解和实践。如果你刚学完 Java 基础的话，我建议你学习并发这部分内容的时候，可以先简单地了解一下基础知识比如线程和进程的对比。到了后面，你对于 Java 了解的更深了之后，再回来仔细看看这部分的内容。</p>
<p>下面是一些我比较推荐的书籍。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30351286/">《Java 并发编程之美》</a></strong></p>
<p><img src="https://pic2.zhimg.com/50/v2-2ca1ce12697e4368246b124cc5ebf295_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-2ca1ce12697e4368246b124cc5ebf295_720w.jpg?source=1940ef5c" alt="img"></p>
<p><em>这本书还是非常适合我们用来学习 Java 多线程的。这本书的讲解非常通俗易懂，作者从并发编程基础到实战都是信手拈来。</em></p>
<p>另外，这本书的作者加多自身也会经常在网上发布各种技术文章。这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解，非常有说服力！</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30358019/">《实战 Java 高并发程序设计》</a></strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-c83749f4bc91edbb131681d9f94f821f_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-c83749f4bc91edbb131681d9f94f821f_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这个是我第二本要推荐的书籍，比较适合作为多线程入门&#x2F;进阶书籍来看。这本书内容同样是理论结合实战，对于每个知识点的讲解也比较通俗易懂，整体结构也比较清。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://github.com/RedSpider1/concurrent">《深入浅出 Java 多线程》</a></strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-b477244d7b3229167ea31aa2e16e3302_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-b477244d7b3229167ea31aa2e16e3302_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书是几位大厂的大佬开源的。</p>
<p>这几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客，然后再加上他们的经验总结、Demo 实例、源码解析，最终才形成了这本书。</p>
<p>这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑。并且每篇文章初稿写完后，作者们就会互相审校，合并到主分支时所有成员会再次审校，最后再通篇修订了三遍。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/35013531/">《Java 并发实现原理：JDK 源码剖析》</a></strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-9da660b9c3acde7a185d342c0dbbbb09_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-9da660b9c3acde7a185d342c0dbbbb09_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书是去年也就是 2020 年新出的，所以，现在知道的人还不是很多。</p>
<p>这本书主要是对 Java Concurrent 包中一些比较重要的源码进行了讲解，另外，像 JMM、happen-before、CAS 等等比较重要的并发知识这本书也都会一并介绍到。</p>
<p>不论是你想要深入研究 Java 并发，还是说要准备面试，你都可以看看这本书。</p>
<p>下面是我总结的一些关于并发的小问题，你可以拿来自测：</p>
<ol>
<li>什么是线程和进程? 线程与进程的关系,区别及优缺点？</li>
<li>说说并发与并行的区别?</li>
<li>为什么要使用多线程呢?</li>
<li>使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）</li>
<li>创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）</li>
<li>说说线程的生命周期和状态?</li>
<li>什么是上下文切换?</li>
<li>什么是线程死锁?如何避免死锁?</li>
<li>说说 sleep() 方法和 wait() 方法区别和共同点?</li>
<li>Java 内存模型（JMM）、重排序与 happens-before 原则了解吗？</li>
<li>synchronized 关键字、volatile 关键字</li>
<li>ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？</li>
<li>为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？</li>
<li>AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)</li>
<li>ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）</li>
<li>CAS 了解么？原理？</li>
<li>Atomic 原子类</li>
<li>并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap</li>
<li>Future 和 CompletableFuture</li>
<li>……</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h2><p>对于 Java 程序员来说，JVM 帮助我们做了很多事情比如内存管理、垃圾回收等等。在 JVM 的帮助下，我们的程序出现内存泄漏这些问题的概率相对来说是比较低的。但是，这并不代表我们在日常开发工作中不会遇到。万一你在工作中遇到了 OOM 问题，你至少要知道如何去排查和解决问题吧！</p>
<p>并且，就单纯从面试角度来说，JVM 是 Java 后端面试（大厂）中非常重要的一环。不论是应届还是社招，面试国内的一些大厂，你都会被问到很多 JVM 相关的问题（应届的话侧重理论，社招实践）。</p>
<p>只有搞懂了 JVM 才有可能真正把 Java 语言“吃透”。学习 JVM 这部分的内容，一定要注意要实战和理论结合。</p>
<p>书籍的话，**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a>** 这本书是首先要推荐的。</p>
<p><img src="https://pic1.zhimg.com/50/v2-ef98840c238a19a70318ae9fa3ec7bf5_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-ef98840c238a19a70318ae9fa3ec7bf5_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书就一句话形容：<strong>国产书籍中的战斗机，实实在在的优秀！</strong> （真心希望国内能有更多这样的优质书籍出现！加油！ ）</p>
<p>这本书的第三版去年年底已经出来了，新增了很多实在的内容比如 ZGC 等新一代 GC 的原理剖析。目前豆瓣上是 9.6 的高分，  不   我就不多说了！</p>
<p>不论是你面试还是你想要在 Java 领域学习的更深，你都离不开这本书籍。这本书不光要看，你还要多看几遍，里面都是干货。这本书里面还有一些需要自己实践的东西，我建议你也跟着实践一下。</p>
<p>类似的书籍还有 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26354292/">《实战 Java 虚拟机》</a><strong>、</strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34935105/">《虚拟机设计与实现:以 JVM 为例》</a></strong> ，这两本都是非常不错的！</p>
<p><img src="https://pic4.zhimg.com/50/v2-114035a0430694dd2562e5a136aa410b_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-114035a0430694dd2562e5a136aa410b_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你对实战比较感兴趣，想要自己动手写一个简易的 JVM 的话，可以看看 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26802084/">《自己动手写 Java 虚拟机》</a></strong> 这本书。</p>
<p><img src="https://pic3.zhimg.com/50/v2-171e35db906d0d4b330afe176a6ed823_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-171e35db906d0d4b330afe176a6ed823_720w.jpg?source=1940ef5c" alt="img"></p>
<p>书中的代码是基于 Go 语言实现的，搞懂了原理之后，你可以使用 Java 语言模仿着写一个，也算是练练手！ 如果你当前没有能力独立使用 Java 语言模仿着写一个的话，你也可以在网上找到很多基于 Java 语言版本的实现，比如<a href="https://link.zhihu.com/?target=https://zachaxy.github.io/tags/JVM/">《zachaxy 的手写 JVM 系列》</a> 。</p>
<p>这本书目前在豆瓣有 8.2 的评分，我个人觉得张秀宏老师写的挺好的，这本书值得更高的评分。</p>
<p>另外，R 大在豆瓣发的<a href="https://link.zhihu.com/?target=https://www.douban.com/doulist/2545443/">《从表到里学习 JVM 实现》</a>这篇文章中也推荐了很多不错的 JVM 相关的书籍，推荐小伙伴们去看看。</p>
<p>再推荐两个视频给喜欢看视频学习的小伙伴。</p>
<p>第 1 个是尚硅谷的宋红康老师讲的<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1PJ411n7xZ">《JVM 全套教程》</a>。这个课程的内容非常硬，一共有接近 400 小节。</p>
<p>课程的内容分为 3 部分：</p>
<ol>
<li>《内存与垃圾回收篇》</li>
<li>《字节码与类的加载篇》</li>
<li>《性能监控与调优篇》</li>
</ol>
<p><img src="https://pic2.zhimg.com/50/v2-4d2a238642281bdf1b8bda06b34eb8be_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4d2a238642281bdf1b8bda06b34eb8be_720w.jpg?source=1940ef5c" alt="img"></p>
<p>第 2 个是你假笨大佬的 <strong><a href="https://link.zhihu.com/?target=https://club.perfma.com/course/438755/list">《JVM 参数【Memory 篇】》</a></strong> 教程，很厉害了！</p>
<p><img src="https://pic4.zhimg.com/50/v2-30067f8554c7bd6089a87e971d14b069_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-30067f8554c7bd6089a87e971d14b069_720w.jpg?source=1940ef5c" alt="img"></p>
<p>下面是我总结的一些关于 JVM 的小问题，你可以拿来自测：</p>
<ol>
<li>什么是虚拟机？</li>
<li>Java 内存区域是怎么划分的？大对象放在哪个内存区域？</li>
<li>垃圾回收有哪些算法？GC 的流程</li>
<li>什么是类加载？何时类加载？类加载流程？</li>
<li>知道哪些类加载器。类加载器之间的关系？</li>
<li>类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。</li>
<li>常见调优参数有哪些？</li>
<li>……</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p>我们网站或 者 APP 的数据都是需要使用数据库来存储数据的。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><strong>MySQL</strong></h3><p>一般企业项目开发中，使用 MySQL 比较多。如果你要学习 MySQL 的话，可以看下面这 3 本书籍：</p>
<ul>
<li><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/3354490/">《MySQL 必知必会》</a></strong> ：非常薄！非常适合 MySQL 新手阅读，很棒的入门教材。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></strong> ： MySQL 领域的经典之作！学习 MySQL 必看！属于进阶内容，主要教你如何更好地使用 MySQL 。既有有理论，又有实践！如果你没时间都看一遍的话，拿我建议第 5 章（创建高性能的索引） 、第 6 章（查询性能优化） 你你一定要认真看一下。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/24708143/">《MySQL 技术内幕》</a></strong> ：你想深入了解 MySQL 存储引擎的话，看这本书准没错！</li>
</ul>
<p><img src="https://pic2.zhimg.com/50/v2-3446cfaa214394ec7137ba34ca5362ba_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-3446cfaa214394ec7137ba34ca5362ba_720w.jpg?source=1940ef5c" alt="img"></p>
<p>视频的话，你可以看看动力节点的 <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1fx411X7BD">《MySQL 数据库教程视频》</a>。这个视频基本上把 MySQL 的相关一些入门知识给介绍完了。</p>
<p>学习了 MySQL 之后，务必确保自己掌握下面这些知识点：</p>
<ol>
<li>MySQL 常用命令 ：</li>
</ol>
<ul>
<li>安全：登录、增加&#x2F;删除用户、备份数据和还原数据</li>
<li>数据库操作： 建库建表&#x2F;删库删表、用户权限分配</li>
<li>……</li>
</ul>
<ol>
<li>MySQL 中常用的数据类型、字符集编码</li>
<li>MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……</li>
<li>MySQL 中使用索引、视图、存储过程、游标、触发器</li>
<li>……</li>
</ol>
<p>如果你想让自己更加了解 MySQL ，同时也是为了准备面试的话，下面这些知识点要格外注意：</p>
<ol>
<li>索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引</li>
<li>事务：事务、数据库事务、ACID、并发事务、事务隔离级别</li>
<li>存储引擎（MyISAM 和 InnoDB）</li>
<li>锁机制与 InnoDB 锁算法</li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p><strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>如果你要学习 Redis 的话，强烈推荐 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/25900156/">《Redis 设计与实现》</a></strong> 和 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26612779/">《Redis 实战》</a></strong> 这两本书。另外，**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26971561/">《Redis 开发与运维》</a>** 这本书也非常不错，既有基础介绍，又有一线开发运维经验分享。</p>
<p><img src="https://pic4.zhimg.com/50/v2-6fe8373526af0107bcda6a73b2e9a801_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-6fe8373526af0107bcda6a73b2e9a801_720w.jpg?source=1940ef5c" alt="img"></p>
<p>下面是我总结的一些关于并发的小问题，你可以拿来自测：</p>
<ol>
<li>Redis 和 Memcached 的区别和共同点</li>
<li>为什么要用 Redis&#x2F;为什么要用缓存？</li>
<li>Redis 常见数据结构以及使用场景分析</li>
<li>Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？</li>
<li>Redis 给缓存数据设置过期时间有啥用？</li>
<li>Redis 是如何判断数据是否过期的呢？</li>
<li>过期的数据的删除策略了解么？</li>
<li>Redis 内存淘汰机制了解么？</li>
<li>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</li>
<li>Redis 缓存穿透、缓存雪崩？</li>
<li>如何保证缓存和数据库数据的一致性？</li>
<li>……</li>
</ol>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><p>非常重要！非常重要！特别是 Git 和 Docker。</p>
<p>除了下面这些工具之外，我强烈建议你一定要搞懂 Github 的使用。一些使用 Github 的小技巧，你可以看<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Github%E6%8A%80%E5%B7%A7">《Github 小技巧》</a>这篇文章。</p>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a><strong>IDEA</strong></h3><p>俗话说：“工欲善其事，必先利其器 !”。选择一款好的开发工具对于我们高效率编码非常有帮助！</p>
<p>常用的 Java 开发工具就 Eclipse 和 IDEA。就我个人而言 IDEA 是最适合 Java 开发者的 IDE 。</p>
<p>建议你要熟悉 IDEA 的基本操作以及常用快捷。你可以通过 Github 上的开源教程 <a href="https://link.zhihu.com/?target=https://github.com/judasn/IntelliJ-IDEA-Tutorial">《IntelliJ IDEA 简体中文专题教程》</a> 来学习 IDEA 的相关使用。</p>
<p>除了 IDEA 自身对编码优秀的支持（比如智能上下文提示）之外，IDEA 中还有丰富的插件来帮助我们高效开发。<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTA0Njk0OA==&action=getalbum&album_id=1319419426898329600%23wechat_redirect">《IDEA 插件》</a> 这个系列专辑中推荐了很多实用 IDEA 必备的插件！</p>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p>强烈建议学习常用框架之前可以提前花几天时间学习一下<strong>Maven</strong>的使用。（到处找 Jar 包，下载 Jar 包是真的麻烦费事，使用 Maven 可以为你省很多事情）。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><p>Git 技能对于程序员来说也是必备的！试着在学习的过程中将自己的代码托管在 Github 上，有一个漂亮的 Github 主页在求职面试中是十分加分的。并且，现在的企业都是基于 Git 在 GitHub 或 GitLab 平台上做版本控制。</p>
<p>学习 Git 的话，强烈推荐给大家一个可以交互式学习 Git 的网站 <a href="https://link.zhihu.com/?target=https://learngitbranching.js.org/">Learn Git Branching</a>。效果真的非常非常棒，通过游戏的方式让你学习 Git 的常见操作。</p>
<p>整个教程分为很多关，每一关都有非常详细的指导，还会有详细的动图展示结果。并且，你做错了之后还可以使用 reset 命令从头开始。</p>
<p><img src="https://pic2.zhimg.com/50/v2-964b02483882588923780a75d9775ab8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-964b02483882588923780a75d9775ab8_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你是在不知道答案的话，还可以使用 show solution 命令查看答案。</p>
<p><img src="https://pic4.zhimg.com/50/v2-1924f6df27c62026f3d531e7de843fb4_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-1924f6df27c62026f3d531e7de843fb4_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这种即时反馈的学习让过程变得有趣！真心感谢这个网站的作者，太爱了！</p>
<p>另外，你可以看看 Github 上开源的这篇 <a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Git">《Git 极简入门》</a> ，像版本控制和 Git 的相关概念、Git 常见操作这篇文章都有介绍到。</p>
<p>如果想要详细了解 Git 的话，<a href="https://link.zhihu.com/?target=https://git-scm.com/book/zh/v2">Git 官方文档教程</a>是肯定要看的，介绍的非常全面，并且有中文版！</p>
<p><img src="https://pic3.zhimg.com/50/v2-0b2163d2c8064c33a034d9bb31ced577_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-0b2163d2c8064c33a034d9bb31ced577_720w.jpg?source=1940ef5c" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.progit.cn/">《Pro Git》</a>这本书也非常不错，还有中文版，内容非常全面，硬核！</p>
<p><img src="https://pic1.zhimg.com/50/v2-ce008dd1ba37fc12e91e9adf63f87fe6_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-ce008dd1ba37fc12e91e9adf63f87fe6_720w.jpg?source=1940ef5c" alt="img"></p>
<p><img src="https://pic1.zhimg.com/50/v2-566dccf603d7708a831be89f993c8c3d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-566dccf603d7708a831be89f993c8c3d_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你比较喜欢看视频教程的话，可以看看极客时间的<a href="https://link.zhihu.com/?target=http://gk.link/a/10qcT">《玩转 Git 三剑客》</a>，课程的作者是携程代码平台负责人苏玲，讲的挺不错的！</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h3><p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p>
<p>Docker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：</p>
<ol>
<li>一致的运行环境，能够更轻松地迁移</li>
<li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源</li>
<li>可以通过镜像复制多个一致的容器</li>
</ol>
<p>Docker 常见概念解读，可以看这篇 Github 上开源的这篇<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker">《Docker 基本概念解读》</a> ，从零到上手实战可以看<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98">《Docker 从入门到上手干事》</a>这篇文章，内容非常详细！</p>
<p>另外，再给大家推荐一本质量非常高的开源书籍<a href="https://link.zhihu.com/?target=https://yeasy.gitbook.io/docker_practice/introduction/why">《Docker 从入门到实践》</a> ，这本书的内容非常新，毕竟书籍的内容是开源的，可以随时改进。</p>
<p><img src="https://pic1.zhimg.com/50/v2-f5d0bf0587f742c9a65f985e7fc12f93_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-f5d0bf0587f742c9a65f985e7fc12f93_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a><strong>常用框架</strong></h2><p><a href="https://link.zhihu.com/?target=https://t.1yb.co/mBsy">2021 最新Java实战项目源码打包下载t.1yb.co<img src="https://pic2.zhimg.com/v2-5c70f2d4123edf16afab8b4bed070b4d_180x120.jpg" alt="图标"></a></p>
<h3 id="Spring-x2F-SpringBoot"><a href="#Spring-x2F-SpringBoot" class="headerlink" title="Spring&#x2F;SpringBoot"></a><strong>Spring&#x2F;SpringBoot</strong></h3><p><strong>Spring 和 SpringBoot 真的很重要！</strong></p>
<p>一定要搞懂 AOP 和 IOC 这两个概念。Spring 中 bean 的作用域与生命周期、SpringMVC 工作原理详解等等知识点都是非常重要的，一定要搞懂。</p>
<p>企业中做 Java 后端，你一定离不开 SpringBoot ，这个是必备的技能了！一定一定一定要学好！</p>
<p>像 SpringBoot 和一些常见技术的整合你也要知识怎么做，比如 SpringBoot 整合 MyBatis、 ElasticSearch、SpringSecurity、Redis 等等。</p>
<p>学习 Spring 的话，可以多看看 **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-framework%23learn">《Spring 的官方文档》</a>**，写的很详细。你可以在这里找到 Spring 全家桶的学习资源。</p>
<p><img src="https://pic4.zhimg.com/50/v2-617c73716c914ce3ee4c9a32be97daa3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-617c73716c914ce3ee4c9a32be97daa3_720w.jpg?source=1940ef5c" alt="img"></p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34949443/">《Spring 实战》</a></strong> 这本书作为学习 Spring 的参考资料。 这本书还是比较新的，目前已经出到了第 5 版，基于 Spring 5 来讲。</p>
<p><img src="https://pic2.zhimg.com/50/v2-27116d84a7876e40fe9e008d0bd1927e_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-27116d84a7876e40fe9e008d0bd1927e_720w.jpg?source=1940ef5c" alt="img"></p>
<p>了解了 Spring 中的一些常见概念和基本用法之后，你就可以开始学习 Spring Boot 了。</p>
<p>当然了，Spring 其实并不是学习 Spring Boot 的前置基础，相比于 Spring 来说，Spring Boot 要更容易上手一些！如果你只是想使用 Spring Boot 来做项目的话，直接学 Spring Boot 就可以了。</p>
<p>不过，我建议你在学习 Spring Boot 之前，可以看看 <strong><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">《Spring 常见问题总结》</a></strong> 。这些问题都是 Spring 比较重要的知识点，也是面试中经常会被问到的。</p>
<p>学习 Spring Boot 的话，还是建议可以多看看  **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-boot%23learn">《Spring Boot 的官方文档》</a>**，写的很详细。</p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26857423/">《Spring Boot 实战》</a></strong> 这本书作为学习 Spring Boot 的参考资料。</p>
<p><img src="https://pic2.zhimg.com/50/v2-ccd869cdada64fb595d5e2c524180eba_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-ccd869cdada64fb595d5e2c524180eba_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书的整体质量实际一般，你当做参考书来看就好了!</p>
<p>相比于 《Spring Boot 实战》这本书，我更推荐国人写的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34894533/">《Spring Boot 实战派》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-347c02b27d1c8074dd6423c11c867b95_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-347c02b27d1c8074dd6423c11c867b95_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书使用的 Spring Boot 2.0+的版本，还算比较新。整本书采用“知识点+实例”的形式编写，书籍的最后两章还有 2 个综合性的企业实战项目：</p>
<ul>
<li>开发企业级通用的后台系统</li>
<li>实现一个类似“京东”的电子商务商城</li>
</ul>
<p>作者在注意实战的过程中还不忘记对于一些重要的基础知识的讲解。</p>
<p>如果你想专研 Spring Boot 底层原理的话，可以看看 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/33390560/">《Spring Boot 编程思想（核心篇）》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书稍微有点啰嗦，不过，原理介绍的比较清楚（不适合初学者）。</p>
<p>如果你比较喜欢看视频的话，推荐尚硅谷雷神的**<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV19K4y1L7MT">《2021 版 Spring Boot2 零基础入门》</a>** 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-8edcdf9da09d431d5a827737df1326f8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-8edcdf9da09d431d5a827737df1326f8_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这可能是全网质量最高并且免费的 Spring Boot 教程了，好评爆炸！</p>
<p>另外，Spring Boot 这块还有很多优质的开源教程，我已经整理好放到 <a href="https://link.zhihu.com/?target=https://github.com/CodingDocs/awesome-java%23springboot">awesome-java@SpringBoot</a> 中了。</p>
<p><img src="https://pic4.zhimg.com/50/v2-bd98e686b9da09ebbe25bfc843364147_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-bd98e686b9da09ebbe25bfc843364147_720w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a><strong>Netty</strong></h3><p>但凡涉及到网络通信就必然必然离不开网络编程。 Netty 目前作为 Java 网络编程最热门的框架，毫不夸张地说是每个 Java 程序员必备的技能之一。</p>
<p><strong>为什么说学好 Netty 很有必要呢？</strong></p>
<ol>
<li>Netty 基于 NIO （NIO 是一种同步非阻塞的 I&#x2F;O 模型，在 Java 1.4 中引入了 NIO ）。使用 Netty 可以极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面都非常优秀。</li>
<li>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC、Spark、Elasticsearch 等等热门开源项目都用到了 Netty。</li>
<li>大部分微服务框架底层涉及到网络通信的部分都是基于 Netty 来做的，比如说 Spring Cloud 生态系统中的网关 Spring Cloud Gateway 。</li>
</ol>
<p>下面是一些比较推荐的书籍&#x2F;专栏。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/27038538/">《Netty 实战》</a></strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-8a4c942af44520f5d2c99c3d6f37b4dc_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-8a4c942af44520f5d2c99c3d6f37b4dc_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书可以用来入门 Netty ，内容从 BIO 聊到了 NIO、之后才详细介绍为什么有 Netty 、Netty 为什么好用以及 Netty 重要的知识点讲解。</p>
<p>这本书基本把 Netty 一些重要的知识点都介绍到了，而且基本都是通过实战的形式讲解。</p>
<p><strong>《Netty 进阶之路：跟着案例学 Netty》</strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-214ed872bb89b37b2b3c06b4c8c022e5_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-214ed872bb89b37b2b3c06b4c8c022e5_720w.jpg?source=1940ef5c" alt="img"></p>
<p>内容都是关于使用 Netty 的实践案例比如内存泄露这些东西。如果你觉得你的 Netty 已经完全入门了，并且你想要对 Netty 掌握的更深的话，推荐你看一下这本书。</p>
<p><strong>《Netty 入门与实战：仿写微信 IM 即时通讯系统》</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-31d3de0843d01caea292fc461ca00d55_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-31d3de0843d01caea292fc461ca00d55_720w.jpg?source=1940ef5c" alt="img"></p>
<p>通过一个基于 Netty 框架实现 IM 核心系统为引子，带你学习 Netty。整个小册的质量还是很高的，即使你没有 Netty 使用经验也能看懂。</p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h2><p>搜索引擎用于提高搜索效率，功能和浏览器搜索引擎类似。比较常见的搜索引擎是 Elasticsearch（推荐） 和 Solr。</p>
<p>如果你要学习 Elasticsearch 的话，<a href="https://link.zhihu.com/?target=http://www.elasticsearch.cn/">Elastic 中文社区</a> 以及 <a href="https://link.zhihu.com/?target=https://www.elastic.co/cn/blog/">Elastic 官方博客</a> 都是非常不错的资源，上面会分享很多具体的实践案例。</p>
<p>除此之外，极客时间的<a href="https://link.zhihu.com/?target=http://gk.link/a/10bcT">《Elasticsearch 核心技术与实战》</a>这门课程非常赞！这门课基于 Elasticsearch 7.1 版本讲解，比较新。并且，作者是 eBay 资深技术专家，有 20 年的行业经验，课程质量有保障！</p>
<p><img src="https://pic1.zhimg.com/50/v2-057c22f1e83338a78f2e6b22e5da777d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-057c22f1e83338a78f2e6b22e5da777d_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想看书的话，可以考虑一下 《Elasticsearch 实战》 这本书。不过，需要说明的是，这本书中的 Elasticsearch 版本比较老，你可以将其作为一个参考书籍来看，有一些原理性的东西可以在上面找找答案。</p>
<p><img src="https://pic2.zhimg.com/50/v2-d2048059f45eac3a26001579c7826d8f_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d2048059f45eac3a26001579c7826d8f_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想进一步深入研究 Elasticsearch 原理的话，可以看看张超老师的《Elasticsearch 源码解析与优化实战》这本书。这是市面上唯一一本写 Elasticsearch 源码的书。</p>
<p><img src="https://pic4.zhimg.com/50/v2-85d4049c868a55ecbc76ae6c329eaebf_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-85d4049c868a55ecbc76ae6c329eaebf_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>下面我们开始学习分布式以及高并发、高可用了。</p>
<p>这块内容的话，对于每一个知识点没有特定的书籍。我就推荐 2 本我觉得还不错的书籍吧！这两把书籍基本把下面涉及到的知识点给涵盖了。</p>
<p>第一本是李运华老师的**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30335935/">《从零开始学架构》</a>** 。</p>
<p><img src="https://pic2.zhimg.com/50/v2-145c577cd6856daca487eec730ffc394_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-145c577cd6856daca487eec730ffc394_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书对应的有一个极客时间的专栏—<a href="https://link.zhihu.com/?target=http://gk.link/a/10pKZ">《从零开始学架构》</a>，里面的很多内容都是这个专栏里面的，两者买其一就可以了。</p>
<p>第二本是余老师的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30443578/">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-fe7286730c9ea0f94196b5e9f1dd3e07_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-fe7286730c9ea0f94196b5e9f1dd3e07_720w.jpg?source=1940ef5c" alt="img"></p>
<p>事务与锁、分布式（CAP、分布式事务……）、高并发、高可用这本书都有介绍到。值得推荐！良心好书！</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a><strong>理论</strong></h3><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a><strong>CAP 理论</strong></h3><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">《CAP 理论解读》</a>。</p>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a><strong>BASE 理论</strong></h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/BASE%E7%90%86%E8%AE%BA">《BASE 理论解读》</a>。</p>
<h3 id="Paxos-算法和-Raft-算法"><a href="#Paxos-算法和-Raft-算法" class="headerlink" title="Paxos 算法和 Raft 算法"></a><strong>Paxos 算法和 Raft 算法</strong></h3><p><strong>Paxos 算法</strong>诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—<strong>Raft 算法</strong>。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><strong>RPC</strong></h3><p>RPC 让调用远程服务调用像调用本地方法那样简单。</p>
<p>Dubbo 是一款国产的 RPC 框架，由阿里开源。相关阅读：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/Dubbo">Dubbo 常见问题总结</a></li>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC">服务之间的调用为啥不直接用 HTTP 而用 RPC？</a></li>
</ul>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a><strong>服务注册与发现</strong></h3><p>Eureka、Zookeeper、Consul、Nacos 都可以提供服务注册与发现的功能。</p>
<p><img src="https://pic1.zhimg.com/50/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_720w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a><strong>API 网关</strong></h3><p>网关主要用于请求转发、安全认证、协议转换、容灾。</p>
<p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，为了取代 Netflix Zuul。</p>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a><strong>配置中心</strong></h3><p>微服务下，业务的发展一般会导致服务数量的增加，进而导致程序配置（服务地址、数据库参数等等）增多。</p>
<p>传统的配置文件的方式已经无法满足当前需求，主要有两点原因：一是安全性得不到保障（配置放在代码库中容易泄露）；二是时效性不行 （修改配置需要重启服务才能生效）。</p>
<p>Spring Cloud Config、Nacos 、Apollo、K8s ConfigMap 都可以用来做配置中心。</p>
<p>Apollo 和 Nacos 我个人更喜欢。Nacos 使用起来更加顺手，Apollo 在配置管理方面做的更加全面。</p>
<h3 id="分布式-id"><a href="#分布式-id" class="headerlink" title="分布式 id"></a><strong>分布式 id</strong></h3><p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>
<p><img src="https://pic1.zhimg.com/50/v2-21c5fb2a333d04d70ccf2554e4a66995_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-21c5fb2a333d04d70ccf2554e4a66995_720w.jpg?source=1940ef5c" alt="img"></p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>
<p>我简单举一个分库分表的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。</p>
<p>单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>
<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-1f699f3733924441f3707926da884744_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-1f699f3733924441f3707926da884744_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<p>分布式 ID 的解决方案有很多比如 ：</p>
<ul>
<li>算法 ：UUID、Snowflake</li>
<li>开源框架 ： UidGenerator、Leaf 、Tinyid</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><strong>分布式事务</strong></h3><p>微服务架构下，一个系统被拆分为多个小的微服务。</p>
<p>每个微服务都可能存在不同的机器上，并且每个微服务可能都有一个单独的数据库供自己使用。这种情况下，一组操作可能会涉及到多个微服务以及多个数据库。</p>
<p>举个例子：电商系统中，你创建一个订单往往会涉及到订单服务（订单数加一）、库存服务（库存减一）等等服务，这些服务会有供自己单独使用的数据库。</p>
<p><img src="https://pic2.zhimg.com/50/v2-feaa7d9765154fa367bc008444d208c3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-feaa7d9765154fa367bc008444d208c3_720w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>那么如何保证这一组操作要么都执行成功，要么都执行失败呢？</strong></p>
<p>这个时候单单依靠数据库事务就不行了！我们就需要引入 <strong>分布式事务</strong> 这个概念了！</p>
<p>常用分布式事务解决方案有 Seata 和 Hmily。</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://seata.io/zh-cn/index.html">Seata</a></strong> :Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://gitee.com/shuaiqiyu/hmily">Hmily</a></strong> : 金融级分布式事务解决方案</li>
</ol>
<h3 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a><strong>分布式链路追踪</strong></h3><p>不同于单体架构，在分布式架构下，请求需要在多个服务之间调用，排查问题会非常麻烦。我们需要分布式链路追踪系统来解决这个痛点。</p>
<p>目前分布式链路追踪系统基本都是根据谷歌的《Dapper 大规模分布式系统的跟踪系统》这篇论文发展而来，主流的有 Pinpoint，Skywalking ，CAT（当然也有其他的例如 Zipkin，Jaeger 等产品，不过总体来说不如前面选取的 3 个完成度高）等。</p>
<p>Zipkin 是 Twitter 公司开源的一个分布式链路追踪工具，Spring Cloud Sleuth 实际是基于 Zipkin 的。</p>
<p>SkyWalking 是国人吴晟（华为）开源的一款分布式追踪，分析，告警的工具，现在是 Apache 旗下开源项目</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><p>微服务的很多东西实际在分布式这一节已经提到了。</p>
<p>我这里就再补充一些微服务架构中，经常使用到的一些组件。</p>
<ul>
<li><strong>声明式服务调用</strong> : Feign</li>
<li><strong>负载均衡</strong> : Ribbon</li>
<li>……</li>
</ul>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a><strong>高并发</strong></h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h3><p><img src="https://pic2.zhimg.com/50/v2-4903cf7307350d41a16d0277112d5424_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4903cf7307350d41a16d0277112d5424_720w.jpg?source=1940ef5c" alt="img"></p>
<p>消息队列在分布式系统中主要是为了解耦和削峰。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/message-queue/message-queue">消息队列常见问题总结</a>。</p>
<p>常用的消息队列如下：</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/rocketmq">RocketMQ</a></strong> ：阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/kafka">Kafaka</a></strong>: Kafka 是一种分布式的，基于发布 &#x2F; 订阅的消息系统。关于它的入门可以查看：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md">Kafka 入门看这一篇就够了</a></li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/rabbitmq">RabbitMQ</a></strong> :由 erlang 开发的基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。</li>
</ol>
<h3 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a><strong>读写分离&amp;分库分表</strong></h3><p>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。主服务器负责写，从服务器负责读。另外，一主一从或者一主多从都可以。</p>
<p>读写分离可以大幅提高读性能，小幅提高写的性能。因此，读写分离更适合单机并发读请求比较多的场景。</p>
<p><img src="https://pic3.zhimg.com/50/v2-36f2ed6de6018bb4cebab32623373864_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-36f2ed6de6018bb4cebab32623373864_720w.jpg?source=1940ef5c" alt="img"></p>
<p>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</p>
<p>常见的分库分表工具有：sharding-jdbc（当当）、TSharding（蘑菇街）、MyCAT（基于 Cobar）、Cobar（阿里巴巴）…。 推荐使用 sharding-jdbc。 因为，sharding-jdbc 是一款轻量级 Java 框架，以 jar 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。</p>
<p><img src="https://pic2.zhimg.com/50/v2-635a97b84f0e3b718b1cfdc61a0bbe08_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-635a97b84f0e3b718b1cfdc61a0bbe08_720w.jpg?source=1940ef5c" alt="img"></p>
<p>相关阅读： <a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">读写分离&amp;分库分表常见问题总结</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。</p>
<p>常见的负载均衡系统包括 3 种：</p>
<ol>
<li><strong>DNS 负载均衡</strong> ：一般用来实现地理级别的均衡。</li>
<li><strong>硬件负载均衡</strong> ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li>
<li><strong>软件负载均衡</strong> ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li>
</ol>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h2><p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的 。</p>
<p>相关阅读： <strong>《<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9">如何设计一个高可用系统？要考虑哪些地方？</a>》</strong> 。</p>
<h3 id="限流-amp-降级-amp-熔断"><a href="#限流-amp-降级-amp-熔断" class="headerlink" title="限流&amp;降级&amp;熔断"></a><strong>限流&amp;降级&amp;熔断</strong></h3><p>限流是从用户访问压力的角度来考虑如何应对系统故障。限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。比如某一接口的请求限制为 100 个每秒, 对超过限制的请求放弃处理或者放到队列中等待处理。限流可以有效应对突发请求过多。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/limit-request">限流算法有哪些？</a></p>
<p>降级是从系统功能优先级的角度考虑如何应对系统故障。服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<p>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。</p>
<p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Netflix/Hystrix">Hystrix</a> 和 <a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel">Sentinel</a> 都能实现限流、降级、熔断。</p>
<p>Hystrix 是 Netflix 开源的熔断降级组件，Sentinel 是阿里中间件团队开源的一款不光具有熔断降级功能，同时还支持系统负载保护的组件。</p>
<p>两者都是主要做熔断降级 ，那么两者到底有啥异同呢？该如何选择呢？</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94">Sentinel 的 wiki 中已经详细描述了其与 Hystrix 的区别</a>，你可以看看。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a><strong>排队</strong></h3><p>另类的一种限流，类比于现实世界的排队。玩过英雄联盟的小伙伴应该有体会，每次一有活动，就要经历一波排队才能进入游戏。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><p>相同的服务部署多份，避免单点故障。</p>
<h3 id="超时和重试机制"><a href="#超时和重试机制" class="headerlink" title="超时和重试机制"></a><strong>超时和重试机制</strong></h3><p><strong>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</strong> 如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。</p>
<p>另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/a269a036/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/a269a036/" class="post-title-link" itemprop="url">jvm调优</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/a269a036/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/a269a036/" data-xid="/posts/a269a036/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><h2 id="一、优化系统的思路"><a href="#一、优化系统的思路" class="headerlink" title="一、优化系统的思路"></a>一、优化系统的思路</h2><p>没有jvm调优经历</p>
<ol>
<li>一般来说关系型数据库是先到瓶颈，首先排查是否为数据库的问题<br>（这个过程中就需要评估自己建的索引是否合理、是否需要引入分布式缓存、是否需要分库分表等等</li>
<li>然后，我们会考虑是否需要扩容（横向和纵向都会考虑）<br>（这个过程中我们会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题）</li>
<li>接着，应用代码层面上排查并优化<br>（扩容是不能无止境的，里头里外都是钱阿，这个过程中我们会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过并行的方式处理某些请求)</li>
<li>再接着，JVM层面上排查并优化<br>（审视完代码之后，这个过程我们观察J VM是否存在多次GC问题等等）</li>
<li>最后，网络和操作系统层面排查<br>（这个过程查看内存&#x2F;CPU&#x2F;网络&#x2F;硬盘读写指标是否正常等等）</li>
</ol>
<p><strong>绝大多数情况下，到第三步就结束了，一般经过「运维团队」给我们设置的JVM和机器上的参数，已经满足绝大多数的需求了。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ymDKDD_20210923115445.png"></p>
<h2 id="二、举例子"><a href="#二、举例子" class="headerlink" title="二、举例子"></a>二、举例子</h2><p>之前有过其他团队在「大促」发现接口处理超时的问题，那时候查各种监控怀疑是FULLGC频率稍大所导致的</p>
<ol>
<li>第一想法不是说去调节各种JVM参数来进行优化，而是直接加机器（用最粗暴的方法，解决问题是最简单的，扩容YYDS）</li>
<li>不过，我是学过JVM相关的调优命令和思路的。<br>在我的理解下，调优JVM其实就是在「理解」JVM内存结构以及各种垃圾收集器前提下，结合自己的现有的业务来「调整参数」，使自己的应用能够正常稳定运行。<ul>
<li>一般调优JVM我们认为会有几种指标可以参考：「吞吐量」、「停顿时间」和「垃圾回收频率」</li>
<li>基于这些指标，我们就有可能需要调整：<ol>
<li>内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等）<br>比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX：SurvivorRatio：伊甸区和幸存区的比例等等）<br>按经验来说：I0密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</li>
<li>垃圾回收器（选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数）<br>比如（-XX：+UseG1GC：指定JVM使用的垃圾回收器为G1、-XX：MaxGCPause Millis：设置目标停顿时间、-XX：InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例，全局并发标记阶段就会被启动等等）<br>没错，这些都是因地制宜，具体问题具体分析（前提是得懂JVM的各种基础知识，基础知识都不懂，谈何调优）<br>在大多数场景下，JVM已经能够达到「开箱即用」</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="三、调优工具"><a href="#三、调优工具" class="headerlink" title="三、调优工具"></a>三、调优工具</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ixx1QR_20210923115955.png"></p>
<p>一般我们是「遇到问题」之后才进行调优的，而遇到问题后需要利用各种的 「工具」 进行排查</p>
<ol>
<li>通过jps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥</li>
<li>通过jstat命令查看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况</li>
<li>通过jinfo命令来查看和调整Java进程的「运行参数」</li>
<li>通过jmap命令来查看Java进程的「内存信息」。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT（Memory Analyzer tool内存解析工具）把文件进行分析</li>
<li>通过jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题</li>
<li>还有近期比较热门的Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。这也是我这边常用的排查和分析工具</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HzOR97_20210923141932.png"></p>
<h2 id="四、jvm的jit优化技术"><a href="#四、jvm的jit优化技术" class="headerlink" title="四、jvm的jit优化技术"></a>四、jvm的jit优化技术</h2><p>JIT优化技术比较出名的有两种：方法内联和逃逸分析</p>
<ol>
<li>所谓方法内联就是把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以「方法内联」的优化可以提高一定的性能<br>在JVM中也有相关的参数给予我们指定 (-XX:MaxFreqlnlineSize、 -XX:MaxInli neSize等等）</li>
<li>而「逃逸分析」则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化<br>下面我举几个可优化的例子（思路）：<ul>
<li>1.锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉0</li>
<li>2.栈上分配：该对象只会在方法内部被访问，直接将对象分配在「栈」中（Java默认是将对象分配在「堆」中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）</li>
<li>3.标量替换&#x2F;分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/D1Gg1I_20210923142207.png"></p>
<p>不过扯了这么多，不同的JVM版本对JIT的优化都不太相同</p>
<p>这里也只能算是一个参考</p>
<p>线上在使用的JVM也不知道有没有做了这么些优化.</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/8537f75f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/8537f75f/" class="post-title-link" itemprop="url">双亲委派机制</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/8537f75f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/8537f75f/" data-xid="/posts/8537f75f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h2 id="一、双亲委派机制"><a href="#一、双亲委派机制" class="headerlink" title="一、双亲委派机制"></a>一、双亲委派机制</h2><ol>
<li><p>class文件是通过类加载器加载到jvm中的</p>
</li>
<li><p>为了防止内存中存在多份同样的字节码，使用了双亲委派机制（不会自己加载类，而是把请求委托给父加载器去完成，依次向上）</p>
</li>
<li><p>jdk本地方法类一般有根加载器（BootStrap Loader） 装载，jdk内部实现的扩展类一般由扩展加载器（ExtClassLoader），程序中的类文件则有系统加载器（AppClassLoader）装载</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/W7CetM_20210922105555.png"></p>
</li>
</ol>
<h2 id="二、如何打破双亲委派机制"><a href="#二、如何打破双亲委派机制" class="headerlink" title="二、如何打破双亲委派机制"></a>二、如何打破双亲委派机制</h2><ol>
<li>只要我加载类的时候，不是从AppClassLoader→ExtClassLoader→BootStrap Loader这个顺序找，那就是打破了。</li>
<li>因为加载class核心的方法在LoaderClass类的loadClass()方法上（双亲委派机制的核心实现上）</li>
<li>只要我自定义个ClassLoader，重写loadClass方法（不依照往上开始寻找类加载器），那就算是打破双亲委派机制了。</li>
</ol>
<h2 id="三、破坏双亲委派机制的场景"><a href="#三、破坏双亲委派机制的场景" class="headerlink" title="三、破坏双亲委派机制的场景"></a>三、破坏双亲委派机制的场景</h2><ol>
<li>tomcat：初学部署项目时，我们是把war包放到tomcat的webapp下，意味着tomcat可以运行多个web应用程序</li>
<li>那假设我现在有2个web应用程序，都有一个类，叫做User，并且它们的类全限定名都一样，比如：都是com.xxxxx.User。但是它们的具体实现是不一样的</li>
<li>那么tomcat是如何保证它们不会冲突的呢？</li>
<li>答案就是：tomcat给每个web应用创建了一个类加载器实例（WebAppClassLoader），该加载器重写了loadClass方法，优先加载当前应用目录下的类，如果当前找不到，才一层一层往上找。这样就做到了web应用层级的隔离。</li>
</ol>
<h2 id="四、tomcat还有别的类加载器吗"><a href="#四、tomcat还有别的类加载器吗" class="headerlink" title="四、tomcat还有别的类加载器吗"></a>四、tomcat还有别的类加载器吗</h2><ol>
<li><p>并不是web应用下的所有依赖都是需要隔离的，比如redis就是可以web应用之间共享的</p>
</li>
<li><p>因为如果版本相同，没必要每个web应用都独自加载一份</p>
</li>
<li><p>做法很简单，tomcat就在WebAppClassLoader上加了个父类加载器（SharedClassLoader），如果WebAppClassLoader自身没有加载到某个类，那就委托ShaerClassLoader去加载。（无非就是把需要应用程序之间需要共享的类放到一个共享目录下,SharedClassLoader）读共享目录的类就好了</p>
</li>
<li><p>为了隔离web应用与tomcat本身的类，又有类加载器（CatalinaClassLoader）来装载tomcat本身的依赖</p>
</li>
<li><p>如果tomcat本身的类的依赖和web应用还需要共享，那么还有类加载器（CommonClassLoader）来装载进而达到共享</p>
</li>
<li><p>各个类加载器的加载目录可以到tomcat的catalina.properties配置文件上查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5TeCHY_20210922111755.png"></p>
</li>
</ol>
<h2 id="五、jdbc"><a href="#五、jdbc" class="headerlink" title="五、jdbc"></a>五、jdbc</h2><ol>
<li>有没有破坏双亲委派机制，见仁见智</li>
<li>jdbc定义类接口，具体实现类由各个厂商进行实现（比如Mysql）</li>
<li>类加载有个规则：如果一个类由类加载器A加载，那么这个类的依赖类也是有相同的类加载器加载</li>
<li>我们用jdbc的时候，是使用DriverManager进而获取Connection，DriverManager在java.sql包下，显然是有BootStrap类加载器进行装载</li>
<li>当我们使用DriverManager.getConnection()时，得到的是一定是厂商实现的类</li>
<li>但BootStrap 加载器显然不可以加载各个厂商实现的类，这些实现类又没在java包中，怎么可能加载到呢</li>
<li>DriverManager的解决方案是：在DriverManager初始化时，得到上下文加载器，去获取Connection时，是使用上下文加载器去加载Connection的，而这里的线程上下文加载器实际上还是（AppClassLoader）</li>
<li>在获取Connection的时候，还是先找到ExtClassLoader和B o o t S t ra p C la s sLoader，只不过这两加载器肯定是加载不到的，最终会有AppClassLoader进行加载</li>
<li>那这种情况，有的人觉得破坏了双亲委派机制，因为本来明明应该是有BootStrapClassLoader进行加载的，结果你来了一手线程上下文加载器，改掉了类加载器</li>
<li>有的人觉得没破坏双亲委派机制，只是改成了由线程上下文加载器进行类加载，但是还是遵守依次往上找父类加载，都找不到时才由自身加载。认为原则上没有改变。</li>
<li>我觉得这不重要，重要的是弄懂底层原理</li>
</ol>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/5bf4d040/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/5bf4d040/" class="post-title-link" itemprop="url">线程与进程</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/5bf4d040/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/5bf4d040/" data-xid="/posts/5bf4d040/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><ol>
<li>计算机内存空间</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/RqW68w_20210909173200.png"></p>
<p>​        用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组， 这个数组肯定存在用户空间;内核空间存放内核进程需要加载的系统资源， 这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内 核空间的资源，比如一些动态链接库等等。</p>
<ol start="2">
<li><p><strong>对于操作系统，进程就是一个数据结构</strong>，直接看 Linux 的源码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">  		<span class="comment">// 进程状态</span></span><br><span class="line">      <span class="type">long</span> state; </span><br><span class="line">  		<span class="comment">// 虚拟内存结构体</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> </span><br><span class="line">  		<span class="comment">// 进程号</span></span><br><span class="line">      <span class="type">pid_t</span> pid;</span><br><span class="line">      <span class="comment">// 指向父进程的指针</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> </span><br><span class="line">      <span class="comment">// 一个数组，包含该进程打开的文件指针 </span></span><br><span class="line">  		<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        其中比较有意思的是 mm 指针和 files 指针。</p>
<p>​        mm 指针指向：进程的虚拟内存，也就是载入资源和可执行文件的地方;</p>
<p>​        files 指针指向：一个数组，这个数组里装着所有该进程打开的文件的指针。</p>
</li>
</ol>
<h2 id="二、文件描述符"><a href="#二、文件描述符" class="headerlink" title="二、文件描述符"></a>二、文件描述符</h2><p>​        <strong>每个进程被创建时，</strong> <strong>files</strong> <strong>的前三位被填入默认值，分别指向标准输入 流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件 指针数组的索引（0，1，2）</strong>，所以程序的文件描述符默认情况下 <strong>0 是输入，1 是输出， 2 是错误。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210909224717097_20210909224717.png"></p>
<p>​        linux一切皆文件，对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器， 所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的 进程需要通过「系统调用」让内核进程访问硬件资源。</p>
<p>​        如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简 单，进行系统调用，让内核把文件打开，这个文件就会被放到 files 的第 4 个位置:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ex9iww_20210909225018.png"></p>
<p><strong>输入重定向</strong>：command &lt; file.txt，file[0]指向file.txt,程序从file[0]读取数据</p>
<p><strong>输出重定向</strong>：command &gt; file.txt，file[1]指向file.txt， 程序像file[1]写入数据</p>
<p><strong>管道符</strong>：cmd1 | cmd2 把一个进程的输出流和另一个进程的输入流接起 一条「管道」，数据就在其中传递</p>
<p><strong>注意：</strong>一个简单的 files 数组，进程通过简单的文件描述符访问相应资源， 具体细节交于操作系统，有效解耦，优美高效。</p>
<h2 id="三、线程是什么"><a href="#三、线程是什么" class="headerlink" title="三、线程是什么"></a>三、线程是什么</h2><p>​            之所以Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。<strong>都是用</strong> <strong>task_struct</strong> <strong>结构表示的，唯一的 区别就是共享的数据区域不同</strong>。</p>
<p>​        换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进 程是共享的，而子进程是拷⻉副本，而不是共享。就比如说， mm 结构 和 files 结构在线程中都是共享的，我画两张图你就明白了:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/X1GvhJ_20210909230142.png"></p>
<p><strong>注意：</strong>对于新建进程时内存区域拷 ⻉的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父 进程的内存空间，而是等到需要写操作时才去复制。<strong>所以</strong> <strong>Linux</strong> <strong>中新建进 程和新建线程都是很迅速的</strong>。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/4d79f088/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4d79f088/" class="post-title-link" itemprop="url">面试官：说说你了解class文件吗？</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/4d79f088/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/4d79f088/" data-xid="/posts/4d79f088/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面试官：说说你了解class文件吗？"><a href="#面试官：说说你了解class文件吗？" class="headerlink" title="面试官：说说你了解class文件吗？"></a>面试官：说说你了解class文件吗？</h1><p><strong>本文思维导图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2rLXEs_20210507091957.png" alt="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2rLXEs_20210507091957.png"></p>
<h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><h2 id="为什么Java可以一次编译到处运行？JVM无关性"><a href="#为什么Java可以一次编译到处运行？JVM无关性" class="headerlink" title="为什么Java可以一次编译到处运行？JVM无关性"></a>为什么Java可以一次编译到处运行？JVM无关性</h2><p>与平台无关性是建立在操作系统上，虚拟机厂商提供了许多可以运行在各种不同平台的虚拟机，它们都可以载入和执行字节码，从而实现程序的“一次编写，到处运行”。</p>
<p>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（Byte Code）是构成平台无关性的基石，也是语言无关性的基础。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ZGOAdI_20210507092208.png" alt="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ZGOAdI_20210507092208.png"></p>
<h2 id="Class-类文件"><a href="#Class-类文件" class="headerlink" title="Class  类文件"></a>Class  类文件</h2><p>Java 技术能够一直保持非常好的向后兼容性，这点 Class 文件结构的稳定性功不可没。Java 已经发展到 14 版本，但是 class 文件结构的内容，绝大部分在JDK1.2 时代就已经定义好了。虽然 JDK1.2 的内容比较古老，但是 java 发展经历了十余个大版本，但是每次基本上知识在原有结构基础上新增内容、扩充功能，并未对定义的内容做修改。</p>
<p>任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际上它并不一定以磁盘文件的形式存在（比如可以动态生成、或者直接送入类加载器中）。</p>
<p>Class 文件是一组以 8 位字节为基础单位的二进制流。</p>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>Sublime：查看 16 进制的编辑器<br>javap：javap 是 JDK 自带的反解析工具。它的作用是将 .class 字节码文件解析成可读的文件格式。<br>在使用 javap 时我一般会添加 -v 参数，尽量多打印一些信息。同时，我也会使用 -p 参数，打印一些私有的字段和方法。<br>jclasslib：如果你不太习惯使用命令行的操作，还可以使用 jclasslib，jclasslib 是一个图形化的工具，能够更加直观的查看字节码中的内容。它还分门别类的对类中的各个部分进行了整理，非常的人性化。同时，它还提供了 Idea 的插件，你可以从 plugins 中搜索到它。</p>
<h2 id="Class-文件格式"><a href="#Class-文件格式" class="headerlink" title="Class  文件格式"></a>Class  文件格式</h2><p>从一个 Class 文件开始，整个 Class 文件的格式就是一个二进制的字节流。各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>
<p>Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p>
<p>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节（一个字节是由两位 16 进制数组成 （<strong>1个16进制数&#x3D;4个二进制数 8个二进制数&#x3D;一个字节</strong>））、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class 文件本质上就是一张表。</p>
<h2 id="Class-文件格式详解"><a href="#Class-文件格式详解" class="headerlink" title="Class  文件格式详解"></a>Class  文件格式详解</h2><p>Class 的结构不像 XML 等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/mwHImZ_20210507115741.png" alt="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/mwHImZ_20210507115741.png"></p>
<p>按顺序包括：</p>
<h3 id="魔数与-Class-文件的版本"><a href="#魔数与-Class-文件的版本" class="headerlink" title="魔数与 Class  文件的版本"></a>魔数与 Class  文件的版本</h3><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。</p>
<p>紧接着魔数的 4 个字节存储的是 Class 文件  的版本号：第 5 和第 6 个字节是次版本号（MinorVersion），第 7 和第 8 个字节是主版本号（Major Version）。</p>
<p>Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1 高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件。<img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/1xvCIr_20210507115713.png" style = "width:20px height:1px" />代表 JDK1.8（16 进制的 34，换成 10 进制就是 52）</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/L7NUe4_20210507115859.png"></p>
<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。<br>字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。<br>符号引用则属于编译原理方面的概念，包括了下面三类常量：类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等</p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p>这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。<br>而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>描述了方法的定义，但是方法里的 Java 代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。</p>
<p>与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>存储 Class 文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在 Code 属性表中。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/995671e7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/995671e7/" class="post-title-link" itemprop="url">动态规划答疑篇</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-11 10:11:17" itemprop="dateModified" datetime="2022-03-11T10:11:17+08:00">2022-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/995671e7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/995671e7/" data-xid="/posts/995671e7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态规划答疑篇"><a href="#动态规划答疑篇" class="headerlink" title="动态规划答疑篇"></a>动态规划答疑篇</h1><h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>这篇文章就给你讲明白两个读者问得最多的问题：</p>
<p>1、到底什么才叫「最优子结构」，和动态规划什么关系。</p>
<p>2、为什么动态规划遍历<code>dp</code>数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历，有的无论咋遍历都是对的。</p>
<h2 id="一、最优子结构详解"><a href="#一、最优子结构详解" class="headerlink" title="一、最优子结构详解"></a>一、最优子结构详解</h2><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。</p>
<p>我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p>
<p>我给你提出的这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p>
<p>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p>
<p>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p>
<p>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划详解</a> 说过，想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p>
<p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a : school) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Student b : school) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a is b) <span class="keyword">continue</span>;</span><br><span class="line">        result = max(result, |a.score - b.score|);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p>
<p>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。</p>
<p>前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484469&idx=1&sn=e8d321c8ad62483874a997e9dd72da8f&chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 和 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484690&idx=1&sn=eea075701a5d96dd5c6e3dc6a993cac5&chksm=9bd7fb1aaca0720c58c9d9e02a8b9211a289bcea359633a95886d7808d2846898d489ce98078&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋（进阶篇）</a> 就展示了如何改造问题，不同的最优子结构，可能导致不同的解法和效率。</p>
<p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxVal(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxVal(root.right);</span><br><span class="line">    <span class="keyword">return</span> max(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看这个问题也符合最优子结构，以<code>root</code>为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p>
<p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p>
<p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p>
<p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。</p>
<p>这里就不举那些正宗动态规划的例子了，读者可以翻翻历史文章，看看状态转移是如何遵循最优子结构的，这个话题就聊到这，下面再来看另外个动态规划迷惑行为。</p>
<h3 id="二、dp-数组的遍历方向"><a href="#二、dp-数组的遍历方向" class="headerlink" title="二、dp 数组的遍历方向"></a>二、dp 数组的遍历方向</h3><p>我相信读者做动态规划问题时，肯定会对<code>dp</code>数组的遍历顺序有些头疼。我们拿二维<code>dp</code>数组来举例，有时候我们是正向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p>有时候我们反向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p>有时候可能会斜向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斜着遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a> 中有的地方就正反皆可。</p>
<p>那么，如果仔细观察的话可以发现其中的原因的。你只要把住两点就行了：</p>
<p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p>
<p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p>
<p>下面来具体解释上面两个原则是什么意思。</p>
<p>比如编辑距离这个经典的问题，详解见前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect">经典动态规划：编辑距离</a>，我们通过对<code>dp</code>数组的定义，确定了 base case 是<code>dp[..][0]</code>和<code>dp[0][..]</code>，最终答案是<code>dp[m][n]</code>；而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i-1][j-1]</code>转移而来，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/H23fMQ_20210507174659.png" alt="图片"></p>
<p>那么，参考刚才说的两条原则，你该怎么遍历<code>dp</code>数组？肯定是正向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="comment">// 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span></span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案<code>dp[m][n]</code>。</strong></p>
<p>再举一例，回文子序列问题，详见前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484666&idx=1&sn=e3305be9513eaa16f7f1568c0892a468&chksm=9bd7faf2aca073e4f08332a706b7c10af877fee3993aac4dae86d05783d3d0df31844287104e&scene=21#wechat_redirect">子序列解题模板：最长回文子序列</a>，我们通过过对<code>dp</code>数组的定义，确定了 base case 处在中间的对角线，<code>dp[i][j]</code>需要从<code>dp[i+1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i+1][j-1]</code>转移而来，想要求的最终答案是<code>dp[0][n-1]</code>，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/L4hOYZ_20210507174734.png" alt="图片"></p>
<p>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/UGCkQ2_20210507174820.png" alt="图片"></p>
<p><strong>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>的左边、下边、左下边已经计算完毕，最终得到正确结果。</strong></p>
<p>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/117b65dd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/117b65dd/" class="post-title-link" itemprop="url">动态规划设计之最长递增子序列</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/117b65dd/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/117b65dd/" data-xid="/posts/117b65dd/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态规划设计之最长递增子序列"><a href="#动态规划设计之最长递增子序列" class="headerlink" title="动态规划设计之最长递增子序列"></a>动态规划设计之最长递增子序列</h1><h2 id="预计阅读时间：-9-分钟"><a href="#预计阅读时间：-9-分钟" class="headerlink" title="预计阅读时间： 9 分钟"></a>预计阅读时间： 9 分钟</h2><p>很多读者反应，就算看了前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247483818&idx=1&sn=6035f861d1b2bfd0178e842f26ac4836&chksm=fb3361e8cc44e8fe331154bfd32bd7b3b4f159bfad5d38d4a6b0b9f0d7e3485b93b828ee72cc&scene=21#wechat_redirect">动态规划详解</a>，了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。</p>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。</p>
<p>比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p>
<p>先看一下题目，很容易理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/MEAMGr_20210715222744.png" alt="图片"></p>
<p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p>
<h2 id="一、动态规划解法"><a href="#一、动态规划解法" class="headerlink" title="一、动态规划解法"></a>一、动态规划解法</h2><p><strong>动态规划的核心设计思想是数学归纳法。</strong></p>
<p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k&lt;n 时成立，然后想办法证明 k&#x3D;<em>n</em> 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <em>dp</em>[0…<em>i</em>−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出<em>dp[i] ?</em></p>
<p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？</p>
<p><strong>我们的定义是这样的：****dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。</strong></p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/S9DvIE_20210715222829.png" alt="图片"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/vrYoH4_20210715222841.png" alt="图片"></p>
<p>算法演进的过程是这样的：<img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640_20210715222950.gif" alt="图片"></p>
<p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？</p>
<p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p>
<p>我们已经知道了 <em>d**p</em>[0…4] 的所有结果，我们如何通过这些已知结果推出 <em>d**p</em>[5] 呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/xpC5LY_20210715223016.png" alt="图片"></p>
<p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p>
<p>nums[5] &#x3D; 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p>
<p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p>
<p>![图片](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640">https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640</a> (1)_20210715223303.gif)</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QksgN5_20210715223039.png" alt="图片"></p>
<p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？</p>
<p>类似数学归纳法，你已经可以通过 dp[0…4] 算出 dp[5] 了，那么任意 dp[i] 你肯定都可以算出来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9CYook_20210715223056.png" alt="图片"></p>
<p>还有一个细节问题，就是 base case。dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210715223113307_20210715223113.png" alt="图片"></p>
<p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：</p>
<p>首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p>然后根据 dp 数组的定义，运用数学归纳法的思想，假设 <em>d**p</em>[0…<em>i</em>−1] 都已知，想办法求出 <em>d**p</em>[<em>i</em>]，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p>
<h2 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h2><p>这个解法的时间复杂度会将为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以如果大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p>
<p>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。</p>
<p>为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下思路。</p>
<p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/DFBLV6_20210715223123.png" alt="图片"></p>
<p>处理这些扑克牌要遵循以下规则：</p>
<p>只能把点数小的牌压到点数比它大的牌上。如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去。如果当前牌有多个堆可供选择，则选择最左边的堆放置。</p>
<p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 A 的值是最大的，而不是 1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210715223138612_20210715223138.png" alt="图片"></p>
<p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Cnd9HF_20210715223145.png" alt="图片"></p>
<p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是我们想求的最长递增子序列的长度，证明略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/8SHDGY_20210715223158.png" alt="图片"></p>
<p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。</p>
<p>PS：旧文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484090&idx=1&sn=5635cf1c4fd8a8570b63c7ae9b4304c2&chksm=fb3362f8cc44ebee0a19a4cfba7f2e13923e05f47e15f2e99a1f42b01aeee83b946aceac3d4c&scene=21#wechat_redirect">二分查找算法详解</a> 详细介绍了二分查找的细节及变体，这里就完美应用上了。如果没读过强烈建议阅读。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/f6Golz_20210715223219.png" alt="图片"></p>
<p>至此，二分查找的解法也讲解完毕。</p>
<p>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。</p>
<p>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/6e5dcbe0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6e5dcbe0/" class="post-title-link" itemprop="url">回溯算法团灭排列组合子集问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/6e5dcbe0/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/6e5dcbe0/" data-xid="/posts/6e5dcbe0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="回溯算法团灭排列-x2F-组合-x2F-子集问题"><a href="#回溯算法团灭排列-x2F-组合-x2F-子集问题" class="headerlink" title="回溯算法团灭排列&#x2F;组合&#x2F;子集问题"></a>回溯算法团灭排列&#x2F;组合&#x2F;子集问题</h1><h2 id="回溯算法团灭排列-x2F-组合-x2F-子集问题-1"><a href="#回溯算法团灭排列-x2F-组合-x2F-子集问题-1" class="headerlink" title="回溯算法团灭排列&#x2F;组合&#x2F;子集问题"></a>回溯算法团灭排列&#x2F;组合&#x2F;子集问题</h2><h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。这几个问题都可以用回溯算法解决。</p>
<h3 id="一、子集"><a href="#一、子集" class="headerlink" title="一、子集"></a>一、子集</h3><p>问题很简单，输入一个<strong>不包含重复数字</strong>的数组，要求算法输出这些数字的所有子集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 <code>nums = [1,2,3]</code>，你的算法应输出 8 个子集，包含空集和本身，顺序可以不同：</p>
<p>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]</p>
<p><strong>第一个解法是利用数学归纳的思想</strong>：假设我现在知道了规模更小的子问题的结果，如何推导出当前问题的结果呢？</p>
<p>具体来说就是，现在让你求 <code>[1,2,3]</code> 的子集，如果你知道了 <code>[1,2]</code> 的子集，是否可以推导出 <code>[1,2,3]</code> 的子集呢？先把  <code>[1,2]</code> 的子集写出来瞅瞅：</p>
<p>[ [],[1],[2],[1,2] ]</p>
<p>你会发现这样一个规律：</p>
<p>subset(<code>[1,2,3]</code>) - subset(<code>[1,2]</code>)</p>
<p>&#x3D; [3],[1,3],[2,3],[1,2,3]</p>
<p>而这个结果，就是把 sebset(<code>[1,2]</code>) 的结果中每个集合再添加上 3。</p>
<p>换句话说，如果 <code>A = subset([1,2])</code> ，那么：</p>
<p>subset(<code>[1,2,3]</code>)</p>
<p>&#x3D; A + [A[i].add(3) for i &#x3D; 1..len(A)]</p>
<p>这就是一个典型的递归结构嘛，<code>[1,2,3]</code> 的子集可以由 <code>[1,2]</code> 追加得出，<code>[1,2]</code> 的子集可以由 <code>[1]</code> 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。</p>
<p>翻译成代码就很容易理解了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// base case，返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.back();</span><br><span class="line">    nums.pop_back();</span><br><span class="line">    <span class="comment">// 先递归算出前面元素的所有子集</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = subsets(nums);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.push_back(res[i]);</span><br><span class="line">        res.back().push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个问题的时间复杂度计算比较容易坑人</strong>。我们之前说的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是 N，但我们发现每次递归 for 循环的迭代次数取决于 <code>res</code> 的长度，并不是固定的。</p>
<p>根据刚才的思路，<code>res</code> 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。或者不用这么麻烦，你想想一个大小为 N 的集合的子集总共有几个？2^N 个对吧，所以说至少要对 <code>res</code> 添加 2^N 次元素。</p>
<p>那么算法的时间复杂度就是 O(2^N) 吗？还是不对，2^N 个子集是 <code>push_back</code> 添加进 <code>res</code> 的，所以要考虑 <code>push_back</code> 这个操作的效率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    res.push_back(res[i]); <span class="comment">// O(N)</span></span><br><span class="line">    res.back().push_back(n); <span class="comment">// O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>res[i]</code> 也是一个数组呀，<code>push_back</code> 是把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。</p>
<p>综上，总的时间复杂度就是 O(N*2^N)，还是比较耗时的。</p>
<p>空间复杂度的话，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p>
<p><strong>第二种通用方法就是回溯算法</strong>。旧文「回溯算法详解」写过回溯算法的模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>只要改造回溯算法的模板就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> &#123;</span><br><span class="line">    res.push_back(track);</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，对 <code>res</code> 的更新是一个<strong>前序遍历</strong>，也就是说，<code>res</code> 就是树上的所有节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/sULT7a_20210507182400.png" alt="图片"></p>
<h3 id="二、组合"><a href="#二、组合" class="headerlink" title="二、组合"></a>二、组合</h3><p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 <code>n = 4, k = 2</code>，输出如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，<code>[1,2]</code> 和 <code>[2,1]</code> 也算重复）：</p>
<p>[<br> [1,2],<br> [1,3],<br> [1,4],<br> [2,3],<br> [2,4],<br> [3,4]<br>]</p>
<p>这就是典型的回溯算法，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度，直接套我们以前讲过的回溯算法模板框架就行了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/y3DT6L_20210507182421.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    backtrack(n, k, <span class="number">1</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达树的底部</span></span><br><span class="line">    <span class="keyword">if</span> (k == track.size()) &#123;</span><br><span class="line">        res.push_back(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(i);</span><br><span class="line">        backtrack(n, k, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>backtrack</code> 函数和计算子集的差不多，<strong>区别在于，更新 <code>res</code> 的地方是树的底端</strong>。</p>
<h3 id="三、排列"><a href="#三、排列" class="headerlink" title="三、排列"></a>三、排列</h3><p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：</p>
<p>[<br> [1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1]<br>]</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法详解</a> 中就是拿这个问题来解释回溯模板的。这里又列出这个问题，是将「排列」和「组合」这两个回溯算法的代码拿出来对比。</p>
<p>首先画出回溯树来看一看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/uRIb5X_20210507182434.png" alt="图片"></p>
<p>我们当时使用 Java 代码写的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯模板依然没有变，但是根据排列问题和组合问题画出的树来看，排列问题的树比较对称，而组合问题的树越靠右节点越少。</p>
<p>在代码中的体现就是，排列问题每次通过 <code>contains</code> 方法来排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。</p>
<p><strong>以上，就是排列组合和子集三个问题的解法，总结一下</strong>：</p>
<p>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 <code>start</code> 参数排除已选择的数字。</p>
<p>组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 <code>start</code> 排除已经选择过的数字。</p>
<p>排列问题是回溯思想，也可以表示成树结构套用算法模板，不同之处在于使用 <code>contains</code> 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。</p>
<p>对于这三个问题，关键区别在于回溯树的结构，不妨多观察递归树的结构，很自然就可以理解代码的含义了。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swimminghao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">994k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:04</span>
  </span>
</div>

<span id="sitetime"></span>
<script language=javascript>
    function siteTime(){
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2022,02,28,00,00,00); //你的建站时间
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById("sitetime").innerHTML=" 本站已安全运行 "+diffYears+" Year "+diffDays+" Days "+diffHours+" Hours "+diffMinutes+" m "+diffSeconds+" s";
    }
    siteTime();
</script>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        访问人数：<span id="busuanzi_value_site_uv"></span>
      </span>人
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
       访问总量：<span id="busuanzi_value_site_pv"></span>
      </span>次
    </span>


<!--
  本文总阅读量：<span id="busuanzi_value_page_pv"></span>次
-->

</div>


<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

--><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-nu.vercel.app","placeholder":"请文明评论呀","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/page/8/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "middleCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
</body>
</html>
