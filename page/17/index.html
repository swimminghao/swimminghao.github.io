<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-loading-bar.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="swimminghao的学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swimminghao&#39;s blog">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="swimminghao&#39;s blog">
<meta property="og:description" content="swimminghao的学习博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swimminghao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/17/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/17/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>swimminghao's blog</title>
  




<link rel="dns-prefetch" href="waline-server-nu.vercel.app"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">swimminghao's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">56</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">280</span></a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="swimminghao"
      src="/images/lion.png">
  <p class="site-author-name" itemprop="name">swimminghao</p>
  <div class="site-description" itemprop="description">swimminghao的学习博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">280</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/swimminghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swimminghao0@gmail.com" title="E-Mail → mailto:swimminghao0@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/swimminghao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- recent posts -->
    <div class="links-of-blogroll motion-element links-of-blogroll-block">
        <div class="links-of-blogroll-title recent-posts-title">
	    <i class="fa fa-history " aria-hidden="true"></i>
            近期文章
	</div>
	<ul class="links-of-blogroll-list recent-posts-list">
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/7ac8a987/" title="HIFI日记：HQPlayer embedded （HQPlayer OS）嵌入版使用教程" target="">
		    HIFI日记：HQPlayer embedded （HQPlayer OS）嵌入版使用教程
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/eb18152/" title="OpenCore添加ubuntu引导，引导双系统" target="">
		    OpenCore添加ubuntu引导，引导双系统
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/f3a01220/" title="hqplayer和roon二合一" target="">
		    hqplayer和roon二合一
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/a0ae5a65/" title="CentOS7 源码安装redis4" target="">
		    CentOS7 源码安装redis4
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/701fa192/" title="mac10.15 下 git2.33 安装 git-gui" target="">
		    mac10.15 下 git2.33 安装 git-gui
		    </a>
		</li>
	</ul>
    </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/c988e95f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/c988e95f/" class="post-title-link" itemprop="url">上线流程-DESKTOP-J06DG54</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/c988e95f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/c988e95f/" data-xid="/posts/c988e95f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>790</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          这是一篇加密文章，需要密码才能继续阅读。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/c988e95f/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/4b90d310/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4b90d310/" class="post-title-link" itemprop="url">上线流程(另一个复件)</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/4b90d310/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/4b90d310/" data-xid="/posts/4b90d310/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>790</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          这是一篇加密文章，需要密码才能继续阅读。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/4b90d310/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/4f289b4f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4f289b4f/" class="post-title-link" itemprop="url">上线流程(复件)</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/4f289b4f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/4f289b4f/" data-xid="/posts/4f289b4f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>955</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          这是一篇加密文章，需要密码才能继续阅读。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/4f289b4f/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/16b3e53b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/16b3e53b/" class="post-title-link" itemprop="url">上线流程</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/16b3e53b/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/16b3e53b/" data-xid="/posts/16b3e53b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>824</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          这是一篇加密文章，需要密码才能继续阅读。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/16b3e53b/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/c77b99c1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/c77b99c1/" class="post-title-link" itemprop="url">使用java8实现List中对象属性的去重</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">语法</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/c77b99c1/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/c77b99c1/" data-xid="/posts/c77b99c1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用java8实现List中对象属性的去重"><a href="#使用java8实现List中对象属性的去重" class="headerlink" title="使用java8实现List中对象属性的去重"></a>使用java8实现List中对象属性的去重</h1><p>今天在工作的时候遇到了一个问题，就是List的去重，不想用双重for，感觉太low，不想用for+Map，感觉应该有更好的方法，于是，google之。发现java8的stream流能完美解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;BookInfoVo&gt; list</span><br></pre></td></tr></table></figure>
<p>比如在 BookInfoVo 中有一个 recordId 属性,现在需要对此去重.</p>
<p>怎么办呢?</p>
<p>有两种方法:</p>
<ul>
<li>第一种: 不使用java8 的 Stream<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;BookInfoVo&gt; <span class="title function_">removeDupliByRecordId</span><span class="params">(List&lt;BookInfoVo&gt; books)</span> &#123;</span><br><span class="line">	Set&lt;BookInfoVo&gt; bookSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1, o2)-&gt;o1.getRecordId().compareTo(o2.getRecordId()));</span><br><span class="line">          personSet.addAll(books);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BookInfoVo&gt;(bookSet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
这也是大多数人第一想到的,借助 TreeSet 去重,其中 TreeSet 的其中一个构造函数接收一个排序的算法,同时这也会用到 TreeSet 的去重策略上.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty tree set, sorted according to the specified</span></span><br><span class="line"><span class="comment">     * comparator.  All elements inserted into the set must be &lt;i&gt;mutually</span></span><br><span class="line"><span class="comment">     * comparable&lt;/i&gt; by the specified comparator: &#123;<span class="doctag">@code</span> comparator.compare(e1,</span></span><br><span class="line"><span class="comment">     * e2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> e1&#125; and &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add</span></span><br><span class="line"><span class="comment">     * an element to the set that violates this constraint, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> add&#125; call will throw a &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator the comparator that will be used to order this set.</span></span><br><span class="line"><span class="comment">     *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment">     *        ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>第二种: 炫酷的java8写法]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法二:炫酷的java8写法*/</span></span><br><span class="line">ArrayList&lt;BookInfoVo&gt; distinctLiost = list.stream()</span><br><span class="line">                  .collect(</span><br><span class="line">                          Collectors.collectingAndThen(</span><br><span class="line">                                  Collectors.toCollection(() -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparingLong(BookInfoVo::getRecordId))), ArrayList::<span class="keyword">new</span>)</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure>
当然也可以根据多个属性去重<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;BookInfoVo&gt; distinctLiost = list.stream().collect(Collectors.collectingAndThen(</span><br><span class="line">  Collectors.toCollection(() -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(o -&gt; o.getName() + <span class="string">&quot;;&quot;</span> + o.getAuthor()))), ArrayList::<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>
如果没有第一种方法做铺垫,我们很可能一脸懵逼.</li>
</ul>
<p>其实理解起来也不难:</p>
<p>关键在于Collectors.collectingAndThen( Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparingLong(BookInfoVo::getRecordId))), ArrayList::new)的理解,</p>
<p>collectingAndThen 这个方法的意思是: 将收集的结果转换为另一种类型: collectingAndThen,</p>
<p>因此上面的方法可以理解为,把 new TreeSet&lt;&gt;(Comparator.comparingLong(BookInfoVo::getRecordId))这个set转换为 ArrayList,这个结合第一种方法不难理解.</p>
<p>可以看到java8这种写法真是炫酷又强大!!!</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/74cfd586/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/74cfd586/" class="post-title-link" itemprop="url">java8类型互转</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">语法</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/74cfd586/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/74cfd586/" data-xid="/posts/74cfd586/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java8类型互转"><a href="#java8类型互转" class="headerlink" title="java8类型互转"></a>java8类型互转</h1><h2 id="List-lt-Integer-gt-、int-、Integer-相互转换"><a href="#List-lt-Integer-gt-、int-、Integer-相互转换" class="headerlink" title="List&lt; Integer &gt;、int[ ]、Integer[ ]相互转换"></a>List&lt; Integer &gt;、int[ ]、Integer[ ]相互转换</h2><p>[toc]</p>
<p>下文中出现的list、ints、integers分别代表一个列表、一个int数组、一个Integer数组。<br>它们之间所谓的转化，其实是 复制数据，互不干扰，可以理解为深拷贝。</p>
<h3 id="int-转-List-lt-Integer-gt"><a href="#int-转-List-lt-Integer-gt" class="headerlink" title="int[ ] 转 List&lt; Integer &gt;"></a>int[ ] 转 List&lt; Integer &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>Arrays.stream(ints) 之后返回的类型是 IntStream，IntStream 是一个接口继承自 BaseStream，BaseStream 又继承自AutoCloseable。所以我把IntStream看成一个方便对每个整数做操作的数据流。</p>
<p>之后调用了 boxed()，它的作用是对每个整数进行装箱，基本类型流转换为对象流，返回的是 Stream<Integer>，Stream 也是继承自 BaseStream。所以这一步的作用是把 IntStream 转换成了 Stream<Integer>。</p>
<p>最后通过collect方法将数据流 (Stream<Integer>) 收集成了集合 ( List<Integer>)，这里 collect 方法里传入的是一个收集器 (Collector)，它通过 Collectors.toList() 产生。</p>
<p>小结：</p>
<ol>
<li>Arrays.stream(ints) 将基本类型数组转换为基本类型流。 int[ ] &#x3D;&gt; IntStream</li>
<li>.boxed() 将基本类型流转换为对象流。 &#x3D;&gt; Stream&lt; Integer &gt;</li>
<li>.collect(Collectors.toList()) 将对象流收集为集合。 &#x3D;&gt; List&lt; Integer &gt;</li>
</ol>
<h3 id="int-转-List-lt-List-lt-Integer-gt-gt"><a href="#int-转-List-lt-List-lt-Integer-gt-gt" class="headerlink" title="int[ ] [ ] 转 List&lt;  List &lt; Integer &gt;  &gt;"></a>int[ ] [ ] 转 List&lt;  List &lt; Integer &gt;  &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> Arrays.deepToString(fooArr).replaceAll(<span class="string">&quot;\\[&quot;</span>,<span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;\\]&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">List&lt;String&gt; fooList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;,&quot;</span>)); <span class="comment">//不对</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; collect2 = Arrays.Stream(ints1).map(ar -&gt; Arrays.stream(ar).boxed().collect(Collectors.toList())).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="int-转-Integer"><a href="#int-转-Integer" class="headerlink" title="int[ ] 转 Integer[ ]"></a>int[ ] 转 Integer[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = Arrays.stream(ints).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>一样的内容就不重复了，toArray(T[ ] :: new) 方法返回基本类型数组。<br>小结：</p>
<ol>
<li>Arrays.stream(ints) 将基本类型数组转换为基本类型流。 int[ ] &#x3D;&gt; IntStream</li>
<li>.boxed() 将基本类型流转换为对象流。&#x3D;&gt; Stream&lt; Integer &gt;</li>
<li>.toArray(Integer[ ]::new) 将对象流转换为对象数组。&#x3D;&gt; Integer[ ]</li>
</ol>
<h3 id="int-转-Integer-1"><a href="#int-转-Integer-1" class="headerlink" title="int[ ] [ ]转 Integer[ ] [ ]"></a>int[ ] [ ]转 Integer[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] integers3 = Arrays.stream(ints1).map(ints -&gt; Arrays.stream(ints).boxed().toArray(Integer[]::<span class="keyword">new</span>)).toArray(Integer[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Integer-转-List-lt-Integer-gt"><a href="#Integer-转-List-lt-Integer-gt" class="headerlink" title="Integer[ ] 转 List&lt; Integer &gt;"></a>Integer[ ] 转 List&lt; Integer &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(integers);</span><br></pre></td></tr></table></figure>

<p>这个就很简单了，通过Arrays类里的asList方法将数组装换为List。值得注意：</p>
<p>asList 返回的是 Arrays 里的静态私有类 ArrayList，而不是 java.util 里的 ArrayList，它无法自动扩容。</p>
<p>可以用下面2种方法生成可扩容的ArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(integers)); </span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">Collections.addAll(list, integers);</span><br></pre></td></tr></table></figure>

<h3 id="Integer-转-List-lt-List-lt-Integer-gt-gt"><a href="#Integer-转-List-lt-List-lt-Integer-gt-gt" class="headerlink" title="Integer[ ] [ ]转 List&lt; List &lt; Integer &gt; &gt;"></a>Integer[ ] [ ]转 List&lt; List &lt; Integer &gt; &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; lists = Arrays.stream(a).map(Arrays::asList).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="Integer-转-int"><a href="#Integer-转-int" class="headerlink" title="Integer[ ] 转 int[ ]"></a>Integer[ ] 转 int[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>

<p>map的意思是把每一个元素进行同样的操作。mapToInt的意思是把每一个元素转换为int。mapToInt(Integer::valueOf)方法返回的是IntStream。<br>小结：</p>
<ol>
<li>Arrays.stream(integers) 将对象数组转换为对象流。 Integer[ ] &#x3D;&gt; Stream&lt; Integer &gt;</li>
<li>.mapToInt(Integer::valueOf) 将对象流转换成基本类型流。&#x3D;&gt; IntStream</li>
<li>.toArray() 将基本类型流转换为基本类型数组。 &#x3D;&gt; int[ ]</li>
</ol>
<h3 id="Integer-转-int-1"><a href="#Integer-转-int-1" class="headerlink" title="Integer[ ] [ ]转 int[ ] [ ]"></a>Integer[ ] [ ]转 int[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;      </span><br><span class="line"><span class="type">int</span>[][] ints1 = Arrays.stream(a).map(a1 -&gt; Arrays.stream(a1).mapToInt(Integer::valueOf).toArray()).toArray(<span class="type">int</span>[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="List-lt-Integer-gt-转-int"><a href="#List-lt-Integer-gt-转-int" class="headerlink" title="List&lt; Integer &gt; 转 int[ ]"></a>List&lt; Integer &gt; 转 int[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = list.stream().mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>

<p>经过上面的说明，相信这里已经很好理解了，直接小结。<br>小结：</p>
<ol>
<li>list.stream() 将列表转换为对象流。List&lt; Integer &gt; &#x3D;&gt; Stream&lt; Integer &gt;</li>
<li>.mapToInt(Integer::valueOf) 将对象流转换为基本数据类型流。&#x3D;&gt; IntStream</li>
<li>.toArray() 将基本数据类型流转换为基本类型数组。&#x3D;&gt;int[ ]</li>
</ol>
<h3 id="List-lt-List-lt-Integer-gt-gt-转-int"><a href="#List-lt-List-lt-Integer-gt-gt-转-int" class="headerlink" title="List&lt; List &lt; Integer &gt; &gt; 转 int[ ] [ ]"></a>List&lt; List &lt; Integer &gt; &gt; 转 int[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; lists = ...;</span><br><span class="line"><span class="type">int</span>[][] arrays = lists.stream()                                <span class="comment">// Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">        .map(list -&gt; list.stream().mapToInt(i -&gt; i).toArray()) <span class="comment">// Stream&lt;int[]&gt;</span></span><br><span class="line">        .toArray(<span class="type">int</span>[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="List-lt-Integer-gt-转-Integer"><a href="#List-lt-Integer-gt-转-Integer" class="headerlink" title="List&lt; Integer &gt; 转 Integer[ ]"></a>List&lt; Integer &gt; 转 Integer[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = list.stream().toArray(Integer[]::<span class="keyword">new</span>); <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure>

<p>这个也很简单，方法里的参数是一个数组，所以要规定长度。也有无参的方法，但是要进行转型，所以不推荐使用。</p>
<h3 id="List-lt-List-lt-Integer-gt-gt-转-Integer"><a href="#List-lt-List-lt-Integer-gt-gt-转-Integer" class="headerlink" title="List&lt; List &lt; Integer &gt; &gt; 转 Integer[ ] [ ]"></a>List&lt; List &lt; Integer &gt; &gt; 转 Integer[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; lists = ...;</span><br><span class="line">Integer[][] arrays = lists.stream()                                <span class="comment">// Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">        .map(list -&gt; list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()])) <span class="comment">// Stream&lt;Integer[]&gt;</span></span><br><span class="line">        .toArray(Integer[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] arrays = lists.stream()                                <span class="comment">// Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">        .map(l -&gt; l.stream().toArray(String[]::<span class="keyword">new</span>)) <span class="comment">// Stream&lt;Integer[]&gt;</span></span><br><span class="line">        .toArray(Integer[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] arrays = lists.stream().map(List::toArray).toArray(Integer[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>



<h2 id="List-lt-Character-gt-、char-、Character-相互转换"><a href="#List-lt-Character-gt-、char-、Character-相互转换" class="headerlink" title="List&lt; Character &gt;、char[ ]、Character[ ]相互转换"></a>List&lt; Character &gt;、char[ ]、Character[ ]相互转换</h2><h3 id="char-转-List-lt-Character-gt"><a href="#char-转-List-lt-Character-gt" class="headerlink" title="char[ ] 转 List&lt; Character &gt;"></a>char[ ] 转 List&lt; Character &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">List&lt;Character&gt; collect = <span class="keyword">new</span> <span class="title class_">String</span>(chars).chars().mapToObj(i -&gt; (<span class="type">char</span>) i).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="char-转-List-lt-List-lt-Character-gt-gt"><a href="#char-转-List-lt-List-lt-Character-gt-gt" class="headerlink" title="char[ ] [ ] 转 List&lt;  List &lt; Character &gt;  &gt;"></a>char[ ] [ ] 转 List&lt;  List &lt; Character &gt;  &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Character&gt;&gt; collect2 = Arrays.stream(ints1).map(chars1 -&gt; <span class="keyword">new</span> <span class="title class_">String</span>(chars1).chars().mapToObj(i -&gt; (<span class="type">char</span>) i).collect(Collectors.toList())).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="char-转-Character"><a href="#char-转-Character" class="headerlink" title="char[ ] 转 Character[ ]"></a>char[ ] 转 Character[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">Character[] characters1 = <span class="keyword">new</span> <span class="title class_">String</span>(chars).chars().mapToObj(i -&gt; (<span class="type">char</span>) i).toArray(Character[]::<span class="keyword">new</span>);     </span><br></pre></td></tr></table></figure>

<h3 id="char-转-Character-1"><a href="#char-转-Character-1" class="headerlink" title="char[ ] [ ]转 Character[ ] [ ]"></a>char[ ] [ ]转 Character[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character[][] integers3 = Arrays.stream(ints1).map(chars -&gt; <span class="keyword">new</span> <span class="title class_">String</span>(chars).chars().mapToObj(i-&gt;(<span class="type">char</span>)i).toArray(Character[]::<span class="keyword">new</span>)).toArray(Character[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Character-转-List-lt-Character-gt"><a href="#Character-转-List-lt-Character-gt" class="headerlink" title="Character[ ] 转 List&lt; Character &gt;"></a>Character[ ] 转 List&lt; Character &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; collect2 = Arrays.stream(characters).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="Character-转-List-lt-List-lt-Character-gt-gt"><a href="#Character-转-List-lt-List-lt-Character-gt-gt" class="headerlink" title="Character[ ] [ ]转 List&lt; List &lt; Character &gt; &gt;"></a>Character[ ] [ ]转 List&lt; List &lt; Character &gt; &gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Character&gt;&gt; lists = Arrays.stream(a).map(Arrays::asList).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="Character-转-char"><a href="#Character-转-char" class="headerlink" title="Character[ ] 转 char[ ]"></a>Character[ ] 转 char[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars4 = Arrays.stream(characters1).map(String::valueOf).collect(Collectors.joining()).toCharArray();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Character-转-char-1"><a href="#Character-转-char-1" class="headerlink" title="Character[ ] [ ]转 char[ ] [ ]"></a>Character[ ] [ ]转 char[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[][] ints1 = Arrays.stream(a).map(a1 -&gt; Arrays.stream(a1).map(String::valueOf).collect(Collectors.joining()).toCharArray()).toArray(<span class="type">char</span>[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="List-lt-Character-gt-转-char"><a href="#List-lt-Character-gt-转-char" class="headerlink" title="List&lt; Character &gt; 转 char[ ]"></a>List&lt; Character &gt; 转 char[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value = characters.stream().map(String::valueOf).collect(Collectors.joining()).toCharArray();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Character[] charArr = characters.toArray(<span class="keyword">new</span> <span class="title class_">Character</span>[characters.size()]);</span><br><span class="line"><span class="type">char</span>[] value = ArrayUtils.toPrimitive(charArr);</span><br></pre></td></tr></table></figure>

<h3 id="List-lt-List-lt-Character-gt-gt-转-char"><a href="#List-lt-List-lt-Character-gt-gt-转-char" class="headerlink" title="List&lt; List &lt; Character &gt; &gt; 转 char[ ] [ ]"></a>List&lt; List &lt; Character &gt; &gt; 转 char[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[][] arrays = lists.stream()                                <span class="comment">// Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">                .map(list -&gt; list.stream().map(String::valueOf).collect(Collectors.joining()).toCharArray()) <span class="comment">// Stream&lt;int[]&gt;</span></span><br><span class="line">                .toArray(<span class="type">char</span>[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="List-lt-Character-gt-转-Character"><a href="#List-lt-Character-gt-转-Character" class="headerlink" title="List&lt; Character &gt; 转 Character[ ]"></a>List&lt; Character &gt; 转 Character[ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character[] characters2 = Arrays.stream(characters1).toArray(Character[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="List-lt-List-lt-Character-gt-gt-转-Character"><a href="#List-lt-List-lt-Character-gt-gt-转-Character" class="headerlink" title="List&lt; List &lt; Character &gt; &gt; 转 Character[ ] [ ]"></a>List&lt; List &lt; Character &gt; &gt; 转 Character[ ] [ ]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Character[][] integers1 = lists.stream()                                <span class="comment">// Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">               .map(list -&gt; list.toArray(<span class="keyword">new</span> <span class="title class_">Character</span>[list.size()])).toArray(Character[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Character[][] integers2 = lists.stream()                                <span class="comment">// Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">                .map(l -&gt; l.stream().toArray(Character[]::<span class="keyword">new</span>))</span><br><span class="line">                .toArray(Character[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character[][] integers = lists.stream().map(List::toArray).toArray(Character[][]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/f0b74f41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/f0b74f41/" class="post-title-link" itemprop="url">注释书写</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">语法</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/f0b74f41/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/f0b74f41/" data-xid="/posts/f0b74f41/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="注释书写规范"><a href="#注释书写规范" class="headerlink" title="注释书写规范"></a>注释书写规范</h1><ul>
<li>一般情况下，源程序有效注释量必须在30％以上。注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。可以用注释统计工具来统计。<h2 id="一、类和接口的注释"><a href="#一、类和接口的注释" class="headerlink" title="一、类和接口的注释"></a>一、类和接口的注释</h2></li>
</ul>
<p><strong>1. 类外注释</strong></p>
<blockquote>
<p>该注释放在 package 关键字之后，class 或者 interface 关键字之前。</p>
</blockquote>
<ul>
<li>说明：方便JavaDoc收集。<br>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huawei.msg.relay.comm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类和接口的注释内容：类的注释主要是一句话功能简述、功能详细描述。<br>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉</span></span><br><span class="line"><span class="comment"> * 〈功能详细描述〉</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>描述部分说明该类或者接口的功能、作用、使用方法和注意事项。<br>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LogManager 类集中控制对日志读写的操作。</span></span><br><span class="line"><span class="comment"> * 全部为静态变量和静态方法，对外提供统一接口。分配对应日志类型的读写器，</span></span><br><span class="line"><span class="comment"> * 读取或写入符合条件的日志纪录。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 类内注释</strong></p>
<blockquote>
<p>类属性、公有和保护方法必须写注释。geter、seter方法不用写注释</p>
</blockquote>
<p>  示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String logType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>1).成员变量注释内容：成员变量的意义、目的、功能，可能被用到的地方。<br>2).公有和保护方法注释内容：列出方法的一句话功能    简述、功能详细描述、输入参数、输出参数、返回值、违例等。<br>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉</span></span><br><span class="line"><span class="comment"> * 〈功能详细描述〉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  [参数1] [in或out]  [参数1说明]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  [参数2] [in或out]  [参数2说明]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> [返回类型说明]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>/throws [违例类型] [违例说明]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>说明： @exception或throws 列出可能仍出的异常。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用MD5算法计算输入字符串的32位摘要</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sIn [in] 待处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sOut [out] sIn的32为摘要，调用函数负责new sOut对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getMd5</span><span class="params">(String sIn, StringBuffer sOut)</span> </span><br></pre></td></tr></table></figure>
<p>说明：<br>1）.注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。<br>2）.注释与所描述内容进行同样的缩排。<br>3）.将注释与其上面的代码用空行隔开。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释</span></span><br><span class="line">program code <span class="title function_">one</span></span><br><span class="line"><span class="params">(空一格)</span>   </span><br><span class="line"><span class="comment">//注释</span></span><br><span class="line">program code two</span><br></pre></td></tr></table></figure>
<h2 id="二、方法与复杂逻辑的注释"><a href="#二、方法与复杂逻辑的注释" class="headerlink" title="二、方法与复杂逻辑的注释"></a>二、方法与复杂逻辑的注释</h2><blockquote>
<p>对变量的定义和分支语句（条件分支、循环语句等）对复杂的分支必须编写注释，如果时间允许，建议对所有分支语句写注释。</p>
</blockquote>
<p>说明：这些语句往往是程序实现某一特定功能的关键，对于维护人员来说，良好的注释帮助更好的理解程序，有时甚至优于看设计文档。</p>
<ol>
<li>switch语句</li>
</ol>
<ul>
<li>switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。</li>
<li>说明：这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。</li>
</ul>
<ol start="2">
<li>边写代码边注释</li>
</ol>
<ul>
<li>修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</li>
</ul>
<ol start="3">
<li>避免在注释中使用缩写</li>
</ol>
<ul>
<li>在使用缩写时或之前，应对缩写进行必要的说明，特别是不常用缩写。</li>
</ul>
<ol start="4">
<li>用中文注释，禁止用英文写注释。<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2></li>
<li>避免在一行代码或表达式的中间插入注释。</li>
</ol>
<ul>
<li>说明：除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差。</li>
</ul>
<ol start="2">
<li>通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。</li>
</ol>
<ul>
<li>说明：清晰准确的函数、变量等的命名，可增加代码可读性，并减少不必要的注释。</li>
</ul>
<ol start="3">
<li>在代码的功能、意图层次上进行注释，提供有用、额外的信息。</li>
</ol>
<ul>
<li>说明：注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。</li>
<li>示例：如下注释意义不大。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 receiveFlag 为真</span></span><br><span class="line"><span class="keyword">if</span> (receiveFlag)</span><br></pre></td></tr></table></figure></li>
<li>而如下的注释则给出了额外有用的信息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果从连结收到消息 </span></span><br><span class="line"><span class="keyword">if</span> (receiveFlag)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>在程序块的结束行右方加注释标记，以表明某程序块的结束。</li>
</ol>
<ul>
<li>说明：当代码段较长，特别是多重嵌套时，这样做可以使代码更清晰，更便于阅读。</li>
<li>示例：参见如下例子。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    program code1</span><br><span class="line">    <span class="title function_">while</span> <span class="params">(index &lt; MAX_INDEX)</span></span><br><span class="line">    &#123;</span><br><span class="line">        program code2</span><br><span class="line">    &#125; <span class="comment">// end of while (index &lt; MAX_INDEX) // 指明该条while语句结束</span></span><br><span class="line">&#125; <span class="comment">// end of  if (...) // 指明是哪条if语句结束</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>方法内的单行注释使用 &#x2F;&#x2F;。</li>
</ol>
<ul>
<li>说明：调试程序的时候可以方便的使用 &#x2F;* 。。。*&#x2F; 注释掉一长段程序。</li>
</ul>
<ol start="6">
<li>注释使用中文注释和中文标点，不得用英文写注释。方法和类描述的第一句话尽量使用简洁明了的话概括一下功能，然后加以句号。接下来的部分可以详细描述。</li>
</ol>
<ul>
<li>说明：JavaDoc工具收集简介的时候使用选取第一句话。</li>
</ul>
<ol start="7">
<li>顺序实现流程的说明使用1、2、3、4在每个实现步骤部分的代码前面进行注释。</li>
</ol>
<ul>
<li>示例：如下是对设置属性的流程注释<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、 判断输入参数是否有效。</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2、设置本地变量。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="8">
<li>一些复杂的算法代码需要说明。</li>
</ol>
<ul>
<li>示例：这里主要是对闰年算法的说明。<br><code>java //1. 如果能被4整除，是闰年； //2. 如果能被100整除，不是闰年.； //3. 如果能被400整除，是闰年.。 </code>星期五, 23. 八月 2019 07:42下午</li>
</ul>
<p>**</p>
<hr>
<p>**</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/22472e9c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/22472e9c/" class="post-title-link" itemprop="url">java 名词</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/22472e9c/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/22472e9c/" data-xid="/posts/22472e9c/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java-名词"><a href="#java-名词" class="headerlink" title="java 名词"></a>java 名词</h1><h2 id="“吃人”的那些Java名词：对象、引用、堆、栈️"><a href="#“吃人”的那些Java名词：对象、引用、堆、栈️" class="headerlink" title="“吃人”的那些Java名词：对象、引用、堆、栈️"></a>“吃人”的那些Java名词：对象、引用、堆、栈️</h2><p>经验都是慢慢积累的，天才不多｜ 第170篇</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/z40lCFUAHpmSC3DSh9MC8QiaZiakWP0mHCnSvS20HavA8udLNlNaImXlzYmA6TlVIxe00l1BkfXKvJoAIQsVWaEg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>记得中学的课本上，有一篇名为《狂人日记》课文；那时候根本理解不了鲁迅写这篇文章要表达的中心思想，只觉得满篇的“<strong>吃人</strong>”令人心情压抑；老师在讲台上慷慨激昂的讲，大多数的同学同我一样，在课本面前“痴痴”的发呆。</p>
<p>作为一个有着8年Java编程经验的IT老兵，说起来很惭愧，我被Java当中的四五个名词一直困扰着：<strong>对象、引用、堆、栈、堆栈</strong>（栈可同堆栈，因此是四个名词，也是五个名词）。每次我看到这几个名词，都隐隐约约觉得自己在被一只无形的大口慢慢地吞噬，只剩下满地的衣服碎屑（为什么不是骨头，因为骨头也好吃）。</p>
<p>十几年后，再读《狂人日记》，恍然如梦：</p>
<blockquote>
<p>鲁迅先生以狂人的口吻，再现了动乱时期下中国人的精神状态，视角新颖，文笔细腻又不乏辛辣之味。<br>当时的中国，混乱成了主色调。以清廷和孔教为主的封建旧思想还在潜移默化地影响着人们的思想，与此同时以革命和新思潮为主的现代思想已经开始了对大众灵魂的洗涤和冲击。</p>
</blockquote>
<p>最近，和沉默王二技术交流群（120926808）的群友们交流后，Java中那四五个会吃人的名词：对象、引用、堆、栈、堆栈，似乎在脑海中也清晰了起来，尽管疑惑有时候仍然会在阴云密布时跑出来——正鉴于此，这篇文章恰好做一下归纳。</p>
<h3 id="一、对象和引用"><a href="#一、对象和引用" class="headerlink" title="一、对象和引用"></a>一、对象和引用</h3><p><strong>在Java中，尽管一切都可以看做是对象，但计算机操作的并非对象本身，而是对象的引用。</strong> 这话乍眼一看，似懂非懂。究竟什么是对象，什么又是引用呢？</p>
<p>先来看对象的定义：按照通俗的说法，<strong>每个对象都是某个类（class）的一个实例（instance）</strong>。那么，实例化的过程怎么描述呢？来看代码（类是String）：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;我是对象张三&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;我是对象李四&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在Java中，实例化指的就是通过关键字“new”来创建对象的过程</strong>。以上代码在运行时就会创建两个对象——“我是对象张三”和”我是对象李四”；现在，该怎么操作他们呢？</p>
<p>我们都去过公园，见过几个大爷，他们很有一番本领——个个都能把风筝飞得老高老高，徒留我们眼馋的份！风筝飞那么高，没办法直接用手拽着飞啊，全要靠一根长长的看不见的结实的绳子来牵引！操作Java对象也是这个理，得有一根绳——也就是接下来要介绍的“引用”（我们肉眼也常常看不见它）。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> zhangsan, lisi;</span><br><span class="line">zhangsan = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;我是对象张三&quot;</span>);</span><br><span class="line">lisi = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;我是对象李四&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这三行代码该怎么理解呢？</p>
<p>先来看第一行代码：<code>String zhangsan, lisi;</code>——声明了两个变量zhangsan和lisi，他们的类型为String。</p>
<p>①、歧义：zhangsan和lisi此时被称为引用。</p>
<p>你也许听过这样一句古文：“<strong>神之于形，犹利之于刀；未闻刀没而利存，岂容形亡而神在？</strong>”这是无神论者范缜（zhen）的名言，大致的意思就是：灵魂对于肉体来说，就像刀刃对于刀身；从没听说过刀身都没了刀刃还存在，那么怎么可能允许肉体死亡了而灵魂还在呢？</p>
<p><strong>“引用”之于对象，就好比刀刃之于刀身，对象还没有创建，又怎么存在对象的“引用”呢？</strong></p>
<p>如果zhangsan和lisi此时不能被称为“引用”，那么他们是什么呢？答案很简单，就是变量啊！（鄙人理解）</p>
<p>②、误解：zhangsan和lisi此时的默认值为<code>null</code>。</p>
<p>应该说zhangsan和lisi此时的值为<code>undefined</code>——借用JavaScript的关键字；也就是未定义；或者应该是一个新的关键字<code>uninitialized</code>——未初始化。但不管是<code>undefined</code>还是<code>uninitialized</code>，都与<code>null</code>不同。</p>
<p>既然没有初始化，zhangsan和lisi此时就不能被使用。假如强行使用的话，编译器就会报错，提醒zhangsan和lisi还没有出生（初始化）；见下图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmSC3DSh9MC8QiaZiakWP0mHCNHs3SgxauYqH7dfThPqpXLcy1XmBFqk8KS6V6V2N1xjWTy3QtZKgjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果把zhangsan和lisi初始化为<code>null</code>，编译器是认可的（见下图）；由此可见，zhangsan和lisi此时的默认值不为<code>null</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmSC3DSh9MC8QiaZiakWP0mHCtBhECcmKL8DW8nGZ8pZWGOic829gaf3Ro8wqibHII0ldETvciaYHtKFKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>再来看第二行代码：<code>zhangsan = new String(&quot;我是对象张三&quot;);</code>——创建“我是对象张三”的String类对象，并将其赋值给zhangsan这个变量。</p>
<p>此时，zhangsan就是”我是对象张三”的引用；“&#x3D;”操作符赋予了zhangsan这样神圣的权利。</p>
<p>第三行代码<code>lisi = new String(&quot;我是对象李四&quot;);</code>和第二行代码<code>zhangsan = new String(&quot;我是对象张三&quot;);</code>同理。</p>
<p>现在，我可以下这样一个结论了——<strong>对象是通过<code>new</code>关键字创建的；引用是依赖于对象的；<code>=</code>操作符把对象赋值给了引用</strong>。</p>
<p>我们再来看这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String zhangsan, lisi;</span><br><span class="line">zhangsan = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我是对象张三&quot;</span>);</span><br><span class="line">lisi = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我是对象李四&quot;</span>);</span><br><span class="line">zhangsan = lisi;</span><br></pre></td></tr></table></figure>

<p>当<code>zhangsan = lisi;</code>执行过后，zhangsan就不再是”我是对象张三”的引用了；zhangsan和lisi指向了同一个对象（”我是对象李四”）；因此，你知道<code>System.out.println(zhangsan == lisi);</code>打印的是<code>false</code>还是<code>true</code>了吗？</p>
<h3 id="二、堆、栈、堆栈"><a href="#二、堆、栈、堆栈" class="headerlink" title="二、堆、栈、堆栈"></a>二、堆、栈、堆栈</h3><p>谁来告诉我，为什么有很多地方（书、博客等等）把栈叫做堆栈，把堆栈叫做栈？搞得我都头晕目眩了——绕着门柱估计转了80圈，不晕才怪！</p>
<p>我查了一下金山词霸，结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmSC3DSh9MC8QiaZiakWP0mHCj8OO5nupmycuwht01HibVPgN2UysUiaic5CViaKzAsBBdhBAIeBHpAzx2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我的天呐，更晕了，有没有！怎么才能不晕呢？我这里有几招武功秘籍，你们尽管拿去一睹为快：</p>
<p>1）以后再<strong>看到堆、栈、堆栈三个在一起打牌的时候，直接把“堆栈”踢出去</strong>；这仨人不适合在一起玩，因为堆和栈才是老相好；你“堆栈”来这插一脚算怎么回事；这世界上只存在“堆、栈”或者“堆栈”（标点符号很重要哦）。</p>
<p>2）<strong>堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时</strong>；因此，Java中的对象就放在这里，这样做的好处就是：</p>
<blockquote>
<p>当需要一个对象时，只需要通过new关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。</p>
</blockquote>
<p>另外，需要记住，<strong>堆遵循“先进后出”的规则</strong>。就好像，一个和尚去挑了一担水，然后把一担水装缸里面，等到他口渴的时候他再用瓢舀出来喝。请放肆地打开你的脑洞脑补一下这个流程：缸底的水是先进去的，但后出来的。所以，我建议这位和尚在缸上贴个标签——保质期90天，过期饮用，后果自负！</p>
<p>还是记不住，看下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/z40lCFUAHpmSC3DSh9MC8QiaZiakWP0mHCfOjwjLfkibbAfhjPM8rUFuFGFsEu6YY8DUAhYHPbDBGgBuHqfCxLACA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">不好意思，这是鼎，不是缸，将就一下哈</p>
<p>3）栈，又名堆栈（简直了，完全不符合程序员的思维啊，我们陈许愿习惯说一就是一，说二就是二嘛），能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快；举个十分不恰当的例子哈——<strong>眼睛相对嘴巴是离脑子近的一方，因此，你可以一目十行，但绝对做不到一开口就读十行字，哪怕十个字也做不到</strong>。</p>
<p>既然访问速度快，要好好利用啊！<strong>Java就把对象的引用放在栈里</strong>。为什么呢？因为引用的使用频率高吗？</p>
<p>不是的，<strong>因为Java在编译程序时，必须明确的知道存储在栈里的东西的生命周期</strong>，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。</p>
<p>现在清楚堆、栈和堆栈了吧？</p>
<h3 id="三、特殊的“对象”"><a href="#三、特殊的“对象”" class="headerlink" title="三、特殊的“对象”"></a>三、特殊的“对象”</h3><p>先来看《Java编程思想》中的一段话：</p>
<blockquote>
<p>在程序设计中经常用到一系列类型，他们需要特殊对待。之所以特殊对待，是因为new将对象存储于“堆”中，故用new创建一个对象──特别小、简单的变量，往往不是很有效。因此，不用new来创建这类变量，而是创建一个并非是引用的变量，这个变量直接存储值，并置于栈中，因此更加高效。</p>
</blockquote>
<p>在Java中，这些基本类型有：boolean、char、byte、short、int、long、float、double和void；还有与之对应的包装器：Boolean、Character、Byte、Short、Integer、Long、Float、Double和Void；他们之间涉及到装箱和拆箱，我们有机会再聊。</p>
<p>看两行简单的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这两行代码在编译的时候是什么样子呢？</p>
<p>编译器当然是先处理<code>int a = 3;</code>，不然还能跳过吗？编译器在处理<code>int a = 3;</code>时在栈中创建了一个变量为a的内存空间，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。</p>
<p>编译器忙完了<code>int a = 3;</code>，就来接着处理<code>int b = 3;</code>；在创建完b的变量后，由于栈中已经有3这个字面值，就将b直接指向3的地址；就不需要再开辟新的空间了。</p>
<p>依据上面的概述，我们假设在定义完a与b的值后，再令a&#x3D;4，此时b是等于3呢，还是4呢？</p>
<p>思考一下，再看答案哈。</p>
<p>答案揭晓：当编译器遇到<code>a = 4;</code>时，它会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向4这个地址；因此a值的改变不会影响到b的值哦。</p>
<p>最后，留个作业吧，下面这段代码在运行时会输出什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">TT</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TT</span>(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">        <span class="type">TT</span> <span class="variable">t1</span> <span class="operator">=</span> t;</span><br><span class="line">        t.setName(<span class="string">&quot;TT&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(t.getName());</span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TT</span> <span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/3a533665/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3a533665/" class="post-title-link" itemprop="url">Java泛型类型擦除以及类型擦除带来的问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/3a533665/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/3a533665/" data-xid="/posts/3a533665/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java泛型类型擦除以及类型擦除带来的问题"><a href="#Java泛型类型擦除以及类型擦除带来的问题" class="headerlink" title="Java泛型类型擦除以及类型擦除带来的问题"></a>Java泛型类型擦除以及类型擦除带来的问题</h1><h2 id="1-Java泛型的实现方法：类型擦除"><a href="#1-Java泛型的实现方法：类型擦除" class="headerlink" title="1.Java泛型的实现方法：类型擦除"></a>1.Java泛型的实现方法：类型擦除</h2><p>大家都知道，Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>
<p>如在代码中定义 <code>List&lt;Object&gt;</code>和 <code>List&lt;String&gt;</code>等类型，在编译后都会变成 <code>List</code>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
<h3 id="1-1-通过两个例子证明Java类型的类型擦除"><a href="#1-1-通过两个例子证明Java类型的类型擦除" class="headerlink" title="1-1.通过两个例子证明Java类型的类型擦除"></a>1-1.通过两个例子证明Java类型的类型擦除</h3><p>例1.原始类型相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个 <code>ArrayList</code>数组，不过一个是 <code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是 <code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过 <code>list1</code>对象和 <code>list2</code>对象的 <code>getClass()</code>方法获取他们的类的信息，最后发现结果为 <code>true</code>。说明泛型类型 <code>String</code>和 <code>Integer</code>都被擦除掉了，只剩下原始类型。</p>
<p>例2.通过反射添加其它类型元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用add方法只能存储整形，因为泛型类型的实例为Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在程序中定义了一个 <code>ArrayList</code>泛型类型实例化为 <code>Integer</code>对象，如果直接调用 <code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用 <code>add()</code>方法的时候，却可以存储字符串，这说明了 <code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>
<h2 id="2-类型擦除后保留的原始类型"><a href="#2-类型擦除后保留的原始类型" class="headerlink" title="2.类型擦除后保留的原始类型"></a>2.类型擦除后保留的原始类型</h2><p>在上面，两次提到了原始类型，什么是原始类型？</p>
<p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<p>例3.原始类型Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;t&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pair的原始类型为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在 <code>Pair&lt;t&gt;&lt;/t&gt;</code>中，T 是一个无限定的类型变量，所以用 <code>Object</code>替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的 <code>Pair</code>，如 <code>Pair&lt;String&gt;</code>或 <code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的 <code>Pair</code>类型了，原始类型都是 <code>Object</code>。</p>
<p>从上面的例2中，我们也可以明白 <code>ArrayList&lt;Integer&gt;</code>被擦除类型后，<strong>原始类型</strong>也变为 <code>Object</code>，所以通过反射我们就可以存储字符串了。</p>
<p>如果类型变量有限定，那么<strong>原始类型</strong>就用<strong>第一个边界的类型变量类</strong>替换。</p>
<p>比如: Pair这样声明的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;t <span class="keyword">extends</span> <span class="title class_">comparable</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>那么<strong>原始类型</strong>就是 <code>Comparable</code>。</p>
<p>要区分原始类型和泛型变量的类型。</p>
<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候**/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**指定泛型的时候*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;t&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为 <code>Object</code>，就比如 <code>ArrayList</code>中，如果不指定泛型，那么这个 <code>ArrayList</code>可以存储任意的对象。</p>
<p>例4.Object泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="string">&quot;121&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-类型擦除引起的问题及解决方法"><a href="#3-类型擦除引起的问题及解决方法" class="headerlink" title="3.类型擦除引起的问题及解决方法"></a>3.类型擦除引起的问题及解决方法</h2><p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。</p>
<h3 id="3-1-先检查，再编译以及编译的对象和引用传递问题"><a href="#3-1-先检查，再编译以及编译的对象和引用传递问题" class="headerlink" title="3-1.先检查，再编译以及编译的对象和引用传递问题"></a>3-1.先检查，再编译以及编译的对象和引用传递问题</h3><p>Q: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>
<p>A: Java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，再进行编译。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，使用 <code>add</code>方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为 <code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>那么，这个<strong>类型检查是针对谁的</strong>呢？我们先看看参数化类型和原始类型的兼容。</p>
<p>以 ArrayList举例子，以前的写法:</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list <span class="operator">=</span> new ArrayList()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>现在的写法:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//第一种情况</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//第二种情况</span></span><br></pre></td></tr></table></figure>

<p>这样是没有错误的，不过会有个编译时警告。</p>
<p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>
<p>因为类型检查就是编译时完成的， <code>new ArrayList()</code>只是在内存中开辟了一个存储空间，可以存储任何类型对象，而<strong>真正设计类型检查的是它的引用</strong>，因为我们是使用它引用 <code>list1</code>来调用它的方法，比如说调用 <code>add</code>方法，所以 <code>list1</code>引用能完成泛型类型的检查。而引用 <code>list2</code>没有使用泛型，所以不行。</p>
<p>举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过</span></span><br><span class="line">        list1.add(<span class="number">1</span>); <span class="comment">//编译错误</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过</span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">//编译通过</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，<strong>用这个引用调用泛型方法</strong>，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>
<p><strong>泛型中参数化类型为什么不考虑继承关系</strong>？</p>
<p>在Java中，像下面形式的引用传递是不允许的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;object&gt;(); <span class="comment">//编译错误 ArrayList&lt;Object&gt;</span></span><br><span class="line">ArrayList&lt;object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//编译错误 ArrayList&lt;String&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们先看第一种情况，将第一种情况拓展成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;object&gt;();</span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">ArrayList&lt;String&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用 <code>list2</code>引用用 <code>get()</code>方法取值的时候，返回的都是 <code>String</code>类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了 <code>Object</code>类型的对象，这样就会有 <code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是<strong>为了解决类型转换的问题</strong>，我们不能违背它的初衷）。</p>
<p>再看第二种情况，将第二种情况拓展成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"></span><br><span class="line">ArrayList&lt;object&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>没错，这样的情况比第一种情况好的多，最起码，在我们用 <code>list2</code>取值的时候不会出现 <code>ClassCastException</code>，因为是从 <code>String</code>转换为 <code>Object</code>。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用 <code>list2</code>往里面 <code>add()</code>新的对象，那么到时候取得时候，我怎么知道我取出来的到底是 <code>String</code>类型的，还是 <code>Object</code>类型的呢？</p>
<p><strong>所以，要格外注意，泛型中的引用传递的问题。</strong></p>
<h3 id="3-2-自动类型转换"><a href="#3-2-自动类型转换" class="headerlink" title="3-2.自动类型转换"></a>3-2.自动类型转换</h3><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</p>
<p>既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>
<p>看下 <code>ArrayList.get()</code>方法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> E <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line"></span><br><span class="line">    Range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[<span class="keyword">index</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>return</code>之前，会根据泛型变量进行强转。假设泛型类型变量为 <code>Date</code>，虽然泛型信息会被擦除掉，但是会将 <code>(E) elementData[index]</code>，编译为 <code>(Date)elementData[index]</code>。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设 <code>Pair</code>类的 <code>value</code>域是 <code>public</code>的，那么表达式：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span> <span class="built_in">Date</span> = <span class="built_in">pair</span>.value;</span><br></pre></td></tr></table></figure>

<p>也会自动地在结果字节码中插入强制类型转换。</p>
<h3 id="3-3-类型擦除与多态的冲突和解决方法"><a href="#3-3-类型擦除与多态的冲突和解决方法" class="headerlink" title="3-3.类型擦除与多态的冲突和解决方法"></a>3-3.类型擦除与多态的冲突和解决方法</h3><p>现在有这样一个泛型类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">t</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们想要一个子类继承它。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">Pair&lt;Date&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void setValue(<span class="type">Date</span> value) &#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Date</span> getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个子类中，我们设定父类的泛型类型为 <code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为 <code>Date</code>，那么父类里面的两个方法的参数都为 <code>Date</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">Date</span> <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setValue</span>(<span class="params"><span class="built_in">Date</span> value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的 <code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>
<p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型 <code>Object</code>，所以父类编译之后会变成下面的样子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Object</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setValue</span>(<span class="params"><span class="built_in">Object</span>  value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看子类的两个重写的方法的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setValue</span>(<span class="params"><span class="built_in">Date</span> value</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">setValue</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Date</span> <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来分析 <code>setValue</code>方法，父类的类型是 <code>Object</code>，而子类的类型是 <code>Date</code>，参数类型不一样，这如果是在普通的继承关系中，根本就不会是<strong>重写</strong>，而是<strong>重载</strong>。</p>
<p>我们在一个main方法测试一下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        DateInter DateInter = <span class="keyword">new</span> <span class="type">DateInter</span>();</span><br><span class="line">        DateInter.setValue(<span class="keyword">new</span> <span class="type">Date</span>());</span><br><span class="line">        DateInter.setValue(<span class="keyword">new</span> <span class="type">Object</span>()); <span class="comment">//编译出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是重载，那么子类中两个 <code>setValue</code>方法，一个是参数 <code>Object</code>类型，一个是 <code>Date</code>类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是<strong>重写</strong>了，而不是<strong>重载</strong>了。</p>
<p>为什么会这样呢？</p>
<p>原因是这样的，我们传入父类的泛型类型是 <code>Date， Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Date</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Date</span> <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setValue</span>(<span class="params"><span class="built_in">Date</span> value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p>
<p>可是由于种种原因，虚拟机并不能将泛型类型变为 <code>Date</code>，只能将类型擦除掉，变为原始类型 <code>Object</code>。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？<strong>知道</strong>！！！可是它能<strong>直接实现</strong>吗，<strong>不能</strong>！！！如果真的不能的话，那我们怎么去重写我们想要的 <code>Date</code>类型参数的方法啊。</p>
<p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是<strong>桥方法</strong>。</p>
<p>首先，我们用 <code>javap -c className</code>的方式反编译下 <code>DateInter</code>子类的字节码，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.tao.test.DateInter <span class="keyword">extends</span> <span class="title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;</span><br><span class="line">  com.tao.test.DateInter();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.util.Date)</span>;  <span class="comment">//我们重写了setValue方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: invokespecial #<span class="number">16</span>                 <span class="comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V</span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Date <span class="title function_">getValue</span><span class="params">()</span>;    <span class="comment">//我们重写了getValue方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">23</span>                 <span class="comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date</span></span><br><span class="line">       <span class="number">7</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">getValue</span><span class="params">()</span>;     <span class="comment">//编译时有编译器生成的桥方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokevirtual #<span class="number">28</span>                 <span class="comment">// Method getValue:()Ljava/util/Date;去调用我们重写的setValue方法；</span></span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//编译时有编译器生成的桥方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">30</span>                 <span class="comment">// Method setValue:(Ljava/util/Date;去调用我们重写的setValue方法）V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从编译的结果来看，我们本意重写 <code>setValue</code>和 <code>getValue</code>方法的子类，<strong>竟然有4个方法</strong>，其实不用惊奇，最后的两个方法，就是<strong>编译器自己生成的桥方法</strong>。可以看到桥方法的<strong>参数类型都是Object</strong>，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的 <code>setvalue</code>和 <code>getValue</code>方法上面的 <code>@Override</code>只不过是假象。而<strong>桥方法的内部实现，就只是去调用我们自己重写的那两个方法</strong>。</p>
<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>
<p>不过，要提到一点，这里面的 <code>setValue</code>和 <code>getValue</code>这两个桥方法的意义又有不同。</p>
<p><code>setValue</code>方法是为了解决类型擦除与多态之间的冲突。</p>
<p>而 <code>getValue</code>却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p>
<p>那么父类的 <code>setValue</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而子类重写的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p>
<p>关于协变：。。。。。。</p>
<p>并且，还有一点也许会有疑问，子类中的桥方法 <code>Object getValue()</code>和 <code>Date getValue()</code>是同 时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来”不合法”的事情，然后交给虚拟器去区别。</p>
<h3 id="3-4-泛型类型变量不能是基本数据类型"><a href="#3-4-泛型类型变量不能是基本数据类型" class="headerlink" title="3-4.泛型类型变量不能是基本数据类型"></a>3-4.泛型类型变量不能是基本数据类型</h3><p>不能用类型参数替换基本类型。就比如，没有 <code>ArrayList&lt;double&gt;</code>，只有 <code>ArrayList&lt;Double&gt;</code>。因为当类型擦除后， <code>ArrayList</code>的原始类型变为 <code>Object</code>，但是 <code>Object</code>类型不能存储 <code>double</code>值，只能引用 <code>Double</code>的值。</p>
<h3 id="3-5-编译时集合的instanceof"><a href="#3-5-编译时集合的instanceof" class="headerlink" title="3-5.编译时集合的instanceof"></a>3-5.编译时集合的instanceof</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>因为类型擦除之后， <code>ArrayList&lt;String&gt;</code>只剩下原始类型，泛型信息 <code>String</code>不存在了。</p>
<p>那么，编译时进行类型查询的时候使用下面的方法是错误的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="3-6-泛型在静态方法和静态类中的问题"><a href="#3-6-泛型在静态方法和静态类中的问题" class="headerlink" title="3-6.泛型在静态方法和静态类中的问题"></a>3-6.泛型在静态方法和静态类中的问题</h3><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>
<p>举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//编译错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型类中的泛型参数的实例化的时候确定，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>
<p>但是要注意区分下面的一种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//这是正确的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/211da837/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/211da837/" class="post-title-link" itemprop="url">Java线程池实现原理及其在美团业务中的实践</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/211da837/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/211da837/" data-xid="/posts/211da837/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java线程池实现原理及其在美团业务中的实践"><a href="#Java线程池实现原理及其在美团业务中的实践" class="headerlink" title="Java线程池实现原理及其在美团业务中的实践"></a><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></h1><p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。</p>
<p>本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。</p>
<h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><h3 id="1-1-线程池是什么"><a href="#1-1-线程池是什么" class="headerlink" title="1.1 线程池是什么"></a>1.1 线程池是什么</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p>而本文描述线程池是JDK中提供的ThreadPoolExecutor类。</p>
<p>当然，使用线程池可以带来一系列好处：</p>
<ul>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h3 id="1-2-线程池解决的问题是什么"><a href="#1-2-线程池解决的问题是什么" class="headerlink" title="1.2 线程池解决的问题是什么"></a>1.2 线程池解决的问题是什么</h3><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请&#x2F;销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<ol>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ol>
<p>在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。</p>
<h2 id="二、线程池核心设计与实现"><a href="#二、线程池核心设计与实现" class="headerlink" title="二、线程池核心设计与实现"></a>二、线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。</p>
<h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/h7Yavu_20220216085715.png" alt="图1 ThreadPoolExecutor UML类图"></p>
<center>图1 ThreadPoolExecutor UML类图</center>



<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NyaZL2_20220216085821.png" alt="图2 ThreadPoolExecutor运行流程"></p>
<center>图2 ThreadPoolExecutor运行流程</center>



<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p>
<ol>
<li>线程池如何维护自身状态。</li>
<li>线程池如何管理任务。</li>
<li>线程池如何管理线程。</li>
</ol>
<h3 id="2-2-生命周期管理"><a href="#2-2-生命周期管理" class="headerlink" title="2.2 生命周期管理"></a>2.2 生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor的运行状态有5种，分别为：</p>
<p><img src="https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png" alt="img"></p>
<p>其生命周期转换如下入所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/k5I53e_20220216085930.png" alt="图3 线程池生命周期"></p>
<p>图3 线程池生命周期</p>
<h3 id="2-3-任务执行机制"><a href="#2-3-任务执行机制" class="headerlink" title="2.3 任务执行机制"></a>2.3 任务执行机制</h3><p><strong>2.3.1 任务调度</strong></p>
<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>
<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/nxM486_20220216090005.png" alt="图4 任务调度流程"></p>
<center>图4 任务调度流程</center>



<p><strong>2.3.2 任务缓冲</strong></p>
<p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KcJ1kc_20220216090056.png" alt="图5 阻塞队列"></p>
<center>图5 阻塞队列</center>



<p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/kNOy8F_20220216090204.png" alt="img"></p>
<p><strong>2.3.3 任务申请</strong></p>
<p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/VS4jHX_20220216090252.png" alt="图6 获取任务流程图"></p>
<center>图6 获取任务流程图</center>



<p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<p><strong>2.3.4 任务拒绝</strong></p>
<p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略是一个接口，其设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/WZboNR_20220216090358.png" alt="img"></p>
<p>2.4 Worker线程管理</p>
<p>2.4.1 Worker线程</p>
<p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/r2pblC_20220216090419.png" alt="图7 Worker执行任务"></p>
<center>图7 Worker执行任务</center>



<p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ERpNl9_20220216090526.png" alt="图8 线程池回收过程"></p>
<p>图8 线程池回收过程</p>
<p><strong>2.4.2 Worker线程增加</strong></p>
<p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/LBwxyo_20220216090601.png" alt="图9 申请线程执行流程图"></p>
<p>图9 申请线程执行流程图</p>
<p><strong>2.4.3 Worker线程回收</strong></p>
<p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程回收的工作是在processWorkerExit方法完成的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ediygi_20220216090637.png" alt="图10 线程销毁流程"></p>
<p>图10 线程销毁流程</p>
<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>
<p><strong>2.4.4 Worker线程执行任务</strong></p>
<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<p>1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</p>
<p>执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2RHyDQ_20220216090659.png" alt="图11 执行任务流程"></p>
<p>图11 执行任务流程</p>
<h2 id="三、线程池在业务中的实践"><a href="#三、线程池在业务中的实践" class="headerlink" title="三、线程池在业务中的实践"></a>三、线程池在业务中的实践</h2><h3 id="3-1-业务背景"><a href="#3-1-业务背景" class="headerlink" title="3.1 业务背景"></a>3.1 业务背景</h3><p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p>
<p><strong>场景1：快速响应用户请求</strong></p>
<p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>
<p><strong>分析</strong>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/osaVvY_20220216090717.png" alt="图12 并行执行任务提升任务响应速度"></p>
<p>图12 并行执行任务提升任务响应速度</p>
<p><strong>场景2：快速处理批量任务</strong></p>
<p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/v43OYx_20220216090733.png" alt="图13 并行执行任务提升批量任务执行速度"></p>
<p>图13 并行执行任务提升批量任务执行速度</p>
<h3 id="3-2-实际问题及方案思考"><a href="#3-2-实际问题及方案思考" class="headerlink" title="3.2 实际问题及方案思考"></a>3.2 实际问题及方案思考</h3><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>
<p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p>
<p><strong>Case1</strong>：2018年XX页面展示接口大量调用降级：</p>
<p><strong>事故描述</strong>：XX页面展示接口产生大量调用降级，数量级在几十到上百。</p>
<p><strong>事故原因</strong>：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/dhjkdv_20220216090747.png" alt="图14 线程数核心设置过小引发RejectExecutionException"></p>
<p>图14 线程数核心设置过小引发RejectExecutionException</p>
<p><strong>Case2</strong>：2018年XX业务服务不可用S2级故障</p>
<p><strong>事故描述</strong>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p>
<p><strong>事故原因</strong>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/dLadG2_20220216090804.png" alt="图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"></p>
<p>图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</p>
<p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p>
<p><strong>1. 能否不用线程池?</strong></p>
<p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Zq7L9g_20220216090823.png" alt="img"></p>
<p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p>
<p><strong>2. 追求参数设置合理性？</strong></p>
<p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p>
<p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/45CiX2_20220216090844.png" alt="img"></p>
<p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p>
<p><strong>3. 线程池参数动态化？</strong></p>
<p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lvnfxz_20220216090858.png" alt="图16 动态修改线程池参数新旧流程对比"></p>
<p>图16 动态修改线程池参数新旧流程对比</p>
<p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p>
<h3 id="3-3-动态化线程池"><a href="#3-3-动态化线程池" class="headerlink" title="3.3 动态化线程池"></a>3.3 动态化线程池</h3><p><strong>3.3.1 整体设计</strong></p>
<p>动态化线程池的核心设计包括以下三个方面：</p>
<ol>
<li>简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li>
<li>参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li>
<li>增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ez5lnf_20220216090914.png" alt="图17 动态化线程池整体设计"></p>
<p>图17 动态化线程池整体设计</p>
<p><strong>3.3.2 功能架构</strong></p>
<p>动态化线程池提供如下功能：</p>
<p><strong>动态调参</strong>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 <strong>任务监控</strong>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95&#x2F;99线等。 <strong>负载告警</strong>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 <strong>操作监控</strong>：创建&#x2F;修改和删除线程池都会通知到应用的开发负责人。 <strong>操作日志</strong>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 <strong>权限校验</strong>：只有应用开发负责人才能够修改应用的线程池参数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BZAd4z_20220216090932.png" alt="图18 动态化线程池功能架构"></p>
<p>图18 动态化线程池功能架构</p>
<p><strong>参数动态化</strong></p>
<p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QAFKK8_20220216090950.png" alt="图19 JDK 线程池参数设置接口"></p>
<p>图19 JDK 线程池参数设置接口</p>
<p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/XBPTEo_20220216091010.png" alt="图20 setCorePoolSize方法执行流程"></p>
<p>图20 setCorePoolSize方法执行流程</p>
<p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HNtC74_20220216091036.png" alt="图21 可动态修改线程池参数"></p>
<p>图21 可动态修改线程池参数</p>
<p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p>
<p><strong>线程池监控</strong></p>
<p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p>
<h4 id="1-负载监控和告警"><a href="#1-负载监控和告警" class="headerlink" title="1. 负载监控和告警"></a>1. 负载监控和告警</h4><p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 &#x3D; activeCount&#x2F;maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NBIB1M_20220216091104.png" alt="图22 大象告警通知"></p>
<p>图22 大象告警通知</p>
<h4 id="2-任务级精细化监控"><a href="#2-任务级精细化监控" class="headerlink" title="2. 任务级精细化监控"></a>2. 任务级精细化监控</h4><p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KMkxjh_20220216091140.png" alt="图23 线程池任务执行监控"></p>
<p>图23 线程池任务执行监控</p>
<h4 id="3-运行时状态实时查看"><a href="#3-运行时状态实时查看" class="headerlink" title="3. 运行时状态实时查看"></a>3. 运行时状态实时查看</h4><p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/pKm5Zo_20220216091155.png" alt="图24 线程池实时运行情况"></p>
<p>图24 线程池实时运行情况</p>
<p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Y6a295_20220216091224.png" alt="图25 线程池实时运行情况"></p>
<p>图25 线程池实时运行情况</p>
<h3 id="3-4-实践总结"><a href="#3-4-实践总结" class="headerlink" title="3.4 实践总结"></a>3.4 实践总结</h3><p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ul>
<li>[1] JDK 1.8源码</li>
<li>[2] <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">维基百科-线程池</a></li>
<li>[3] <a target="_blank" rel="noopener" href="https://my.oschina.net/andylucc/blog/648127">更好的使用Java线程池</a></li>
<li>[4] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pooling_(resource_management)">维基百科Pooling(Resource Management)</a></li>
<li>[5] <a target="_blank" rel="noopener" href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a></li>
<li>[6]《Java并发编程实践》</li>
</ul>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swimminghao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:22</span>
  </span>
</div>

<span id="sitetime"></span>
<script language=javascript>
    function siteTime(){
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2022,02,28,00,00,00); //你的建站时间
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById("sitetime").innerHTML=" 本站已安全运行 "+diffYears+" Year "+diffDays+" Days "+diffHours+" Hours "+diffMinutes+" m "+diffSeconds+" s";
    }
    siteTime();
</script>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        访问人数：<span id="busuanzi_value_site_uv"></span>
      </span>人
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
       访问总量：<span id="busuanzi_value_site_pv"></span>
      </span>次
    </span>


<!--
  本文总阅读量：<span id="busuanzi_value_page_pv"></span>次
-->

</div>


<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

--><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-nu.vercel.app","placeholder":"请文明评论呀","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/page/17/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "middleCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
</body>
</html>
