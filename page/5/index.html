<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-loading-bar.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="swimminghao的学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swimminghao&#39;s blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="swimminghao&#39;s blog">
<meta property="og:description" content="swimminghao的学习博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swimminghao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>swimminghao's blog</title>
  




<link rel="dns-prefetch" href="waline-server-nu.vercel.app"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">swimminghao's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">124</span></a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="swimminghao"
      src="/images/lion.png">
  <p class="site-author-name" itemprop="name">swimminghao</p>
  <div class="site-description" itemprop="description">swimminghao的学习博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">124</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/swimminghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swimminghao0@gmail.com" title="E-Mail → mailto:swimminghao0@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/swimminghao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- recent posts -->
    <div class="links-of-blogroll motion-element links-of-blogroll-block">
        <div class="links-of-blogroll-title recent-posts-title">
	    <i class="fa fa-history " aria-hidden="true"></i>
            近期文章
	</div>
	<ul class="links-of-blogroll-list recent-posts-list">
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/dc033d1f/" title="1、【对线面试官】今天来聊聊Java注解" target="">
		    1、【对线面试官】今天来聊聊Java注解
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/c30e6297/" title="Hexo博客文章加密" target="">
		    Hexo博客文章加密
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/a07389a8/" title="Hexo博客进阶：为 Next 主题添加 Waline 评论系统" target="">
		    Hexo博客进阶：为 Next 主题添加 Waline 评论系统
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/5cd5216c/" title="经典动态规划：打家劫舍系列问题" target="">
		    经典动态规划：打家劫舍系列问题
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/hello-world/" title="Hello World" target="">
		    Hello World
		    </a>
		</li>
	</ul>
    </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/498f0b66/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/498f0b66/" class="post-title-link" itemprop="url">JAVA</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/498f0b66/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/498f0b66/" data-xid="/posts/498f0b66/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>116k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:46</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><a href="#%E4%B8%80%E5%9F%BA%E7%A1%80%E7%AF%87">一、基础篇</a><ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">网络基础</a><ul>
<li><a href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><strong>TCP三次握手</strong></a><ul>
<li><a href="#1osi%E4%B8%8Etcpip-%E6%A8%A1%E5%9E%8B"><strong>1、OSI与TCP&#x2F;IP 模型</strong></a></li>
<li><a href="#2%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B1%82"><strong>2、常见网络服务分层</strong></a></li>
<li><a href="#3tcp%E4%B8%8Eudp%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%9C%BA%E6%99%AF"><strong>3、TCP与UDP区别及场景</strong></a></li>
<li><a href="#4tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><strong>4、TCP滑动窗口，拥塞控制</strong></a></li>
<li><a href="#5tcp%E7%B2%98%E5%8C%85%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><strong>5、TCP粘包原因和解决方法</strong></a></li>
<li><a href="#6tcpudp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><strong>6、TCP、UDP报文格式</strong></a></li>
</ul>
</li>
<li><a href="#http%E5%8D%8F%E8%AE%AE"><strong>HTTP协议</strong></a><ul>
<li><a href="#1http%E5%8D%8F%E8%AE%AE10_11_20">1、HTTP协议<em>1.0_1.1_2.0</em></a></li>
<li><a href="#2http%E4%B8%8Ehttps%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">2、HTTP与HTTPS之间的区别</a></li>
<li><a href="#3get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E5%8C%BA%E5%88%AB"><strong>3、Get和Post请求区别</strong></a></li>
<li><a href="#4http%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><strong>4、HTTP常见响应状态码</strong></a></li>
<li><a href="#5%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB"><strong>5、重定向和转发区别</strong></a></li>
<li><a href="#6cookie%E5%92%8Csession%E5%8C%BA%E5%88%AB"><strong>6、Cookie和Session区别。</strong></a></li>
</ul>
</li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E8%BF%87%E7%A8%8B"><strong>浏览器输入URL过程</strong></a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><strong>操作系统基础</strong></a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>进程和线程的区别</strong></a><ul>
<li><a href="#1%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc"><strong>1、进程间通信方式IPC</strong></a></li>
<li><a href="#2%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E6%A0%B8%E5%BF%83%E6%80%81"><strong>2、用户态和核心态</strong></a></li>
<li><a href="#3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4"><strong>3、操作系统的进程空间</strong></a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">操作系统内存管理</a><ul>
<li><a href="#1%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95fifolru"><strong>1、页面置换算法FIFO、LRU</strong></a></li>
<li><a href="#2%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><strong>2、死锁条件、解决方式。</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#java%E5%9F%BA%E7%A1%80"><strong>Java基础</strong></a><ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">面向对象三大特性</a><ul>
<li><a href="#1java%E4%B8%8Ec%E5%8C%BA%E5%88%AB"><strong>1、Java与C++区别</strong></a></li>
<li><a href="#2%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><strong>2、多态实现原理</strong></a></li>
<li><a href="#3static%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97">3、static和final关键字</a></li>
<li><a href="#4%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3">4、抽象类和接口</a></li>
<li><a href="#5%E6%B3%9B%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4">5、泛型以及泛型擦除</a></li>
<li><a href="#6%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>6、反射原理以及使用场景</strong></a></li>
<li><a href="#7java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><strong>7、Java异常体系</strong></a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul>
<li><a href="#1arraylist%E5%92%8Clinkedlist"><strong>1、ArrayList和LinkedList</strong></a></li>
<li><a href="#2list%E9%81%8D%E5%8E%86%E5%BF%AB%E9%80%9F%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5"><strong>2、List遍历快速和安全失败</strong></a></li>
<li><a href="#3%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8Dhashmap"><strong>3、详细介绍HashMap</strong></a></li>
<li><a href="#4concurrenthashmap-">**4、ConcurrentHashMap **</a></li>
<li><a href="#5%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><strong>5、序列化和反序列化</strong></a></li>
<li><a href="#6string"><strong>6、String</strong></a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99">设计模式与原则</a><ul>
<li><a href="#1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">1、单例模式</a></li>
<li><a href="#2%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">2、工厂模式</a></li>
<li><a href="#3%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">3、抽象工厂模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a><ul>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97">初始化块</a></li>
<li><a href="#this">This</a></li>
<li><a href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>重写和重载的区别</strong></a></li>
<li><a href="#object%E7%B1%BB%E6%96%B9%E6%B3%95">Object类方法</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB">基本数据类型和包装类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8Cjvm%E7%AF%87">二、JVM篇</a><ul>
<li><a href="#jvm%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><strong>JVM内存划分</strong></a><ul>
<li><a href="#1jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><strong>1、JVM运行时数据区域</strong></a></li>
<li><a href="#2%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><strong>2、堆内存分配策略</strong></a></li>
<li><a href="#3%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><strong>3、创建一个对象的步骤</strong></a></li>
<li><a href="#4%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">4、<strong>对象引用</strong></a></li>
</ul>
</li>
<li><a href="#jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><strong>JVM类加载过程</strong></a><ul>
<li><a href="#1%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><strong>1、双亲委派机制</strong></a></li>
<li><a href="#2tomcat%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><strong>2、tomcat的类加载机制</strong></a></li>
</ul>
</li>
<li><a href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">JVM垃圾回收</a><ul>
<li><a href="#1%E5%AD%98%E6%B4%BB%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%A4%E6%AC%A1%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><strong>1、存活算法和两次标记过程</strong></a></li>
<li><a href="#2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><strong>2、垃圾回收算法</strong></a><ul>
<li><a href="#minorgcmajorgcfullgc"><strong>MinorGC、MajorGC、FullGC</strong></a></li>
</ul>
</li>
<li><a href="#3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><strong>3、垃圾收集器</strong></a></li>
<li><a href="#4%E9%85%8D%E7%BD%AE%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><strong>4、配置垃圾收集器</strong></a></li>
<li><a href="#4jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><strong>4、JVM性能调优</strong></a></li>
<li><a href="#5jdk%E6%96%B0%E7%89%B9%E6%80%A7">5、JDK新特性</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5">线上故障排查</a><ul>
<li><a href="#1%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5">1、硬件故障排查</a></li>
<li><a href="#2%E6%8A%A5%E8%A1%A8%E5%BC%82%E5%B8%B8--jvm%E8%B0%83%E4%BC%98">2、报表异常 | JVM调优</a></li>
<li><a href="#3%E5%A4%A7%E5%B1%8F%E5%BC%82%E5%B8%B8--juc%E8%B0%83%E4%BC%98">3、大屏异常 | JUC调优</a></li>
<li><a href="#4%E6%8E%A5%E5%8F%A3%E5%BB%B6%E8%BF%9F--swap%E8%B0%83%E4%BC%98"><strong>4、接口延迟 | SWAP调优</strong></a></li>
<li><a href="#5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA--cache%E8%B0%83%E4%BC%98">5、<strong>内存溢出 | Cache调优</strong></a></li>
<li><a href="#6cpu%E9%A3%99%E9%AB%98--%E6%AD%BB%E5%BE%AA%E7%8E%AF">6：CPU飙高 | 死循环</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87">三、多线程篇</a><ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6">线程调度</a><ul>
<li><a href="#1%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><strong>1、线程状态</strong></a></li>
<li><a href="#2%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><strong>2、线程状态切换</strong></a></li>
<li><a href="#3%E9%98%BB%E5%A1%9E%E5%94%A4%E9%86%92%E8%BF%87%E7%A8%8B"><strong>3、阻塞唤醒过程</strong></a></li>
<li><a href="#4wait%E5%92%8Csleep%E5%8C%BA%E5%88%AB"><strong>4、wait和sleep区别</strong></a></li>
<li><a href="#5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F">5、创建线程方式</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><ul>
<li><a href="#1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><strong>1、线程池构造函数</strong></a></li>
<li><a href="#2%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%BF%87%E7%A8%8B"><strong>2、线程处理任务过程：</strong></a></li>
<li><a href="#3%E7%BA%BF%E7%A8%8B%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><strong>3、线程拒绝策略</strong></a></li>
<li><a href="#4execuors%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><strong>4、Execuors类实现线程池</strong></a></li>
<li><a href="#5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><strong>5、线程池大小设置</strong></a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a><ul>
<li><a href="#1%E4%B9%90%E8%A7%82%E9%94%81cas%E6%80%9D%E6%83%B3"><strong>1、乐观锁，CAS思想</strong></a></li>
<li><a href="#2synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><strong>2、synchronized底层实现</strong></a></li>
<li><a href="#3reentrantlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><strong>3、ReenTrantLock底层实现</strong></a></li>
<li><a href="#4%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8C%BA%E5%88%AB"><strong>4、公平锁和非公平锁区别</strong></a></li>
<li><a href="#5%E4%BD%BF%E7%94%A8%E5%B1%82%E9%9D%A2%E9%94%81%E4%BC%98%E5%8C%96"><strong>5、使用层面锁优化</strong></a></li>
<li><a href="#6%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E9%94%81%E4%BC%98%E5%8C%96">6、系统层面锁优化</a></li>
<li><a href="#7threadlocal%E5%8E%9F%E7%90%86"><strong>7、ThreadLocal原理</strong></a></li>
<li><a href="#8hashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><strong>8、HashMap线程安全</strong></a></li>
<li><a href="#9string%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8E%9F%E5%9B%A0">9、String不可变原因</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">内存模型</a><ul>
<li><a href="#1volatile%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><strong>1、volatile底层实现</strong></a></li>
<li><a href="#2aqs%E6%80%9D%E6%83%B3"><strong>2、AQS思想</strong></a></li>
<li><a href="#3happens-before">3、happens-before</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9Bmysql%E7%AF%87">四、MySQL篇</a><ul>
<li><a href="#whymysql">WhyMysql？</a><ul>
<li><a href="#%E6%B5%B7%E9%87%8Faerospike">海量Aerospike</a></li>
<li><a href="#%E5%9B%BE%E8%B0%B1neo4j">图谱Neo4j</a></li>
<li><a href="#%E6%96%87%E6%A1%A3mongodb"><strong>文档MongoDB</strong></a></li>
<li><a href="#%E4%BA%91%E5%AD%98%E5%82%A8"><strong>云存储</strong></a></li>
<li><a href="#fastdfs"><strong>FastDFS</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1">事务</a><ul>
<li><a href="#1%E4%BA%8B%E5%8A%A14%E5%A4%A7%E7%89%B9%E6%80%A7"><strong>1、事务4大特性</strong></a></li>
<li><a href="#2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><strong>2、事务隔离级别</strong></a></li>
<li><a href="#3%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-rr"><strong>3、默认隔离级别-RR</strong></a></li>
<li><a href="#4rr%E5%92%8Crc%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>4、RR和RC使用场景</strong></a></li>
<li><a href="#5%E8%A1%8C%E9%94%81%E8%A1%A8%E9%94%81%E6%84%8F%E5%90%91%E9%94%81"><strong>5、行锁，表锁，意向锁</strong></a></li>
<li><a href="#6mvcc%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><strong>6、MVCC多版本并发控制</strong></a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a><ul>
<li><a href="#1innodb%E5%92%8Cmyisam%E5%BC%95%E6%93%8E"><strong>1、Innodb和Myisam引擎</strong></a></li>
<li><a href="#2%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><strong>2、哈希索引</strong></a></li>
<li><a href="#3b%E6%A0%91%E7%B4%A2%E5%BC%95"><strong>3、B+树索引</strong></a></li>
<li><a href="#4%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">4、创建索引</a></li>
<li><a href="#5%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><strong>5、聚簇索引和非聚簇索引</strong></a></li>
<li><a href="#6%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98">6、最左前缀问题</a></li>
</ul>
</li>
<li><a href="#sql%E6%9F%A5%E8%AF%A2">SQL查询</a><ul>
<li><a href="#1sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><strong>1、SQL语句的执行过程</strong></a></li>
<li><a href="#2%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><strong>2、回表查询和覆盖索引</strong></a></li>
<li><a href="#3explain%E5%8F%8A%E4%BC%98%E5%8C%96">3、Explain及优化</a></li>
<li><a href="#4join%E6%9F%A5%E8%AF%A2">4、JOIN查询</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E7%BE%A4"><strong>集群</strong></a><ul>
<li><a href="#1%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B">1、主从复制过程</a></li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">2、数据一致性问题</a></li>
<li><a href="#3%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84">3、集群架构</a></li>
<li><a href="#4%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%92%8C%E6%81%A2%E5%A4%8D">4、故障转移和恢复</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1">面试题</a><ul>
<li><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">分库分表</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">如何进行分库分表</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%B0%86%E8%80%81%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%81%E7%A7%BB">如何将老数据进行迁移</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E8%AF%84%E4%BC%B0%E5%8F%8A%E6%89%A9%E5%AE%B9">系统性能的评估及扩容</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E8%87%AA%E5%A2%9E%E7%9A%84id%E4%B8%BB%E9%94%AE">如何生成自增的id主键</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E5%8F%8A%E4%BC%98%E5%8C%96">线上故障及优化</a><ul>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5--%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6">更新失败 | 主从同步延时</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83--%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%98%E5%8C%96"><strong>应用崩溃 | 分库分表优化</strong></a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%BC%82%E5%B8%B8--sql-%E8%B0%83%E4%BC%98">查询异常 | SQL 调优</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94redis%E7%AF%87"><strong>五、Redis篇</strong></a><ul>
<li><a href="#whyredis">WhyRedis</a><ul>
<li><a href="#1%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88">1、简单高效</a></li>
<li><a href="#2memcache">2、Memcache</a></li>
<li><a href="#3tair">3、Tair</a></li>
<li><a href="#4guava">4、Guava</a></li>
<li><a href="#5evcache">5、EVCache</a></li>
<li><a href="#6etcd">6、ETCD</a></li>
</ul>
</li>
<li><a href="#redis%E5%BA%95%E5%B1%82">Redis底层</a><ul>
<li><a href="#1redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1、redis数据类型</a></li>
<li><a href="#2%E7%9B%B8%E5%85%B3api"><strong>2、相关API</strong></a></li>
<li><a href="#3redis%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">3、redis底层结构</a></li>
<li><a href="#4zset%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">4、Zset底层实现</a></li>
</ul>
</li>
<li><a href="#redis%E5%8F%AF%E7%94%A8%E6%80%A7"><strong>Redis可用性</strong></a><ul>
<li><a href="#1redis%E6%8C%81%E4%B9%85%E5%8C%96">1、redis持久化</a></li>
<li><a href="#2redis%E4%BA%8B%E5%8A%A1">2、redis事务</a></li>
<li><a href="#3redis%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5">3、redis失效策略</a></li>
<li><a href="#4redis%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F">4、redis读写模式</a></li>
<li><a href="#5%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">5、多级缓存</a></li>
</ul>
</li>
<li><a href="#redis%E4%B8%83%E5%A4%A7%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98">Redis七大经典问题</a><ul>
<li><a href="#1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">1、缓存雪崩</a></li>
<li><a href="#2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><strong>2、缓存穿透</strong></a></li>
<li><a href="#3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><strong>3、缓存击穿</strong></a></li>
<li><a href="#4%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4">4、数据不一致</a></li>
<li><a href="#5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89">5、数据并发竞争</a></li>
<li><a href="#6%E7%83%AD%E7%82%B9key%E9%97%AE%E9%A2%98">6、热点key问题</a></li>
<li><a href="#7bigkey%E9%97%AE%E9%A2%98">7、BigKey问题</a></li>
</ul>
</li>
<li><a href="#redis%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99">Redis分区容错</a><ul>
<li><a href="#1redis%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><strong>1、redis数据分区</strong></a></li>
<li><a href="#2%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95"><strong>2、主从模式&#x3D;简单</strong></a></li>
<li><a href="#3%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E8%AF%BB%E5%A4%9A">3、<strong>哨兵模式</strong>&#x3D;读多</a></li>
<li><a href="#4%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%86%99%E5%A4%9A">4、集群模式&#x3D;写多</a></li>
<li><a href="#5%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">5、分布式锁</a></li>
<li><a href="#6redis%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B">6、redis心跳检测</a></li>
</ul>
</li>
<li><a href="#redis%E5%AE%9E%E6%88%98">Redis实战</a><ul>
<li><a href="#1redis%E4%BC%98%E5%8C%96">1、Redis优化</a></li>
<li><a href="#2redis%E7%83%AD%E5%8D%87%E7%BA%A7">2、Redis热升级</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%ADkafka%E7%AF%87">六、Kafka篇</a><ul>
<li><a href="#why-kafka">Why kafka</a></li>
<li><a href="#what-kafka">What Kafka</a></li>
<li><a href="#how-kafka">How Kafka</a></li>
<li><a href="#%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><strong>生产消费基本流程</strong></a></li>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li>
<li><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-2">面试题</a><ul>
<li><a href="#%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98rebalance"><strong>线上问题rebalance</strong></a></li>
<li><a href="#zookeeper-%E7%9A%84%E4%BD%9C%E7%94%A8">ZooKeeper 的作用</a></li>
<li><a href="#replica%E5%89%AF%E6%9C%AC%E7%9A%84%E4%BD%9C%E7%94%A8">Replica副本的作用</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">为什么不支持读写分离?</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9">如何防止重复消费</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1"><strong>如何保证数据不会丢失</strong></a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><strong>如何保证顺序消费</strong></a></li>
<li><a href="#%E7%BA%BF%E4%B8%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%A7%AF%E5%8E%8B%E6%B6%88%E8%B4%B9">【线上】如何解决积压消费</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B">如何避免消息积压</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">如何设计消息队列</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%83spring%E7%AF%87">七、Spring篇</a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3beans">设计思想&amp;Beans</a><ul>
<li><a href="#1ioc-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><strong>1、IOC 控制反转</strong></a></li>
<li><a href="#2aop-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>2、AOP 动态代理</strong></a></li>
<li><a href="#3bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>3、Bean生命周期</strong></a></li>
<li><a href="#4bean%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>4</strong>、Bean作用域</a></li>
<li><a href="#5%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">5、循环依赖</a></li>
</ul>
</li>
<li><a href="#spring%E6%B3%A8%E8%A7%A3">Spring注解</a><ul>
<li><a href="#1springboot">1、@SpringBoot</a></li>
<li><a href="#2springmvc"><strong>2、@SpringMVC</strong></a></li>
<li><a href="#3springmybatis">3、@SpringMybatis</a></li>
<li><a href="#4transactional">4、@Transactional</a></li>
</ul>
</li>
<li><a href="#spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">Spring源码阅读</a><ul>
<li><a href="#1spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><strong>1、Spring中的设计模式</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%ABspringcloud%E7%AF%87">八、SpringCloud篇</a><br>- <a href="#why-springcloud">Why SpringCloud</a><br>- <a href="#spring-boot">Spring Boot</a><br>- <a href="#gateway--zuul">GateWay &#x2F; Zuul</a><br>- <a href="#eureka--zookeeper">Eureka &#x2F; Zookeeper</a><br>- <a href="#feign--ribbon">Feign &#x2F; Ribbon</a><br>- <a href="#hystrix--sentinel">Hystrix &#x2F; Sentinel</a><br>- <a href="#config--nacos">Config &#x2F; Nacos</a><br>- <a href="#bus--stream">Bus &#x2F; Stream</a><br>- <a href="#sleuth--zipkin"><strong>Sleuth &#x2F; Zipkin</strong></a><ul>
<li><a href="#%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81"><strong>安全认证</strong></a></li>
<li><a href="#%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83">灰度发布</a></li>
<li><a href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E9%9A%94%E7%A6%BB">多版本隔离</a><ul>
<li><a href="#%E5%90%84%E7%BB%84%E4%BB%B6%E8%B0%83%E4%BC%98"><strong>各组件调优</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E5%88%86%E5%B8%83%E5%BC%8F%E7%AF%87"><strong>九、分布式篇</strong></a><ul>
<li><a href="#%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><strong>发展历程</strong></a></li>
<li><a href="#cap">CAP</a></li>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7-1">一致性</a><ul>
<li><a href="#xa%E6%96%B9%E6%A1%88">XA方案</a></li>
<li><a href="#paxos%E7%AE%97%E6%B3%95"><strong>Paxos算法</strong></a></li>
<li><a href="#zab%E7%AE%97%E6%B3%95"><strong>ZAB算法</strong></a></li>
<li><a href="#raft%E7%AE%97%E6%B3%95">Raft算法</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Credis%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">数据库和Redis的一致性</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7-1">可用性</a><ul>
<li><a href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><strong>心跳检测</strong></a></li>
<li><a href="#%E5%A4%9A%E6%9C%BA%E6%88%BF%E5%AE%9E%E6%97%B6%E7%83%AD%E5%A4%87"><strong>多机房实时热备</strong></a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7">分区容错性</a><ul>
<li><a href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6">日志复制</a></li>
<li><a href="#%E4%B8%BB%E5%A4%87master-slave"><strong>主备（Master-Slave）</strong></a></li>
<li><a href="#%E4%BA%92%E5%A4%87active-active"><strong>互备（Active-Active）</strong></a></li>
<li><a href="#%E9%9B%86%E7%BE%A4cluster%E6%A8%A1%E5%BC%8F"><strong>集群（Cluster）模式</strong></a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a><ul>
<li><a href="#xa%E6%96%B9%E6%A1%88-1">XA方案</a></li>
<li><a href="#tcc%E6%96%B9%E6%A1%88">TCC方案</a></li>
<li><a href="#saga%E6%96%B9%E6%A1%88"><strong>Saga方案</strong></a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8ebay"><strong>本地消息表（eBay）</strong></a></li>
<li><a href="#mq%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><strong>MQ最终一致性</strong></a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88%E8%AE%A2%E5%8D%95---%E7%A7%AF%E5%88%86">最大努力通知方案（订单 -&gt; 积分）</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-3">面试题</a><ul>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8Fsession%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">分布式Session实现方案</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h3><p>​    <strong>三次握手过程：</strong></p>
<p>​        客户端——发送带有SYN标志的数据包——服务端       <strong>一次握手</strong>  Client进入syn_sent状态</p>
<p>​        服务端——发送带有SYN&#x2F;ACK标志的数据包——客户端   <strong>二次握手</strong>  服务端进入syn_rcvd</p>
<p>​        客户端——发送带有ACK标志的数据包——服务端               <strong>三次握手</strong>   连接就进入Established状态</p>
<p>​    <strong>为什么三次：</strong></p>
<p>​        主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</p>
<p>​    <strong>为什么两次不行？</strong></p>
<p>​        1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源</p>
<p>​        2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维    护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方    相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）</p>
<p>**TCP四次挥手过程 **</p>
<p><strong>四次挥手过程：</strong></p>
<p>​    客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态</p>
<p>​    服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态</p>
<p>​    服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态</p>
<p>​    客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态</p>
<p><strong>为什么四次：</strong></p>
<p>​    因为需要确保客户端与服务端的数据能够完成传输。</p>
<p><strong>CLOSE-WAIT：</strong></p>
<p>​    这种状态的含义其实是表示在等待关闭</p>
<p><strong>TIME-WAIT：</strong></p>
<p>​    为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接</p>
<p><strong>如何查看TIME-WAIT状态的链接数量？</strong>        </p>
<p>​    netstat -an |grep TIME_WAIT|wc -l  查看连接数等待time_wait状态连接数</p>
<p><strong>为什么会TIME-WAIT过多？解决方法是怎样的？</strong></p>
<p>​    <strong>可能原因：</strong> 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接</p>
<p>​    <strong>解决：</strong>负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接</p>
<h4 id="1、OSI与TCP-x2F-IP-模型"><a href="#1、OSI与TCP-x2F-IP-模型" class="headerlink" title="1、OSI与TCP&#x2F;IP 模型"></a><strong>1、OSI与TCP&#x2F;IP 模型</strong></h4><p>​        OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>​        TCP&#x2F;IP五层：物理层、数据链路层、网络层、传输层、应用层</p>
<h4 id="2、常见网络服务分层"><a href="#2、常见网络服务分层" class="headerlink" title="2、常见网络服务分层"></a><strong>2、常见网络服务分层</strong></h4><p>​        应用层：HTTP、SMTP、DNS、FTP</p>
<p>​        传输层：TCP 、UDP</p>
<p>​        网络层：ICMP 、IP、路由器、防火墙</p>
<p>​        数据链路层：网卡、网桥、交换机</p>
<p>​        物理层：中继器、集线器</p>
<h4 id="3、TCP与UDP区别及场景"><a href="#3、TCP与UDP区别及场景" class="headerlink" title="3、TCP与UDP区别及场景"></a><strong>3、TCP与UDP区别及场景</strong></h4><table>
<thead>
<tr>
<th>类型</th>
<th align="center">特点</th>
<th align="center">性能</th>
<th align="center">应用过场景</th>
<th align="center">首部字节</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td align="center">面向连接、可靠、字节流</td>
<td align="center">传输效率慢、所需资源多</td>
<td align="center">文件、邮件传输</td>
<td align="center">20-60</td>
<td></td>
</tr>
<tr>
<td>UDP</td>
<td align="center">无连接、不可靠、数据报文段</td>
<td align="center">传输效率快、所需资源少</td>
<td align="center">语音、视频、直播</td>
<td align="center">8个字节</td>
<td></td>
</tr>
</tbody></table>
<p>​    <strong>基于TCP的协议：</strong>HTTP、FTP、SMTP</p>
<p>​    <strong>基于UDP的协议：</strong>RIP、DNS、SNMP</p>
<h4 id="4、TCP滑动窗口，拥塞控制"><a href="#4、TCP滑动窗口，拥塞控制" class="headerlink" title="4、TCP滑动窗口，拥塞控制"></a><strong>4、TCP滑动窗口，拥塞控制</strong></h4><p>​        <strong>TCP通过：</strong>应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输；</p>
<p>​        <strong>拥塞控制目的：</strong>为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载</p>
<p>​        <strong>拥塞控制过程：</strong>TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。</p>
<h4 id="5、TCP粘包原因和解决方法"><a href="#5、TCP粘包原因和解决方法" class="headerlink" title="5、TCP粘包原因和解决方法"></a><strong>5、TCP粘包原因和解决方法</strong></h4><p>​    <strong>TCP粘包是指</strong>：发送方发送的若干包数据到接收方接收时粘成一包</p>
<p>​    <strong>发送方原因：</strong></p>
<p>​        TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：</p>
<p>​            收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题</p>
<p>​    <strong>接收方原因：</strong></p>
<p>​            TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
<p>​    <strong>解决粘包问题：</strong></p>
<p>​        最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p>
<ul>
<li><p>发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</p>
</li>
<li><p>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。</p>
</li>
<li><p>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</p>
</li>
</ul>
<h4 id="6、TCP、UDP报文格式"><a href="#6、TCP、UDP报文格式" class="headerlink" title="6、TCP、UDP报文格式"></a><strong>6、TCP、UDP报文格式</strong></h4><p>​    <strong>TCP报文格式：</strong></p>
<p>​        <img src="https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg" style="zoom: 67%;" /></p>
<p>​    <strong>源端口号和目的端口号</strong>：</p>
<p>​        用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。</p>
<p>​    <strong>序号字段：</strong></p>
<p>​        序号用来标识从T C P发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。</p>
<p>　　当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号</p>
<p>​    <strong>确认序号</strong>：</p>
<p>​        既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是T C P首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p>
<p>​    <strong>首都长度</strong>：</p>
<p>​        首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。</p>
<p>​    <strong>标志字段</strong>：在T C P首部中有 6个标志比特。它们中的多个可同时被设置为1.<br>　　URG紧急指针（u rgent pointer）有效<br>　　ACK确认序号有效。<br>　　PSH接收方应该尽快将这个报文段交给应用层。<br>　　RST重建连接。<br>　　SYN同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。<br>　　FIN发端完成发送任务。</p>
<p>​    <strong>窗口大小</strong>：</p>
<p>​        T C P的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。</p>
<p>​    <strong>检验和：</strong></p>
<p>​        检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p>
<p>​    <strong>紧急指针</strong>：</p>
<p>​        只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<p>​    <strong>选项</strong>：</p>
<p>​        最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</p>
<p>​    <strong>UDP报文格式：</strong></p>
<p>​    <img src="https://appwk.baidu.com/naapi/doc/view?ih=482&o=png_6_0_0_176_917_504_247_892.979_1262.879&iw=986&ix=0&iy=0&aimw=986&rn=1&doc_id=182d935c3186bceb18e8bb77&pn=1&sign=b88bda03b9954e506622f97b8b2ae438&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7" style="zoom:50%;" /></p>
<p>​    <strong>端口号</strong>：</p>
<p>​        用来表示发送和接受进程。由于 I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字段值），因此T C P端口号由T C P来查看，而 U D P端口号由UDP来查看。T C P端口号与UDP端口号是相互独立的。</p>
<p>​    <strong>长度</strong>：</p>
<p>​        UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是 O K）。</p>
<p>​    <strong>检验和</strong>：</p>
<p>​        UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</p>
<p>​    <strong>IP报文格式：</strong>普通的IP首部长为20个字节，除非含有可选项字段。</p>
<p>​                <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1614312792,1954581760&fm=26&gp=0.jpg" style="zoom:67%;" /></p>
<p>​    <strong>4位版本</strong>：</p>
<p>​        目前协议版本号是4，因此IP有时也称作IPV4.</p>
<p>​    <strong>4位首部长度</strong>：</p>
<p>​        首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p>
<p>​    <strong>服务类型（TOS）</strong>：</p>
<p>​        服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p>
<p>​    <strong>总长度</strong>：</p>
<p>​        总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p>
<p>​    <strong>标识字段</strong>：</p>
<p>​        标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p>
<p>​    <strong>生存时间</strong>：</p>
<p>​        TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p>
<p>​    <strong>首部检验和</strong>：</p>
<p>​        首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p>
<p>​    <strong>以太网报文格式：</strong></p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2733576797,55677727&fm=26&gp=0.jpg"></p>
<p>​    <strong>目的地址和源地址：</strong></p>
<p>​        是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p>
<p>​    <strong>数据：</strong></p>
<p>​        以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h3><h4 id="1、HTTP协议1-0-1-1-2-0"><a href="#1、HTTP协议1-0-1-1-2-0" class="headerlink" title="1、HTTP协议1.0_1.1_2.0"></a>1、HTTP协议1.0_1.1_2.0</h4><p>​    <strong>HTTP1.0：</strong>服务器处理完成后立即断开TCP连接（<strong>无连接</strong>），服务器不跟踪每个客户端也不记录过去的请求（<strong>无状态</strong>）</p>
<p>​    <strong>HTTP1.1：</strong>KeepAlived<strong>长连接</strong>避免了连接建立和释放的开销；通过Content-Length来判断当前请求数据是否已经全部接受（<strong>有状态</strong>）</p>
<p>​    <strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以<strong>并行</strong>的传输数据。</p>
<p>​    <strong>http1.0和http1.1的主要区别如下：</strong><br>​        1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​        2、网络连接的优化：1.1支持断点续传<br>​        3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​        4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​        5、长连接：减少了建立和关闭连接的消耗和延迟。</p>
<p>​    <strong>http1.1和http2.0的主要区别：</strong><br>​        1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​        2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）<br>​        3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小<br>​        4、服务端推送：同google的SPDUY（1.0的一种升级）一样</p>
<h4 id="2、HTTP与HTTPS之间的区别"><a href="#2、HTTP与HTTPS之间的区别" class="headerlink" title="2、HTTP与HTTPS之间的区别"></a>2、HTTP与HTTPS之间的区别</h4><p>​        <strong>HTTP与HTTPS之间的区别：</strong></p>
<table>
<thead>
<tr>
<th align="center">HTTP</th>
<th align="center">HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认端口80</td>
<td align="center">HTTPS默认使用端口443</td>
</tr>
<tr>
<td align="center">明文传输、数据未加密、安全性差</td>
<td align="center">传输过程ssl加密、安全性较好</td>
</tr>
<tr>
<td align="center">响应速度快、消耗资源少</td>
<td align="center">响应速度较慢、消耗资源多、需要用到CA证书</td>
</tr>
</tbody></table>
<p>​        <strong>HTTPS链接建立的过程：</strong></p>
<p>​            1.首先客户端先给服务器发送一个请求</p>
<p>​            2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p>
<p>​            3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密</p>
<p>​            4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</p>
<p>​            5.随后客户端和服务端就使用对称密钥进行信息传输</p>
<p>​        <strong>对称加密算法：</strong></p>
<p>​            双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES</p>
<p>​        <strong>非对称加密算法：</strong></p>
<p>​            密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA</p>
<h4 id="3、Get和Post请求区别"><a href="#3、Get和Post请求区别" class="headerlink" title="3、Get和Post请求区别"></a><strong>3、Get和Post请求区别</strong></h4><p><strong>HTTP请求：</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td>向特定资源发送请求，查询数据，并返回实体</td>
</tr>
<tr>
<td align="left">POST</td>
<td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td>
</tr>
<tr>
<td align="left">PUT</td>
<td>向服务器上传新的内容</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td>请求服务器删除指定标识的资源</td>
</tr>
<tr>
<td align="left">OPTIONS</td>
<td>可以用来向服务器发送请求来测试服务器的功能性</td>
</tr>
<tr>
<td align="left">TRACE</td>
<td>回显服务器收到的请求，用于测试或诊断</td>
</tr>
<tr>
<td align="left">CONNECT</td>
<td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
</tbody></table>
<p><strong>get和Post区别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>数据在URL中对所有人可见</td>
<td>数据不会显示在URL中</td>
</tr>
<tr>
<td>安全性</td>
<td>与post相比，get的安全性较差，因为所<br/>发送的数据是URL的一部分</td>
<td>安全，因为参数不会被保存在浏览器<br/>历史或web服务器日志中</td>
</tr>
<tr>
<td>数据长度</td>
<td>受限制，最长2kb</td>
<td>无限制</td>
</tr>
<tr>
<td>编码类型</td>
<td>application&#x2F;x-www-form-urlencoded</td>
<td>multipart&#x2F;form-data</td>
</tr>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能被缓存</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="4、HTTP常见响应状态码"><a href="#4、HTTP常见响应状态码" class="headerlink" title="4、HTTP常见响应状态码"></a><strong>4、HTTP常见响应状态码</strong></h4><p>​        100：Continue — 继续。客户端应继续其请求。</p>
<p>​        200：OK — 请求成功。一般用于GET与POST请求。</p>
<p>​        301：Moved Permanently — 永久重定向。</p>
<p>​        302：Found — 暂时重定向。</p>
<p>​        400：Bad Request — 客户端请求的语法错误，服务器无法理解。</p>
<p>​        403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。</p>
<p>​        404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。</p>
<p>​        500：Internal Server Error — 服务器内部错误，无法完成请求。</p>
<p>​        502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p>
<h4 id="5、重定向和转发区别"><a href="#5、重定向和转发区别" class="headerlink" title="5、重定向和转发区别"></a><strong>5、重定向和转发区别</strong></h4><p>​    <strong>重定向：redirect：</strong></p>
<p>​            地址栏发生变化    </p>
<p>​            重定向可以访问其他站点（服务器）的资源</p>
<p>​            重定向是两次请求。不能使用request对象来共享数据</p>
<p>​    <strong>转发：forward：</strong></p>
<p>​            转发地址栏路径不变</p>
<p>​            转发只能访问当前服务器下的资源</p>
<p>​            转发是一次请求，可以使用request对象共享数据</p>
<h4 id="6、Cookie和Session区别。"><a href="#6、Cookie和Session区别。" class="headerlink" title="6、Cookie和Session区别。"></a><strong>6、Cookie和Session区别。</strong></h4><p>​    Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p>
<p>​            Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>​            cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。</p>
<p>​            Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态</p>
<h3 id="浏览器输入URL过程"><a href="#浏览器输入URL过程" class="headerlink" title="浏览器输入URL过程"></a><strong>浏览器输入URL过程</strong></h3><p>​    <strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p>
<table>
<thead>
<tr>
<th>过程</th>
<th>使用的协议</th>
</tr>
</thead>
<tbody><tr>
<td>1、浏览器查找域名DNS的IP地址<br />DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td>
<td>DNS：获取域名对应的ip</td>
</tr>
<tr>
<td>2、根据ip建立TCP连接</td>
<td>TCP：与服务器建立连接</td>
</tr>
<tr>
<td>3、浏览器向服务器发送HTTP请求</td>
<td>HTTP：发送请求</td>
</tr>
<tr>
<td>4、服务器响应HTTP响应</td>
<td>HTTP</td>
</tr>
<tr>
<td>5、浏览器进行渲染</td>
<td></td>
</tr>
</tbody></table>
<div style="page-break-after: always;"></div>

<h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a><strong>操作系统基础</strong></h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h3><p>​        <strong>进程：</strong>是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器</p>
<p>​        <strong>线程：</strong>是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题</p>
<p>​        <strong>协程：</strong>是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p>
<h4 id="1、进程间通信方式IPC"><a href="#1、进程间通信方式IPC" class="headerlink" title="1、进程间通信方式IPC"></a><strong>1、进程间通信方式IPC</strong></h4><p><strong>管道pipe：</strong></p>
<p>​        亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信；</p>
<p><strong>信号：</strong></p>
<p>​        信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。</p>
<p><strong>消息队列：</strong></p>
<p>​        消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。</p>
<p><strong>共享内存(share memory)：</strong></p>
<ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<p><strong>信号量(Semaphores) ：</strong></p>
<p>​        信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p>
<p><strong>套接字(Sockets) :</strong> </p>
<p>​        简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p>
<h4 id="2、用户态和核心态"><a href="#2、用户态和核心态" class="headerlink" title="2、用户态和核心态"></a><strong>2、用户态和核心态</strong></h4><p><strong>用户态：</strong>只能受限的访问内存，运行所有的应用程序</p>
<p><strong>核心态：</strong>运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备</p>
<p><strong>为什么要有用户态和内核态：</strong></p>
<p>​        由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络</p>
<p><strong>用户态切换到内核态的3种方式：</strong></p>
<p>​    <strong>a. 系统调用</strong></p>
<p>​        主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>​    <strong>b. 异常</strong></p>
<p>​        当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。</p>
<p>​    <strong>c. 外围设备的中断</strong></p>
<p>​        当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会由用户态到内核态的切换。</p>
<h4 id="3、操作系统的进程空间"><a href="#3、操作系统的进程空间" class="headerlink" title="3、操作系统的进程空间"></a><strong>3、操作系统的进程空间</strong></h4><p>​    栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</p>
<p>​    堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。</p>
<p>​    静态区（static）—存放全局变量和静态变量的存储</p>
<p>​    代码区(text)—存放函数体的二进制代码。</p>
<p>​    <strong>线程共享堆区、静态区</strong></p>
<h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p><strong>存管理方式：</strong>页式管理、段式管理、段页式管理</p>
<p><strong>分段管理：</strong></p>
<p>​        将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>
<p><strong>分页管理：</strong></p>
<p>​        在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）</p>
<p><strong>段页式管理：</strong></p>
<p>​        段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的</p>
<h4 id="1、页面置换算法FIFO、LRU"><a href="#1、页面置换算法FIFO、LRU" class="headerlink" title="1、页面置换算法FIFO、LRU"></a><strong>1、页面置换算法FIFO、LRU</strong></h4><p><strong>置换算法：</strong>先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT</p>
<p><strong>先进先出FIFO:</strong></p>
<p>​        缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少</p>
<p><strong>最近最久未使用LRU:</strong></p>
<p>​        原理：选择最近且最久未使用的页面进行淘汰</p>
<p>​        优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多</p>
<p>​        缺点：没有合适的算法，只有适合的算法，lFU、random都可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-17 10:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;   <span class="comment">//容量大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *初始化构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//缓存中不存在此key，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        cache.remove(key);   <span class="comment">//先从链表中删除</span></span><br><span class="line">        cache.put(key,res);  <span class="comment">//再把该节点放到链表末尾处</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(key); <span class="comment">//已经存在，在当前链表移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">//cache已满，删除链表头位置</span></span><br><span class="line">            Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">            cache.remove(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key,value);  <span class="comment">//插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-17 10:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *初始化构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Integer, Integer&gt;(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;  <span class="comment">// 容量大于capacity 时就删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//返回key对应的value值，若不存在，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳置换算法OPT:</strong></p>
<p>​        原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰</p>
<p>​        优点：具有较好的性能，可以保证获得最低的缺页率</p>
<p>​        缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）</p>
<h4 id="2、死锁条件、解决方式。"><a href="#2、死锁条件、解决方式。" class="headerlink" title="2、死锁条件、解决方式。"></a><strong>2、死锁条件、解决方式。</strong></h4><p>​    死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象；</p>
<p>​    <strong>死锁的条件：</strong></p>
<p>​        互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；</p>
<p>​        请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源</p>
<p>​        非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p>
<p>​        循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p>
<p>​    <strong>解决方法：</strong>破坏死锁的任意一条件</p>
<p>​        乐观锁，破坏资源互斥条件，<strong>CAS</strong></p>
<p>​        资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></p>
<p>​        可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></p>
<p>​        资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong></p>
<div style="page-break-after: always;"></div>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><strong>Java基础</strong></h2><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>特性：</strong>封装、继承、多态</p>
<p>​    <strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；</p>
<p>​    <strong>继承</strong>：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；</p>
<p>​    <strong>多态：</strong>通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）</p>
<h4 id="1、Java与C-区别"><a href="#1、Java与C-区别" class="headerlink" title="1、Java与C++区别"></a><strong>1、Java与C++区别</strong></h4><p>​    不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p>
<h4 id="2、多态实现原理"><a href="#2、多态实现原理" class="headerlink" title="2、多态实现原理"></a><strong>2、多态实现原理</strong></h4><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p>
<p><strong>静态绑定与动态绑定：</strong></p>
<p>​    一种是在编译期确定，被称为静态分派，比如方法的重载；</p>
<p>​    一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。</p>
<p><strong>多态的实现</strong></p>
<p>​        虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p>
<h4 id="3、static和final关键字"><a href="#3、static和final关键字" class="headerlink" title="3、static和final关键字"></a>3、static和final关键字</h4><p><strong>static：</strong>可以修饰属性、方法</p>
<p>​    <strong>static修饰属性：</strong></p>
<p>​        类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p>
<p>​    <strong>static修饰方法：</strong></p>
<p>​        随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this；</p>
<p><strong>final：</strong>关键字主要⽤在三个地⽅：变量、⽅法、类。</p>
<p>​    <strong>final修饰变量：</strong></p>
<p>​        如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；</p>
<p>​        如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p>
<p>​    <strong>final修饰方法：</strong></p>
<p>​        把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p>
<p>​    <strong>final修饰类：</strong></p>
<p>​         final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p>
<p>一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效）</p>
<h4 id="4、抽象类和接口"><a href="#4、抽象类和接口" class="headerlink" title="4、抽象类和接口"></a>4、抽象类和接口</h4><p><strong>抽象类：</strong>包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化，</p>
<p><strong>接口：</strong>接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法</p>
<p><strong>相同点：</strong></p>
<p>​    ① 抽象类和接口都不能被实例化</p>
<p>​    ② 抽象类和接口都可以定义抽象方法，子类&#x2F;实现类必须覆写这些抽象方法</p>
<p><strong>不同点：</strong></p>
<p>​    ① 抽象类有构造方法，接口没有构造方法</p>
<p>​    ③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p>
<p>​    ③ 抽象类只能单继承，接口可以多继承</p>
<p>​    ④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p>
<p><strong>抽象类的使用场景：</strong></p>
<p>​    既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p>
<p><strong>接口的应用场景：</strong></p>
<p>​    约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系</p>
<h4 id="5、泛型以及泛型擦除"><a href="#5、泛型以及泛型擦除" class="headerlink" title="5、泛型以及泛型擦除"></a>5、泛型以及泛型擦除</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baoyinwang/article/details/107341997">https://blog.csdn.net/baoyinwang/article/details/107341997</a></p>
<p><strong>泛型：</strong></p>
<p>​        泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p>
<p><strong>泛型擦除：</strong></p>
<p>​        Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。</p>
<p>​        如List<String>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</p>
<p>可以通过反射添加其它类型元素</p>
<h4 id="6、反射原理以及使用场景"><a href="#6、反射原理以及使用场景" class="headerlink" title="6、反射原理以及使用场景"></a><strong>6、反射原理以及使用场景</strong></h4><p><strong>Java反射：</strong></p>
<p>​        是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p>
<p><strong>反射原理：</strong></p>
<p>​        反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p>
<p>​    <strong>如何得到Class的实例:</strong></p>
<pre><code>     1.类名.class(就是一份字节码)
     2.Class.forName(String className);根据一个类的全限定名来构建Class对象
     3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型
</code></pre>
<p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>开发通用框架 -</strong> 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。</p>
</li>
<li><p><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</p>
<p>JDK：spring默认动态代理，需要实现接口</p>
<p>CGLIB：通过asm框架序列化字节流，可配置，性能差</p>
</li>
<li><p><strong>自定义注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。</p>
</li>
</ul>
<h4 id="7、Java异常体系"><a href="#7、Java异常体系" class="headerlink" title="7、Java异常体系"></a><strong>7、Java异常体系</strong></h4><p>​                <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3137389296,1222888772&fm=26&gp=0.jpg" style="zoom:67%;" /></p>
<p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p>
<p><strong>Error ：</strong></p>
<p>​        是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p>
<p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p>
<p>编程错误可以分成三类：语法错误、逻辑错误和运行错误。</p>
<p><strong>语法错误</strong>（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误</p>
<p><strong>逻辑错误</strong>指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因</p>
<p><strong>运行错误</strong>是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误</p>
<p><strong>RuntimeException：</strong> 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>​     如 NullPointerException 、 ClassCastException ； </p>
<p><strong>CheckedException：</strong>受检异常，程序使用trycatch进行捕捉处理</p>
<p>​        如IOException、SQLException、NotFoundException；</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goe17hajvzj316d0lhju3.jpg" alt="JavaCollection"></p>
<h4 id="1、ArrayList和LinkedList"><a href="#1、ArrayList和LinkedList" class="headerlink" title="1、ArrayList和LinkedList"></a><strong>1、ArrayList和LinkedList</strong></h4><p><strong>ArrayList：</strong></p>
<p>​        底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上）<br>​        默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</p>
<p><strong>LinkedList：</strong></p>
<p>​        底层基于双向链表实现，适合数据的动态插入和删除；<br>​        内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如jdk官方推荐使用基于linkedList的Deque进行堆栈操作）</p>
<p><strong>ArrayList与LinkedList区别：</strong></p>
<p>​        都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景</p>
<p><strong>实现线程安全：</strong></p>
<p>​        可以使用原生的Vector，或者是Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList集合。<br>​        建议使用concurrent并发包下的<strong>CopyOnWriteArrayList</strong>的。</p>
<p>​            ①<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p>
<p>​            ②<strong>CopyOnWriteArrayList：</strong>写时加锁，使用了一种叫<strong>写时复制</strong>的方法；读操作是可以不用加锁的</p>
<p>​            </p>
<h4 id="2、List遍历快速和安全失败"><a href="#2、List遍历快速和安全失败" class="headerlink" title="2、List遍历快速和安全失败"></a><strong>2、List遍历快速和安全失败</strong></h4><p><strong>①普通for循环遍历List删除指定元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(list.get(i) == <span class="number">5</span>) </span><br><span class="line">       list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② 迭代遍历,用list.remove(i)方法删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">5</span>)&#123;</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>③foreach遍历List删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>) list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fail—fast：</strong>快速失败</p>
<p>​        当异常产生时，直接抛出异常，程序终止;</p>
<p>​        fail-fast主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p>
<p><strong>fail—safe：</strong>安全失败</p>
<p>    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<p>    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h4 id="3、详细介绍HashMap"><a href="#3、详细介绍HashMap" class="headerlink" title="3、详细介绍HashMap"></a><strong>3、详细介绍HashMap</strong></h4><p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9fe4cb316c05">https://www.jianshu.com/p/9fe4cb316c05</a></p>
<p><strong>数据结构：</strong></p>
<p>​        HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p>
<p><strong>扩容情况：</strong></p>
<p>​        默认的负载因子是0.75，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p>
<p>​        【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p>
<p>​        【2】1.7采用Entry的重新hash运算，1.8采用高于与运算。</p>
<p><strong>put操作步骤：</strong></p>
<p>​                <img src="https://s0.lgstatic.com/i/image3/M01/73/D9/CgpOIF5rDYmATP43AAB3coc0R64799.png" alt="img" style="zoom:67%;" /></p>
<p>​    1、判断数组是否为空，为空进行初始化;</p>
<p>​    2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p>
<p>​    3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p>
<p>​    4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p>
<p>​    5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p>
<p>​    6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p>
<p>​    7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p>
<p><strong>哈希函数：</strong></p>
<p>​     通过hash函数（优质因子31循环累加）先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞，通过尾插法进行插入。</p>
<p><strong>容量为什么始终都是2^N：</strong></p>
<p>​        先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“  (n - 1) &amp; hash ”。（n代表数组⻓度）。方便数组的扩容和增删改时的取模。</p>
<p><strong>JDK1.7与1.8的区别：</strong></p>
<p><strong>JDK1.7 HashMap：</strong></p>
<p>​        底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致cpu100%</p>
<p><strong>JDK1.8 HashMap：</strong>    </p>
<p>​        底层数据结构上采用了<strong>数组＋链表＋红黑树</strong>；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64时，链表将转化为红⿊树，以减少搜索时间。（解决了tomcat臭名昭著的url参数dos攻击问题）</p>
<h4 id="4、ConcurrentHashMap"><a href="#4、ConcurrentHashMap" class="headerlink" title="**4、ConcurrentHashMap **"></a>**4、ConcurrentHashMap **</h4><p>​        可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p>
<p><strong>ConcurrentHashMap的底层实现：</strong></p>
<p>​        <strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment默认16个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1035283471,1167301443&fm=26&gp=0.jpg"></p>
<p>​        <strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表&#x2F;红⿊树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p>
<h4 id="5、序列化和反序列化"><a href="#5、序列化和反序列化" class="headerlink" title="5、序列化和反序列化"></a><strong>5、序列化和反序列化</strong></h4><p>​        序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p>
<p><strong>序列化：</strong>将java对象转化为字节序列的过程。</p>
<p><strong>反序列化：</strong>将字节序列转化为java对象的过程。 </p>
<p><strong>优点：</strong></p>
<p>​    a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p>
<p>​    b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p>
<p><strong>反序列化失败的场景：</strong></p>
<p>​        序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p>
<h4 id="6、String"><a href="#6、String" class="headerlink" title="6、String"></a><strong>6、String</strong></h4><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong></p>
<p>StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder</p>
<h3 id="设计模式与原则"><a href="#设计模式与原则" class="headerlink" title="设计模式与原则"></a>设计模式与原则</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p>​    某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存里的单例池。</p>
<p><strong>优点</strong>：</p>
<p>​    <strong>唯一访问</strong>：如生成唯一序列化的场景、或者spring默认的bean类型。</p>
<p>​    <strong>提高性能</strong>：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。</p>
<p><strong>缺点</strong>：</p>
<p>​    不适合有状态且需变更的</p>
<p><strong>实现方式</strong>：</p>
<p>​    <strong>饿汉式</strong>：线程安全速度快</p>
<p>​    <strong>懒汉式</strong>：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成</p>
<p><strong>为什么要 double-check？</strong></p>
<p>我们先来看第二次的 check，这时你需要考虑这样一种情况，有两个线程同时调用 getInstance 方法，由于 singleton 是空的 ，因此两个线程都可以通过第一重的 if 判断；然后由于锁机制的存在，会有一个线程先进入同步语句，并进入第二重 if 判断 ，而另外的一个线程就会在外面等待。</p>
<p>不过，当第一个线程执行完 new Singleton() 语句后，就会退出 synchronized 保护的区域，这时如果没有第二重 if (singleton &#x3D;&#x3D; null) 判断的话，那么第二个线程也会创建一个实例，此时就破坏了单例，这肯定是不行的。</p>
<p>而对于第一个 check 而言，如果去掉它，那么所有线程都会串行执行，效率低下，所以两个 check 都是需要保留的。</p>
<p><strong>在双重检查锁模式中为什么需要使用 volatile 关键字?</strong></p>
<p>在java内存模型中，volatile 关键字作用可以是保证可见性或者禁止指令重排。这里是因为 singleton &#x3D; new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：</p>
<ul>
<li>第一步是给 singleton 分配内存空间；</li>
<li>第二步开始调用 Singleton 的构造函数等，来初始化 singleton；</li>
<li>第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。</li>
</ul>
<p>这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。</p>
<p>如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，详细流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/EKNSfp_20210917165416.png"></p>
<p>线程 1 首先执行新建实例的第一步，也就是分配单例对象的内存空间，由于线程 1 被重排序，所以执行了新建实例的第三步，也就是把 singleton 指向之前分配出来的内存地址，在这第三步执行之后，singleton 对象便不再是 null。</p>
<p>这时线程 2 进入 getInstance 方法，判断 singleton 对象不是 null，紧接着线程 2 就返回 singleton 对象并使用，由于没有初始化，所以报错了。最后，线程 1 “姗姗来迟”，才开始执行新建实例的第二步——初始化对象，可是这时的初始化已经晚了，因为前面已经报错了。</p>
<p>使用了 volatile 之后，相当于是表明了该字段的更新可能是在其他线程中发生的，因此应确保在读取另一个线程写入的值时，可以顺利执行接下来所需的操作。在 JDK 5 以及后续版本所使用的 JMM 中，在使用了 volatile 后，会一定程度禁止相关语句的重排序，从而避免了上述由于重排序所导致的读取到不完整对象的问题的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>静态内部类</strong>：线程安全利用率高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    <strong>枚举</strong>：effictiveJAVA推荐，反射也无法破坏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">SingletonEnum</span><span class="params">()</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h4><p>​    定义一个用于创建产品的接口，由子类决定生产何种产品。</p>
<p><strong>优点：</strong>解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。</p>
<p><strong>缺点：</strong>每增加一个产品就得新增一个产品类</p>
<h4 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h4><p>​    提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。</p>
<p><strong>优点：</strong>可以在类的内部对产品族进行约束</p>
<p><strong>缺点</strong>：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。</p>
<h4 id="4、设计模式中工厂方法与抽象工厂之间的区别联系"><a href="#4、设计模式中工厂方法与抽象工厂之间的区别联系" class="headerlink" title="4、设计模式中工厂方法与抽象工厂之间的区别联系"></a>4、设计模式中工厂方法与抽象工厂之间的区别联系</h4><p>首先来看看两者的定义区别：</p>
<ul>
<li>工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类</li>
<li>抽象工厂模式 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类</li>
</ul>
<p>个人觉得这个区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。 再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。</p>
<p>再来看看工厂方法模式与抽象工厂模式对比：</p>
<table>
<thead>
<tr>
<th>工厂方法模式</th>
<th>抽象工厂模式</th>
</tr>
</thead>
<tbody><tr>
<td>针对的是单个产品等级结构</td>
<td>针对的是面向多个产品等级结构</td>
</tr>
<tr>
<td>一个抽象产品类</td>
<td>多个抽象产品类</td>
</tr>
<tr>
<td>可以派生出多个具体产品类</td>
<td>每个抽象产品类可以派生出多个具体产品类</td>
</tr>
<tr>
<td>一个抽象工厂类，可以派生出多个具体工厂类</td>
<td>一个抽象工厂类，可以派生出多个具体工厂类</td>
</tr>
<tr>
<td>每个具体工厂类只能创建一个具体产品类的实例</td>
<td>每个具体工厂类可以创建多个具体产品类的实例</td>
</tr>
</tbody></table>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。</p>
<p>构造方法没有返回值，构造方法的作用是创建新对象。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。</p>
<p>静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。</p>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>关键字 <code>this</code> 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象</p>
<p>关键字 <code>this</code> 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用</p>
<h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h3><p>重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。</p>
<p>重写指在子类中的方法的名称和签名都和父类相同，使用override注解</p>
<h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><p><strong>toString</strong>     默认是个指针，一般需要重写</p>
<p><strong>equals</strong>        比较对象是否相同，默认和&#x3D;&#x3D;功能一致</p>
<p><strong>hashCode</strong>  散列码，equals则hashCode相同，所以重写equals必须重写hashCode</p>
<p>**finalize   **    用于垃圾回收之前做的遗嘱，默认空，子类需重写</p>
<p><strong>clone</strong>           深拷贝，类需实现cloneable的接口</p>
<p><strong>getClass</strong>     反射获取对象元数据，包括类名、方法、</p>
<p><strong>notify、wait</strong>   用于线程通知和唤醒</p>
<h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg" alt="image-20210309224910999"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte,Short,Integer,Long</td>
<td>[-128, 127]</td>
</tr>
<tr>
<td>Character</td>
<td>[0, 127]</td>
</tr>
<tr>
<td>Boolean</td>
<td>[false, true]</td>
</tr>
</tbody></table>
<h1 id="二、JVM篇"><a href="#二、JVM篇" class="headerlink" title="二、JVM篇"></a>二、JVM篇</h1><h3 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a><strong>JVM内存划分</strong></h3><h4 id="1、JVM运行时数据区域"><a href="#1、JVM运行时数据区域" class="headerlink" title="1、JVM运行时数据区域"></a><strong>1、JVM运行时数据区域</strong></h4><p>​        堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobgnw8m8uj30l10bejs4.jpg" alt="xxx"></p>
<p><strong>Heap(堆)：</strong></p>
<p>​        对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配</p>
<p>​        堆细分：新生代、老年代，对于新生代又分为：<strong>Eden区</strong>和<strong>Surviver1</strong>和<strong>Surviver2</strong>区；</p>
<p><strong>方法区：</strong></p>
<p>​        对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p>
<p>​        当应用中的 Java 类过多时，比如 <strong>Spring 等一些使用动态代理的框架生成了很多类</strong>，如果占用空间超出了我们的设定值，就会发生<strong>元空间溢出</strong></p>
<p><strong>虚拟机栈：</strong></p>
<p>​        虚拟机栈<strong>是线程私有的</strong>，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的<strong>栈帧</strong>，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（<strong>局部变量表</strong>、<strong>操作数栈</strong> 、<strong>动态链接</strong> 、<strong>返回地址</strong>）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</p>
<ul>
<li><p><strong>局部变量表：</strong>局部变量表是一组变量值存储空间，用来存放<strong>方法参数</strong>、方法内部定义的<strong>局部变量</strong>。底层是变量槽（variable slot）<strong>（注意：java分成员变量、局部变量）</strong></p>
</li>
<li><p><strong>操作数栈：</strong>是用来记录一个方法在执行的过程中，<strong>字节码指令向操作数栈中进行入栈和出栈的过程</strong>。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种<strong>字节码指令</strong>往操作数栈中<strong>入栈和出栈</strong>。</p>
</li>
<li><p><strong>动态链接：</strong>因为字节码文件中有很多符号的引用，这些符号引用一部分会在<strong>类加载的解析阶段</strong>或<strong>第一次使用</strong>的时候转化成<strong>直接引用</strong>，这种称为<strong>静态解析</strong>；另一部分会<strong>在运行期间</strong>转化为直接引用，称为<strong>动态链接</strong>。</p>
</li>
<li><p><strong>返回地址（returnAddress）：</strong>类型（指向了一条字节码指令的地址）</p>
<p><strong>JIT即时编译器（Just In Time Compiler），简称 JIT 编译器</strong>: </p>
<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等</p>
</li>
</ul>
<p><strong>本地方法栈：</strong></p>
<p>​        本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p>
<p><strong>PC程序计数器：</strong></p>
<p>​        PC，指的是存放下一条指令的位置的一个指针。它是一块较小的内存空间，且是<strong>线程私有</strong>的。由于线程的切换，CPU在执行的过程中，需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p>
<h4 id="2、堆内存分配策略"><a href="#2、堆内存分配策略" class="headerlink" title="2、堆内存分配策略"></a><strong>2、堆内存分配策略</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnjl5glvj30l10h9jrt.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Hm2wXK_20210918154730.png"></p>
<ul>
<li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p>
</li>
<li><p>大对象直接进入老年代（<strong>需要大量连续内存空间的对象</strong>）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</li>
<li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p>
<p>（<strong>动态对象年龄判定</strong>：程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代）</p>
</li>
<li><p>每次进行Minor GC或者大对象直接进入老年区时，JVM会计算所需空间大小如小于老年区的剩余值大小，则进行一次<strong>Full GC</strong>。</p>
</li>
</ul>
<h4 id="3、创建一个对象的步骤"><a href="#3、创建一个对象的步骤" class="headerlink" title="3、创建一个对象的步骤"></a><strong>3、创建一个对象的步骤</strong></h4><p><strong>步骤：类加载检查、分配内存、初始化对象（包括：初始化零值、设置对象头、执行init方法）、将创建的对象指向分配的内存</strong></p>
<p><strong>①类加载检查：</strong> </p>
<p>​        虚拟机遇到 new 指令时，⾸先去检查是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p>
<p><strong>②分配内存：</strong></p>
<p>​         在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存，分配⽅式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。</p>
<p><strong>③初始化对象</strong></p>
<ul>
<li><strong>初始化零值：</strong></li>
</ul>
<p>​         内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。</p>
<ul>
<li><strong>设置对象头：</strong></li>
</ul>
<p>​        初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p>
<ul>
<li><strong>执⾏ init ⽅法：</strong></li>
</ul>
<p>​        从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说（除循环依赖），执⾏ new 指令之后会接着执⾏  <init> ⽅法，这样⼀个真正可⽤的对象才算产⽣出来。</p>
<p><strong>④将创建的对象指向分配的内存</strong></p>
<h4 id="4、对象引用"><a href="#4、对象引用" class="headerlink" title="4、对象引用"></a>4、<strong>对象引用</strong></h4><p>普通的对象引用关系就是<strong>强引用</strong>。</p>
<p><strong>软引用</strong>用于维护一些可有可无的对象。只有在<strong>内存不足时，系统则会回收软引用对象</strong>，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p>
<p><strong>弱引用</strong>对象相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，<strong>无论内存是否充足</strong>，都会回收被弱引用关联的对象。</p>
<p><strong>虚引用</strong>是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来<strong>跟踪对象被垃圾回收</strong>的活动。</p>
<div style="page-break-after: always;"></div>

<h3 id="JVM类加载过程"><a href="#JVM类加载过程" class="headerlink" title="JVM类加载过程"></a><strong>JVM类加载过程</strong></h3><p><strong>过程：加载、验证、准备、解析、初始化</strong></p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnnbem87j30eq0cogmj.jpg" alt="img" style="zoom:50%;" />

<p><strong>加载阶段：</strong></p>
<p>​        1.通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>​        2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>​        3.在Java堆中生成一个代表这个类的java.lang.class对象，作为访问方法区这些数据的入口。</p>
<p><strong>验证阶段：</strong></p>
<p>​        1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理）</p>
<p>​        2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求）</p>
<p>​        3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）</p>
<p>​        4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生）</p>
<p><strong>准备阶段：</strong></p>
<p>​        准备阶段是正式为类变量（成员变量）分配内存并设置类变量初始值的阶段。将对象初始化为“零”值。</p>
<p>这一步只会给那些静态变量设置一个初始的值，而那些实例变量是在实例化对象时进行分配的。</p>
<p><strong>解析阶段：</strong></p>
<p>​        解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>​        <strong>字符串常量池</strong>：堆上，默认class文件的静态常量池</p>
<p>​        <strong>运行时常量池</strong>：在方法区，属于元空间</p>
<p><strong>初始化阶段：</strong></p>
<p>​        初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。</p>
<h4 id="1、双亲委派机制"><a href="#1、双亲委派机制" class="headerlink" title="1、双亲委派机制"></a><strong>1、双亲委派机制</strong></h4><p>​        每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的  loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器  BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器  BootstrapClassLoader 作为⽗类加载器。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobn5lh4f6j30hk08rjso.jpg" alt="img"></p>
<p><strong>使用好处：</strong></p>
<p>​        此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为  java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。</p>
<p><strong>破坏双亲委派机制：</strong></p>
<ul>
<li><p>可以⾃⼰定义⼀个类加载器，重写loadClass方法；</p>
</li>
<li><p>Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；</p>
</li>
<li><p>Java 的 SPI，发起者 BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。</p>
</li>
</ul>
<h4 id="2、tomcat的类加载机制"><a href="#2、tomcat的类加载机制" class="headerlink" title="2、tomcat的类加载机制"></a><strong>2、tomcat的类加载机制</strong></h4><p><strong>步骤：</strong></p>
<ol>
<li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li>
<li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li>
<li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li>
<li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li>
<li>加载依然失败，才使用 AppClassLoader 继续加载。</li>
<li>都没有加载成功的话，抛出异常。</li>
</ol>
<p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p>
<div style="page-break-after: always;"></div>

<h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="1、存活算法和两次标记过程"><a href="#1、存活算法和两次标记过程" class="headerlink" title="1、存活算法和两次标记过程"></a><strong>1、存活算法和两次标记过程</strong></h4><p><strong>引用计数法：</strong></p>
<p>​        给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>​    优点：实现简单，判定效率也很高</p>
<p>​    缺点：他很难解决对象之间相互循环引用的问题，基本上被抛弃</p>
<p><strong>可达性分析法：</strong></p>
<p>​        通过一系列的成为“GC Roots”(活动线程相关的各种引用，虚拟机<strong>栈帧引用</strong>，<strong>静态变量引用</strong>，<strong>JNI引用</strong>)的对象作为起始点，从这些节点ReferenceChains开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的；</p>
<p><strong>两次标记过程：</strong></p>
<p>​        对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p>
<h4 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a><strong>2、垃圾回收算法</strong></h4><p><strong>垃圾回收算法</strong>：复制算法、标记清除、标记整理、分代收集</p>
<p><strong>复制算法：(young)</strong></p>
<p>​        将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p>
<p>​        优点：实现简单，内存效率高，不易产生碎片</p>
<p>​        缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低</p>
<p><strong>标记清除：(cms)</strong></p>
<p>​        标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p>
<p>​        缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，需要预留空间给分配阶段的浮动垃圾</p>
<p><strong>标记整理：(old)</strong></p>
<p>​        标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题</p>
<p><strong>分代收集：</strong></p>
<p>​        根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>​        新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p>
<p>​        老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p>
<p><strong>Safepoint</strong> 当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnmip32vj30l109q0t3.jpg" alt="img"></p>
<h5 id="MinorGC、MajorGC、FullGC"><a href="#MinorGC、MajorGC、FullGC" class="headerlink" title="MinorGC、MajorGC、FullGC"></a><strong>MinorGC、MajorGC、FullGC</strong></h5><p><strong>MinorGC</strong> 在年轻代空间不足的时候发生，</p>
<p><strong>MajorGC</strong> 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。</p>
<p><strong>FullGC</strong> 1、当老年代无法再分配内存的时候；2、元空间不足的时候；3、显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。</p>
<p><strong>对象优先在 Eden 区分配</strong><br>    大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<p><strong>大对象直接进入老年代</strong><br>    大对象是指需要连续内存空间的对象，比如很长的字符串以及数组。老年代直接分配的<strong>目的是</strong>避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p>
<p><strong>长期存活的对象进入老年代</strong><br>    虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过一次 Minor GC 之后，将进入 Survivor 区，同时对象年龄变为 1，增加到一定阈值时则进入老年代（阈值默认为 15）</p>
<p><strong>动态对象年龄判定</strong><br>    为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p>
<p><strong>空间分配担保</strong><br>    在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立则进行 Full GC。</p>
<h4 id="3、垃圾收集器"><a href="#3、垃圾收集器" class="headerlink" title="3、垃圾收集器"></a><strong>3、垃圾收集器</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnjx3zcej30l10ctaat.jpg" alt="img"></p>
<p>​    <strong>JDK3：Serial Parnew 关注效率</strong></p>
<p><strong>Serial：</strong></p>
<p>​        Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。适合用于客户端垃圾收集器。</p>
<p><strong>Parnew：</strong></p>
<p>​        ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p>
<p>​    <strong>JDK5：parallel Scavenge+（Serial old&#x2F;parallel old）关注吞吐量</strong></p>
<p><strong>parallel Scavenge：</strong>(关注吞吐量)</p>
<p>​        Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p>
<p><strong>Serial old：</strong></p>
<p>Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途：</p>
<ul>
<li><p>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</p>
</li>
<li><p>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</p>
</li>
</ul>
<p><strong>parallel old：</strong></p>
<p>​        Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。</p>
<p><strong>JDK8-CMS：（关注最短垃圾回收停顿时间）</strong></p>
<p>​        CMS收集器是一种年老代垃圾收集器，其最主要目标是获取<strong>最短垃圾回收停顿时间</strong>，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p>
<p>​        <strong>初始标记：</strong>只是标记一下 GC Roots 能直接关联的对象，速度很快，STW。</p>
<p>​        <strong>并发标记：</strong>进行 ReferenceChains跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p>
<p>​        <strong>重新标记：</strong>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，STW。</p>
<p>​        <strong>并发清除：</strong>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。</p>
<p>​        由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p>
<p>​        <strong>优点：</strong>并发收集、低停顿</p>
<p>​        <strong>缺点：</strong>对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。</p>
<p><strong>JDK9-G1：（精准控制停顿时间，避免垃圾碎片）</strong></p>
<p>​        是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p>
<p>​        【1】基于标记-整理算法，不产生内存碎片。</p>
<p>​        【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p>
<p>​        G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p>
<ul>
<li><p><strong>初始标记</strong>：<strong>Stop The World，</strong>仅使用一条初始标记线程对GC Roots关联的对象进行标记</p>
</li>
<li><p><strong>并发标记</strong>：使用一条标记线程与用户线程并发执行。此过程进行<strong>可达性分析，速度很慢</strong></p>
</li>
<li><p><strong>最终标记</strong>：<strong>Stop The World</strong>，使用多条标记线程并发执行</p>
</li>
<li><p><strong>筛选回收</strong>：回收废弃对象，此时也要 <strong>Stop The World</strong>，并使用多条筛选回收线程并发执行</p>
</li>
</ul>
<p>**JDK11-ZGC:**（在不关注容量的情况获取最小停顿时间5TB&#x2F;10ms）</p>
<p>​    着色笔技术：加快标记过程</p>
<p>​    读屏障：解决GC和应用之间并发导致的STW问题</p>
<ul>
<li><p>支持 TB 级堆内存（最大 4T， JDK13 最大16TB）</p>
</li>
<li><p>最大 GC 停顿 10ms</p>
</li>
<li><p>对吞吐量影响最大，不超过 15%</p>
</li>
</ul>
<h4 id="4、配置垃圾收集器"><a href="#4、配置垃圾收集器" class="headerlink" title="4、配置垃圾收集器"></a><strong>4、配置垃圾收集器</strong></h4><ul>
<li>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。</li>
<li>通常，堆空间我会设置成操作系统的 2&#x2F;3，超过 8GB 的堆，优先选用 G1</li>
<li>然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例</li>
<li>依据系统容量、访问延迟、吞吐量等进行专项优化，我们的服务是高并发的，对 STW 的时间敏感</li>
<li>我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，定位问题</li>
</ul>
<h4 id="4、JVM性能调优"><a href="#4、JVM性能调优" class="headerlink" title="4、JVM性能调优"></a><strong>4、JVM性能调优</strong></h4><p>对应进程的JVM状态以定位问题和解决问题并作出相应的优化</p>
<p><strong>常用命令：</strong>jps、jinfo、jstat、jstack、jmap</p>
<p><strong>jps：查看java进程及相关信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps -l 输出jar包路径，类全名</span><br><span class="line">jps -m 输出main参数</span><br><span class="line">jps -v 输出JVM参数</span><br></pre></td></tr></table></figure>

<p><strong>jinfo：查看JVM参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo <span class="number">11666</span></span><br><span class="line">jinfo -flags <span class="number">11666</span></span><br><span class="line">Xmx、Xms、Xmn、MetaspaceSize</span><br></pre></td></tr></table></figure>

<p><strong>jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br><span class="line">其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）</span><br><span class="line">  </span><br><span class="line">option参数解释：</span><br><span class="line">-gc 垃圾回收堆的行为统计</span><br><span class="line">-gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计</span><br><span class="line">-gcutil 垃圾回收统计概述</span><br><span class="line">-gcnew 新生代行为统计</span><br><span class="line">-gcold 年老代和永生代行为统计</span><br></pre></td></tr></table></figure>

<p><strong>jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstack [-l] &lt;pid&gt; (连接运行中的进程)</span><br><span class="line">  </span><br><span class="line">option参数解释：</span><br><span class="line">-F 当使用jstack &lt;pid&gt;无响应时，强制输出线程堆栈。</span><br><span class="line">-m 同时输出java和本地堆栈(混合模式)</span><br><span class="line">-l 额外显示锁信息</span><br></pre></td></tr></table></figure>

<p><strong>jmap：可以用来查看内存信息</strong>(配合jhat使用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt; (连接正在执行的进程)</span><br><span class="line"></span><br><span class="line">option参数解释：</span><br><span class="line">-heap 打印java heap摘要</span><br><span class="line">-dump:&lt;dump-options&gt; 生成java堆的dump文件</span><br></pre></td></tr></table></figure>



<h4 id="5、JDK新特性"><a href="#5、JDK新特性" class="headerlink" title="5、JDK新特性"></a>5、JDK新特性</h4><p>JDK8</p>
<p>支持 Lamda 表达式、集合的 stream 操作、提升HashMap性能</p>
<p><strong>JDK9</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream API中iterate方法的新重载方法，可以指定什么时候结束迭代</span></span><br><span class="line">IntStream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>默认G1垃圾回收器</p>
<p><strong>JDK10</strong> </p>
<p>其重点在于通过完全GC并行来改善G1最坏情况的等待时间。</p>
<p><strong>JDK11</strong></p>
<p>ZGC (并发回收的策略) 4TB</p>
<p>用于 Lambda 参数的局部变量语法</p>
<p><strong>JDK12</strong></p>
<p>Shenandoah GC (GC 算法)停顿时间和堆的大小没有任何关系，并行关注停顿响应时间。</p>
<p><strong>JDK13</strong></p>
<p>增加ZGC以将未使用的堆内存返回给操作系统，16TB</p>
<p><strong>JDK14</strong></p>
<p>删除cms垃圾回收器、弃用ParallelScavenge+SerialOldGC垃圾回收算法组合</p>
<p>将ZGC垃圾回收器应用到macOS和windows平台</p>
<div style="page-break-after: always;"></div>

<h3 id="线上故障排查"><a href="#线上故障排查" class="headerlink" title="线上故障排查"></a>线上故障排查</h3><h4 id="1、硬件故障排查"><a href="#1、硬件故障排查" class="headerlink" title="1、硬件故障排查"></a>1、硬件故障排查</h4><p>如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常</p>
<p><strong>第一步是隔离</strong>，第二步是<strong>保留现场</strong>，第三步才是<strong>问题排查</strong>。</p>
<p><strong>隔离</strong></p>
<p>就是把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。</p>
<p><strong>现场保留</strong></p>
<p><strong>瞬时态和历史态</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnwy22d2j30l10cpt9d.jpg" alt="img"></p>
<p>查看比如 CPU、系统内存等，通过历史状态可以体现一个趋势性问题，而这些信息的获取一般依靠监控系统的协作。           </p>
<p><strong>保留信息</strong></p>
<p>（1）<strong>系统当前网络连接</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ss</span> -antp &gt; $DUMP_DIR/ss.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>使用 ss 命令而不是 netstat 的原因，是因为 netstat 在网络连接非常多的情况下，执行非常缓慢。</p>
<p>后续的处理，可通过查看各种网络连接状态的梳理，来排查 TIME_WAIT 或者 CLOSE_WAIT，或者其他连接过高的问题，非常有用。</p>
<p>（2）<strong>网络状态统计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s &gt; $DUMP_DIR/netstat-s.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -n DEV <span class="number">1</span> <span class="number">2</span> &gt; $DUMP_DIR/sar-traffic.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。</p>
<p>（3）<strong>进程资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p $PID &gt; $DUMP_DIR/lsof-$PID.dump</span><br></pre></td></tr></table></figure>


<p>通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。</p>
<p>（4）<strong>CPU 资源</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mpstat</span> &gt; $DUMP_DIR/mpstat.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">vmstat</span> <span class="number">1</span> <span class="number">3</span> &gt; $DUMP_DIR/vmstat.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">sar</span> -p <span class="literal">ALL</span>  &gt; $DUMP_DIR/sar-cpu.dump  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">uptime</span> &gt; $DUMP_DIR/uptime.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>主要用于输出当前系统的 CPU 和负载，便于事后排查。</p>
<p>（5）<strong>I&#x2F;O 资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x &gt; $DUMP_DIR/iostat.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>一般，以计算为主的服务节点，I&#x2F;O 资源会比较正常，但有时也会发生问题，比如<strong>日志输出过多，或者磁盘问题</strong>等。此命令可以输出每块磁盘的基本性能信息，用来排查 I&#x2F;O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。</p>
<p>（6）<strong>内存问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h &gt; $DUMP_DIR/free.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。</p>
<p>（7）<strong>其他全局</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef &gt; $DUMP_DIR/ps.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">dmesg &gt; $DUMP_DIR/dmesg.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">sysctl -a &gt; $DUMP_DIR/sysctl.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。</p>
<p>（8）<strong>进程快照</strong>，最后的遗言（jinfo）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jinfo $PID &gt; $DUMP_DIR/jinfo.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>此命令将输出 Java 的基本进程信息，包括<strong>环境变量和参数配置</strong>，可以查看是否因为一些错误的配置造成了 JVM 问题。</p>
<p><strong>（9）dump 堆信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jstat -gcutil $PID &gt; $DUMP_DIR/jstat-gcutil.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jstat -gccapacity $PID &gt; $DUMP_DIR/jstat-gccapacity.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。</p>
<p><strong>（10）堆信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jmap $PID &gt; $DUMP_DIR/jmap.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -heap $PID &gt; $DUMP_DIR/jmap-heap.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -histo $PID &gt; $DUMP_DIR/jmap-histo.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -dump:format=b,file=$DUMP_DIR/heap.bin $PID &gt; /dev/<span class="literal">null</span>  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。</p>
<p><strong>（11）JVM 执行栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jstack $PID &gt; $DUMP_DIR/jstack.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp $PID -b -n <span class="number">1</span> -c &gt;  $DUMP_DIR/top-$PID.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。</p>
<p><strong>（12）高级替补</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -<span class="number">3</span> $PID</span><br></pre></td></tr></table></figure>


<p>有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcore -o $DUMP_DIR/core $PID</span><br></pre></td></tr></table></figure>


<p>对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jhsdb jmap --exe $&#123;JDK&#125;java  --core $DUMP_DIR/core --binaryheap</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>内存泄漏的现象</strong></li>
</ol>
<p>稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jhsdb jmap  --heap --pid  <span class="number">37340</span></span><br><span class="line">jhsdb jmap  --pid  <span class="number">37288</span></span><br><span class="line">jhsdb jmap  --histo --pid  <span class="number">37340</span></span><br><span class="line">jhsdb jmap  --binaryheap --pid  <span class="number">37340</span></span><br></pre></td></tr></table></figure>

<p>一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。</p>
<h4 id="2、报表异常-JVM调优"><a href="#2、报表异常-JVM调优" class="headerlink" title="2、报表异常 | JVM调优"></a>2、报表异常 | JVM调优</h4><p>有一个报表系统，频繁发生内存溢出，在高峰期间使用时，还会频繁的发生拒绝服务，由于大多数使用者是管理员角色，所以很快就反馈到研发这里。</p>
<p>业务场景是由于有些结果集的字段不是太全，因此需要对结果集合进行循环，并通过 HttpClient 调用其他服务的接口进行数据填充。使用 Guava 做了 JVM 内缓存，但是响应时间依然很长。</p>
<p>初步排查，JVM 的资源太少。接口 A 每次进行报表计算时，都要涉及几百兆的内存，而且在内存里驻留很长时间，有些计算又非常耗 CPU，特别的“吃”资源。而我们分配给 JVM 的内存只有 3 GB，在多人访问这些接口的时候，内存就不够用了，进而发生了 OOM。在这种情况下，没办法，只有升级机器。把机器配置升级到 4C8G，给 JVM 分配 6GB 的内存，这样 OOM 问题就消失了。但随之而来的是频繁的 GC 问题和超长的 GC 时间，平均 GC 时间竟然有 5 秒多。</p>
<p>进一步，由于报表系统和高并发系统不太一样，它的对象，存活时长大得多，并不能仅仅通过增加年轻代来解决；而且，如果增加了年轻代，那么必然减少了老年代的大小，由于 CMS 的碎片和浮动垃圾问题，我们可用的空间就更少了。虽然服务能够满足目前的需求，但还有一些不太确定的风险。</p>
<p>第一，了解到程序中有很多缓存数据和静态统计数据，为了减少 MinorGC 的次数，通过分析 GC 日志打印的对象年龄分布，把 MaxTenuringThreshold 参数调整到了 3（特殊场景特殊的配置）。这个参数是让年轻代的这些对象，赶紧回到老年代去，不要老呆在年轻代里。</p>
<p>第二，我们的 GC 时间比较长，就一块开了参数 CMSScavengeBeforeRemark，使得在 CMS remark 前，先执行一次 Minor GC 将新生代清掉。同时配合上个参数，其效果还是比较好的，一方面，对象很快晋升到了老年代，另一方面，年轻代的对象在这种情况下是有限的，在整个 MajorGC 中占的时间也有限。</p>
<p>第三，由于缓存的使用，有大量的弱引用，拿一次长达 10 秒的 GC 来说。我们发现在 GC 日志里，处理 weak refs 的时间较长，达到了 4.5 秒。这里可以加入参数 ParallelRefProcEnabled 来并行处理Reference，以加快处理速度，缩短耗时。</p>
<p>优化之后，效果不错，但并不是特别明显。经过评估，针对高峰时期的情况进行调研，我们决定再次提升机器性能，改用 8core16g 的机器。但是，这带来另外一个问题。</p>
<p><strong>高性能的机器带来了非常大的服务吞吐量</strong>，通过 jstat 进行监控，能够看到年轻代的分配速率明显提高，但随之而来的 MinorGC 时长却变的不可控，有时候会超过 1 秒。累积的请求造成了更加严重的后果。</p>
<p>这是由于堆空间明显加大造成的回收时间加长。为了获取较小的停顿时间，我们在堆上<strong>改用了 G1 垃圾回收器</strong>，把它的目标设定在 200ms。G1 是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的 GC 暂停目标，就能得到不错的性能。修改之后，虽然 GC 更加频繁了一些，但是停顿时间都比较小，应用的运行较为平滑。</p>
<p>到目前为止，也只是勉强顶住了已有的业务，但是，这时候领导层面又发力，<strong>要求报表系统可以支持未来两年业务10到100倍的增长</strong>，并保持其可用性，但是这个“千疮百孔”的报表系统，稍微一压测，就宕机，那如何应对十倍百倍的压力呢 ? 硬件即使可以做到动态扩容，但是毕竟也有极限。</p>
<p>使用 MAT 分析堆快照，发现很多地方可以通过代码优化，那些占用内存特别多的对象：</p>
<p>1、select * 全量排查，只允许获取必须的数据</p>
<p>2、报表系统中cache实际的命中率并不高，将Guava 的 Cache 引用级别改成弱引用（WeakKeys）</p>
<p>3、限制报表导入文件大小，同时拆分用户超大范围查询导出请求。</p>
<p>每一步操作都使得JVM使用变得更加可用，一系列优化以后，机器相同压测数据性能提升了数倍。</p>
<h4 id="3、大屏异常-JUC调优"><a href="#3、大屏异常-JUC调优" class="headerlink" title="3、大屏异常 | JUC调优"></a>3、大屏异常 | JUC调优</h4><p>有些数据需要使用 HttpClient 来获取进行补全。提供数据的服务提供商有的响应时间可能会很长，也有可能会造成服务整体的阻塞。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobr4whjzwj30l1058dfx.jpg" alt="img"></p>
<p>接口 A 通过 HttpClient 访问服务 2，响应 100ms 后返回；接口 B 访问服务 3，耗时 2 秒。HttpClient 本身是有一个最大连接数限制的，如果服务 3 迟迟不返回，就会造成 HttpClient 的连接数达到上限，<strong>概括来讲，就是同一服务，由于一个耗时非常长的接口，进而引起了整体的服务不可用</strong></p>
<p>这个时候，通过 jstack 打印栈信息，会发现大多数竟然阻塞在了接口 A 上，而不是耗时更长的接口 B，这个现象起初十分具有迷惑性，不过经过分析后，我们猜想其实是因为接口 A 的速度比较快，在问题发生点进入了更多的请求，它们全部都阻塞住的同时被打印出来了。</p>
<p>为了验证这个问题，我搭建了一个demo 工程，模拟了两个使用同一个 HttpClient 的接口。fast 接口用来访问百度，很快就能返回；slow 接口访问谷歌，由于众所周知的原因，会阻塞直到超时，大约 10 s。 利用ab对两个接口进行压测，同时使用 jstack 工具 dump 堆栈。首先使用 jps 命令找到进程号，然后把结果重定向到文件（可以参考 10271.jstack 文件）。</p>
<p>过滤一下 nio 关键字，可以查看 tomcat 相关的线程，足足有 200 个，这和 Spring Boot 默认的 maxThreads 个数不谋而合。更要命的是，有大多数线程，都处于 BLOCKED 状态，说明线程等待资源超时。通过grep fast | wc -l 分析，确实200个中有150个都是blocked的fast的进程。</p>
<p>问题找到了，解决方式就顺利成章了。</p>
<p>1、fast和slow争抢连接资源，通过线程池限流或者熔断处理</p>
<p>2、有时候slow的线程也不是一直slow，所以就得加入监控</p>
<p>3、使用带countdownLaunch对线程的执行顺序逻辑进行控制</p>
<h4 id="4、接口延迟-SWAP调优"><a href="#4、接口延迟-SWAP调优" class="headerlink" title="4、接口延迟 | SWAP调优"></a><strong>4、接口延迟 | SWAP调优</strong></h4><p>有一个关于服务的某个实例，经常发生服务卡顿。由于服务的并发量是比较高的，每多停顿 1 秒钟，几万用户的请求就会感到延迟。</p>
<p>我们统计、类比了此服务其他实例的 CPU、内存、网络、I&#x2F;O 资源，区别并不是很大，所以一度怀疑是机器硬件的问题。</p>
<p>接下来我们对比了节点的 GC 日志，发现无论是 Minor GC，还是 Major GC，这个节点所花费的时间，都比其他实例长得多。</p>
<p>通过仔细观察，我们发现在 GC 发生的时候，vmstat 的 si、so 飙升的非常严重，这和其他实例有着明显的不同。</p>
<p>使用 free 命令再次确认，发现 SWAP 分区，使用的比例非常高，引起的具体原因是什么呢？</p>
<p>更详细的操作系统内存分布，从 &#x2F;proc&#x2F;meminfo 文件中可以看到具体的逻辑内存块大小，有多达 40 项的内存信息，这些信息都可以通过遍历 &#x2F;proc 目录的一些文件获取。我们注意到 slabtop 命令显示的有一些异常，dentry（目录高速缓冲）占用非常高。</p>
<p>问题最终定位到是由于某个运维工程师删除日志时，定时执行了一句命令：</p>
<p>find &#x2F; | grep “xxx.log”</p>
<p>他是想找一个叫做 要被删除 的日志文件，看看在哪台服务器上，结果，这些老服务器由于文件太多，扫描后这些文件信息都缓存到了 slab 区上。而服务器开了 swap，操作系统发现物理内存占满后，并没有立即释放 cache，导致每次 GC 都要和硬盘打一次交道。</p>
<p><strong>解决方式就是关闭 SWAP 分区。</strong></p>
<p>swap 是很多性能场景的万恶之源，建议禁用。在高并发 SWAP 绝对能让你体验到它魔鬼性的一面：进程倒是死不了了，但 GC 时间长的却让人无法忍受。</p>
<h4 id="5、内存溢出-Cache调优"><a href="#5、内存溢出-Cache调优" class="headerlink" title="5、内存溢出 | Cache调优"></a>5、<strong>内存溢出 | Cache调优</strong></h4><blockquote>
<p>有一次线上遇到故障，重新启动后，使用 jstat 命令，发现 Old 区一直在增长。我使用 jmap 命令，导出了一份线上堆栈，然后使用 MAT 进行分析，通过对 GC Roots 的分析，发现了一个非常大的 HashMap 对象，这个原本是其他同事做缓存用的，但是做了一个无界缓存，没有设置超时时间或者 LRU 策略，在使用上又没有重写key类对象的hashcode和equals方法，对象无法取出也直接造成了堆内存占用一直上升，后来，将这个缓存改成 guava 的 Cache，并设置了弱引用，故障就消失了。</p>
<p>关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p>
</blockquote>
<p>内存溢出是一个结果，而<strong>内存泄漏</strong>是一个原因。内存溢出的原因有<strong>内存空间不足、配置错误</strong>等因素。一些错误的编程方式，不再被使用的对象、没有被回收、没有及时切断与 GC Roots 的联系，这就是内存泄漏。</p>
<p>举个例子，有团队使用了 HashMap 做缓存，但是并没有设置超时时间或者 LRU 策略，造成了放入 Map 对象的数据越来越多，而产生了内存泄漏。</p>
<p>再来看一个经常发生的内存泄漏的例子，也是由于 HashMap 产生的。代码如下，由于没有重写 Key 类的 hashCode 和 equals 方法，造成了放入 HashMap 的所有对象都无法被取出来，它们和外界失联了。所以下面的代码结果是 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leak example</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapLeakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        String title;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Key, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;1&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;2&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>即使提供了 equals 方法和 hashCode 方法，也要非常小心，尽量避免使用自定义的对象作为 Key。</p>
<p>再看一个例子，关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p>
<h4 id="6：CPU飙高-死循环"><a href="#6：CPU飙高-死循环" class="headerlink" title="6：CPU飙高 | 死循环"></a>6：CPU飙高 | 死循环</h4><p>我们有个线上应用，单节点在运行一段时间后，CPU 的使用会飙升，一旦飙升，一般怀疑某个业务逻辑的计算量太大，或者是触发了死循环（比如著名的 HashMap 高并发引起的死循环），但排查到最后其实是 GC 的问题。        </p>
<p>（1）使用 top 命令，查找到使用 CPU 最多的某个进程，记录它的 pid。使用 Shift + P 快捷键可以按 CPU 的使用率进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>


<p>（2）再次使用 top 命令，加 -H 参数，查看某个进程中使用 CPU 最多的某个线程，记录线程的 ID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp $pid</span><br></pre></td></tr></table></figure>


<p>（3）使用 printf 函数，将十进制的 tid 转化成十六进制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf %x $tid</span><br></pre></td></tr></table></figure>


<p>（4）使用 jstack 命令，查看 Java 进程的线程栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack $pid &gt;$pid.log</span><br></pre></td></tr></table></figure>


<p>（5）使用 less 命令查看生成的文件，并查找刚才转化的十六进制 tid，找到发生问题的线程上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less $pid.log</span><br></pre></td></tr></table></figure>


<p>我们在 jstack 日志搜关键字DEAD，以及中找到了 CPU 使用最多的几个线程id。</p>
<p>可以看到问题发生的根源，是我们的堆已经满了，但是又没有发生 OOM，于是 GC 进程就一直在那里回收，回收的效果又非常一般，造成 CPU 升高应用假死。接下来的具体问题排查，就需要把内存 dump 一份下来，使用 MAT 等工具分析具体原因了。</p>
<h1 id="三、多线程篇"><a href="#三、多线程篇" class="headerlink" title="三、多线程篇"></a>三、多线程篇</h1><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="1、线程状态"><a href="#1、线程状态" class="headerlink" title="1、线程状态"></a><strong>1、线程状态</strong></h4><p>​        线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈</p>
<p><strong>线程状态：创建、就绪、运行、阻塞、死亡</strong></p>
<img src="https://s0.lgstatic.com/i/image3/M01/77/29/Cgq2xl5xxGKAKBpeAAEw9Ifr07Y662.png" alt="img" style="zoom: 40%;" />



<h4 id="2、线程状态切换"><a href="#2、线程状态切换" class="headerlink" title="2、线程状态切换"></a><strong>2、线程状态切换</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>启动线程，由虚拟机自动调度执行run()方法</td>
<td>线程处于就绪状态</td>
</tr>
<tr>
<td>run</td>
<td>线程逻辑代码块处理，JVM调度执行</td>
<td>线程处于运行状态</td>
</tr>
<tr>
<td>sleep</td>
<td>让当前正在执行的线程休眠（暂停执行）</td>
<td>不释放锁</td>
</tr>
<tr>
<td>wait</td>
<td>使得当前线程等待</td>
<td>释放同步锁</td>
</tr>
<tr>
<td>notify</td>
<td>唤醒在此对象监视器上等待的单个线程</td>
<td>唤醒单个线程</td>
</tr>
<tr>
<td>notifyAll</td>
<td>唤醒在此对象监视器上等待的所有线程</td>
<td>唤醒多个线程</td>
</tr>
<tr>
<td>yiled</td>
<td>停止当前线程，让同等优先权的线程运行</td>
<td>用Thread类调用</td>
</tr>
<tr>
<td>join</td>
<td>使当前线程停下来等待，直至另一个调用join方法的线程终止</td>
<td>用线程对象调用</td>
</tr>
</tbody></table>
<img src="https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png" alt="img" style="zoom:67%;" />

<h4 id="3、阻塞唤醒过程"><a href="#3、阻塞唤醒过程" class="headerlink" title="3、阻塞唤醒过程"></a><strong>3、阻塞唤醒过程</strong></h4><p><strong>阻塞：</strong></p>
<p>​        这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生：</p>
<p>　　　　① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程；</p>
<p>　　　　② 其他线程调用了该Object的notifyAll方法；</p>
<p><strong>唤醒：</strong></p>
<p>​        线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。<strong>一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。</strong></p>
<p><strong>为什么要出现在同步代码块中：</strong></p>
<p>​        由于<code>wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait()</code> 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法&#x2F;代码块中调用。</p>
<h4 id="4、wait和sleep区别"><a href="#4、wait和sleep区别" class="headerlink" title="4、wait和sleep区别"></a><strong>4、wait和sleep区别</strong></h4><ul>
<li><p>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</p>
</li>
<li><p>wait 方法会主动释放 monitor 锁，在同步代码中执行 sleep 方法时，并不会释放 monitor 锁。</p>
</li>
<li><p>wait 方法意味着永久等待，直到被中断或被唤醒才能恢复，不会主动恢复，sleep 方法中会定义一个时间，时间到期后会主动恢复。</p>
</li>
<li><p>wait&#x2F;notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</p>
</li>
</ul>
<h4 id="5、创建线程方式"><a href="#5、创建线程方式" class="headerlink" title="5、创建线程方式"></a>5、创建线程方式</h4><p><strong>实现 Runnable 接口</strong>（优先使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;System.out.println(<span class="string">&#x27;用实现Runnable接口实现线程&#x27;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现Callable接口</strong>（有返回值可抛出异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承Thread类</strong>（java不支持多继承）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;System.out.println(<span class="string">&#x27;用Thread类实现线程&#x27;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用线程池</strong>（底层都是实现run方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> + poolNumber.getAndIncrement() +<span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,namePrefix + threadNumber.getAndIncrement(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) t.setDaemon(<span class="literal">false</span>);  <span class="comment">//是否守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); <span class="comment">//线程优先级</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div style="page-break-after: always;"></div>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>优点：通过复用已创建的线程，<strong>降低资源损耗</strong>、线程可以直接处理队列中的任务<strong>加快响应速度</strong>、同时便于<strong>统一监控和管理</strong>。</p>
<h4 id="1、线程池构造函数"><a href="#1、线程池构造函数" class="headerlink" title="1、线程池构造函数"></a><strong>1、线程池构造函数</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池构造函数7大参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；</td>
</tr>
<tr>
<td>TimeUnit</td>
<td>keepAliveTime 时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>阻塞任务队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>新建线程工厂</td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td>拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td>
</tr>
</tbody></table>
<h4 id="2、线程处理任务过程："><a href="#2、线程处理任务过程：" class="headerlink" title="2、线程处理任务过程："></a><strong>2、线程处理任务过程：</strong></h4><img src="https://s0.lgstatic.com/i/image3/M01/78/50/Cgq2xl5zjxGAXOA-AABF0Dv8GMI518.png" alt="img" style="zoom: 67%;" />

<ol>
<li>当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li>
<li>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</li>
<li>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</li>
<li>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</li>
<li>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</li>
</ol>
<h4 id="3、线程拒绝策略"><a href="#3、线程拒绝策略" class="headerlink" title="3、线程拒绝策略"></a><strong>3、线程拒绝策略</strong></h4><p>​        线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p>
<p>JDK 内置的拒绝策略如下：</p>
<p>​        <strong>AbortPolicy：</strong>直接抛出异常，阻止系统正常运行。可以根据业务逻辑选择重试或者放弃提交等策略。</p>
<p>​        <strong>CallerRunsPolicy ：</strong>只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。</p>
<p>​                不会造成任务丢失，同时减缓提交任务的速度，给执行任务缓冲时间。</p>
<p>​        <strong>DiscardOldestPolicy ：</strong>丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p>
<p>​        <strong>DiscardPolicy ：</strong>该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p>
<h4 id="4、Execuors类实现线程池"><a href="#4、Execuors类实现线程池" class="headerlink" title="4、Execuors类实现线程池"></a><strong>4、Execuors类实现线程池</strong></h4><img src="https://s0.lgstatic.com/i/image3/M01/63/5A/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png" alt="img" style="zoom: 50%;" />

<ul>
<li><strong>newSingleThreadExecutor()：</strong>只有一个线程的线程池，任务是顺序执行，适用于一个一个任务执行的场景</li>
<li><strong>newCachedThreadPool()：</strong>线程池里有很多线程需要同时执行，60s内复用，适用执行很多短期异步的小程序或者负载较轻的服务</li>
<li><strong>newFixedThreadPool()：</strong>拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务。</li>
<li><strong>newScheduledThreadPool()：</strong>用来调度即将执行的任务的线程池</li>
<li>**newWorkStealingPool()**：底层采用forkjoin的Deque，采用独立的任务队列可以减少竞争同时加快任务处理</li>
<li></li>
<li><img src="https://s0.lgstatic.com/i/image2/M01/AF/80/CgoB5l3kzomAckv5AAAxf6FCPco696.png" alt="img" style="zoom:50%;" /></li>
</ul>
<p><strong>因为以上方式都存在弊端：</strong></p>
<p>​        FixedThreadPool 和 SingleThreadExecutor ： 允许请求的<strong>队列⻓度</strong>为 Integer.MAX_VALUE，会导致OOM。<br>​        CachedThreadPool 和 ScheduledThreadPool ： 允许创建的<strong>线程数量</strong>为 Integer.MAX_VALUE，会导致OOM。</p>
<p>手动创建的线程池底层使用的是ArrayBlockingQueue可以防止OOM。</p>
<h4 id="5、线程池大小设置"><a href="#5、线程池大小设置" class="headerlink" title="5、线程池大小设置"></a><strong>5、线程池大小设置</strong></h4><ul>
<li>CPU 密集型（n+1）</li>
</ul>
<p>​    CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</p>
<p>​    CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</p>
<ul>
<li>IO 密集型（2*n）</li>
</ul>
<p>​    由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 </p>
<p>​    也可以使用公式：CPU 核心数 *（1+平均等待时间&#x2F;平均工作时间）。</p>
<div style="page-break-after: always;"></div>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="1、乐观锁，CAS思想"><a href="#1、乐观锁，CAS思想" class="headerlink" title="1、乐观锁，CAS思想"></a><strong>1、乐观锁，CAS思想</strong></h4><p><strong>java乐观锁机制：</strong></p>
<p>​        乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于<strong>读多写少的场景，这样可以提高系统的并发量</strong>。在Java中 <strong>java.util.concurrent.atomic</strong>下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>　　乐观锁，大多是基于数据版本  (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p><strong>CAS思想：</strong></p>
<p>​        CAS就是compare and swap（<strong>比较交换</strong>），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作：</p>
<p>​        需要读写内存值V；进行比较的值A；准备写入的值B</p>
<p>​        当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个<strong>自旋操作</strong>，即<strong>不断重试</strong></p>
<p><strong>缺点：</strong></p>
<p>​        <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23281499/answer/854522984">ABA问题-知乎</a></p>
<p>​        高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源</p>
<p><strong>原子性：</strong></p>
<p>​        功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能<strong>借助atomic包下的原子类</strong>实现，灵活性受到了限制</p>
<h4 id="2、synchronized底层实现"><a href="#2、synchronized底层实现" class="headerlink" title="2、synchronized底层实现"></a><strong>2、synchronized底层实现</strong></h4><p><strong>使用方法：</strong>主要的三种使⽤⽅式</p>
<p>​        <strong>修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</p>
<p>​        <strong>修饰静态⽅法:</strong> 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员。</p>
<p>​        <strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p>
<p>​        <strong>总结：</strong>synchronized锁住的资源只有两类：一个是<strong>对象</strong>，一个是<strong>类</strong>。</p>
<p><strong>底层实现：</strong></p>
<p>​        对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 组成，<strong>其中<code>Mark Word</code>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>。</p>
<p>​        锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p>
<p>​        同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。</p>
<h4 id="3、ReenTrantLock底层实现"><a href="#3、ReenTrantLock底层实现" class="headerlink" title="3、ReenTrantLock底层实现"></a><strong>3、ReenTrantLock底层实现</strong></h4><p>​        由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能</p>
<p><strong>使用方法：</strong></p>
<p>​        基于API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</p>
<p><strong>底层实现：</strong></p>
<p>​        ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
<p><strong>和synchronized区别：</strong></p>
<p>​        1、<strong>底层实现</strong>：synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p>
<p>​        2、<strong>实现原理****：synchronized 的实现涉及到</strong>锁的升级<strong>，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用</strong>CAS**（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p>
<p>​        3、<strong>是否可手动释放：</strong>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致<strong>死锁现象</strong>。</p>
<p>​        4、<strong>是否可中断</strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p>
<p>​        5、<strong>是否公平锁</strong>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁,公平锁性能非常低。</p>
<h4 id="4、公平锁和非公平锁区别"><a href="#4、公平锁和非公平锁区别" class="headerlink" title="4、公平锁和非公平锁区别"></a><strong>4、公平锁和非公平锁区别</strong></h4><p><strong>公平锁：</strong></p>
<p>​        公平锁自然是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待</p>
<p>​        <strong>优点：</strong>所有的线程都能得到资源，不会饿死在队列中。适合大任务</p>
<p>​        <strong>缺点：</strong>吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大</p>
<p><strong>非公平锁：</strong></p>
<p>​        多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<p>​        <strong>优点：</strong>可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p>
<p>​        <strong>缺点：</strong>你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁</p>
<img src="https://s0.lgstatic.com/i/image3/M01/02/7D/Ciqah157DAiAK_DJAAC0JawhGp4730.png" alt="img" style="zoom:67%;" />

<p><strong>公平锁效率低原因：</strong></p>
<p>​        公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。这种情况下相比较非公平锁多了一次<strong>挂起和唤醒</strong>。</p>
<p>​        <strong>线程切换的开销</strong>，其实就是非公平锁效率高于公平锁的原因，因为<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</p>
<h4 id="5、使用层面锁优化"><a href="#5、使用层面锁优化" class="headerlink" title="5、使用层面锁优化"></a><strong>5、使用层面锁优化</strong></h4><p>​    【1】<strong>减少锁的时间：</strong><br>​        不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p>
<p>​    【2】<strong>减少锁的粒度：</strong><br>​        它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：</p>
<p>​        <strong>ConcurrentHashMap：</strong></p>
<p>​        java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment&lt; K,V &gt;[] segments</p>
<p>​        Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p>
<p>​    【3】<strong>锁粗化：</strong><br>​        大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; </p>
<p>​        假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p>
<p>​    【4】<strong>使用读写锁：</strong></p>
<p>​        ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；</p>
<p>​    【5】<strong>使用CAS：</strong></p>
<p>​        如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；</p>
<h4 id="6、系统层面锁优化"><a href="#6、系统层面锁优化" class="headerlink" title="6、系统层面锁优化"></a>6、系统层面锁优化</h4><p><strong>自适应自旋锁：</strong></p>
<p>​        自旋锁可以避免等待竞争锁进入阻塞挂起状态被唤醒造成的<strong>内核态和用户态之间的切换</strong>的损耗，它们只需要等一等（自旋），但是如果锁被其他线程长时间占用，一直不释放CPU，死等会带来更多的性能开销；自旋次数默认值是10</p>
<p>​        对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的<strong>自旋时间及锁的拥有者的状态</strong>来决定，这就解决了自旋锁带来的缺点</p>
<p><strong>锁消除：</strong></p>
<p>​        锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。Netty中无锁化设计pipeline中channelhandler会进行锁消除的优化。</p>
<p><strong>锁升级：</strong></p>
<p>​    <strong>偏向锁：</strong></p>
<p>​        如果线程已经占有这个锁，当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，因为在大部分情况下是没有竞争的，所以使用偏向锁是可以提高性能的；</p>
<p>​    <strong>轻量级锁：</strong></p>
<p>​        在竞争不激烈的情况下，通过CAS避免线程上下文切换，可以显著的提高性能。</p>
<p>​    <strong>重量级锁：</strong></p>
<p>​        重量级锁的加锁、解锁过程造成的损耗是固定的，重量级锁适合于竞争激烈、高并发、同步块执行时间长的情况。</p>
<h4 id="7、ThreadLocal原理"><a href="#7、ThreadLocal原理" class="headerlink" title="7、ThreadLocal原理"></a><strong>7、ThreadLocal原理</strong></h4><p><strong>ThreadLocal简介：</strong></p>
<p>​        通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的<br>专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。类似操作系统中的TLAB</p>
<p><strong>原理：</strong></p>
<p>​        首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p>
<p>​        最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p>
<p>​        我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的 </p>
<p><strong>如何使用：</strong></p>
<p>​        1）存储用户Session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br></pre></td></tr></table></figure>

<p>​        2）解决线程安全的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; format1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()</span><br></pre></td></tr></table></figure>



<p><strong>ThreadLocal内存泄漏的场景</strong> </p>
<p>​        实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>​        所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，如果线程长时间不被销毁，可能会产⽣内存泄露。</p>
<img src="https://s0.lgstatic.com/i/image3/M01/68/C4/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png" alt="img" style="zoom:67%;" />

<p>​        ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。因此使⽤完ThreadLocal ⽅法后，<strong>最好⼿动调⽤ remove() ⽅法</strong>。</p>
<h4 id="8、HashMap线程安全"><a href="#8、HashMap线程安全" class="headerlink" title="8、HashMap线程安全"></a><strong>8、HashMap线程安全</strong></h4><p>​    <strong>死循环造成 CPU 100%</strong></p>
<p>​        HashMap 有可能会发生死循环并且造成  CPU 100% ，这种情况发生最主要的原因就是在<strong>扩容</strong>的时候，也就是内部<strong>新建新的 HashMap</strong> 的时候，扩容的逻辑会<strong>反转散列桶中的节点顺序</strong>，当有多个线程同时进行扩容的时候，由于 HashMap 并非线程安全的，所以如果<strong>两个线程同时反转的话，便可能形成一个循环</strong>，并且这种循环是链表的循环，相当于 A 节点指向 B 节点，B 节点又指回到 A 节点，这样一来，在下一次想要获取该 key 所对应的 value 的时候，便会在遍历链表的时候发生永远无法遍历结束的情况，也就发生 CPU 100% 的情况。</p>
<p>​        所以综上所述，HashMap 是线程不安全的，在多线程使用场景中推荐使用线程安全同时性能比较好的 ConcurrentHashMap。</p>
<h4 id="9、String不可变原因"><a href="#9、String不可变原因" class="headerlink" title="9、String不可变原因"></a>9、String不可变原因</h4><ol>
<li><p>可以使用<strong>字符串常量池</strong>，多次创建同样的字符串会指向同一个内存地址</p>
</li>
<li><p>可以很方便地用作 <strong>HashMap 的 key</strong>。通常建议把不可变对象作为 HashMap的 key</p>
</li>
<li><p>hashCode生成后就不会改变，使用时无需重新计算</p>
</li>
<li><p>线程安全，因为具备不变性的对象一定是线程安全的</p>
</li>
</ol>
<div style="page-break-after: always;"></div>

<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>​        Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/7A/05/Cgq2xl54fTKALhevAAB_l3axT_o532.png" alt="img"></p>
<p>​        JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p>
<p><strong>原子性：</strong></p>
<p>​        在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p>
<p><strong>可见性：</strong></p>
<p>​        Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同</p>
<p><strong>有序性</strong></p>
<p>​        在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。</p>
<h4 id="1、volatile底层实现"><a href="#1、volatile底层实现" class="headerlink" title="1、volatile底层实现"></a><strong>1、volatile底层实现</strong></h4><p><strong>作用：</strong></p>
<p>​        保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p>
<p>​        禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致</p>
<p><strong>底层实现：</strong></p>
<p>​        “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p><strong>单例模式中volatile的作用：</strong></p>
<p>防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123; <span class="comment">//减少加锁的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>) <span class="comment">//确认是否初始化完成</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、AQS思想"><a href="#2、AQS思想" class="headerlink" title="2、AQS思想"></a><strong>2、AQS思想</strong></h4><p>​        AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore需解决的问题：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态的原子性管理</span><br><span class="line">线程的阻塞与解除阻塞</span><br><span class="line">队列的管理</span><br></pre></td></tr></table></figure>

<p>​        AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤<strong>CLH（虚拟的双向队列）</strong>队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p>
<p><strong>lock：</strong></p>
<p>​        是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作；</p>
<p><strong>CountDownLatch：</strong></p>
<p>​        通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。</p>
<p><strong>CompletableFuture：</strong></p>
<p>​        通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。</p>
<p><strong>CyclicBarrier：</strong></p>
<p>​        字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。</p>
<p><strong>Semaphore：</strong></p>
<p>​        信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想</p>
<h4 id="3、happens-before"><a href="#3、happens-before" class="headerlink" title="3、happens-before"></a>3、happens-before</h4><p>​        用来描述和可见性相关问题：如果第一个操作 happens-before 第二个操作，那么我们就说第一个操作对于第二个操作是可见的</p>
<p>​        常见的happens-before：volatile 、锁、线程生命周期。</p>
<h1 id="四、MySQL篇"><a href="#四、MySQL篇" class="headerlink" title="四、MySQL篇"></a>四、MySQL篇</h1><h3 id="WhyMysql？"><a href="#WhyMysql？" class="headerlink" title="WhyMysql？"></a>WhyMysql？</h3><p>NoSQL数据库四大家族 </p>
<ul>
<li>列存储 Hbase</li>
<li>K-V存储 Redis</li>
<li>图像存储 Neo4j</li>
<li>文档存储 MongoDB</li>
</ul>
<p>云存储OSS</p>
<h4 id="海量Aerospike"><a href="#海量Aerospike" class="headerlink" title="海量Aerospike"></a>海量Aerospike</h4><p>​    Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL<strong>数据库</strong>。T级别大数据高并发的结构化<strong>数据存储，</strong>采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>Aerospike</th>
<th>Redis</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>Nosql数据库</td>
<td>缓存</td>
</tr>
<tr>
<td>线程数</td>
<td>多线程</td>
<td>单线程</td>
</tr>
<tr>
<td>数据分片</td>
<td>自动处理相当于分片</td>
<td>提供分片算法、平衡各分片数据</td>
</tr>
<tr>
<td>数据扩容</td>
<td>动态增加数据卷平衡流量</td>
<td>需停机</td>
</tr>
<tr>
<td>数据同步</td>
<td>设置复制因子后可以透明的完成故障转移</td>
<td>手动故障转移和数据同步</td>
</tr>
<tr>
<td>载体</td>
<td>内存存储索引+SSD存储数据</td>
<td>内存</td>
</tr>
</tbody></table>
<p>​    Aerospike作为一个大容量的NoSql解决方案，适合对<strong>容量要求比较大，QPS相对低</strong>一些的场景，主要用在广告行业，<strong>个性化推荐厂告</strong>是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmam43b44bj30d90d4aa7.jpg" alt="image-20210103170039711" style="zoom:50%;" />

<p>​    （ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load）</p>
<ul>
<li><p>用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换</p>
</li>
<li><p>把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分</p>
</li>
<li><p>收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。</p>
</li>
<li><p>把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取</p>
<p>分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Aerospike</th>
<th>Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>库名</td>
<td>Namespace</td>
<td>Database</td>
</tr>
<tr>
<td>表名</td>
<td>Set</td>
<td>Table</td>
</tr>
<tr>
<td>记录</td>
<td>Bin</td>
<td>Column</td>
</tr>
<tr>
<td>字段</td>
<td>Record</td>
<td>Row</td>
</tr>
<tr>
<td>索引</td>
<td>key 、 pk 、kv</td>
<td>pk</td>
</tr>
</tbody></table>
<h4 id="图谱Neo4j"><a href="#图谱Neo4j" class="headerlink" title="图谱Neo4j"></a>图谱Neo4j</h4><blockquote>
<p>Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。</p>
</blockquote>
<p>一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。</p>
<p>互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图<strong>Knowledge Graph（谷歌</strong>）、<strong>知心（百度）</strong>和<strong>知立方（搜狗）</strong>，主要用于改进搜索质量。</p>
<p>自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。</p>
<ul>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaq0j9otdj30pz0en0vm.jpg" alt="image-20210103191540372"></p>
<p>优势总结:</p>
</li>
<li><p>性能上，使用cql查询，对长程关系的查询速度快</p>
</li>
<li><p>擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaqc75y6bj30wc0d60u4.jpg" alt="image-20210103192653004"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件</span></span><br><span class="line">match (na:Person)-[re]-(nb:Person) where na.name=<span class="string">&quot;林婉儿&quot;</span> WITH na,re,nb <span class="title function_">match</span> <span class="params">(nb:Person)</span>- [re2:Friends]-&gt;(nc:Person) <span class="keyword">return</span> na,re,nb,re2,nc</span><br><span class="line"><span class="comment">// 直接拼接关系节点查询</span></span><br><span class="line">match data=(na:Person&#123;name:<span class="string">&quot;范闲&quot;</span>&#125;)-[re]-&gt;(nb:Person)-[re2]-&gt;(nc:Person) <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">// 使用深度运算符</span></span><br><span class="line">显然使用以上方式比较繁琐,可变数量的关系-&gt;节点可以使用-[:TYPE*minHops..maxHops]-。</span><br><span class="line">match data=(na:Person&#123;name:<span class="string">&quot;范闲&quot;</span>&#125;)-[*<span class="number">1.</span><span class="number">.2</span>]-(nb:Person) <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>



<h4 id="文档MongoDB"><a href="#文档MongoDB" class="headerlink" title="文档MongoDB"></a><strong>文档MongoDB</strong></h4><blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。</p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaqyp75qsj312q0i8q5f.jpg" alt="image-20210103194830654" style="zoom:80%;" />

<p><strong>什么是BSON</strong></p>
<blockquote>
<p>{key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p>
</blockquote>
<p>BSON有三个特点：轻量性、可遍历性、高效性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/</span><br><span class="line">db.collection.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line">/* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/</span><br><span class="line">db.collection.update(&#123;where&#125;,&#123;$set:&#123;字段名:值&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line">/* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/</span><br><span class="line">db.collection.remove(&#123;where&#125;, &#123;justOne: &lt;boolean&gt;, writeConcern: &lt;回执&gt; &#125; )</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><p><strong>文档结构的存储方式，能够更便捷的获取数据。</strong></p>
<p>对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。</p>
</li>
<li><p><strong>内置GridFS，支持大容量的存储。</strong></p>
<p>GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。</p>
</li>
<li><p><strong>性能优越</strong></p>
<p>千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持事务</li>
<li>磁盘占用空间大</li>
</ul>
<p>MySQL 8.0 版本</p>
<p><strong>1. 性能</strong>：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。</p>
<p><strong>2. NoSQL</strong>：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。</p>
<p><strong>3. 窗口函数</strong>：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。</p>
<p><strong>4. 隐藏索引</strong>：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。</p>
<h4 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a><strong>云存储</strong></h4><table>
<thead>
<tr>
<th></th>
<th>OSS</th>
<th>自建</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可用性不低于99.995%<br />数据设计持久性不低于99.9999999999%（12个9）</td>
<td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td>
</tr>
<tr>
<td>安全</td>
<td>服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。</td>
<td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td>
</tr>
<tr>
<td>成本</td>
<td>多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。</td>
<td>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td>
</tr>
</tbody></table>
<p><strong>使用步骤</strong></p>
<p>​    1、开通服务</p>
<p>​    2、创建存储空间</p>
<p>​    3、上传文件、下载文件、删除文件</p>
<p>​    4、域名绑定、日志记录</p>
<p>​    5、根据开放接口进行鉴权访问</p>
<p><strong>功能</strong></p>
<p>​    图片编辑（裁剪、模糊、水印）</p>
<p>​    视频截图</p>
<p>​    音频转码、视频修复</p>
<p><strong>CDN加速</strong></p>
<p>​    对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同一地区大量用户同时下载同一个静态文件的场景）。可以将OSS的存储空间（Bucket）作为源站，利用阿里云CDN将源内容发布到边缘节点。当大量终端用户重复访问同一文件时，可以直接从边缘节点获取已缓存的数据，提高访问的响应速度</p>
<h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a><strong>FastDFS</strong></h4><blockquote>
<p><strong>开源的轻量级分布式文件系统</strong>。它对文件进行管理，功能包括：<strong>文件存储、文件同步、文件访问</strong>（文件上传、文件下载）等，解决了<strong>大容量存储和负载均衡</strong>的问题。使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。如<strong>相册网站、视频网站</strong>等</p>
</blockquote>
<p><strong>扩展能力:</strong> 支持水平扩展，可以动态扩容；</p>
<p><strong>高可用性:</strong> 一是整个文件系统的可用性，二是数据的完整和一致性；</p>
<p><strong>弹性存储:</strong> 可以根据业务需要灵活地增删存储池中的资源，而不需要中断系统运行。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhjkvo59j30zu0b4dib.jpg" alt="image-20210107221022658"></p>
<p>特性</p>
<ul>
<li>和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块</li>
<li>文件ID由FastDFS生成，作为文件访问凭证，FastDFS不需要传统的name server</li>
<li>分组存储，灵活简洁、对等结构，不存在单点</li>
<li>文件不分块存储，上传的文件和OS文件系统中的文件一一对应</li>
<li>中、小文件均可以很好支持，支持海量小文件存储</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>支持多块磁盘，支持单盘数据恢复</li>
<li>支持在线扩容 支持主从文件</li>
<li>下载文件支持多线程方式，支持断点续传</li>
</ul>
<p><strong>组成</strong></p>
<ul>
<li><p><strong>客户端（client）</strong></p>
<p>通过专有接口，使用TCP&#x2F;IP协议与跟踪器服务器或存储节点进行数据交互。</p>
</li>
<li><p><strong>跟踪器（tracker）</strong> </p>
<p>Trackerserver作用是负载均衡和调度，通过Tracker server在文件上传时可以根据策略找到文件上传的地址。Tracker在访问上起负载均衡的作用。</p>
</li>
<li><p><strong>存储节点（storage）</strong></p>
<p>Storageserver作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server<strong>没有实现自己的文件系统而是利用操作系统的文件系统来管理文件</strong>。存储节点中的服务器均可以<strong>随时增加或下线而不会影响线上服务</strong>。</p>
</li>
</ul>
<p><strong>上传</strong></p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhvk0wwzj30ue0h4dlw.jpg" alt="image-20210107222155291" style="zoom:50%;" />

<p><strong>下载</strong></p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhww8zmfj30uw0g6n37.jpg" alt="image-20210107222312338" style="zoom:50%;" />

<p><strong>断点续传</strong></p>
<p>​    续传涉及到的文件大小MD5不会改变。续传流程与文件上传类似，先<strong>定位到源storage</strong>，完成完整或部分上传，再<strong>通过binlog进行同group内server文件同步</strong>。</p>
<p><strong>配置优化</strong></p>
<p>配置文件：tracker.conf 和 storage.conf </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FastDFS采用内存池的做法。 </span></span><br><span class="line"><span class="comment">// v5.04对预分配采用增量方式，tracker一次预分配 1024个，storage一次预分配256个。 </span></span><br><span class="line">max_connections = <span class="number">10240</span></span><br><span class="line"><span class="comment">// 根据实际需要将 max_connections 设置为一个较大的数值，比如 10240 甚至更大。</span></span><br><span class="line"><span class="comment">// 同时需要将一个进程允许打开的最大文件数调大</span></span><br><span class="line">vi /etc/security/limits.conf 重启系统生效 </span><br><span class="line">* soft nofile <span class="number">65535</span> </span><br><span class="line">* hard nofile <span class="number">65535</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_threads = <span class="number">4</span> </span><br><span class="line"><span class="comment">// 说明：为了避免CPU上下文切换的开销，以及不必要的资源消耗，不建议将本参数设置得过大。</span></span><br><span class="line"><span class="comment">// 公式为： work_threads + (reader_threads + writer_threads) = CPU数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于单盘挂载方式，磁盘读写线程分 别设置为 1即可 </span></span><br><span class="line"><span class="comment">// 如果磁盘做了RAID，那么需要酌情加大读写线程数，这样才能最大程度地发挥磁盘性能</span></span><br><span class="line">disk_rw_separated：磁盘读写是否分离 </span><br><span class="line">disk_reader_threads：单个磁盘读线程数 </span><br><span class="line">disk_writer_threads：单个磁盘写线程数 </span><br></pre></td></tr></table></figure>

<p><strong>避免重复</strong></p>
<p>​    如何避免文件重复上传 解决方案 上传成功后计算文件对应的MD5然后<strong>存入MySQL</strong>,添加文件时把<strong>文件MD5和之前存入MYSQL中的存储的信息对比</strong> 。DigestUtils.md5DigestAsHex(bytes)。</p>
<div style="page-break-after: always;"></div>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、事务4大特性"><a href="#1、事务4大特性" class="headerlink" title="1、事务4大特性"></a><strong>1、事务4大特性</strong></h4><p><strong>事务4大特性：</strong>原子性、一致性、隔离性、持久性</p>
<p>​    <strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p>
<p>​    <strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p>
<p>​    <strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p>
<p>​    <strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p>
<p><strong>实现保证：</strong></p>
<p>​        MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p>
<h4 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a><strong>2、事务隔离级别</strong></h4><p><strong>读未提交：</strong>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p><strong>读已提交：</strong>允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p>
<p><strong>可重复读：</strong>同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。</p>
<p><strong>串行化：</strong>最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>并发问题</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>读已提交</td>
<td>可能会导致幻读或不可重复读</td>
</tr>
<tr>
<td>可重复读</td>
<td>可能会导致幻读</td>
</tr>
<tr>
<td>可串行化</td>
<td>不会产⽣⼲扰</td>
</tr>
</tbody></table>
<h4 id="3、默认隔离级别-RR"><a href="#3、默认隔离级别-RR" class="headerlink" title="3、默认隔离级别-RR"></a><strong>3、默认隔离级别-RR</strong></h4><p><strong>默认隔离级别：</strong>可重复读；</p>
<p>​        同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p>
<p>​        可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p>
<p>​        第二种方式，使用MVCC解决<strong>快照读幻读问题</strong>（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id = ? and version = V</span><br><span class="line">update id from table_xx where id = ? and version = V+1</span><br></pre></td></tr></table></figure>

<p>​        第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决<strong>当前读幻读问题</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id &gt; 100 for update;</span><br><span class="line">select id from table_xx where id &gt; 100 lock in share mode;</span><br></pre></td></tr></table></figure>



<h4 id="4、RR和RC使用场景"><a href="#4、RR和RC使用场景" class="headerlink" title="4、RR和RC使用场景"></a><strong>4、RR和RC使用场景</strong></h4><p>​        事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>RC</th>
<th>RR</th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td>多条查询语句会创建多个不同的ReadView</td>
<td>仅需要一个版本的ReadView</td>
</tr>
<tr>
<td>粒度</td>
<td>语句级读一致性</td>
<td>事务级读一致性</td>
</tr>
<tr>
<td>准确性</td>
<td>每次语句执行时间点的数据</td>
<td>第一条语句执行时间点的数据</td>
</tr>
</tbody></table>
<h4 id="5、行锁，表锁，意向锁"><a href="#5、行锁，表锁，意向锁" class="headerlink" title="5、行锁，表锁，意向锁"></a><strong>5、行锁，表锁，意向锁</strong></h4><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong>    </p>
<p>​    InnoDB按照不同的分类的锁：</p>
<p>​    共享&#x2F;排它锁(Shared and Exclusive Locks)：行级别锁，</p>
<p>​    意向锁(Intention Locks)，表级别锁</p>
<p>​    间隙锁(Gap Locks)，锁定一个区间</p>
<p>​    记录锁(Record Locks)，锁定一个行记录</p>
<p><strong>表级锁：（串行化）</strong></p>
<p>​        Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
<p><strong>行级锁：（RR、RC）</strong></p>
<p>​        Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p>
<p>​        <strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定<strong>符合条件的行</strong>。其他事务不能修改和删除加锁项；</p>
<p>​        <strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定<strong>记录的范围</strong>，不包含索引项本身，其他事务不能在锁范围内插入数据。</p>
<p>​        <strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p>
<p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p>
<p><strong>共享锁</strong>（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁</p>
<p><strong>排他锁</strong>（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁  </p>
<p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<table>
<thead>
<tr>
<th>互斥性</th>
<th>共享锁（S）</th>
<th>排它锁（X）</th>
<th>意向共享锁IS</th>
<th>意向排他锁IX</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（S）</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>排它锁（X）</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>意向共享锁IS</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>意向排他锁IX</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h4 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a><strong>6、MVCC多版本并发控制</strong></h4><p>​        MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作）</p>
<p>​        InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。</p>
<p>​        1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p>
<p>​        2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p>
<p>​        3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁</p>
<p>​        原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<p><strong>版本链</strong></p>
<p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>
<p><strong>trx_id</strong></p>
<p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p>
<p><strong>roll_pointer</strong></p>
<p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p>每次修改都会在版本链中记录。<strong>SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，</strong>提升了系统的性能。</p>
<div style="page-break-after: always;"></div>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、Innodb和Myisam引擎"><a href="#1、Innodb和Myisam引擎" class="headerlink" title="1、Innodb和Myisam引擎"></a><strong>1、Innodb和Myisam引擎</strong></h4><p><strong>Myisam：</strong>支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p>
<p><strong>Innodb：</strong>支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p>
<h4 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a><strong>2、哈希索引</strong></h4><p>​        哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能</p>
<h4 id="3、B-树索引"><a href="#3、B-树索引" class="headerlink" title="3、B+树索引"></a><strong>3、B+树索引</strong></h4><p><strong>优点：</strong></p>
<p>​        B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p>
<p>​        B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而<strong>提高范围查找的效率，增加的索引的范围</strong></p>
<p>​        在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p>​        <strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p>
<h4 id="4、创建索引"><a href="#4、创建索引" class="headerlink" title="4、创建索引"></a>4、创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT]  INDEX  索引名 <span class="keyword">ON</span>  表名(字段名) [<span class="keyword">USING</span> 索引方法]；</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="keyword">UNIQUE</span>:可选。表示索引为唯一性索引。</span><br><span class="line">FULLTEXT:可选。表示索引为全文索引。</span><br><span class="line">INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</span><br><span class="line">索引名:可选。给创建的索引取一个新名称。</span><br><span class="line">字段名<span class="number">1</span>:指定索引对应的字段的名称，该字段必须是前面定义好的字段。</span><br><span class="line">注：索引方法默认使用B<span class="operator">+</span>TREE。</span><br></pre></td></tr></table></figure>



<h4 id="5、聚簇索引和非聚簇索引"><a href="#5、聚簇索引和非聚簇索引" class="headerlink" title="5、聚簇索引和非聚簇索引"></a><strong>5、聚簇索引和非聚簇索引</strong></h4><p>​    <strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（<strong>主键索引</strong>）</p>
<p>​    <strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（<strong>辅助索引</strong>）</p>
<p>​    聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<h4 id="6、最左前缀问题"><a href="#6、最左前缀问题" class="headerlink" title="6、最左前缀问题"></a>6、最左前缀问题</h4><p>​        最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p>
<p>​        联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p>​        采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p>
<div style="page-break-after: always;"></div>

<h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><h4 id="1、SQL语句的执行过程"><a href="#1、SQL语句的执行过程" class="headerlink" title="1、SQL语句的执行过程"></a><strong>1、SQL语句的执行过程</strong></h4><p><strong>查询语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student  A where A.age=&#x27;18&#x27; and A.name=&#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>

<img src="http://s0.lgstatic.com/i/image2/M01/8B/0F/CgotOV14ySKAMxohAAH2VHcAzkE612.png" alt="img" style="zoom: 67%;" />

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<p>①通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。并查询是否有权限</p>
<p>②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p>
<p>③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id&#x3D;’1’</p>
<p>④查询优化器生成执行计划。根据索引看看是否可以优化</p>
<p>⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p>
<h4 id="2、回表查询和覆盖索引"><a href="#2、回表查询和覆盖索引" class="headerlink" title="2、回表查询和覆盖索引"></a><strong>2、回表查询和覆盖索引</strong></h4><p><strong>普通索引</strong>（唯一索引+联合索引+全文索引）需要扫描两遍索引树</p>
<p>（1）先通过普通索引定位到主键值id&#x3D;5；</p>
<p>（2）在通过聚集索引定位到行记录；</p>
<p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p>
<p><strong>覆盖索引</strong>：主键索引&#x3D;&#x3D;聚簇索引&#x3D;&#x3D;覆盖索引</p>
<p>​    覆盖索引（covering index ，或称为索引覆盖）就是把单列的非主键 索引 修改为多字段的联合索引,  在一棵索引数上 就找到了想要的数据, 不需要去主键索引树上,再检索一遍  这个现象,称之为 索引覆盖.</p>
<p>​    如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p>
<p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p>
<h4 id="3、Explain及优化"><a href="#3、Explain及优化" class="headerlink" title="3、Explain及优化"></a>3、Explain及优化</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from staff;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | staff | ALL  | NULL          | 索引  | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>

<p><strong>索引优化：</strong></p>
<p>​    ①最左前缀索引：like只用于’string%’，语句中的&#x3D;和in会动态调整顺序</p>
<p>​    ②唯一索引：唯一键区分度在0.1以上</p>
<p>​        区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/hadoop">大数据</a>面前区分度就 是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条 记录</p>
<p>​    ③无法使用索引：!&#x3D;  、is null 、 or、&gt;&lt; 、（<strong>5.7以后根据数量自动判定）in 、not in</strong></p>
<p>​    ④联合索引：避免select * ，查询列使用覆盖索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT uid From user Where gid = 2 order by ctime asc limit 10</span><br><span class="line">ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询</span><br></pre></td></tr></table></figure>



<p><strong>语句优化：</strong></p>
<p>​    ①char固定长度查询效率高，varchar第一个字节记录数据长度</p>
<p>​    ②应该针对Explain中Rows增加索引</p>
<p>​    ③group&#x2F;order by字段均会涉及索引</p>
<p>​    ④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>  改进后的<span class="keyword">SQL</span>语句如下：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">where</span> id <span class="operator">&gt;=</span> ( <span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">1</span> ) limit <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">inner</span> ori <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>) <span class="keyword">as</span> tmp <span class="keyword">on</span> tmp.id<span class="operator">=</span>ori.id;</span><br></pre></td></tr></table></figure>

<p>​    ⑤count会进行全表扫描，如果估算可以使用explain</p>
<p>​    ⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate</p>
<p><strong>表结构优化：</strong></p>
<p>​    ①单库不超过200张表</p>
<p>​    ②单表不超过500w数据</p>
<p>​    ③单表不超过40列</p>
<p>​    ④单表索引不超过5个</p>
<p><strong>数据库范式</strong> ：</p>
<p>​    ①第一范式（1NF）列不可分割</p>
<p>​    ②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p>
<p>​    ③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p>
<p><strong>配置优化：</strong></p>
<p>​    配置连接数、禁用Swap、增加内存、升级SSD硬盘</p>
<h4 id="4、JOIN查询"><a href="#4、JOIN查询" class="headerlink" title="4、JOIN查询"></a>4、JOIN查询</h4><img src="https://image-static.segmentfault.com/276/780/2767807589-5c122586a23c4_articlex" style="align:left;zoom: 60%;" />

<p><strong>left join(左联接)</strong> 返回包括左表中的所有记录和右表中关联字段相等的记录 </p>
<p><strong>right join(右联接)</strong> 返回包括右表中的所有记录和左表中关联字段相等的记录</p>
<p><strong>inner join(等值连接)</strong> 只返回两个表中关联字段相等的行</p>
<div style="page-break-after: always;"></div>

<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="1、主从复制过程"><a href="#1、主从复制过程" class="headerlink" title="1、主从复制过程"></a>1、主从复制过程</h4><p><strong>MySQl主从复制：</strong></p>
<ul>
<li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li>
<li><strong>过程</strong>：从库开启一个I&#x2F;O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li>
<li><strong>优点</strong>：<ul>
<li>作为备用数据库，并且不影响业务</li>
<li>可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li>
</ul>
</li>
</ul>
<p><strong>binlog记录格式：</strong>statement、row、mixed</p>
<p>​        基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p>
<h4 id="2、数据一致性问题"><a href="#2、数据一致性问题" class="headerlink" title="2、数据一致性问题"></a>2、数据一致性问题</h4><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p>
<p><strong>缓存记录写key法：</strong></p>
<p>​        在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p>
<p><strong>异步复制：</strong></p>
<p>​        在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能<strong>会造成数据的不一致</strong>。</p>
<p><strong>半同步复制：</strong></p>
<p>​        当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。</p>
<p><strong>全同步复制：</strong></p>
<p>​        指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的<strong>性能必然会收到严重的影响</strong>。</p>
<h4 id="3、集群架构"><a href="#3、集群架构" class="headerlink" title="3、集群架构"></a>3、集群架构</h4><p> <strong>Keepalived + VIP + MySQL 主从&#x2F;双主</strong></p>
<p>​        当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是采用共享存储，单点故障切换可以通过分布式哨兵系统监控。</p>
<img src="http://s0.lgstatic.com/i/image2/M01/89/48/CgoB5l12KuGALf-cAAGuHVmMkHs743.png" alt="img" style="zoom: 67%;" />

<p> <strong>架构选型：</strong>MMM 集群  -&gt; MHA集群 -&gt; MHA+Arksentinel。</p>
<img src="http://s0.lgstatic.com/i/image2/M01/89/68/CgotOV12KuKAe_HOAABl-wRATa0772.png" alt="img"  />



<h4 id="4、故障转移和恢复"><a href="#4、故障转移和恢复" class="headerlink" title="4、故障转移和恢复"></a>4、故障转移和恢复</h4><p><strong>转移方式及恢复方法</strong></p>
<pre><code>1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS  和 MMM 架构）
</code></pre>
<p>​    问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。</p>
<pre><code>2. 提升备库为主库（MHA、QMHA）
</code></pre>
<p>​    尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。</p>
<div style="page-break-after: always;"></div>

<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h5 id="如何进行分库分表"><a href="#如何进行分库分表" class="headerlink" title="如何进行分库分表"></a>如何进行分库分表</h5><blockquote>
<p><strong>分表</strong>用户id进行分表，每个表控制在300万数据。</p>
<p><strong>分库</strong>根据业务场景和地域分库，每个库并发不超过2000</p>
</blockquote>
<p><strong>Sharding-jdbc</strong> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖，升级比较麻烦</p>
<p><strong>Mycat</strong> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了</p>
<p><strong>水平拆分</strong>：一个表放到多个库，分担高并发，加快查询速度</p>
<ul>
<li><strong>id</strong>保证业务在关联多张表时可以在同一库上操作</li>
<li><strong>range</strong>方便扩容和数据统计</li>
<li><strong>hash</strong>可以使得数据更加平均</li>
</ul>
<p><strong>垂直拆分</strong>：一个表拆成多个表，可以将一些冷数据拆分到冗余库中</p>
<blockquote>
<p>不是写瓶颈优先进行分表</p>
</blockquote>
<ul>
<li><p>分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题</p>
</li>
<li><p>分库越多，出现问题的可能性越大，维护成本也变得更高。</p>
</li>
<li><p>分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。</p>
</li>
</ul>
<p>分库首先需考虑满足业务最核心的场景：</p>
<p>1、订单数据按<strong>用户</strong>分库，可以<strong>提升用户的全流程体验</strong></p>
<p>2、超级客户导致<strong>数据倾斜</strong>可以使用最细粒度唯一标识进行hash拆分</p>
<p>3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了</p>
<p>三个问题：</p>
<ul>
<li><p>富查询：采用分库分表之后，如何满足跨越分库的查询？<strong>使用ES</strong>的宽表</p>
<p>借助<strong>分库网关+分库业务</strong>虽然能够实现<strong>多维度查询的能力</strong>，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对<strong>多维度实时查询</strong>的最常见方式便是借助 <strong>ElasticSearch</strong></p>
</li>
<li><p>数据倾斜：数据分库基础上再进行分表</p>
</li>
<li><p>分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？</p>
</li>
<li><p>深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID</p>
</li>
</ul>
<h4 id="如何将老数据进行迁移"><a href="#如何将老数据进行迁移" class="headerlink" title="如何将老数据进行迁移"></a>如何将老数据进行迁移</h4><p><strong>双写不中断迁移</strong></p>
<ul>
<li>线上系统里所有写库的地方，增删改操作，<strong>除了对老库增删改，都加上对新库的增删改</strong></li>
<li>系统部署以后，还需要跑程序读老库数据写新库，写的时候需要判断updateTime</li>
<li>循环执行，直至两个库的数据完全一致，最后重新部署分库分表的代码就行了</li>
</ul>
<h4 id="系统性能的评估及扩容"><a href="#系统性能的评估及扩容" class="headerlink" title="系统性能的评估及扩容"></a>系统性能的评估及扩容</h4><p>和家亲目前有1亿用户：场景 10万写并发，100万读并发，60亿数据量</p>
<p>设计时考虑极限情况，32库*32表~64个表，一共1000 ~ 2000张表</p>
<ul>
<li><p>支持<strong>3万</strong>的写并发，配合MQ实现每秒10万的写入速度</p>
</li>
<li><p>读写分离<strong>6万</strong>读并发，配合分布式缓存每秒100读并发</p>
</li>
<li><p>2000张表每张300万，可以最多写入60亿的数据</p>
</li>
<li><p>32张用户表，支撑亿级用户，后续最多也就扩容一次</p>
</li>
</ul>
<p><strong>动态扩容的步骤</strong></p>
<ol>
<li>推荐是 32 库 * 32 表，对于我们公司来说，可能几年都够了。</li>
<li>配置路由的规则，uid % 32 &#x3D; 库，uid &#x2F; 32 % 32 &#x3D; 表</li>
<li>扩容的时候，申请增加更多的数据库服务器，呈倍数扩容</li>
<li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去</li>
<li>修改一下配置，重新发布系统，上线，原先的路由规则变都不用变</li>
<li>直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li>
</ol>
<h4 id="如何生成自增的id主键"><a href="#如何生成自增的id主键" class="headerlink" title="如何生成自增的id主键"></a>如何生成自增的id主键</h4><ul>
<li>使用redis可以</li>
<li>并发不高可以单独起一个<strong>服务</strong>，生成自增id</li>
<li>设置数据库<strong>step</strong>自增步长可以支撑水平伸缩</li>
<li>UUID适合文件名、编号，但是<strong>不适合做主键</strong></li>
<li><strong>snowflake雪花算法</strong>，综合了<strong>41时间</strong>（ms）、<strong>10机器</strong>、<strong>12序列号</strong>（ms内自增）</li>
</ul>
<p>其中机器预留的10bit可以根据自己的业务场景配置</p>
<div style="page-break-after: always;"></div>

<h3 id="线上故障及优化"><a href="#线上故障及优化" class="headerlink" title="线上故障及优化"></a>线上故障及优化</h3><h4 id="更新失败-主从同步延时"><a href="#更新失败-主从同步延时" class="headerlink" title="更新失败 | 主从同步延时"></a>更新失败 | 主从同步延时</h4><p>以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p>
<p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000&#x2F;s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p>
<p>我们通过 MySQL 命令：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">show</span> slave <span class="built_in">status</span></span><br></pre></td></tr></table></figure>

<p>查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p>
<p>一般来说，如果主从延迟较为严重，有以下解决方案：</p>
<ul>
<li>分库，拆分为多个主库，每个主库的写并发就减少了几倍，主从延迟可以忽略不计。</li>
<li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li>
<li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>或者<strong>延迟查询</strong>。主从复制延迟一般不会超过50ms</li>
</ul>
<h4 id="应用崩溃-分库分表优化"><a href="#应用崩溃-分库分表优化" class="headerlink" title="应用崩溃 | 分库分表优化"></a><strong>应用崩溃 | 分库分表优化</strong></h4><p>​    我们有一个线上通行记录的表，由于数据量过大，进行了分库分表，当时分库分表初期经常产生一些问题。典型的就是通行记录查询中使用了深分页，通过一些工具如MAT、Jstack追踪到是由于sharding-jdbc内部引用造成的。</p>
<p>​    通行记录数据被存放在两个库中。如果没有提供<strong>切分键</strong>，查询语句就会被分发到所有的数据库中，比如查询语句是 limit 10、offset 1000，最终结果只需要返回 10 条记录，但是数据库中间件要完成这种计算，则需要 (1000+10)*2&#x3D;2020 条记录来完成这个计算过程。如果 offset 的值过大，使用的内存就会暴涨。虽然 sharding-jdbc 使用归并算法进行了一些优化，但在实际场景中，深分页仍然引起了<strong>内存和性能</strong>问题。</p>
<p>​    这种在中间节点进行<strong>归并聚合</strong>的操作，在分布式框架中非常常见。比如在 ElasticSearch 中，就存在相似的数据获取逻辑，<strong>不加限制的深分页</strong>，同样会造成 ES 的内存问题。</p>
<p><strong>业界解决方案：</strong></p>
<p><strong>方法一：全局视野法</strong></p>
<p>（1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y</p>
<p>（2）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录</p>
<p>这种方法随着翻页的进行，性能越来越低。</p>
<p><strong>方法二：业务折衷法-禁止跳页查询</strong></p>
<p>（1）用正常的方法取得第一页数据，并得到第一页记录的time_max</p>
<p>（2）每次翻页，将order by time offset X limit Y，改写成order by time where time&gt;$time_max limit Y</p>
<p>以保证每次只返回一页数据，性能为常量。</p>
<p><strong>方法三：业务折衷法-允许模糊数据</strong></p>
<p>（1）将order by time offset X limit Y，改写成order by time offset X&#x2F;N limit Y&#x2F;N</p>
<p><strong>方法四：二次查询法</strong></p>
<p>（1）将order by time offset X limit Y，改写成order by time offset X&#x2F;N limit Y</p>
<p>（2）找到最小值time_min</p>
<p>（3）between二次查询，order by time between $time_min and $time_i_max</p>
<p>（4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset</p>
<p>（5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y</p>
<h4 id="查询异常-SQL-调优"><a href="#查询异常-SQL-调优" class="headerlink" title="查询异常 | SQL 调优"></a>查询异常 | SQL 调优</h4><p>分库分表前，有一段用用户名来查询某个用户的 SQL 语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> user where name = <span class="string">&quot;xxx&quot;</span> <span class="keyword">and</span> community=<span class="string">&quot;other&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>为了达到动态拼接的效果，这句 SQL 语句被一位同事进行了如下修改。他的本意是，当 name 或者 community 传入为空的时候，动态去掉这些查询条件。这种写法，在 MyBaits 的配置文件中，也非常常见。大多数情况下，这种写法是没有问题的，因为结果集合是可以控制的。但随着系统的运行，用户表的记录越来越多，当传入的 name 和 community 全部为空时，悲剧的事情发生了:</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>数据库中的所有记录，都会被查询出来，载入到 JVM 的内存中。由于数据库记录实在太多，直接把内存给撑爆了。由于这种原因引起的内存溢出，发生的频率非常高，比如导入Excel文件时。</p>
<p>通常的解决方式是<strong>强行加入分页功能</strong>，或者对一些<strong>必填的参数进行校验</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobovqjvijj30zd0lctbp.jpg" alt="img"></p>
<p><strong>Controller 层</strong></p>
<p>现在很多项目都采用前后端分离架构，所以 Controller 层的方法，一般使用 @ResponseBody 注解，把查询的结果，解析成 JSON 数据返回。这在数据集非常大的情况下，会占用很多内存资源。假如结果集在解析成 JSON 之前，占用的内存是 10MB，那么在解析过程中，有可能会使用 20M 或者更多的内存</p>
<p>因此，保持结果集的精简，是非常有必要的，这也是 DTO（Data Transfer Object）存在的必要。互联网环境不怕小结果集的高并发请求，却非常恐惧大结果集的耗时请求，这是其中一方面的原因。</p>
<p><strong>Service 层</strong></p>
<p>Service 层用于处理具体的业务，更加贴合业务的功能需求。一个 Service，可能会被多个 Controller 层所使用，也可能会使用多个 dao 结构的查询结果进行计算、拼装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getUserSize</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = dao.getAllUser();</span><br><span class="line">        <span class="type">return</span> <span class="variable">null</span> <span class="operator">=</span>= users ? <span class="number">0</span> : users.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码review中发现了定时炸弹，这种在数据量达到一定程度后，才会暴露问题。</p>
<p><strong>ORM 层</strong></p>
<p>比如使用Mybatis时，有一个批量导入服务，在 MyBatis 执行批量插入的时候，竟然产生了内存溢出，按道理这种插入操作是不会引起额外内存占用的，最后通过源码追踪到了问题。</p>
<p>这是因为 MyBatis 循环处理 batch 的时候，操作对象是数组，而我们在接口定义的时候，使用的是 List；当传入一个非常大的 List 时，它需要调用 List 的 toArray 方法将列表转换成数组（浅拷贝）；在最后的拼装阶段，又使用了 StringBuilder 来拼接最终的 SQL，所以实际使用的内存要比 List 多很多。</p>
<p>事实证明，不论是插入操作还是查询动作，只要涉及的数据集非常大，就容易出现问题。由于项目中众多框架的引入，想要分析这些具体的内存占用，就变得非常困难。所以保持小批量操作和结果集的干净，是一个非常好的习惯。</p>
<h1 id="五、Redis篇"><a href="#五、Redis篇" class="headerlink" title="五、Redis篇"></a><strong>五、Redis篇</strong></h1><h3 id="WhyRedis"><a href="#WhyRedis" class="headerlink" title="WhyRedis"></a>WhyRedis</h3><p>​        速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p>
<table>
<thead>
<tr>
<th></th>
<th>GuavaCache</th>
<th>Tair</th>
<th>EVCache</th>
<th>Aerospike</th>
</tr>
</thead>
<tbody><tr>
<td>类别</td>
<td>本地JVM缓存</td>
<td>分布式缓存</td>
<td>分布式缓存</td>
<td>分布式nosql数据库</td>
</tr>
<tr>
<td>应用</td>
<td>本地缓存</td>
<td>淘宝</td>
<td>Netflix、AWS</td>
<td>广告</td>
</tr>
<tr>
<td>性能</td>
<td>非常高</td>
<td>较高</td>
<td>很高</td>
<td>较高</td>
</tr>
<tr>
<td>持久化</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>集群</td>
<td>无</td>
<td>灵活配置</td>
<td>有</td>
<td>自动扩容</td>
</tr>
</tbody></table>
<p>​        与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h4 id="1、简单高效"><a href="#1、简单高效" class="headerlink" title="1、简单高效"></a>1、简单高效</h4><p>​        1）完全基于内存，绝大部分请求是纯粹的内存操作。数据存在内存中，类似于 HashMap，查找和操作的时间复杂度都是O(1)；</p>
<p>​        2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p>​        3）采用单线程，避免了多线程不必要的上下文切换和竞争条件，不存在加锁释放锁操作，减少了因为锁竞争导致的性能消耗；（6.0以后多线程）</p>
<p>​        4）使用EPOLL多路 I&#x2F;O 复用模型，非阻塞 IO；</p>
<p>​        5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<h4 id="2、Memcache"><a href="#2、Memcache" class="headerlink" title="2、Memcache"></a>2、Memcache</h4><table>
<thead>
<tr>
<th>redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>内存高速数据库</td>
<td>高性能分布式内存缓存数据库</td>
</tr>
<tr>
<td>支持hash、list、set、zset、string结构</td>
<td>只支持key-value结构</td>
</tr>
<tr>
<td>将大部分数据放到内存</td>
<td>全部数据放到内存中</td>
</tr>
<tr>
<td>支持持久化、主从复制备份</td>
<td>不支持数据持久化及数据备份</td>
</tr>
<tr>
<td>数据丢失可通过AOF恢复</td>
<td>挂掉后，数据不可恢复</td>
</tr>
<tr>
<td>单线程（2~4万TPS）</td>
<td>多线程（20-40万TPS）</td>
</tr>
</tbody></table>
<p><strong>使用场景：</strong></p>
<p>​    1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。<br>​    2、如果简单的key&#x2F;value 存储应该选择memcached。    </p>
<h4 id="3、Tair"><a href="#3、Tair" class="headerlink" title="3、Tair"></a>3、Tair</h4><p>​    Tair(Taobao Pair)是淘宝开发的分布式Key-Value存储引擎，既可以做缓存也可以做数据源（三种引擎切换）</p>
<ul>
<li>MDB（Memcache）属于内存型产品,支持kv和类hashMap结构,性能最优</li>
<li>RDB（Redis）支持List.Set.Zset等复杂的数据结构,性能次之,可提供缓存和持久化存储两种模式</li>
<li>LDB（levelDB）属于持久化产品,支持kv和类hashmap结构,性能较前两者稍低,但持久化可靠性最高</li>
</ul>
<p><strong>分布式缓存</strong></p>
<p>大访问少量临时数据的存储（kb左右）</p>
<p>用于缓存，降低对后端数据库的访问压力</p>
<p>session场景</p>
<p>高速访问某些数据结构的应用和计算（rdb）</p>
<p><strong>数据源存储</strong></p>
<p>快速读取数据（fdb）</p>
<p>持续大数据量的存入读取（ldb），交易快照</p>
<p>高频度的更新读取（ldb），库存</p>
<p><strong>痛点</strong>：redis集群中，想借用缓存资源必须得指明redis服务器地址去要。这就增加了程序的维护复杂度。因为redis服务器很可能是需要频繁变动的。所以人家淘宝就想啊，为什么不能像操作分布式数据库或者hadoop那样。增加一个中央节点，让他去代理所有事情。在tair中程序只要跟tair中心节点交互就OK了。同时tair里还有配置服务器概念。又免去了像操作hadoop那样，还得每台hadoop一套一模一样配置文件。改配置文件得整个集群都跟着改。</p>
<h4 id="4、Guava"><a href="#4、Guava" class="headerlink" title="4、Guava"></a>4、Guava</h4><p>​        分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；</p>
<p>​        本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。</p>
<p><strong>本地缓存设计：</strong></p>
<p>​        以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p><strong>解决缓存过期：</strong></p>
<p>​    1、将缓存过期时间调为永久</p>
<p>​    2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p><strong>解决内存溢出：</strong></p>
<p>​    <strong>第一步</strong>，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p>
<p>　<strong>第二步</strong>，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p>
<p>　<strong>第三步</strong>，对代码进行走查和分析，找出可能发生内存溢出的位置。</p>
<p><strong>Google Guava Cache</strong> </p>
<p><strong>自己设计本地缓存痛点：</strong></p>
<ul>
<li>不能按照一定的规则淘汰数据，如 LRU，LFU，FIFO 等。</li>
<li>清除数据时的回调通知</li>
<li>并发处理能力差，针对并发可以使用CurrentHashMap，但缓存的其他功能需要自行实现</li>
<li>缓存过期处理，缓存数据加载刷新等都需要手工实现</li>
</ul>
<p><strong>Guava Cache 的场景：</strong></p>
<ul>
<li>对性能有非常高的要求</li>
<li>不经常变化，占用内存不大</li>
<li>有访问整个集合的需求</li>
<li>数据允许不实时一致</li>
</ul>
<p><strong>Guava Cache 的优势</strong>：</p>
<ul>
<li>缓存过期和淘汰机制</li>
</ul>
<p>在GuavaCache中可以设置Key的过期时间，包括访问过期和创建过期。GuavaCache在缓存容量达到指定大小时，采用LRU的方式，将不常使用的键值从Cache中删除</p>
<ul>
<li>并发处理能力</li>
</ul>
<p>GuavaCache类似CurrentHashMap，是线程安全的。提供了设置并发级别的api，使得缓存支持并发的写入和读取，采用分离锁机制，分离锁能够减小锁力度，提升并发能力，分离锁是分拆锁定，把一个集合看分成若干partition, 每个partiton一把锁。更新锁定</p>
<ul>
<li>防止缓存击穿</li>
</ul>
<p>一般情况下，在缓存中查询某个key，如果不存在，则查源数据，并回填缓存。（Cache Aside Pattern）在高并发下会出现，多次查源并重复回填缓存，可能会造成源的宕机（DB），性能下降 GuavaCache可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待。（相当于集成数据源，方便用户使用）</p>
<ul>
<li>监控缓存加载&#x2F;命中情况</li>
</ul>
<p>统计</p>
<p><strong>问题：</strong></p>
<p>​    OOM-&gt;设置过期时间、使用弱引用、配置过期策略</p>
<h4 id="5、EVCache"><a href="#5、EVCache" class="headerlink" title="5、EVCache"></a>5、EVCache</h4><p>EVCache是一个Netflflix（网飞）公司开源、快速的分布式缓存，是基于Memcached的内存存储实现的，用以构建超大容量、高性能、低延时、跨区域的全球可用的缓存数据层。</p>
<p>E：Ephemeral：数据存储是短暂的，有自身的存活时间</p>
<p>V：Volatile：数据可以在任何时候消失</p>
<p>EVCache典型地适合对强一致性没有必须要求的场合</p>
<p>典型用例：Netflflix向用户推荐用户感兴趣的电影</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmapdnh0yaj30ku0aigmc.jpg" alt="image-20210103185340548" style="zoom:50%;" />

<p><strong>EVCache集群</strong>在峰值每秒可以处理<strong>200kb</strong>的请求，</p>
<p>Netflflix生产系统中部署的EVCache经常要处理超过<strong>每秒3000万个</strong>请求，存储数十亿个对象，</p>
<p>跨数千台memcached服务器。整个EVCache集群<strong>每天处理近2万亿个</strong>请求。</p>
<p>EVCache集群响应平均延时大约是1-5毫秒，最多不会超过20毫秒。</p>
<p>EVCache集群的缓存命中率在99%左右。</p>
<p><strong>典型部署</strong></p>
<p>EVCache 是线性扩展的，可以在一分钟之内完成扩容，在几分钟之内完成负载均衡和缓存预热。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmapg99q8lj30ix0f3jrw.jpg" alt="image-20210103185611516" style="zoom:50%;" />

<p>1、集群启动时，EVCache向服务注册中心（Zookeeper、Eureka）注册各个实例</p>
<p>2、在web应用启动时，查询命名服务中的EVCache服务器列表，并建立连接。</p>
<p>3、客户端通过key使用一致性hash算法，将数据分片到集群上。</p>
<h4 id="6、ETCD"><a href="#6、ETCD" class="headerlink" title="6、ETCD"></a>6、ETCD</h4><p>​    <strong>和Zookeeper一样，CP模型追求数据一致性，</strong>越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它<strong>保存各节点信</strong>息，以便控制消费 MQ 的服务数量。还有些业务系统的<strong>配置数据</strong>，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的<strong>配置数据实时同步给秒杀 API 服务各节点</strong>。</p>
<p>![image-20210418174251742](&#x2F;Users&#x2F;suhongliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210418174251742.png)</p>
<div style="page-break-after: always;"></div>

<h3 id="Redis底层"><a href="#Redis底层" class="headerlink" title="Redis底层"></a>Redis底层</h3><h4 id="1、redis数据类型"><a href="#1、redis数据类型" class="headerlink" title="1、redis数据类型"></a>1、redis数据类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>底层</th>
<th>应用场景</th>
<th>编码类型</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>SDS数组</td>
<td>帖子、评论、热点数据、输入缓冲</td>
<td>RAW &lt;&lt; EMBSTR &lt;&lt; INT</td>
</tr>
<tr>
<td>List</td>
<td>QuickList</td>
<td>评论列表、商品列表、发布与订阅、慢查询、监视器</td>
<td>LINKEDLIST &lt;&lt; ZIPLIST</td>
</tr>
<tr>
<td>Set</td>
<td>intSet</td>
<td>适合交集、并集、查集操作，例如朋友关系</td>
<td>HT &lt;&lt; INSET</td>
</tr>
<tr>
<td>Zset</td>
<td>跳跃表</td>
<td>去重后排序，适合排名场景</td>
<td>SKIPLIST &lt;&lt; ZIPLIST</td>
</tr>
<tr>
<td>Hash</td>
<td>哈希</td>
<td>结构化数据，比如存储对象</td>
<td>HT &lt;&lt; ZIPLIST</td>
</tr>
<tr>
<td>Stream</td>
<td>紧凑列表</td>
<td>消息队列</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2、相关API"><a href="#2、相关API" class="headerlink" title="2、相关API"></a><strong>2、相关API</strong></h4><blockquote>
<p><a target="_blank" rel="noopener" href="http://redisdoc.com/">http://redisdoc.com</a></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>SET</td>
<td>SETNX</td>
<td>SETEX</td>
<td>GET</td>
<td>GETSET</td>
<td>INCR</td>
<td>DECR</td>
<td>MSET</td>
<td>MGET</td>
</tr>
<tr>
<td>Hash</td>
<td>HSET</td>
<td>HSETNX</td>
<td>HGET</td>
<td>HDEL</td>
<td>HLEN</td>
<td>HMSET</td>
<td>HMGET</td>
<td>HKEYS</td>
<td>HGETALL</td>
</tr>
<tr>
<td>LIST</td>
<td>LPUSH</td>
<td>LPOP</td>
<td>RPUSH</td>
<td>RPOP</td>
<td>LINDEX</td>
<td>LREM</td>
<td>LRANGE</td>
<td>LLEN</td>
<td>RPOPLPUSH</td>
</tr>
<tr>
<td>ZSET</td>
<td>ZADD</td>
<td>ZREM</td>
<td>ZSCORE</td>
<td>ZCARD</td>
<td>ZRANGE</td>
<td>ZRANK</td>
<td>ZREVRANK</td>
<td></td>
<td>ZREVRANGE</td>
</tr>
<tr>
<td>SET</td>
<td>SADD</td>
<td>SREM</td>
<td>SISMEMBER</td>
<td>SCARD</td>
<td>SINTER</td>
<td>SUNION</td>
<td>SDIFF</td>
<td>SPOP</td>
<td>SMEMBERS</td>
</tr>
<tr>
<td>事务</td>
<td>MULTI</td>
<td>EXEC</td>
<td>DISCARD</td>
<td>WATCH</td>
<td>UNWATCH</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="3、redis底层结构"><a href="#3、redis底层结构" class="headerlink" title="3、redis底层结构"></a>3、redis底层结构</h4><p><strong>SDS数组结构</strong>，用于存储字符串和整型数据及输入缓冲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123; </span><br><span class="line">  <span class="type">int</span> len;<span class="comment">//记录buf数组中已使用字节的数量 </span></span><br><span class="line">  <span class="type">int</span> free; <span class="comment">//记录 buf 数组中未使用字节的数量 </span></span><br><span class="line">  <span class="type">char</span> buf[];<span class="comment">//字符数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳跃表</strong>：将有序链表中的部分节点分层，每一层都是一个有序链表。</p>
<p>​    1、可以快速查找到需要的节点 O(logn) ，额外存储了一倍的空间</p>
<p>​    2、可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度。            </p>
<p><strong>字典dict:</strong> 又称散列表(hash)，是用来存储键值对的一种数据结构。 </p>
<p>​    Redis整个数据库是用字典来存储的(K-V结构) —Hash+数组+链表</p>
<p>​    Redis字典实现包括:**字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)**。</p>
<p>​    字典达到存储上限(阈值 0.75)，需要rehash(扩容)</p>
<p>​    1、初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。</p>
<p>​    2、rehashidx&#x3D;0表示要进行rehash操作。</p>
<p>​    3、新增加的数据在新的hash表h[1] 、修改、删除、查询在老hash表h[0]</p>
<p>​    4、将老的hash表h[0]的数据重新计算索引值后全部迁移到新的hash表h[1]中，这个过程称为 rehash。</p>
<p>​    <strong>渐进式rehash</strong></p>
<pre><code> 由于当数据量巨大时rehash的过程是非常缓慢的，所以需要进行优化。 可根据服务器空闲程度批量rehash部分节点
</code></pre>
<p><strong>压缩列表zipList</strong></p>
<p>​    压缩列表(ziplist)是由一系列特殊编码的连续内存块组成的顺序型数据结构，节省内容</p>
<p>​    <strong>sorted-set和hash元素个数少</strong>且是小整数或短字符串(直接使用) </p>
<p>​    list用快速链表(quicklist)数据结构存储，而<strong>快速链表是双向列表与压缩列表</strong>的组合。(间接使用)</p>
<p><strong>整数集合intSet</strong></p>
<p>​    整数集合(intset)是一个有序的(整数升序)、存储整数的连续存储结构。 </p>
<p>​    当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(2^64)，使用该结构体存储。</p>
<p><strong>快速列表quickList</strong></p>
<p>​    快速列表(quicklist)是Redis底层重要的数据结构。是Redis3.2列表的底层实现。</p>
<p>​    (在Redis3.2之前，Redis采 用双向链表(adlist)和压缩列表(ziplist)实现。)</p>
<p><strong>Redis Stream</strong>的底层主要使用了listpack(紧凑列表)和Rax树(基数树)。</p>
<p>​    <strong>listpack</strong>表示一个字符串列表的序列化，listpack可用于存储字符串或整数。用于存储stream的消息内 容。</p>
<p>​    <strong>Rax树</strong>是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操 作。</p>
<h4 id="4、Zset底层实现"><a href="#4、Zset底层实现" class="headerlink" title="4、Zset底层实现"></a>4、Zset底层实现</h4><p>​        跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度</p>
<p>​        Zset<strong>数据量少的时候使用压缩链表ziplist</strong>实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。 <strong>数据量大的时候使用跳跃列表skiplist和哈希表hash_map</strong>结合实现，查找删除插入的时间复杂度都是O(longN)</p>
<p>​        Redis使用跳表而不使用红黑树，是因为跳表的索引结构序列化和反序列化更加快速，方便持久化。</p>
<p><strong>搜索</strong></p>
<p>​        跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 <em>O(logN)，最坏 O(N) 。</em></p>
<p><strong>插入</strong></p>
<p>  选用链表作为底层结构支持，为了高效地动态增删。因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p>
<p><strong>删除</strong></p>
<p>  如果该节点还在索引中，删除时不仅要删除单链表中的节点，还要删除索引中的节点；单链表在知道删除的节点是谁时，时间复杂度为O(1)，但针对单链表来说，删除时都需要拿到前驱节点O(logN)才可改变引用关系从而删除目标节点。</p>
<div style="page-break-after: always;"></div>

<h3 id="Redis可用性"><a href="#Redis可用性" class="headerlink" title="Redis可用性"></a><strong>Redis可用性</strong></h3><h4 id="1、redis持久化"><a href="#1、redis持久化" class="headerlink" title="1、redis持久化"></a>1、redis持久化</h4><p>持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失</p>
<p>Redis 提供两种持久化机制 <strong>RDB（默认）</strong> 和 <strong>AOF 机制</strong>，Redis4.0以后采用混合持久化，用 AOF 来<strong>保证数据不丢失</strong>，作为数据恢复的第一选择; 用 RDB 来做不同程度的<strong>冷备</strong></p>
<p><strong>RDB：</strong>是Redis DataBase缩写快照</p>
<p>​        RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p>​    <strong>优点：</strong></p>
<p>​    1）只有一个文件 dump.rdb，方便持久化；</p>
<p>​    2）容灾性好，一个文件可以保存到安全的磁盘。</p>
<p>​    3）性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。</p>
<p>​    4）相对于数据集大时，比 AOF 的启动效率更高。</p>
<p>​    <strong>缺点：</strong></p>
<p>​    数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。</p>
<p><strong>AOF：持久化</strong></p>
<p>​        AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>​    <strong>优点：</strong></p>
<p>​    1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p>
<p>​    2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p>
<p><strong>缺点：</strong></p>
<p>​    1）AOF 文件比 RDB 文件大，且恢复速度慢。</p>
<p>​    2）数据集大的时候，比 rdb 启动效率低。</p>
<h4 id="2、redis事务"><a href="#2、redis事务" class="headerlink" title="2、redis事务"></a>2、redis事务</h4><p>​        事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p><strong>Redis事务的概念</strong></p>
<p>​        Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<p>Redis的事务总是具有ACID中的<strong>一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p><strong>事务命令：</strong></p>
<p><strong>MULTI：</strong>用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p>
<p><strong>EXEC：</strong>执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p>
<p><strong>WATCH ：</strong>是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。（<strong>秒杀场景</strong>）</p>
<p><strong>DISCARD：</strong>调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。</p>
<p><strong>UNWATCH</strong>：命令可以取消watch对所有key的监控。</p>
<h4 id="3、redis失效策略"><a href="#3、redis失效策略" class="headerlink" title="3、redis失效策略"></a>3、redis失效策略</h4><p><strong>内存淘汰策略</strong></p>
<p>1）全局的键空间选择性移除</p>
<p>​    <strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用）</p>
<p>​    <strong>allkeys-lru</strong>：在键空间中，移除最近最少使用的key。（缓存常用）</p>
<p>​    <strong>allkeys-random</strong>：在键空间中，随机移除某个key。</p>
<p>2）设置过期时间的键空间选择性移除</p>
<p>​    <strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</p>
<p>​    <strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。</p>
<p>​    <strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p>
<p><strong>缓存失效策略</strong></p>
<p>​    <strong>定时清除：</strong>针对每个设置过期时间的key都创建指定定时器</p>
<p>​    <strong>惰性清除：</strong>访问时判断，对内存不友好</p>
<p>​    <strong>定时扫描清除：</strong>定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除。</p>
<h4 id="4、redis读写模式"><a href="#4、redis读写模式" class="headerlink" title="4、redis读写模式"></a>4、redis读写模式</h4><p>​    <strong>CacheAside旁路缓存</strong></p>
<p>写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存</p>
<img src="https://img-blog.csdnimg.cn/20200806194316539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 15%;" />

<img src="https://img-blog.csdnimg.cn/20200806194300826.png" style="zoom: 15%;" />

<p>​    业务端处理所有数据访问细节，同时利用 <strong>Lazy 计算</strong>的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率</p>
<p>​    如果没有专门的存储服务，同时是对<strong>数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务</strong>，适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line">	redis.delKey(key);</span><br><span class="line">	db.updateData(data);</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高并发下保证绝对的一致，先删缓存再更新数据，需要用到<strong>内存队列做异步串行化</strong>。非高并发场景，先更新数据再删除缓存，<strong>延迟双删</strong>策略基本满足了</p>
<ul>
<li>先更新db后删除redis：删除redis失败则出现问题</li>
<li>先删redis后更新db：删除redis瞬间，旧数据被回填redis</li>
<li>先删redis后更新db休眠后删redis：同第二点，休眠后删除redis 可能宕机</li>
<li>java内部jvm队列：不适用分布式场景且降低并发</li>
</ul>
<p>​    <strong>Read&#x2F;Write Though</strong>（读写穿透）</p>
<p>​        <strong>先查询</strong>缓存中数据是否存在,如果存在则直接返回,如果<strong>不存在</strong>,则由<strong>缓存组件负责从数据库中同步加载数据.</strong></p>
<p>​    <img src="https://img-blog.csdnimg.cn/20200806194334623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /></p>
<p>​    先查询要<strong>写入的数据在缓存中</strong>是否已经存在,如果已经存在,则<strong>更新缓存中的数据</strong>，并且由<strong>缓存组件同步更新</strong>到数据库中。</p>
<p>​    <img src="https://img-blog.csdnimg.cn/20200806194346642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%" /></p>
<p>​    用户<strong>读操作</strong>较多.相较于Cache aside而言更适合缓存一致的场景。使用简单屏蔽了<strong>底层数据库的操作</strong>,只是操作缓存.</p>
<p><strong>场景：</strong></p>
<p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p>
<p>​    </p>
<p><strong>Write Behind Caching（异步缓存写入）</strong></p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorlsg74i6j31950e3dhs.jpg" alt="img" style="zoom:35%;" />

<p>比如对一些计数业务，一条 <strong>Feed 被点赞</strong> 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。</p>
<h4 id="5、多级缓存"><a href="#5、多级缓存" class="headerlink" title="5、多级缓存"></a>5、多级缓存</h4><p><strong>浏览器本地内存缓存：</strong>专题活动，一旦上线，在活动期间是不会随意变更的。</p>
<p><strong>浏览器本地磁盘缓存：</strong>Logo缓存，大图片懒加载</p>
<p><strong>服务端本地内存缓存：</strong>由于没有持久化，重启时必定会被穿透</p>
<p><strong>服务端网络内存缓存</strong>：Redis等，针对穿透的情况下可以继续分层，必须保证数据库不被压垮</p>
<p><strong>为什么不是使用服务器本地磁盘做缓存？</strong></p>
<p>​    当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 <strong>iowait</strong></p>
<div style="page-break-after: always;"></div>

<h3 id="Redis七大经典问题"><a href="#Redis七大经典问题" class="headerlink" title="Redis七大经典问题"></a>Redis七大经典问题</h3><h4 id="1、缓存雪崩"><a href="#1、缓存雪崩" class="headerlink" title="1、缓存雪崩"></a>1、缓存雪崩</h4><p>​        指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>​    <strong>解决方案：</strong></p>
<ul>
<li><p><strong>Redis 高可用</strong>，主从+哨兵，Redis cluster，避免全盘崩溃</p>
</li>
<li><p>本地 ehcache 缓存 + hystrix <strong>限流&amp;降级</strong>，避免 MySQL 被打死</p>
</li>
<li><p>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</p>
</li>
<li><p><strong>逻辑上永不过期</strong>给每一个缓存数据增加相应的<strong>缓存标记</strong>，缓存标记失效则更新数据缓存</p>
</li>
<li><p><strong>多级缓存</strong>，失效时通过二级更新一级，由第三方插件更新二级缓存。</p>
</li>
</ul>
<h4 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a><strong>2、缓存穿透</strong></h4><p>​        <a target="_blank" rel="noopener" href="https://blog.csdn.net/lin777lin/article/details/105666839">https://blog.csdn.net/lin777lin/article/details/105666839</a></p>
<p>​        缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>​    <strong>解决方案：</strong></p>
<p>​    1）<strong>接口层增加校验</strong>，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p>
<p>​    2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将<strong>key-value对写为key-null</strong>，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击；</p>
<p>​    3）采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人）</p>
<h4 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a><strong>3、缓存击穿</strong></h4><p>​        这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p>
<p>​    <strong>解决方案：</strong></p>
<p>​    1）设置<strong>热点数据永远不过期</strong>，异步线程处理。</p>
<p>​    2）加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</p>
<p>​    3）缓存预热</p>
<p>​        系统上线后，将相关<strong>可预期（例如排行榜）</strong>热点数据直接加载到缓存。</p>
<p>​        写一个缓存刷新页面，手动操作热点数据<strong>（例如广告推广）</strong>上下线。</p>
<h4 id="4、数据不一致"><a href="#4、数据不一致" class="headerlink" title="4、数据不一致"></a>4、数据不一致</h4><p>​    在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p>
<ul>
<li><p>Cache 更新失败后，可以进行重试，则将重试失败的 key 写入mq，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性</p>
</li>
<li><p>缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</p>
</li>
<li><p>不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</p>
</li>
</ul>
<h4 id="5、数据并发竞争"><a href="#5、数据并发竞争" class="headerlink" title="5、数据并发竞争"></a>5、数据并发竞争</h4><p>​    数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成并发竞争读取的问题。</p>
<ul>
<li>​    加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</li>
<li>​    对缓存数据保持多个备份，减少并发竞争的概率</li>
</ul>
<p>​    </p>
<h4 id="6、热点key问题"><a href="#6、热点key问题" class="headerlink" title="6、热点key问题"></a>6、热点key问题</h4><p>​    明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。</p>
<p>如何提前发现HotKey？</p>
<ul>
<li>对于重要节假日、线上促销活动这些提前已知的事情，可以提前评估出可能的热 key 来。</li>
<li>而对于突发事件，无法提前评估，可以<strong>通过 Spark，对应流任务进行实时分析</strong>，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载</p>
</li>
<li><p>缓存集群可以单节点进行主从复制和垂直扩容</p>
</li>
<li><p>利用应用内的前置缓存，但是需注意需要设置上限</p>
</li>
<li><p>延迟不敏感，定时刷新，实时感知用主动刷新</p>
</li>
<li><p>和缓存穿透一样，限制逃逸流量，单请求进行数据回源并刷新前置</p>
</li>
<li><p>无论如何设计，最后都要写一个兜底逻辑，千万级流量说来就来</p>
</li>
</ul>
<h4 id="7、BigKey问题"><a href="#7、BigKey问题" class="headerlink" title="7、BigKey问题"></a>7、BigKey问题</h4><p>​    比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key</p>
<ul>
<li>首先Redis底层数据结构里，根据Value的不同，会进行数据结构的重新选择</li>
<li>可以扩展新的数据结构，进行序列化构建，然后通过 restore 一次性写入</li>
<li>将大 key 分拆为多个 key，设置较长的过期时间</li>
</ul>
<div style="page-break-after: always;"></div>

<h3 id="Redis分区容错"><a href="#Redis分区容错" class="headerlink" title="Redis分区容错"></a>Redis分区容错</h3><h4 id="1、redis数据分区"><a href="#1、redis数据分区" class="headerlink" title="1、redis数据分区"></a><strong>1、redis数据分区</strong></h4><p><strong>Hash：（不稳定）</strong></p>
<p>​        客户端分片：哈希+取余</p>
<p>​        节点伸缩：数据节点关系变化，导致数据迁移</p>
<p>​        迁移数量和添加节点数量有关：建议翻倍扩容</p>
<p>​        一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。</p>
<p><strong>一致性Hash：（不均衡）</strong></p>
<p>​        客户端分片：哈希+顺时针（优化取余）</p>
<p>​        节点伸缩：只影响邻近节点，但是还是有数据迁移</p>
<p>​        翻倍伸缩：保证最小迁移数据和负载均衡</p>
<p>​        一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这又带来均匀性的问题，即使可以将存储节点等距排列，也会在<strong>存储节点个数变化时带来数据的不均匀</strong>。</p>
<p><strong>Codis的Hash槽</strong></p>
<p>​        Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p>
<p><strong>RedisCluster</strong></p>
<p>​        Redis-cluster把所有的物理节点映射到[0-16383]个<strong>slot</strong>上,对key采用crc16算法得到hash值后对16384取模，基本上采用平均分配和连续分配的方式。</p>
<h4 id="2、主从模式-x3D-简单"><a href="#2、主从模式-x3D-简单" class="headerlink" title="2、主从模式&#x3D;简单"></a><strong>2、主从模式&#x3D;简单</strong></h4><p>​    主从模式最大的优点是<strong>部署简单</strong>，最少<strong>两个节点便可以构成主从模式</strong>，并且可以通过<strong>读写分离避免读和写同时不可用</strong>。不过，一旦 Master 节点出现故障，主从节点就<strong>无法自动切换</strong>，直接导致 SLA 下降。所以，主从模式一般<strong>适合业务发展初期，并发量低，运维成本低</strong>的情况</p>
<img src="https://s0.lgstatic.com/i/image/M00/80/25/Ciqc1F_QgPOAaL8TAAC5EiNlvo4795.png" alt="Drawing 1.png" style="zoom:50%;" />



<p><strong>主从复制原理：</strong></p>
<p>​    ①通过从服务器发送到PSYNC命令给主服务器</p>
<p>​    ②如果是首次连接，触发一次<strong>全量复制</strong>。此时主节点会启动一个后台线程，生成 RDB 快照文件</p>
<p>​    ③主节点会将这个 RDB 发送给从节点，slave 会先写入本地磁盘，再从本地磁盘加载到内存中</p>
<p>​    ④master会将此过程中的写命令写入缓存，从节点<strong>实时同步</strong>这些数据</p>
<p>​    ⑤如果网络断开了连接，自动重连后主节点通过命令传播<strong>增量复制</strong>给从节点部分缺少的数据</p>
<p><strong>缺点</strong></p>
<p>​    所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决，redis4.0中引入psync2 解决了slave重启后仍然可以增量同步。</p>
<h4 id="3、哨兵模式-x3D-读多"><a href="#3、哨兵模式-x3D-读多" class="headerlink" title="3、哨兵模式&#x3D;读多"></a>3、<strong>哨兵模式</strong>&#x3D;读多</h4><p>​    由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;" />

<p>当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p>
<p><strong>检测主观下线状态</strong></p>
<p>​    Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命 令</p>
<p>​    实例在down-after-milliseconds毫秒内返回无效回复Sentinel就会认为该实例主观下线(<strong>SDown</strong>)</p>
<p><strong>检查客观下线状态</strong></p>
<p>​    当一个Sentinel将一个主服务器判断为主观下线后 ，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令</p>
<p>​    如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线(<strong>ODown</strong>)。</p>
<p><strong>选举Leader Sentinel</strong> </p>
<p>​    当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法(raft)，选出一个Leader Sentinel去执行**failover(故障转移)**操作。</p>
<p>​    <strong>Raft算法</strong></p>
<p>​    Raft协议是用来解决分布式系统一致性问题的协议。 Raft协议描述的节点共有三种状态:Leader, Follower, Candidate。 Raft协议将时间切分为一个个的Term(任期)，可以认为是一种“逻辑时间”。 选举流程:<br>     ①Raft采用心跳机制触发Leader选举系统启动后，全部节点初始化为Follower，term为0</p>
<p>​     ②节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份 </p>
<p>​     ③节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。 一旦转化为Candidate，该节点立即开始下面几件事情:<br>​        –增加自己的term，启动一个新的定时器<br>​        –给自己投一票，向所有其他节点发送RequestVote，并等待其他节点的回复。</p>
<p>​     ④如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时通过 AppendEntries，向其他节点发送通知。</p>
<p>​     ⑤每个节点在一个term内只能投一票，采取先到先得的策略，Candidate投自己， Follower会投给第一个收到RequestVote的节点。</p>
<p>​     ⑥Raft协议的定时器采取随机超时时间（选举的关键），先转为Candidate的节点会先发起投票，从而获得多数票。</p>
<p><strong>主服务器的选择</strong></p>
<p>​    当选举出Leader Sentinel后，Leader Sentinel会根据以下规则去从服务器中选择出新的主服务器。</p>
<ol>
<li>过滤掉主观、客观下线的节点</li>
<li>选择配置slave-priority最高的节点，如果有则返回没有就继续选择</li>
<li>选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整</li>
<li>选择run_id最小的节点，因为run_id越小说明重启次数越少</li>
</ol>
<p><strong>故障转移</strong></p>
<p>​    当Leader Sentinel完成新的主服务器选择后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步骤:</p>
<p>​    1、它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复制新的 Master ;</p>
<p>​    2、当客户端试图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群当前状态只有一个Master。</p>
<p>​    3、Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和 sentinel.conf 的配置文件的内容都会发生相应的改变，即 Master 主服务器的 redis.conf配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。</p>
<h4 id="4、集群模式-x3D-写多"><a href="#4、集群模式-x3D-写多" class="headerlink" title="4、集群模式&#x3D;写多"></a>4、集群模式&#x3D;写多</h4><p>​    为了避免单一节点负载过高导致不稳定，集群模式采用<strong>一致性哈希算法或者哈希槽的方法</strong>将 Key 分布到各个节点上。其中，每个 Master 节点后跟若干个 Slave 节点，用于<strong>出现故障时做主备切换</strong>，客户端可以<strong>连接任意 Master 节点</strong>，集群内部会按照<strong>不同 key 将请求转发到不同的 Master</strong> 节点</p>
<p>​    集群模式是如何实现高可用的呢？集群内部节点之间会<strong>互相定时探测</strong>对方是否存活，如果多数节点判断某个节点挂了，则会将其踢出集群，然后从 <strong>Slave</strong> 节点中选举出一个节点<strong>替补</strong>挂掉的 Master 节点。<strong>整个原理基本和哨兵模式一致</strong></p>
<p>​    虽然集群模式避免了 Master 单节点的问题，但<strong>集群内同步数据时会占用一定的带宽</strong>。所以，只有在<strong>写操作比较多的情况下人们才使用集群模式</strong>，其他大多数情况，使用<strong>哨兵模式</strong>都能满足需求</p>
<h4 id="5、分布式锁"><a href="#5、分布式锁" class="headerlink" title="5、分布式锁"></a>5、分布式锁</h4><p><strong>利用Watch实现Redis乐观锁</strong></p>
<p>​    乐观锁基于CAS(Compare And Swap)比较并替换思想，不会产生锁等待而消耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实现乐观锁<strong>（秒杀）</strong>。具体思路如下:</p>
<p>1、利用redis的watch功能，监控这个redisKey的状态值<br>2、获取redisKey的值，创建redis事务，给这个key的值+1<br>3、执行这个事务，如果key的值被修改过则回滚，key不加1</p>
<p><strong>利用setnx防止库存超卖</strong><br>    分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁推荐使用set的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId); <span class="comment">//如线程死掉，其他线程无法获取到锁</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁，非原子操作，可能会释放其他线程刚加上的锁</span></span><br><span class="line"><span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">  jedis.del(lockKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐使用redis+lua脚本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lua</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua, Collections.singletonList(lockKey),</span><br></pre></td></tr></table></figure>



<p><strong>分布式锁存在的问题</strong>：</p>
<ul>
<li><strong>客户端长时间阻塞导致锁失效问题</strong></li>
</ul>
<p>​    计算时间内异步启动另外一个线程去检查的问题，这个key是否超时，当锁超时时间快到期且逻辑未执行完，延长锁超时时间。</p>
<ul>
<li><p>**Redis服务器时钟漂移问题导致同时加锁<br>redis的过期时间是依赖系统时钟的，如果时钟漂移过大时 理论上是可能出现的 **会影响到过期时间的计算。</p>
</li>
<li><p><strong>单点实例故障，锁未及时同步导致丢失</strong></p>
<p><strong>RedLock算法</strong></p>
</li>
</ul>
<ol>
<li><p>获取当前时间戳T0，配置时钟漂移误差T1</p>
</li>
<li><p>短时间内逐个获取全部N&#x2F;2+1个锁，结束时间点T2</p>
</li>
<li><p>实际锁能使用的处理时长变为：TTL - （T2 - T0）- T1</p>
<p>该方案通过多节点来<strong>防止Redis的单点故障</strong>，效果一般，也无法防止：</p>
</li>
</ol>
<ul>
<li><p><strong>主从切换导致的两个客户端同时持有锁</strong></p>
<p>大部分情况下<strong>持续时间极短</strong>，而且使用<strong>Redlock在切换的瞬间</strong>获取到节点的锁，也存在问题。已经是极低概率的时间，无法避免。<strong>Redis分布式锁适合幂等性事务</strong>，如果一定要<strong>保证安全</strong>，应该<strong>使用Zookeeper或者DB</strong>，但是，<strong>性能会急剧下降</strong>。</p>
</li>
</ul>
<p><strong>与zookeeper分布式锁对比</strong></p>
<ul>
<li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li>
<li>zk 分布式锁，注册个监听器即可，不需要不断主动尝试获取锁，ZK获取锁会按照加锁的顺序，所以是公平锁，性能和mysql差不多，和redis差别大</li>
</ul>
<p><strong>Redission生产环境的分布式锁</strong></p>
<p>​    Redisson是基于NIO的Netty框架上的一个Java驻内存数据网格(In-Memory Data Grid)分布式锁开源组件。 </p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glurlfrrp4j30qk0g876c.jpg" alt="image-20201221000119586" style="zoom:67%;" />

<p>但当业务必须要数据的强一致性，即不允许重复获得锁，比如金融场景(重复下单，重复转账)，<strong>请不要使用redis分布式锁</strong>。可以使用CP模型实现，比如:<strong>zookeeper和etcd。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>zookeeper</th>
<th>etcd</th>
</tr>
</thead>
<tbody><tr>
<td>一致性算法</td>
<td>无</td>
<td>paxos(ZAB)</td>
<td>raft</td>
</tr>
<tr>
<td>CAP</td>
<td>AP</td>
<td>CP</td>
<td>CP</td>
</tr>
<tr>
<td>高可用</td>
<td>主从集群</td>
<td>n+1</td>
<td>n+1</td>
</tr>
<tr>
<td>实现</td>
<td>setNX</td>
<td>createNode</td>
<td>restfulAPI</td>
</tr>
</tbody></table>
<h4 id="6、redis心跳检测"><a href="#6、redis心跳检测" class="headerlink" title="6、redis心跳检测"></a>6、redis心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送ACK命令:</p>
<p>​    1、检测主从的连接状态 检测主从服务器的网络连接状态</p>
<p>​            lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有 故障。</p>
<p>​    2、辅助实现min-slaves,Redis可以通过配置防止主服务器在不安全的情况下执行写命令</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">min-slaves-to-write</span> <span class="number">3</span> <span class="string">(min-replicas-to-write</span> <span class="number">3</span> <span class="string">)</span></span><br><span class="line"></span><br><span class="line"><span class="string">min-slaves-max-lag</span> <span class="number">10</span> <span class="string">(min-replicas-max-lag</span> <span class="number">10</span><span class="string">)</span></span><br></pre></td></tr></table></figure>

<p>​        上面的配置表示:从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10 秒时，主服务器将拒绝执行写命令。</p>
<p>​    3、检测命令丢失，增加重传机制</p>
<p>​        如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发 送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量， 然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<div style="page-break-after: always;"></div>

<h3 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h3><h4 id="1、Redis优化"><a href="#1、Redis优化" class="headerlink" title="1、Redis优化"></a>1、Redis优化</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorm5m7b4gj30uy0hjwfp.jpg" alt="img"></p>
<p><strong>读写方式</strong><br>    简单来说就是不用<strong>keys</strong>等，用<strong>range、contains</strong>之类。比如，用户粉丝数，大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表只能部分获取。另外在判断某用户是否关注了另外一个用户时，也只需要关注列表上进行检查判断，然后返回 True&#x2F;False 或 0&#x2F;1 的方式更为高效。</p>
<p><strong>KV size</strong><br>    如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。拆分时应<strong>考虑访问频率</strong></p>
<p><strong>key 的数量</strong><br>    如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</p>
<p><strong>读写峰值</strong><br>    如果小于 10万 级别，简单分拆到独立 Cache 池即可<br>    如果达到 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。<strong>（多级缓存）</strong></p>
<p><strong>命中率</strong><br>    缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache（<strong>热点资讯</strong>），常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p>
<p><strong>过期策略</strong></p>
<p>​    可以设置较短的过期时间，让冷 key 自动过期；也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。</p>
<p><strong>缓存穿透时间</strong><br>    平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。</p>
<p><strong>缓存可运维性</strong><br>    对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p>
<p><strong>缓存安全性</strong><br>    对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时加密鉴权访问。</p>
<h4 id="2、Redis热升级"><a href="#2、Redis热升级" class="headerlink" title="2、Redis热升级"></a>2、Redis热升级</h4><blockquote>
<p>在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。面对这种问题，可以对 Redis 扩展热升级功能，从而在毫秒级完成升级操作，完全不影响业务访问。</p>
</blockquote>
<p>热升级方案如下，首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 redis-4.so 到 redis-5.so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。</p>
<h1 id="六、Kafka篇"><a href="#六、Kafka篇" class="headerlink" title="六、Kafka篇"></a>六、Kafka篇</h1><h3 id="Why-kafka"><a href="#Why-kafka" class="headerlink" title="Why kafka"></a>Why kafka</h3><p>消息队列的作用：<strong>异步、削峰填谷、解耦</strong></p>
<p><strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 <strong>RabbitMQ</strong> （开源、社区活跃）是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 <strong>RocketMQ</strong>（Java二次开发） 是很好的选择。</p>
<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 <strong>Kafka</strong> 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfiyienm0j30zu0hago7.jpg" alt="image-20210107225921930" style="zoom:50%;" />



<p><strong>RabbitMQ</strong></p>
<p>RabbitMQ开始是用在电信业务的可靠通信的，也是少有的几款<strong>支持AMQP</strong>协议的产品之一。</p>
<p><strong>优点：</strong></p>
<ul>
<li>轻量级，快速，部署使用方便</li>
<li>支持灵活的路由配置。RabbitMQ中，在生产者和队列之间有一个交换器模块。根据配置的路由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。</li>
<li>RabbitMQ的客户端支持大多数的编程语言，支持<strong>AMQP</strong>协议。</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfjicxzb2j30u80hx0uw.jpg" alt="image-20210107231826261" style="zoom:40%;" />

<p><strong>缺点：</strong></p>
<ul>
<li>如果有大量消息堆积在队列中，性能会急剧下降</li>
<li>每秒处理几万到几十万的消息。如果应用要求高的性能，不要选择RabbitMQ。 </li>
<li>RabbitMQ是Erlang开发的，功能扩展和二次开发代价很高。</li>
</ul>
<p><strong>RocketMQ</strong></p>
<p>借鉴了Kafka的设计并做了很多改进，<strong>几乎具备了消息队列应该具备的所有特性和功能</strong>。</p>
<ul>
<li>RocketMQ主要用于有序，事务，流计算，消息推送，日志流处理，binlog分发等场景。</li>
<li>经过了历次的双11考验，性能，稳定性可靠性没的说。</li>
<li>java开发，阅读源代码、扩展、二次开发很方便。</li>
<li>对电商领域的响应延迟做了很多优化。</li>
<li>每秒处理几十万的消息，同时响应在毫秒级。如果应用很关注响应时间，可以使用RocketMQ。</li>
<li>性能比RabbitMQ高一个数量级，。</li>
<li>支持死信队列，DLX 是一个非常有用的特性。它可以处理<strong>异常情况下，消息不能够被消费者正确消费而被置入死信队列中</strong>的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以<strong>改善和优化系统</strong>。</li>
</ul>
<p><strong>缺点</strong>：</p>
<p>​    跟周边系统的整合和兼容不是很好。</p>
<p><strong>Kafka</strong></p>
<p><strong>高可用</strong>，几乎所有相关的开源软件都支持，满足大多数的应用场景，尤其是<strong>大数据和流计算</strong>领域，</p>
<ul>
<li>Kafka高效，可伸缩，消息持久化。支持分区、副本和容错。</li>
<li>对批处理和异步处理做了大量的设计，因此Kafka可以得到非常高的性能。</li>
<li>每秒处理几十万异步消息消息，如果开启了压缩，最终可以达到每秒处理2000w消息的级别。</li>
<li>但是由于是异步的和批处理的，延迟也会高，不适合电商场景。</li>
</ul>
<h3 id="What-Kafka"><a href="#What-Kafka" class="headerlink" title="What Kafka"></a>What Kafka</h3><ul>
<li>Producer API：允许应用程序将记录流发布到一个或多个Kafka主题。</li>
<li>Consumer API：允许应用程序订阅一个或多个主题并处理为其生成的记录流。</li>
<li>Streams API：允许应用程序充当流处理器，将输入流转换为输出流。</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gme95cirjfj31000kb41j.jpg" alt="image-20210106203420526" style="zoom: 40%;" />



<p><strong>消息Message</strong></p>
<p>​    Kafka的数据单元称为消息。可以把消息看成是数据库里的一个“数据行”或一条“记录”。</p>
<p><strong>批次</strong></p>
<p>​    为了提高效率，消息被分批写入Kafka。提高吞吐量却加大了响应时间</p>
<p><strong>主题Topic</strong></p>
<p>​    通过主题进行分类，类似数据库中的表，</p>
<p><strong>分区Partition</strong></p>
<p>​    Topic可以被分成若干分区分布于kafka集群中，方便扩容</p>
<p>​    单个分区内是有序的，partition设置为一才能保证全局有序</p>
<p><strong>副本Replicas</strong></p>
<p>​    每个主题被分为若干个分区，每个分区有多个副本。</p>
<p><strong>生产者Producer</strong></p>
<p>​    生产者在默认情况下把<strong>消息均衡地分布</strong>到主题的所有分区上：</p>
<ul>
<li>直接指定消息的分区</li>
<li>根据消息的key散列取模得出分区</li>
<li>轮询指定分区。</li>
</ul>
<p><strong>消费者Comsumer</strong></p>
<p>​    消费者通过<strong>偏移量</strong>来区分已经读过的消息，从而消费消息。把每个分区最后读取的消息偏移量保存在Zookeeper 或Kafka上，如果消费者关闭或重启，它的<strong>读取状态不会丢失</strong>。</p>
<p><strong>消费组ComsumerGroup</strong></p>
<p>​    消费组保证<strong>每个分区只能被一个消费者</strong>使用，避免重复消费。如果群组内一个<strong>消费者失效</strong>，消费组里的其他消费者可以<strong>接管失效消费者的工作再平衡</strong>，重新分区</p>
<p><strong>节点Broker</strong></p>
<p>​    连接生产者和消费者，<strong>单个</strong>broker<strong>可以轻松处理</strong>数千个分区<strong>以及</strong>每秒百万级的消息量。</p>
<ul>
<li>broker接收来自生产者的消息，为消息设置偏移量，并提交<strong>消息到磁盘保存</strong>。</li>
<li>broker为消费者提供服务，响应读取分区的请求，<strong>返回已经提交到磁盘上的消息</strong>。</li>
</ul>
<p><strong>集群</strong></p>
<p>​    每隔分区都有一个<strong>首领</strong>，当分区被分配给多个broker时，会通过首领进行<strong>分区复制</strong>。    </p>
<p><strong>生产者Offset</strong></p>
<p>​    消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。</p>
<p><strong>消费者Offset</strong></p>
<p>​    不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响</p>
<p><strong>LogSegment</strong></p>
<ul>
<li>一个分区由多个LogSegment组成，</li>
<li>一个LogSegment由<code>.log .index .timeindex</code>组成</li>
<li><code>.log</code>追加是顺序写入的，文件名是以文件中第一条message的offset来命名的</li>
<li><code>.Index</code>进行日志删除的时候和数据查找的时候可以快速定位。</li>
<li><code>.timeStamp</code>则根据<strong>时间戳查找对应的偏移量</strong>。</li>
</ul>
<h3 id="How-Kafka"><a href="#How-Kafka" class="headerlink" title="How Kafka"></a>How Kafka</h3><p><strong>优点</strong></p>
<ul>
<li><strong>高吞吐量</strong>：单机每秒处理几十上百万的消息量。即使存储了TB及消息，也保持稳定的性能。<ul>
<li><strong>零拷贝</strong> 减少内核态到用户态的拷贝，磁盘通过sendfile实现<strong>DMA</strong> 拷贝Socket buffer</li>
<li><strong>顺序读写</strong> 充分利用磁盘顺序读写的超高性能</li>
<li><strong>页缓存mmap</strong>，将磁盘文件<strong>映射</strong>到内存, 用户通过修改内存就能修改磁盘文件。</li>
</ul>
</li>
<li><strong>高性能</strong>：单节点支持上千个客户端，并保证零停机和零数据丢失。</li>
<li><strong>持久化</strong>：将消息持久化到磁盘。通过将数据持久化到硬盘以及replication防止数据丢失。</li>
<li><strong>分布式系统</strong>，易扩展。所有的组件均为分布式的，无需停机即可扩展机器。</li>
<li><strong>可靠性</strong> - Kafka是分布式，分区，复制和容错的。</li>
<li><strong>客户端状态维护</strong>：消息被处理的状态是在Consumer端维护，当失败时能自动平衡。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>日志收集：</strong>用Kafka可以收集各种服务的Log，通过大数据平台进行处理；</li>
<li><strong>消息系统：</strong>解耦生产者和消费者、缓存消息等；</li>
<li><strong>用户活动跟踪：</strong>Kafka经常被用来记录Web用户或者App用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到Kafka的Topic中，然后消费者通过订阅这些Topic来做<strong>运营数据</strong>的实时的监控分析，也可保存到数据库；</li>
</ul>
<h3 id="生产消费基本流程"><a href="#生产消费基本流程" class="headerlink" title="生产消费基本流程"></a><strong>生产消费基本流程</strong></h3><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmeb1cw09gj313m0kgwgb.jpg" alt="image-20210106213944461" style="zoom:40%;" />

<ol>
<li><p>Producer创建时，会创建一个Sender线程并设置为守护线程。</p>
</li>
<li><p>生产的消息先经过拦截器-&gt;序列化器-&gt;分区器，然后将消息缓存在缓冲区。</p>
</li>
<li><p>批次发送的条件为：缓冲区数据大小达到<strong>batch.size</strong>或者<strong>linger.ms</strong>达到上限。</p>
</li>
<li><p>批次发送后，发往指定分区，然后落盘到broker；</p>
<ul>
<li><p><strong>acks&#x3D;0</strong>只要将消息放到缓冲区，就认为消息已经发送完成。</p>
</li>
<li><p><strong>acks&#x3D;1</strong>表示消息<strong>只需要写到主分区</strong>即可。在该情形下，如果主分区收到消息确认之后就宕机了，而副本分区还没来得及同步该消息，则该消息丢失。</p>
</li>
<li><p><strong>acks&#x3D;all （默认）</strong>首领分区会等待<strong>所有的ISR副本分区确认记录</strong>。该处理保证了只要有一个ISR副本分区存活，消息就不会丢失。</p>
</li>
</ul>
</li>
<li><p>如果生产者配置了<strong>retrires参数大于0并且未收到确认</strong>，那么客户端会对该消息进行重试。</p>
</li>
<li><p>落盘到broker成功，返回生产元数据给生产者。</p>
</li>
</ol>
<p><strong>Leader选举</strong></p>
<ul>
<li><p>Kafka会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica）的集合</p>
</li>
<li><p>当集合中副本都跟Leader中的副本同步了之后，kafka才会认为消息已提交</p>
</li>
<li><p>只有这些跟Leader保持同步的Follower才应该被选作新的Leader</p>
</li>
<li><p>假设某个topic有N+1个副本，kafka可以容忍N个服务器不可用，冗余度较低</p>
<p>如果ISR中的副本都丢失了，则：</p>
<ul>
<li>可以等待ISR中的副本任何一个恢复，接着对外提供服务，需要时间等待</li>
<li>从OSR中选出一个副本做Leader副本，此时会造成数据丢失</li>
</ul>
</li>
</ul>
<p><strong>副本消息同步</strong></p>
<p>​    首先，Follower 发送 FETCH 请求给 Leader。接着，Leader 会读取底层日志文件中的消 息数据，再更新它内存中的 Follower 副本的 LEO 值，更新为 FETCH 请求中的 fetchOffset 值。最后，尝试更新分区高水位值。Follower 接收到 FETCH 响应之后，会把消息写入到底层日志，接着更新 LEO 和 HW 值。</p>
<p><strong>相关概念</strong>：<strong>LEO</strong>和<strong>HW</strong>。</p>
<ul>
<li>LEO：即日志末端位移(log end offset)，记录了该副本日志中下一条消息的位移值。如果LEO&#x3D;10，那么表示该副本保存了10条消息，位移值范围是[0, 9]</li>
<li>HW：水位值HW（high watermark）即已备份位移。对于同一个副本对象而言，其HW值不会大于LEO值。小于等于HW值的所有消息都被认为是“已备份”的（replicated）</li>
</ul>
<p><strong>Rebalance</strong></p>
<ul>
<li>组成员数量发生变化</li>
<li>订阅主题数量发生变化</li>
<li>订阅主题的分区数发生变化</li>
</ul>
<p>leader选举完成后，当以上三种情况发生时，Leader根据配置的<strong>RangeAssignor</strong>开始分配消费方案，即哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案封装进<strong>SyncGroup</strong>请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。coordinator接收到分配方案之后会把方案塞进SyncGroup的response中发给各个consumer。这样组内的所有成员就都知道自己应该消费哪些分区了。</p>
<p><strong>分区分配算法RangeAssignor</strong></p>
<ul>
<li><p>原理是按照消费者总数和分区总数进行整除运算平均分配给所有的消费者。</p>
</li>
<li><p>订阅Topic的消费者按照名称的字典序排序，分均分配，剩下的字典序从前往后分配</p>
</li>
</ul>
<p><strong>增删改查</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --create --topic topic_x </span><br><span class="line">								--partitions 1 --replication-factor 1</span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --delete --topic topic_x</span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --alter --topic topic_x</span><br><span class="line">								--config max.message.bytes=1048576</span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka --describe --topic topic_x</span><br></pre></td></tr></table></figure>

<p><strong>如何查看偏移量为23的消息？</strong></p>
<p>通过查询跳跃表<code>ConcurrentSkipListMap</code>，定位到在00000000000000000000.index ，通过二分法在偏移量索引文件中找到不大于 23 的<strong>最大索引项</strong>，即offset 20 那栏，然后从日志分段文件中的物理位置为320 开始顺序查找偏移量为 23 的消息。</p>
<img src="https://img-blog.csdnimg.cn/20191230225447849.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjMzNzA2,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />





<p><strong>切分文件</strong></p>
<ul>
<li><strong>大小分片</strong> 当前日志分段文件的大小超过了 broker 端参数 <code>log.segment.bytes</code> 配置的值</li>
<li><strong>时间分片</strong> 当前日志分段中消息的最大时间戳与系统的时间戳的差值大于<code>log.roll.ms</code>配置的值</li>
<li><strong>索引分片</strong> 偏移量或时间戳索引文件大小达到broker端 <code>log.index.size.max.bytes</code>配置的值</li>
<li><strong>偏移分片</strong> 追加的消息的偏移量与当前日志分段的偏移量之间的差值大于 Integer.MAX_VALUE</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><strong>幂等性</strong></p>
<p>保证在消息重发的时候，消费者不会重复处理。即使在<strong>消费者收到重复消息的时候，重复处理</strong>，也</p>
<p>要<strong>保证最终结果的一致性</strong>。所谓幂等性，数学概念就是： f(f(x)) &#x3D; f(x) </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmefdeas1vj315i0bgmya.jpg" alt="image-20210107000942286"></p>
<p><strong>如何实现？</strong></p>
<p>​    添加唯一ID，类似于数据库的主键，用于唯一标记一个消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProducerID：<span class="comment">#在每个新的Producer初始化时，会被分配一个唯一的PID</span></span><br><span class="line">SequenceNumber：<span class="comment">#对于每个PID发送数据的每个Topic都对应一个从0开始单调递增的SN值</span></span><br></pre></td></tr></table></figure>

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmefjpeet8j317e0cgmyp.jpg" alt="image-20210107001546404" style="zoom:80%;" />

<p><strong>如何选举</strong></p>
<ol>
<li>使用 Zookeeper 的<strong>分布式锁选举控制器</strong>，并在节点加入集群或退出集群时通知控制器。</li>
<li>控制器负责在节点加入或离开集群时进行分区Leader选举。</li>
<li>控制器使用epoch<code>忽略小的纪元</code>来避免<strong>脑裂</strong>：两个节点同时认为自己是当前的控制器。</li>
</ol>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ul>
<li>创建Topic的时候可以指定 –replication-factor 3 ，表示不超过broker的副本数</li>
<li>只有Leader是负责读写的节点，Follower定期地到Leader上Pull数据。</li>
<li>ISR是Leader负责维护的与其保持同步的Replica列表，即当前活跃的副本列表。如果一个Follow落后太多，Leader会将它从ISR中移除。选举时优先从ISR中挑选Follower。 </li>
<li>设置 acks&#x3D;all 。Leader收到了ISR中所有Replica的ACK，才向Producer发送ACK。</li>
</ul>
<div style="page-break-after: always;"></div>

<h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="线上问题rebalance"><a href="#线上问题rebalance" class="headerlink" title="线上问题rebalance"></a><strong>线上问题rebalance</strong></h4><blockquote>
<p>因集群架构变动导致的消费组内重平衡，如果kafka集内节点较多，比如数百个，那重平衡可能会耗时导致<strong>数分钟到数小时</strong>，此时kafka基本处于不可用状态，对kafka的TPS影响极大</p>
</blockquote>
<p>产生的原因：</p>
<ul>
<li><p>组成员数量发生变化</p>
</li>
<li><p>订阅主题数量发生变化</p>
</li>
<li><p>订阅主题的分区数发生变化</p>
<p><strong>组成员崩溃和组成员主动离开是两个不同的场景。</strong>因为在崩溃时成员并不会主动地告知coordinator此事，coordinator有可能需要一个完整的session.timeout周期(心跳周期)才能检测到这种崩溃，这必然会造成consumer的滞后。可以说离开组是主动地发起rebalance；而崩溃则是被动地发起rebalance。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooe9o07fvj30p00btju1.jpg" alt="img"></p>
</li>
</ul>
<p>解决方案：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">加大超时时间</span> <span class="string">session.timout.ms=6s</span></span><br><span class="line"><span class="attr">加大心跳频率</span> <span class="string">heartbeat.interval.ms=2s</span></span><br><span class="line"><span class="attr">增长推送间隔</span> <span class="string">max.poll.interval.ms=t+1 minutes</span></span><br></pre></td></tr></table></figure>



<h4 id="ZooKeeper-的作用"><a href="#ZooKeeper-的作用" class="headerlink" title="ZooKeeper 的作用"></a>ZooKeeper 的作用</h4><p>目前，Kafka 使用 ZooKeeper 存放集群元数据、成员管理、Controller 选举，以及其他一些管理类任务。之后，等 KIP-500 提案完成后，Kafka 将完全不再依赖于 ZooKeeper。</p>
<ul>
<li><strong>存放元数据</strong>是指主题分区的所有数据都保存在 ZooKeeper 中，其他“人”都要与它保持对齐。</li>
<li><strong>成员管理</strong>是指 Broker 节点的注册、注销以及属性变更等 。</li>
<li><strong>Controller 选举</strong>是指选举集群 Controller，包括但不限于主题删除、参数配置等。</li>
</ul>
<p>一言以蔽之:<strong>KIP-500 ，是使用社区自研的基于 Raft 的共识算法，实现 Controller 自选举</strong>。</p>
<p>同样是存储元数据，这几年<strong>基于Raft算法的etcd</strong>认可度越来越高</p>
<p>​    越来越多的系统开始用它保存关键数据。比如，<strong>秒杀系统经常用它保存各节点信息</strong>，以便控制消费 MQ 的服务数量。还有些<strong>业务系统的配置数据</strong>，也会通过 etcd 实时<strong>同步给业务系统的各节点</strong>，比如，秒杀管理后台会使用 etcd 将<strong>秒杀活动的配置数据实时同步给秒杀 API 服务各节点</strong>。</p>
<h4 id="Replica副本的作用"><a href="#Replica副本的作用" class="headerlink" title="Replica副本的作用"></a>Replica副本的作用</h4><p><strong>Kafka 只有 Leader 副本才能 对外提供读写服务，响应 Clients 端的请求。Follower 副本只是采用拉(PULL)的方 式，被动地同步 Leader 副本中的数据，并且在 Leader 副本所在的 Broker 宕机后，随时准备应聘 Leader 副本。</strong></p>
<ul>
<li><strong>自 Kafka 2.4 版本开始</strong>，社区可以通过配置参数，允许 Follower 副本有限度地提供读服务。</li>
<li>之前确保一致性的主要手段是高水位机制， 但高水位值无法保证 Leader 连续变更场景下的数据一致性，因此，社区引入了 <strong>Leader Epoch</strong> 机制，来修复高水位值的弊端。</li>
</ul>
<h4 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="headerlink" title="为什么不支持读写分离?"></a>为什么不支持读写分离?</h4><ul>
<li><p><strong>自 Kafka 2.4 之后</strong>，Kafka 提供了有限度的读写分离。</p>
</li>
<li><p><strong>场景不适用</strong>。读写分离适用于那种读负载很大，而写操作相对不频繁的场景。</p>
</li>
<li><p><strong>同步机制</strong>。Kafka 采用 PULL 方式实现 Follower 的同步，同时复制延迟较大。</p>
</li>
</ul>
<h4 id="如何防止重复消费"><a href="#如何防止重复消费" class="headerlink" title="如何防止重复消费"></a>如何防止重复消费</h4><ul>
<li>代码层面每次消费需提交offset</li>
<li>通过Mysql的<strong>唯一键约束</strong>，结合Redis查看<strong>id是否被消费</strong>，存Redis可以直接使用set方法</li>
<li>量大且允许误判的情况下，使用布隆过滤器也可以</li>
</ul>
<h4 id="如何保证数据不会丢失"><a href="#如何保证数据不会丢失" class="headerlink" title="如何保证数据不会丢失"></a><strong>如何保证数据不会丢失</strong></h4><ul>
<li><strong>生产者</strong>生产消息可以通过comfirm配置<strong>ack&#x3D;all</strong>解决</li>
<li><strong>Broker</strong>同步过程中leader宕机可以通过配置<strong>ISR副本+重试</strong>解决</li>
<li><strong>消费者</strong>丢失可以<strong>关闭自动提交</strong>offset功能，系统处理完成时提交offset</li>
</ul>
<h4 id="如何保证顺序消费"><a href="#如何保证顺序消费" class="headerlink" title="如何保证顺序消费"></a><strong>如何保证顺序消费</strong></h4><ul>
<li>单 topic，单partition，单 consumer，单线程消费，吞吐量低，不推荐</li>
<li><strong>如只需保证单key有序</strong>，为每个key申请单独内存 queue，每个线程分别消费一个内存 queue 即可，这样就能保证单key（例如用户id、活动id）顺序性。</li>
</ul>
<h4 id="【线上】如何解决积压消费"><a href="#【线上】如何解决积压消费" class="headerlink" title="【线上】如何解决积压消费"></a>【线上】如何解决积压消费</h4><ul>
<li><strong>修复consumer</strong>，使其具备消费能力，并且扩容N台</li>
<li>写一个<strong>分发的程序</strong>，将Topic均匀分发到临时Topic中</li>
<li>同时<strong>起N台consumer</strong>，消费不同的<strong>临时Topic</strong></li>
</ul>
<h4 id="如何避免消息积压"><a href="#如何避免消息积压" class="headerlink" title="如何避免消息积压"></a>如何避免消息积压</h4><ul>
<li>提高消费并行度</li>
<li>批量消费</li>
<li>减少组件IO的交互次数</li>
<li>优先级消费</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxOffset - curOffset &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO 消息堆积情况的优先处理逻辑</span></span><br><span class="line">  <span class="comment">// 未处理的消息可以选择丢弃或者打日志</span></span><br><span class="line">  <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO 正常消费过程</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br></pre></td></tr></table></figure>



<h4 id="如何设计消息队列"><a href="#如何设计消息队列" class="headerlink" title="如何设计消息队列"></a>如何设计消息队列</h4><p>需要支持快速水平扩容，broker+partition，partition放不同的机器上，增加机器时将数据根据topic做迁移，分布式需要考虑一致性、可用性、分区容错性</p>
<ul>
<li><strong>一致性：</strong>生产者的消息确认、消费者的幂等性、Broker的数据同步</li>
<li><strong>可用性：</strong>数据如何保证不丢不重、数据如何持久化、持久化时如何读写</li>
<li><strong>分区容错：</strong>采用何种选举机制、如何进行多副本同步</li>
<li><strong>海量数据：</strong>如何解决消息积压、海量Topic性能下降</li>
</ul>
<p>性能上，可以借鉴<strong>时间轮、零拷贝、IO多路复用、顺序读写、压缩批处理</strong></p>
<h1 id="七、Spring篇"><a href="#七、Spring篇" class="headerlink" title="七、Spring篇"></a>七、Spring篇</h1><h3 id="设计思想-amp-Beans"><a href="#设计思想-amp-Beans" class="headerlink" title="设计思想&amp;Beans"></a>设计思想&amp;Beans</h3><h4 id="1、IOC-控制反转"><a href="#1、IOC-控制反转" class="headerlink" title="1、IOC 控制反转"></a><strong>1、IOC 控制反转</strong></h4><p>​        IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 </p>
<p>​        IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</p>
<p><strong>DI 依赖注入</strong></p>
<p>​    DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。</p>
<h4 id="2、AOP-动态代理"><a href="#2、AOP-动态代理" class="headerlink" title="2、AOP 动态代理"></a><strong>2、AOP 动态代理</strong></h4><p>​        AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>​        Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p>
<h4 id="3、Bean生命周期"><a href="#3、Bean生命周期" class="headerlink" title="3、Bean生命周期"></a><strong>3、Bean生命周期</strong></h4><p><strong>单例对象：</strong> singleton                    </p>
<p>总结：单例对象的生命周期和容器相同        </p>
<p><strong>多例对象：</strong> prototype           </p>
<p>出生：使用对象时spring框架为我们创建            </p>
<p>活着：对象只要是在使用过程中就一直活着            </p>
<p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p>
<img src="https://s0.lgstatic.com/i/image3/M01/89/0C/Cgq2xl6WvHqAdmt4AABGAn2eSiI631.png" alt="img" style="zoom:67%;" />

<p>IOC容器初始化加载Bean流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123; <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">  <span class="comment">// 第一步:刷新前的预处理 </span></span><br><span class="line">  prepareRefresh();</span><br><span class="line">  <span class="comment">//第二步: 获取BeanFactory并注册到 BeanDefitionRegistry</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">  <span class="comment">// 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等)</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第四步:完成BeanFactory准备工作后的前置处理工作 </span></span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 第五步:实例化BeanFactoryPostProcessor接口的Bean </span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    <span class="comment">// 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 </span></span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    <span class="comment">// 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); </span></span><br><span class="line">    initMessageSource();</span><br><span class="line">    <span class="comment">// 第八步:注册初始化事件派发器 </span></span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line">    <span class="comment">// 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 </span></span><br><span class="line">    onRefresh();</span><br><span class="line">    <span class="comment">// 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器</span></span><br><span class="line">    registerListeners();</span><br><span class="line">    <span class="comment">//第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性)</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    <span class="comment">//第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建</span></span><br><span class="line">    finishRefresh();</span><br><span class="line">	&#125;</span><br><span class="line">  ……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>四个阶段</strong></p>
<ul>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ul>
<p><strong>多个扩展点</strong></p>
<ul>
<li>影响多个Bean<ul>
<li>BeanPostProcessor</li>
<li>InstantiationAwareBeanPostProcessor</li>
</ul>
</li>
<li>影响单个Bean<ul>
<li>Aware</li>
</ul>
</li>
</ul>
<p><strong>完整流程</strong>  </p>
<ol>
<li>实例化一个Bean－－也就是我们常说的<strong>new</strong>；</li>
<li>按照Spring上下文对实例化的Bean进行配置－－<strong>也就是IOC注入</strong>；</li>
<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中<strong>Bean的id和name进行传递</strong></li>
<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的<strong>Spring工厂自身进行传递</strong>；</li>
<li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以<strong>更加灵活</strong></li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于<strong>内存或缓存技</strong>术</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，<strong>打印日志或者三级缓存技术里面的bean升级</strong></li>
<li>以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</li>
<li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法</li>
</ol>
<h4 id="4、Bean作用域"><a href="#4、Bean作用域" class="headerlink" title="4、Bean作用域"></a><strong>4</strong>、Bean作用域</h4><table>
<thead>
<tr>
<th>名称</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>singleton</strong></td>
<td><strong>单例对象，默认值的作用域</strong></td>
</tr>
<tr>
<td><strong>prototype</strong></td>
<td><strong>每次获取都会创建⼀个新的 bean 实例</strong></td>
</tr>
<tr>
<td>request</td>
<td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td>
</tr>
<tr>
<td>session</td>
<td>在一次 HTTP session 中，容器将返回同一个实例</td>
</tr>
<tr>
<td>global-session</td>
<td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td>
</tr>
</tbody></table>
<p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p>
<p><strong>保障线程安全方法：</strong></p>
<ol>
<li><p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p>
</li>
<li><p>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</p>
</li>
</ol>
<p>  <strong>ThreadLocal</strong>：</p>
<p>  ​        每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p>
<p>  ​        将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p>
<h4 id="5、循环依赖"><a href="#5、循环依赖" class="headerlink" title="5、循环依赖"></a>5、循环依赖</h4><p>​    循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A</p>
<p>Spring中循环依赖场景有: </p>
<ul>
<li><p>prototype 原型 bean循环依赖</p>
</li>
<li><p>构造器的循环依赖（构造器注入）</p>
</li>
<li><p>Field 属性的循环依赖（set注入）</p>
<p>其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。</p>
</li>
</ul>
<p><strong>懒加载@Lazy解决循环依赖问题</strong></p>
<p>​    Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy-init&#x3D;true修饰的 bean 则是在从容器里第一次进行<strong>context.getBean() 时进行触发</strong>。</p>
<p><strong>三级缓存解决循环依赖问题</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glv7ivru2lj31980qcn13.jpg" alt="循环依赖问题" style="zoom: 33%;" />

<ol>
<li><p>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器中的singletonFactorys（三级缓存中）。</p>
</li>
<li><p>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring 容器中。</p>
</li>
<li><p>Spring容器初始化ClassB，ClasssB首先将自己暴露在三级缓存中，然后从Spring容器一级、二级、三级缓存中一次中获取ClassA 。</p>
</li>
<li><p>获取到ClassA后将自己实例化放入单例池中，实例 ClassA通过Spring容器获取到ClassB，完成了自己对象初始化操作。</p>
</li>
<li><p>这样ClassA和ClassB都完成了对象初始化操作，从而解决了循环依赖问题。</p>
</li>
</ol>
<div style="page-break-after: always;"></div>

<h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="1、-SpringBoot"><a href="#1、-SpringBoot" class="headerlink" title="1、@SpringBoot"></a>1、@SpringBoot</h4><p>​    <strong>声明bean的注解</strong></p>
<p>​    <strong>@Component</strong> 通⽤的注解，可标注任意类为  Spring 组件</p>
<p>​    <strong>@Service</strong> 在业务逻辑层使用（service层）</p>
<p>​    <strong>@Repository</strong> 在数据访问层使用（dao层）</p>
<p>​    <strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p>
<p>​    <strong>注入bean的注解</strong></p>
<p>​    <strong>@Autowired</strong>：默认按照类型来装配注入，**@Qualifier**：可以改成名称</p>
<p>​    <strong>@Resource</strong>：默认按照名称来装配注入，JDK的注解，新版本已经弃用</p>
<p><strong>@Autowired注解原理</strong> </p>
<p>​         @Autowired的使用简化了我们的开发，</p>
<p>​                实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。<br>​                实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。<br>​                实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来；<br>​                实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。</p>
<p><strong>@SpringBootApplication</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(JpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p>
<ul>
<li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li>
<li><strong>@EnableAutoConfiguration：</strong>开启<strong>自动配置</strong>功能</li>
<li><strong>@ComponentScan：</strong>就是<strong>扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li>
</ul>
<p>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</p>
<p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p>
<p> <strong>@EnableAutoConfiguration作用：</strong></p>
<p>它主要利用了一个</p>
<p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration </span><br></pre></td></tr></table></figure>





<h4 id="2、-SpringMVC"><a href="#2、-SpringMVC" class="headerlink" title="2、@SpringMVC"></a><strong>2、@SpringMVC</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> 声明该类为SpringMVC中的Controller</span><br><span class="line"><span class="meta">@RequestMapping</span> 用于映射Web请求</span><br><span class="line"><span class="meta">@ResponseBody</span> 支持将返回值放在response内，而不是一个页面，通常用户返回json数据</span><br><span class="line"><span class="meta">@RequestBody</span> 允许request的参数在request体中，而不是在直接连接在地址后面。</span><br><span class="line"><span class="meta">@PathVariable</span> 用于接收路径参数</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)</span>申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</span><br></pre></td></tr></table></figure>

<p><strong>SpringMVC原理</strong> </p>
<img src="https://img-blog.csdn.net/20181022224058617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F3YWtlX2xxaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom: 50%;" />

<ol>
<li>客户端（浏览器）发送请求，直接请求到  DispatcherServlet 。</li>
<li>DispatcherServlet 根据请求信息调⽤  HandlerMapping ，解析请求对应的  Handler 。</li>
<li>解析到对应的  Handler （也就是  Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li>
<li>HandlerAdapter 会根据  Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回⼀个  ModelAndView 对象， Model 是返回的数据对象</li>
<li>ViewResolver 会根据逻辑  View 查找实际的  View 。</li>
<li>DispaterServlet 把返回的  Model 传给  View （视图渲染）。</li>
<li>把  View 返回给请求者（浏览器）</li>
</ol>
<h4 id="3、-SpringMybatis"><a href="#3、-SpringMybatis" class="headerlink" title="3、@SpringMybatis"></a>3、@SpringMybatis</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span> ： 插入sql ,和xml insert sql语法完全一样</span><br><span class="line"><span class="meta">@Select</span> ： 查询sql, 和xml select sql语法完全一样</span><br><span class="line"><span class="meta">@Update</span> ： 更新sql, 和xml update sql语法完全一样</span><br><span class="line"><span class="meta">@Delete</span> ： 删除sql, 和xml delete sql语法完全一样</span><br><span class="line"><span class="meta">@Param</span> ： 入参</span><br><span class="line"><span class="meta">@Results</span> ： 设置结果集合<span class="meta">@Result</span> ： 结果</span><br><span class="line"><span class="meta">@ResultMap</span> ： 引用结果集合</span><br><span class="line"><span class="meta">@SelectKey</span> ： 获取最新插入id </span><br></pre></td></tr></table></figure>

<p><strong>mybatis如何防止sql注入？</strong></p>
<p>​    简单的说就是#{}是经过预编译的，是安全的，**$<strong>{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用</strong>“#{xxx}”<strong>这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性</strong>statementType&#x3D;”STATEMENT”<strong>，同时sql里的属有变量取值都改成</strong>${xxxx}**</p>
<p><strong>Mybatis和Hibernate的区别</strong> </p>
<p><strong>Hibernate 框架：</strong> </p>
<p>​    <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p>
<p><strong>Mybatis框架：</strong></p>
<p>​    <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p>
<p><strong>区别：</strong></p>
<p>  <strong>开发方面</strong></p>
<p>​    在项目开发过程当中，就速度而言：</p>
<p>​      hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p>
<p>​      Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p>
<p>​    但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p>
<p>  <strong>sql优化方面</strong></p>
<p>​    Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p>
<p>​    Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p>
<p>  <strong>对象管理比对</strong></p>
<p>​    Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p>
<p>​    Mybatis 需要自行管理映射关系；</p>
<h4 id="4、-Transactional"><a href="#4、-Transactional" class="headerlink" title="4、@Transactional"></a>4、@Transactional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span> </span><br><span class="line"><span class="meta">@Transactional</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>​    ①事务函数中不要处理耗时任务，会导致长期占有数据库连接。</p>
<p>​    ②事务函数中不要处理无关业务，防止产生异常导致事务回滚。</p>
<p><strong>事务传播属性</strong></p>
<p><strong>1) REQUIRED（默认属性）</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 </p>
<ol start="2">
<li><p>MANDATORY  支持当前事务，如果当前没有事务，就抛出异常。 </p>
</li>
<li><p>NEVER  以非事务方式执行，如果当前存在事务，则抛出异常。 </p>
</li>
<li><p>NOT_SUPPORTED  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p>
</li>
<li><p>REQUIRES_NEW  新建事务，如果当前存在事务，把当前事务挂起。 </p>
</li>
<li><p>SUPPORTS  支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
</li>
</ol>
<p><strong>7) NESTED</strong> （<strong>局部回滚</strong>） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 <strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p>
<div style="page-break-after: always;"></div>

<h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><h4 id="1、Spring中的设计模式"><a href="#1、Spring中的设计模式" class="headerlink" title="1、Spring中的设计模式"></a><strong>1、Spring中的设计模式</strong></h4><p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd">spring中的设计模式</a></p>
<p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p>
<p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建bean 对象。</p>
<p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p>
<p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p>
<p><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p>
<h1 id="八、SpringCloud篇"><a href="#八、SpringCloud篇" class="headerlink" title="八、SpringCloud篇"></a>八、SpringCloud篇</h1><h4 id="Why-SpringCloud"><a href="#Why-SpringCloud" class="headerlink" title="Why SpringCloud"></a>Why SpringCloud</h4><blockquote>
<p>​    Spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册</strong>、<strong>配置中心</strong>、<strong>消息总线</strong>、<strong>负载均衡</strong>、<strong>断路器</strong>、<strong>数据监控</strong>等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
</blockquote>
<table>
<thead>
<tr>
<th>SpringCloud（微服务解决方案）</th>
<th>Dubbo（分布式服务治理框架）</th>
</tr>
</thead>
<tbody><tr>
<td>Rest API （轻量、灵活、swagger）</td>
<td>RPC远程调用（高效、耦合）</td>
</tr>
<tr>
<td>Eureka、Nacos</td>
<td>Zookeeper</td>
</tr>
<tr>
<td>使用方便</td>
<td>性能好</td>
</tr>
<tr>
<td>即将推出SpringCloud2.0</td>
<td>断档5年后17年重启</td>
</tr>
</tbody></table>
<p>​    SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,<strong>旨在快速搭建单个微服务</strong>，SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发</p>
<p>​    MartinFlower 提出的微服务之间是通过RestFulApi进行通信，具体实现</p>
<ul>
<li>RestTemplate：基于HTTP协议</li>
<li>Feign：封装了ribbon和Hystrix 、RestTemplate 简化了客户端开发工作量</li>
<li>RPC：基于TCP协议，序列化和传输效率提升明显</li>
<li>MQ：异步解耦微服务之间的调用</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmawejgpgwj30ht0bnt9d.jpg" alt="img" style="zoom:67%;" />

<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><blockquote>
<p>Spring Boot 通过<strong>简单的步骤</strong>就可以创建一个 Spring 应用。</p>
<p>Spring Boot 为 Spring 整合第三方框架提供了<strong>开箱即用功能</strong>。</p>
<p>Spring Boot 的核心思想是<strong>约定大于配置</strong>。</p>
</blockquote>
<p><strong>Spring Boot 解决的问题</strong></p>
<ul>
<li><p>搭建后端框架时需要手动添加 Maven 配置，涉及很多 XML 配置文件，增加了搭建难度和时间成本。</p>
</li>
<li><p>将项目编译成 war 包，部署到 Tomcat 中，项目部署依赖 Tomcat，这样非常不方便。</p>
</li>
<li><p>应用监控做的比较简单，通常都是通过一个没有任何逻辑的接口来判断应用的存活状态。</p>
</li>
</ul>
<p><strong>Spring Boot 优点</strong></p>
<p><strong>自动装配：</strong>Spring Boot 会根据某些规则对所有配置的 Bean 进行初始化。可以减少了很多重复性的工作。</p>
<p>​    比如使用 MongoDB 时，只需加入 MongoDB 的 Starter 包，然后配置  的连接信息，就可以直接使用 MongoTemplate 自动装配来操作数据库了。简化了 Maven Jar 包的依赖，降低了烦琐配置的出错几率。</p>
<p><strong>内嵌容器：</strong>Spring Boot 应用程序可以不用部署到外部容器中，比如 Tomcat。</p>
<p>​    应用程序可以直接通过 Maven 命令编译成可执行的 jar 包，通过 java-jar 命令启动即可，非常方便。</p>
<p><strong>应用监控：</strong>Spring Boot 中自带监控功能 Actuator，可以实现对程序内部运行情况进行监控，</p>
<p>​    比如 Bean 加载情况、环境变量、日志信息、线程信息等。当然也可以自定义跟业务相关的监控，通过Actuator 的端点信息进行暴露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter-web          <span class="comment">//用于快速构建基于 Spring MVC 的 Web 项目。</span></span><br><span class="line">spring-boot-starter-data-redis   <span class="comment">//用于快速整合并操作 Redis。</span></span><br><span class="line">spring-boot-starter-data-mongodb <span class="comment">//用于对 MongoDB 的集成。</span></span><br><span class="line">spring-boot-starter-data-jpa     <span class="comment">//用于操作 MySQL。</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义一个Starter</strong></p>
<ol>
<li><p>创建 Starter 项目，定义 Starter 需要的配置（Properties）类，比如数据库的连接信息；</p>
</li>
<li><p>编写自动配置类，自动配置类就是获取配置，根据配置来自动装配 Bean；</p>
</li>
<li><p>编写 spring.factories 文件加载自动配置类，Spring 启动的时候会扫描 spring.factories 文件，；</p>
</li>
<li><p>编写配置提示文件 spring-configuration-metadata.json（不是必须的），在添加配置的时候，我们想要知道具体的配置项是什么作用，可以通过编写提示文件来提示；</p>
</li>
<li><p>在项目中引入自定义 Starter 的 Maven 依赖，增加配置值后即可使用。</p>
</li>
</ol>
<p><strong>Spring Boot Admin</strong>（将 actuator 提供的数据进行可视化）</p>
<ul>
<li><p>显示应用程序的监控状态、查看 JVM 和线程信息</p>
</li>
<li><p>应用程序上下线监控  </p>
</li>
<li><p>可视化的查看日志、动态切换日志级别</p>
</li>
<li><p>HTTP 请求信息跟踪等实用功能</p>
</li>
</ul>
<h4 id="GateWay-x2F-Zuul"><a href="#GateWay-x2F-Zuul" class="headerlink" title="GateWay &#x2F; Zuul"></a>GateWay &#x2F; Zuul</h4><blockquote>
<p>GateWay⽬标是取代Netflflix Zuul，它基于Spring5.0+SpringBoot2.0+WebFlux等技术开发，提供<strong>统⼀的路由</strong>⽅式（反向代理）并且基于 <strong>Filter</strong>(定义过滤器对请求过滤，完成⼀些功能) 链的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控。</p>
</blockquote>
<p><strong>组成：</strong></p>
<ul>
<li><p><strong>路由route：</strong> ⽹关最基础的⼯作单元。路由由⼀个ID、⼀个⽬标URL、⼀系列的断⾔（匹配条件判断）和Filter过滤器组成。如果断⾔为true，则匹配该路由。</p>
</li>
<li><p><strong>断⾔predicates：</strong>参考了Java8中的断⾔Predicate，匹配Http请求中的所有内容（类似于nginx中的location匹配⼀样），如果断⾔与请求相匹配则路由。</p>
</li>
<li><p><strong>过滤器filter：</strong>标准的Spring webFilter，使⽤过滤器在请求之前或者之后执⾏业务逻辑。</p>
<p>请求前<code>pre</code>类型过滤器：做<strong>参数校验</strong>、<strong>权限校验</strong>、<strong>流量监控</strong>、<strong>⽇志输出</strong>、<strong>协议转换</strong>等，</p>
<p>请求前<code>post</code>类型的过滤器：做<strong>响应内容</strong>、<strong>响应头</strong>的修改、<strong>⽇志的输出</strong>、<strong>流量监控</strong>等。</p>
</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmc49l9babj31do0n7n13.jpg" alt="image-20210105001419761" style="zoom: 50%;" />

<p><strong>GateWayFilter</strong> 应⽤到单个路由路由上 、<strong>GlobalFilter</strong> 应⽤到所有的路由上</p>
<h4 id="Eureka-x2F-Zookeeper"><a href="#Eureka-x2F-Zookeeper" class="headerlink" title="Eureka &#x2F; Zookeeper"></a>Eureka &#x2F; Zookeeper</h4><blockquote>
<p>服务注册中⼼本质上是为了解耦服务提供者和服务消费者，为了⽀持弹性扩缩容特性，⼀个微服务的提供者的数量和分布往往是动态变化的。</p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmawwm3k7bj30o80ecq3u.jpg" alt="image-20210103231405882" style="zoom: 50%;" />

<table>
<thead>
<tr>
<th>区别</th>
<th>Zookeeper</th>
<th>Eureka</th>
<th>Nacos</th>
</tr>
</thead>
<tbody><tr>
<td>CAP</td>
<td>CP</td>
<td>AP</td>
<td>CP&#x2F;AP切换</td>
</tr>
<tr>
<td>可用性</td>
<td>选举期间不可用</td>
<td>自我保护机制，数据不是最新的</td>
<td></td>
</tr>
<tr>
<td>组成</td>
<td>Leader和Follower</td>
<td>节点平等</td>
<td></td>
</tr>
<tr>
<td>优势</td>
<td>分布式协调</td>
<td>注册与发现</td>
<td>注册中心和配置中心</td>
</tr>
<tr>
<td>底层</td>
<td>进程</td>
<td>服务</td>
<td>Jar包</td>
</tr>
</tbody></table>
<p><strong>Eureka</strong>通过<strong>⼼跳检测</strong>、<strong>健康检查</strong>和<strong>客户端缓存</strong>等机制，提⾼系统的灵活性、可伸缩性和可⽤性。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaxc493qyj30ji0a6mxx.jpg" alt="image-20210103232900353" style="zoom:67%;" />

<ol>
<li>us-east-1c、us-east-1d，us-east-1e代表不同的机房，<strong>每⼀个Eureka Server都是⼀个集群</strong>。</li>
<li>Service作为服务提供者向Eureka中注册服务，Eureka接受到注册事件会在<strong>集群和分区中进⾏数据同步</strong>，Client作为消费端（服务消费者）可以从Eureka中获取到服务注册信息，进⾏服务调⽤。</li>
<li>微服务启动后，会周期性地向Eureka<strong>发送⼼跳</strong>（默认周期为30秒）以续约⾃⼰的信息</li>
<li>Eureka在⼀定时间内<strong>（默认90秒）没有接收</strong>到某个微服务节点的⼼跳，Eureka将会注销该微服务节点</li>
<li>Eureka Client<strong>会缓存Eureka Server中的信息</strong>。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使⽤缓存中的信息找到服务提供者</li>
</ol>
<p><strong>Eureka缓存</strong></p>
<blockquote>
<p>新服务上线后，服务消费者<strong>不能立即访问</strong>到刚上线的新服务，需要过⼀段时间后才能访问？或是将服务下线后，服务还是会被调⽤到，⼀段时候后<strong>才彻底停⽌服务</strong>，访问前期会导致频繁报错！</p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaxmk97q0j30vw0j6gmu.jpg" alt="image-20210103233902439" style="zoom:50%;" />

<p>​    服务注册到注册中⼼后，服务实例信息是<strong>存储在Registry表</strong>中的，也就是内存中。但Eureka为了提⾼响应速度，在内部做了优化，加⼊了两层的缓存结构，将Client需要的实例信息，直接缓存起来，获取的时候直接从缓存中拿数据然后响应给 Client。 </p>
<ul>
<li><p>第⼀层缓存是<strong>readOnlyCacheMap</strong>，采⽤<strong>ConcurrentHashMap</strong>来存储数据的，主要负责定时与readWriteCacheMap进⾏数据同步，默认同步时间为 <strong>30</strong> 秒⼀次。</p>
</li>
<li><p>第⼆层缓存是<strong>readWriteCacheMap</strong>，采⽤<strong>Guava</strong>来实现缓存。缓存过期时间默认为<strong>180</strong>秒，当服务<strong>下线、过期、注册、状态变更</strong>等操作都会清除此缓存中的数据。</p>
</li>
<li><p>如果两级缓存都无法查询，会<strong>触发缓存的加载</strong>，从存储层拉取数据到缓存中，然后再返回给 Client。</p>
<p>Eureka之所以设计⼆级缓存机制，也是为了<strong>提⾼ Eureka Server 的响应速度</strong>，缺点是缓存会导致 Client<strong>获取不到最新的服务实例信息</strong>，然后导致⽆法快速发现新的服务和已下线的服务。</p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>我们可以<strong>缩短读缓存的更新时间</strong>让服务发现变得更加及时，或者<strong>直接将只读缓存关闭</strong>，同时可以缩短客户端如ribbon服务的定时刷新间隔，多级缓存也导致C层⾯（数据⼀致性）很薄弱。</li>
<li>Eureka Server 中会有<strong>定时任务去检测失效</strong>的服务，将服务实例信息从注册表中移除，也可以将这个失效检测的<strong>时间缩短</strong>，这样服务下线后就能够及时从注册表中清除。</li>
</ul>
<p><strong>自我保护机制开启条件</strong></p>
<ul>
<li>期望最小每分钟能够续租的次数（实例* 频率 * 比例&#x3D;&#x3D;10* 2 *0.85）</li>
<li>期望的服务实例数量（10）</li>
</ul>
<p><strong>健康检查</strong></p>
<ul>
<li><p>Eureka Client 会定时发送心跳给 Eureka Server 来证明自己处于健康的状态</p>
</li>
<li><p>集成SBA以后可以把所有健康状态信息一并返回给eureka</p>
</li>
</ul>
<h4 id="Feign-x2F-Ribbon"><a href="#Feign-x2F-Ribbon" class="headerlink" title="Feign &#x2F; Ribbon"></a>Feign &#x2F; Ribbon</h4><ul>
<li>Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡，</li>
<li>Feign 可以与 Hystrix 组合使用，支持熔断回退</li>
<li>Feign 可以与ProtoBuf实现快速的RPC调用</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmbxsh2rfnj30uo0fgmxz.jpg" alt="img" style="zoom:80%;" />

<ul>
<li><p><strong>InvocationHandlerFactory 代理</strong></p>
<p>采用 JDK 的动态代理方式生成代理对象，当我们调用这个接口，实际上是要去调用远程的 HTTP API</p>
</li>
<li><p><strong>Contract 契约组件</strong></p>
<p>比如请求类型是 GET 还是 POST，请求的 URI 是什么</p>
</li>
<li><p><strong>Encoder 编码组件 \ Decoder 解码组件</strong></p>
<p>通过该组件我们可以将请求信息采用指定的编码方式进行编解码后传输</p>
</li>
<li><p><strong>Logger 日志记录</strong></p>
<p>负责 Feign 中记录日志的，可以指定 Logger 的级别以及自定义日志的输出</p>
</li>
<li><p><strong>Client 请求执行组件</strong></p>
<p>负责 HTTP 请求执行的组件，Feign 中默认的 Client 是通过 JDK 的 HttpURLConnection 来发起请求的，在每次发送请求的时候，都会创建新的 HttpURLConnection 链接，Feign 的性能会很差，可以通过扩展该接口，使用 Apache HttpClient 等基于连接池的高性能 HTTP 客户端。</p>
</li>
<li><p><strong>Retryer 重试组件</strong></p>
<p>负责重试的组件，Feign 内置了重试器，当 HTTP 请求出现 IO 异常时，Feign 会限定一个最大重试次数来进行重试操作。</p>
</li>
<li><p><strong>RequestInterceptor 请求拦截器</strong></p>
<p>可以为 Feign 添加多个拦截器，在请求执行前设置一些扩展的参数信息。</p>
</li>
</ul>
<p><strong>Feign最佳使用技巧</strong></p>
<ul>
<li><p>继承特性</p>
</li>
<li><p>拦截器</p>
<p>比如添加指定的请求头信息，这个可以用在服务间传递某些信息的时候。</p>
</li>
<li><p>GET 请求多参数传递</p>
</li>
<li><p>日志配置</p>
<p>FULL 会输出全部完整的请求信息。</p>
</li>
<li><p>异常解码器</p>
<p>异常解码器中可以获取异常信息，而不是简单的一个code，然后转换成对应的异常对象返回。</p>
</li>
<li><p>源码查看是如何继承Hystrix</p>
<p>HystrixFeign.builder 中可以看到继承了 Feign 的 Builder，增加了 Hystrix的SetterFactory， build 方法里，对 invocationHandlerFactory 进行了重写， create 的时候<strong>返回HystrixInvocationHandler</strong>， 在 invoke 的时候<strong>会将请求包装成 HystrixCommand</strong> 去执行，这里就自然的集成了 Hystrix</p>
</li>
</ul>
<p><strong>Ribbon</strong></p>
<img src="http://s0.lgstatic.com/i/image2/M01/93/96/CgotOV2Nux-AO2PcAAEcl4M1Zi4629.png" alt="img" style="zoom: 50%;" />



<p><strong>使用方式</strong></p>
<ul>
<li><p><strong>原生 API</strong>，Ribbon 是 Netflix 开源的，没有使用 Spring Cloud，需要使用 Ribbon 的原生 API。</p>
</li>
<li><p><strong>Ribbon + RestTemplate</strong>，整合Spring Cloud 后，可以基于 RestTemplate 提供负载均衡的服务</p>
</li>
<li><p><strong>Ribbon + Feign</strong></p>
<img src="http://s0.lgstatic.com/i/image2/M01/93/76/CgoB5l2NuyCALoefAAAdV1DlSHY088.png" alt="img" style="zoom: 67%;" /></li>
</ul>
<p><strong>负载均衡算法</strong></p>
<ul>
<li><p>RoundRobinRule 是<strong>轮询的算法</strong>，A和B轮流选择。</p>
</li>
<li><p>RandomRule 是<strong>随机算法</strong>，这个就比较简单了，在服务列表中随机选取。</p>
</li>
<li><p>BestAvailableRule 选择一个最<strong>小的并发请求 server</strong></p>
</li>
</ul>
<p><strong>自定义负载均衡算法</strong></p>
<ul>
<li>实现 Irule 接口</li>
<li>继承 AbstractLoadBalancerRule 类</li>
</ul>
<p><strong>自定义负载均衡使用场景</strong>（核心）</p>
<ul>
<li><p><strong>灰度发布</strong></p>
<p>灰度发布是能够平滑过渡的一种发布方式，在发布过程中，先发布一部分应用，让指定的用户使用刚发布的应用，等到测试没有问题后，再将其他的全部应用发布。如果新发布的有问题，只需要将这部分恢复即可，不用恢复所有的应用。</p>
</li>
<li><p><strong>多版本隔离</strong></p>
<p>多版本隔离跟灰度发布类似，为了兼容或者过度，某些应用会有多个版本，这个时候如何保证 1.0 版本的客户端不会调用到 1.1 版本的服务，就是我们需要考虑的问题。</p>
</li>
<li><p><strong>故障隔离</strong></p>
<p>当线上某个实例发生故障后，为了不影响用户，我们一般都会先留存证据，比如：线程信息、JVM 信息等，然后将这个实例重启或直接停止。然后线下根据一些信息分析故障原因，如果我能做到故障隔离，就可以直接将出问题的实例隔离，不让正常的用户请求访问到这个出问题的实例，只让指定的用户访问，这样就可以单独用特定的用户来对这个出问题的实例进行测试、故障分析等。</p>
</li>
</ul>
<h4 id="Hystrix-x2F-Sentinel"><a href="#Hystrix-x2F-Sentinel" class="headerlink" title="Hystrix &#x2F; Sentinel"></a>Hystrix &#x2F; Sentinel</h4><p><strong>服务雪崩场景</strong></p>
<p>自己即是服务消费者，同时也是服务提供者，同步调用等待结果导致资源耗尽</p>
<p><strong>解决方案</strong></p>
<p>服务方：扩容、限流，排查代码问题，增加硬件监控</p>
<p>消费方：使用Hystrix资源隔离，熔断降级，快速失败</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmby7y9ykzj30wr0ehac5.jpg" alt="img" style="zoom:150%;" />

<p><strong>Hystrix断路保护器的作用</strong></p>
<ul>
<li><strong>封装请求</strong>会将用户的操作进行统一封装，统一封装的目的在于进行统一控制。</li>
<li><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。<ul>
<li>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</li>
<li>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</li>
<li>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</li>
<li>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</li>
</ul>
</li>
<li><strong>失败回退</strong>其实是一个备用的方案，就是说当请求失败后，有没有备用方案来满足这个请求的需求。</li>
<li><strong>断路器</strong>这个是<strong>最核心</strong>的，，如果断路器处于打开的状态，那么所有请求都将失败，执行回退逻辑。如果断路器处于关闭状态，那么请求将会被正常执行。有些场景我们需要手动<strong>打开断路器强制降级</strong>。</li>
<li><strong>指标监控</strong>会对请求的生<strong>命周期进行监控</strong>，请求成功、失败、超时、拒绝等状态，都会被监控起来。</li>
</ul>
<p><strong>Hystrix使用上遇到的坑</strong></p>
<ul>
<li><p>配置可以对接<strong>配置中心</strong>进行动态调整</p>
<p>Hystrix 的配置项非常多，如果不对接配置中心，所有的配置只能在代码里修改，在集群部署的难以应对紧急情况，我们项目只设置一个 CommandKey，其他的都在配置中心进行指定，紧急情况如需隔离部分请求时，只需在配置中心进行修改以后，强制更新即可。</p>
</li>
<li><p>回退逻辑中可以<strong>手动埋点</strong>或者通过<strong>输出日志</strong>进行告警</p>
<p>当请求失败或者超时，会执行回退逻辑，如果有大量的回退，则证明某些服务出问题了，这个时候我们可以在回退的逻辑中进行埋点操作，上报数据给监控系统，也可以输出回退的日志，统一由日志收集的程序去进行处理，这些方式都可以将问题暴露出去，然后通过实时数据分析进行告警操作</p>
</li>
<li><p>用 <strong>ThreadLocal</strong>配合<strong>线程池隔离</strong>模式需当心</p>
<p>当我们用了线程池隔离模式的时候，被隔离的方法会包装成一个 Command 丢入到独立的线程池中进行执行，这个时候就是从 A 线程切换到了 B 线程，ThreadLocal 的数据就会丢失</p>
</li>
<li><p><strong>Gateway中</strong>多用信号量隔离</p>
<p>网关是所有请求的入口，路由的服务数量会很多，几十个到上百个都有可能，如果用线程池隔离，那么需要创建上百个独立的线程池，开销太大，用信号量隔离开销就小很多，还能起到限流的作用。</p>
</li>
</ul>
<p>[^常见问题]: Hystrix的超时时间要⼤于Ribbon的超时时间，因为Hystrix将请求包装了起来，特别需要注意的是，如果Ribbon开启了重试机制，⽐如重试3 次，Ribbon 的超时为 1 秒，那么Hystrix 的超时时间应该⼤于 3 秒，否则就会出现 Ribbon 还在重试中，⽽ Hystrix 已经超时的现象。</p>
<p><strong>Sentinel</strong> </p>
<blockquote>
<p>Sentinel是⼀个⾯向云原⽣微服务的流量控制、熔断降级组件。</p>
<p>替代Hystrix，针对问题：服务雪崩、服务降级、服务熔断、服务限流</p>
</blockquote>
<p>Hystrix区别：</p>
<ul>
<li>独⽴可部署Dashboard（基于 Spring Boot 开发）控制台组件</li>
<li>不依赖任何框架&#x2F;库，减少代码开发，通过UI界⾯配置即可完成细粒度控制</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmbza4zixbj30kl09sq4p.jpg" alt="image-20210104212151598" style="zoom:80%;" />

<p><strong>丰富的应⽤场景</strong>：Sentinel 承接了阿⾥巴巴近 10 年的双⼗⼀⼤促流量的核⼼场景，例如秒杀、消息削峰填⾕、集群流量控制、实时熔断下游不可⽤应⽤等。</p>
<p><strong>完备的实时监控</strong>：可以看到500 台以下规模的集群的汇总也可以看到单机的秒级数据。</p>
<p><strong>⼴泛的开源⽣态：</strong>与 SpringCloud、Dubbo的整合。您只需要引⼊相应的依赖并进⾏简单的配置即可快速地接⼊ Sentinel。</p>
<p><strong>区别：</strong></p>
<ul>
<li>Sentinel不会像Hystrix那样放过⼀个请求尝试⾃我修复，就是明明确确按照时间窗⼝来，熔断触发后，时间窗⼝内拒绝请求，时间窗⼝后就恢复。</li>
<li>Sentinel Dashboard中添加的规则数据存储在内存，微服务停掉规则数据就消失，在⽣产环境下不合适。可以将Sentinel规则数据持久化到Nacos配置中⼼，让微服务从Nacos获取。</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th>Sentinel</th>
<th>Hystrix</th>
</tr>
</thead>
<tbody><tr>
<td>隔离策略</td>
<td>信号量隔离</td>
<td>线程池隔离&#x2F;信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应时间或失败比率</td>
<td>基于失败比率</td>
</tr>
<tr>
<td>实时指标实现</td>
<td>滑动窗口</td>
<td>滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持基于调用关系的限流</td>
<td>不支持</td>
</tr>
<tr>
<td>流量整形</td>
<td>支持慢启动、匀速器模式</td>
<td>不支持</td>
</tr>
<tr>
<td>系统负载保护</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td>不完善</td>
</tr>
<tr>
<td>常见框架的适配</td>
<td>Servlet、Spring Cloud、Dubbo、gRPC</td>
<td>Servlet、Spring Cloud Netflix</td>
</tr>
</tbody></table>
<h4 id="Config-x2F-Nacos"><a href="#Config-x2F-Nacos" class="headerlink" title="Config &#x2F; Nacos"></a>Config &#x2F; Nacos</h4><blockquote>
<p>Nacos是阿⾥巴巴开源的⼀个针对微服务架构中<strong>服务发现</strong>、<strong>配置管理</strong>和<strong>服务管理平台</strong>。</p>
<p>Nacos就是<strong>注册中⼼+配置中⼼</strong>的组合（Nacos&#x3D;Eureka+Confifig+Bus）</p>
</blockquote>
<p><strong>Nacos</strong>功能特性</p>
<ul>
<li>服务发现与健康检查</li>
<li>动态配置管理</li>
<li>动态DNS服务</li>
<li>服务和元数据管理</li>
</ul>
<p><strong>保护阈值：</strong></p>
<p>当服务A健康实例数&#x2F;总实例数 &lt; 保护阈值 的时候，说明健康实例真的不多了，这个时候保护阈值会被触发（状态true），nacos将会把该服务所有的实例信息（健康的+不健康的）全部提供给消费者，消费者可能访问到不健康的实例，请求失败，但这样也⽐造成雪崩要好，牺牲了⼀些请求，保证了整个系统的⼀个可⽤。</p>
<p><strong>Nacos</strong> 数据模型（领域模型）</p>
<ul>
<li><strong>Namespace</strong> 代表不同的环境，如开发dev、测试test、⽣产环境prod</li>
<li><strong>Group</strong> 代表某项⽬，⽐如爪哇云项⽬</li>
<li><strong>Service</strong> 某个项⽬中具体xxx服务</li>
<li><strong>DataId</strong> 某个项⽬中具体的xxx配置⽂件</li>
</ul>
<p>可以通过 Spring Cloud 原⽣注解 <code>@RefreshScope</code> 实现配置⾃动更新</p>
<h4 id="Bus-x2F-Stream"><a href="#Bus-x2F-Stream" class="headerlink" title="Bus &#x2F; Stream"></a>Bus &#x2F; Stream</h4><blockquote>
<p>Spring Cloud Stream 消息驱动组件帮助我们更快速，更⽅便的去构建<strong>消息驱动</strong>微服务的</p>
<p>本质：屏蔽掉了底层不同<strong>MQ</strong>消息中间件之间的差异，统⼀了<strong>MQ</strong>的编程模型，降低了学习、开发、维护<strong>MQ</strong>的成本，⽬前⽀持Rabbit、Kafka两种消息</p>
</blockquote>
<h4 id="Sleuth-x2F-Zipkin"><a href="#Sleuth-x2F-Zipkin" class="headerlink" title="Sleuth &#x2F; Zipkin"></a><strong>Sleuth &#x2F; Zipkin</strong></h4><p><strong>全链路追踪</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmc3avezqrj30xb0lw76z.jpg" alt="image-20210104234058218" style="zoom:67%;" />

<p><strong>Trace ID</strong>：当请求发送到分布式系统的⼊⼝端点时，Sleuth为该请求创建⼀个唯⼀的跟踪标识Trace ID，在分布式系统内部流转的时候，框架始终保持该唯⼀标识，直到返回给请求⽅</p>
<p><strong>Span ID</strong>：为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过⼀个唯⼀标识SpanID来标记它的开始，具体过程以及结束。</p>
<p>Spring Cloud Sleuth （追踪服务框架）可以追踪服务之间的调⽤，Sleuth可以记录⼀个服务请求经过哪些服务、服务处理时⻓等，根据这些，我们能够理清各微服务间的调⽤关系及进⾏问题追踪分析。</p>
<p><strong>耗时分析</strong>：通过 Sleuth 了解采样请求的耗时，分析服务性能问题（哪些服务调⽤⽐较耗时）</p>
<p><strong>链路优化</strong>：发现频繁调⽤的服务，针对性优化等</p>
<p><strong>聚合展示</strong>：数据信息发送给 Zipkin 进⾏聚合，利⽤ Zipkin 存储并展示数据。</p>
<h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a><strong>安全认证</strong></h3><ul>
<li><p>Session</p>
<p>认证中最常用的一种方式，也是最简单的。存在<strong>多节点session丢失</strong>的情况，可通过<strong>nginx粘性Cookie</strong>和Redis集中式Session存储解决</p>
</li>
<li><p>HTTP Basic Authentication </p>
<p>服务端针对请求头中base64加密的Authorization 和用户名和密码进行<strong>校验</strong>。</p>
</li>
<li><p>Token</p>
<p>Session 只是一个 key，<strong>会话信息存储在后端</strong>。而 Token 中会存储用户的信息，然后通过加密算法进行加密，只有服务端才能解密，<strong>服务端拿到 Token 后进行解密获取用户信息</strong>。</p>
</li>
<li><p>JWT认证</p>
</li>
</ul>
<blockquote>
<p>JWT（JSON Web Token）用户提供用户名和密码给认证服务器，服务器验证用户提交信息的合法性；如果验证成功，会产生并返回一个 Token，用户可以使用这个 Token 访问服务器上受保护的资源。</p>
</blockquote>
<img src="http://s0.lgstatic.com/i/image2/M01/AB/87/CgotOV3WUG2ARl98AAD_xcd-ElM857.png" alt="img" style="zoom:70%;" />

<ol>
<li>认证服务提供认证的 API，校验用户信息，返回认证结果</li>
<li>通过JWTUtils中的RSA算法，生成JWT token，token里封装用户id和有效期</li>
<li>服务间参数通过请求头进行传递，服务内部通过 ThreadLocal 进行上下文传递。</li>
<li>Hystrix导致ThreadLocal失效的问题可以通过，重写 Hystrix 的 Callable 方法，传递需要的数据。</li>
</ol>
<p><strong>Token最佳实践</strong></p>
<ul>
<li><p>设置<strong>较短（合理）的过期时间</strong>。</p>
</li>
<li><p>注销的 Token <strong>及时清除</strong>（放入 Redis 中做一层过滤）。</p>
<p>虽然不能修改 Token 的信息，但是能在验证层面做一层过滤来进行处理。</p>
</li>
<li><p>监控 Token 的<strong>使用频率</strong>。</p>
<p>为了防止数据被别人爬取，最常见的就是监控使用频率，程序写出来的爬虫程序访问频率是有迹可循的 </p>
</li>
<li><p>核心功能敏感操作可以使用<strong>动态验证</strong>（验证码）。</p>
<p>比如提现的功能，要求在提现时再次进行验证码的验证，防止不是本人操作。</p>
</li>
<li><p><strong>网络环境、浏览器</strong>信息等识别。</p>
<p>银行 APP 对环境有很高的要求，使用时如果断网，APP 会自动退出，重新登录，因为网络环境跟之前使用的不一样了，还有一些浏览器的信息之类的判断，这些都是可以用来保证后端 API 的安全。</p>
</li>
<li><p><strong>加密密钥</strong>支持动态修改。</p>
<p>如果 Token 的加密密钥泄露了，也就意味着别人可以伪造你的 Token，可以将密钥存储在配置中心，以支持动态修改刷新，需要注意的是建议在流量低峰的时候去做更换的操作，否则 Token 全部失效，所有在线的请求都会重新申请 Token，并发量会比较大。</p>
</li>
</ul>
<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p><strong>痛点：</strong></p>
<ul>
<li><p>服务数量多，业务变动频繁，一周一发布</p>
</li>
<li><p>灰度发布能降低发布失败风险，<strong>减少影响范围</strong></p>
<p>通过灰度发布，先让一部分用户体验新的服务，或者只让测试人员进行测试，等功能正常后再全部发布，这样能降低发布失败带来的影响范围。 </p>
</li>
<li><p>当发布出现故障时，可以<strong>快速回滚</strong>，不影响用户</p>
<p>灰度后如果发现这个节点有问题，那么只需回滚这个节点即可，当然不回滚也没关系，通过灰度策略隔离，也不会影响正常用户</p>
</li>
</ul>
<p>可以通过Ribbon的负载均衡策略进行灰度发布，可以使用更可靠的Discovery</p>
<p><strong>Discovery</strong></p>
<blockquote>
<p>基于Discovery 服务注册发现、Ribbon 负载均衡、Feign 和 RestTemplate 调用等组件的企业级微服务开源解决方案，包括灰度发布、灰度路由、服务隔离等功能</p>
</blockquote>
<img src="https://s0.lgstatic.com/i/image3/M01/54/41/CgpOIF3nXSaAB9bRAAE8rktrUyY037.png" alt="img" style="zoom:50%;" />

<ol>
<li><p>首先将需要发布的服务从转发过程中移除，等流量剔除之后再发布。</p>
</li>
<li><p>部分机器中的版本进行升级，用户默认还是请求老的服务，通过版本来支持测试请求。</p>
</li>
<li><p>测试完成之后，让新的版本接收正常流量，然后部署下一个节点，以此类推。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grayVersions = &#123;<span class="string">&quot;discovery-article-service&quot;</span>:[<span class="string">&quot;1.01&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多版本隔离"><a href="#多版本隔离" class="headerlink" title="多版本隔离"></a>多版本隔离</h3><img src="https://s0.lgstatic.com/i/image3/M01/54/41/Cgq2xl3nXSeAZMTOAAE2sCaIhPE668.png" alt="img" style="zoom:50%;" />



<p><strong>本地复用测试服务</strong>-Eureka Zone亮点</p>
<p>​    <strong>region</strong> 地理上的分区，比如北京、上海等</p>
<p>​    <strong>zone</strong> 可以简单理解为 region 内的具体机房</p>
<p>​    在调用的过程中会优先选择相同的 zone 发起调用，当找不到相同名称的 zone 时会选择其他的 zone 进行调用，我们可以利用这个特性来解决本地需要启动多个服务的问题。</p>
<p>[^]: 当你访问修改的服务 A 时，这个服务依赖了 B、C 两个服务，B 和 C 本地没有启动，B 和 C 找不到相同的 zone 就会选择其他的 zone 进行调用，也就是会调用到测试环境部署的 B 和 C 服务，这样一来就解决了本地部署多个服务的问题。</p>
<h4 id="各组件调优"><a href="#各组件调优" class="headerlink" title="各组件调优"></a><strong>各组件调优</strong></h4><p>当你对网关进行压测时，会发现并发量一直上不去，错误率也很高。因为你用的是默认配置，这个时候我们就需要去调整配置以达到最优的效果。</p>
<p>首先我们可以对容器进行调优，最常见的就是<strong>内置的 Tomcat</strong> 容器了，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count <span class="comment">//请求队列排队数</span></span><br><span class="line">server.tomcat.max-threads <span class="comment">//最大线程数</span></span><br><span class="line">server.tomcat.max-connections <span class="comment">//最大连接数</span></span><br></pre></td></tr></table></figure>

<p><strong>Hystrix</strong> 的信号量（semaphore）隔离模式，并发量上不去很大的原因都在这里，信号量默认值是 100，也就是最大并发只有 100，超过 100 就得等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量</span></span><br><span class="line">zuul.semaphore.max-semaphores <span class="comment">//信号量：最大并发数</span></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line">hystrix.threadpool.<span class="keyword">default</span>.coreSize <span class="comment">//最大线程数</span></span><br><span class="line">hystrix.threadpool.<span class="keyword">default</span>.maximumSize <span class="comment">//队列的大</span></span><br><span class="line">hystrix.threadpool.<span class="keyword">default</span>.maxQueueSize <span class="comment">//等参数</span></span><br></pre></td></tr></table></figure>

<p>配置<strong>Gateway</strong>并发信息，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gateway.host.max-per-route-connections <span class="comment">//每个路由的连接数 </span></span><br><span class="line">gateway.host.max-total-connections <span class="comment">//总连接数</span></span><br></pre></td></tr></table></figure>

<p>调整<strong>Ribbon</strong> 的并发配置，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ribbon.MaxConnectionsPerHost <span class="comment">//单服务并发数</span></span><br><span class="line">ribbon.MaxTotalConnections   <span class="comment">//总并发数</span></span><br></pre></td></tr></table></figure>

<p>修改<strong>Feign</strong>默认的HttpURLConnection 替换成 httpclient 来提高性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feign.httpclient.max-connections-per-route<span class="comment">//每个路由的连接数</span></span><br><span class="line">feign.httpclient.max-connections <span class="comment">//总连接数</span></span><br></pre></td></tr></table></figure>

<p>Gateway+配置中心实现动态路由</p>
<p>Feign+配置中心实现动态日志</p>
<h1 id="九、分布式篇"><a href="#九、分布式篇" class="headerlink" title="九、分布式篇"></a><strong>九、分布式篇</strong></h1><blockquote>
<p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</blockquote>
<h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a><strong>发展历程</strong></h3><ul>
<li><p>入口级负载均衡</p>
<ul>
<li>网关负载均衡</li>
<li>客户端负载均衡</li>
</ul>
</li>
<li><p>单应用架构</p>
<ul>
<li>应用服务和数据服务分离</li>
<li>应用服务集群</li>
<li>应用服务中心化SAAS</li>
</ul>
</li>
<li><p>数据库主备读写分离</p>
<ul>
<li>全文搜索引擎加快数据统计</li>
<li>缓存集群缓解数据库读压力</li>
<li>分布式消息中间件缓解数据库写压力</li>
<li>数据库水平拆分适应微服务</li>
<li>数据库垂直拆分解决慢查询</li>
</ul>
</li>
<li><p>划分上下文拆分微服务</p>
<ul>
<li>服务注册发现（Eureka、Nacos）</li>
<li>配置动态更新（Config、Apollo）</li>
<li>业务灰度发布（Gateway、Feign）</li>
<li>统一安全认证（Gateway、Auth）</li>
<li>服务降级限流（Hystrix、Sentinel）</li>
<li>接口检查监控（Actuator、Prometheus）</li>
<li>服务全链路追踪（Sleuth、Zipkin）</li>
</ul>
</li>
</ul>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul>
<li><strong>一致性</strong>（2PC、3PC、Paxos、Raft）<ul>
<li>强一致性：<strong>数据库一致性</strong>，牺牲了性能<ul>
<li><strong>ACID</strong>：原子性、一致性、隔离性、持久性</li>
</ul>
</li>
<li>弱一致性：<strong>数据库和缓存</strong>，<strong>延迟双删、重试</strong></li>
<li>单调读一致性：<strong>缓存一致性</strong>，ID或者IP哈希</li>
<li>最终一致性：<strong>边缘业务</strong>，消息队列</li>
</ul>
</li>
<li><strong>可用性</strong>（多级缓存、读写分离）<ul>
<li><strong>BASE</strong> 基本可用：限流导致响应速度慢、降级导致用户体验差<ul>
<li>Basically Availabe 基本可用  </li>
<li>Soft state 软状态</li>
<li>Eventual Consistency 最终一致性</li>
</ul>
</li>
</ul>
</li>
<li>分区容忍性（一致性Hash解决扩缩容问题）</li>
</ul>
<div style="page-break-after: always;"></div>

<h3 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h3><h4 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h4><p><strong>2PC</strong>协议：两阶段提交协议，P是指<strong>准备</strong>阶段，C是指<strong>提交</strong>阶段</p>
<ul>
<li>准备阶段：询问是否可以开始，写Undo、Redo日志，收到响应</li>
<li>提交阶段：执行Redo日志进行<strong>Commit</strong>，执行Undo日志进行<strong>Rollback</strong></li>
</ul>
<p><strong>3PC</strong>协议：将提交阶段分为<strong>CanCommit</strong>、<strong>PreCommit</strong>、<strong>DoCommit</strong>三个阶段</p>
<p><strong>CanCommit</strong>：发送canCommit请求，并开始等待</p>
<p><strong>PreCommit</strong>：收到全部Yes，写Undo、Redo日志。超时或者No，则中断</p>
<p><strong>DoCommit</strong>：执行Redo日志进行<strong>Commit</strong>，执行Undo日志进行<strong>Rollback</strong> </p>
<p>区别是第二步，参与者<strong>自身增加了超时</strong>，如果<strong>失败可以及时释放资源</strong></p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h4><blockquote>
<p>如何在一个发生异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致</p>
</blockquote>
<p>​    参与者（例如Kafka）的一致性可以由协调者（例如Zookeeper）来保证，<strong>协调者的一致性就只能由Paxos保证了</strong></p>
<p>Paxos算法中的角色：</p>
<ul>
<li><strong>Client</strong>：客户端、例如，对分布式文件服务器中文件的写请求。</li>
<li><strong>Proposer</strong>：提案发起者，根据Accept返回选择最大N对应的V，发送[N+1,V]</li>
<li><strong>Acceptor</strong>：决策者，Accept以后会拒绝小于N的提案，并把自己的[N,V]返回给Proposer</li>
<li><strong>Learners</strong>：最终决策的学习者、学习者充当该协议的复制因素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法约束</span></span><br><span class="line">P1:一个Acceptor必须接受它收到的第一个提案。</span><br><span class="line"><span class="comment">//考虑到半数以上才作数，一个Accpter得接受多个相同v的提案</span></span><br><span class="line">P2a:如果某个v的提案被accept，那么被Acceptor接受编号更高的提案必须也是v</span><br><span class="line">P2b:如果某个v的提案被accept，那么从Proposal提出编号更高的提案必须也是v</span><br><span class="line"><span class="comment">//如何确保v的提案Accpter被选定后，Proposal都能提出编号更高的提案呢</span></span><br><span class="line">针对任意的[Mid,Vid]，有半数以上的Accepter集合S，满足以下二选一：</span><br><span class="line">  S中接受的提案都大于Mid</span><br><span class="line">  S中接受的提案若小于Mid，编号最大的那个值为Vid</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmlato63bnj319m0u0wmi.jpg" alt="image-20210112225118095"></p>
<p>面试题：如何保证Paxos算法活性</p>
<p>​    假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致最终陷入死循环，没有value被选定</p>
<ul>
<li><strong>通过选取主Proposer</strong>，规定只有主Proposer才能提出议案。只要主Proposer和过半的Acceptor能够正常网络通信，主Proposer提出一个编号更高的提案，该提案终将会被批准。</li>
<li>每个Proposer发送提交提案的时间设置为<strong>一段时间内随机</strong>，保证不会一直死循环</li>
</ul>
<h4 id="ZAB算法"><a href="#ZAB算法" class="headerlink" title="ZAB算法"></a><strong>ZAB算法</strong></h4><h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h4><blockquote>
<p>Raft 是一种为了管理复制日志的一致性算法</p>
</blockquote>
<p>Raft使用<strong>心跳机制</strong>来触发选举。当server启动时，初始状态都是<strong>follower</strong>。每一个server都有一个定时器，超时时间为election timeout（<strong>一般为150-300ms</strong>），如果某server<strong>没有超时的情况下收到</strong>来自领导者或者候选者的任何消息，<strong>定时器重启</strong>，如果超时，它就<strong>开始一次选举</strong>。</p>
<p><strong>Leader异常</strong>：异常期间Follower会超时选举，完成后Leader比较彼此步长</p>
<p><strong>Follower异常：</strong>恢复后直接同步至Leader当前状态</p>
<p><strong>多个Candidate：</strong>选举时失败，失败后超时继续选举</p>
<h4 id="数据库和Redis的一致性"><a href="#数据库和Redis的一致性" class="headerlink" title="数据库和Redis的一致性"></a>数据库和Redis的一致性</h4><p><strong>全量缓存保证高效读取</strong></p>
<img src="/Users/suhongliu/Library/Application Support/typora-user-images/image-20210418185425386.png" alt="image-20210418185425386" style="zoom:50%;" />

<p>所有数据都存储在缓存里，读服务在查询时不会再降级到数据库里，所有的请求都完全依赖缓存。此时，因降级到数据库导致的毛刺问题就解决了。但全量缓存并<strong>没有解决更新时的分布式事务</strong>问题，反而把问题放大了。因为全量缓存<strong>对数据更新要求更加严格</strong>，要求所有数据库<strong>已有数据和实时更新</strong>的数据必须完全同步至缓存，不能有遗漏。对于此问题，一种有效的方案是采用<strong>订阅数据库的 Binlog</strong> 实现数据同步</p>
<img src="/Users/suhongliu/Library/Application Support/typora-user-images/image-20210418185457610.png" alt="image-20210418185457610" style="zoom:50%;" />

<p>​    现在很多开源工具（如<strong>阿里的 Canal</strong>等）可以模拟主从复制的协议。通过模拟协议读取主数据库的 Binlog 文件，从而获取主库的所有变更。对于这些变更，它们开放了各种接口供业务服务获取数据。</p>
<img src="/Users/suhongliu/Library/Application Support/typora-user-images/image-20210418185516743.png" alt="image-20210418185516743" style="zoom:50%;" />

<p>​    将 Binlog 的中间件挂载至目标数据库上，就可以<strong>实时获取该数据库的所有变更数据</strong>。对这些变更数据解析后，便可<strong>直接写入缓存里</strong>。优点还有：</p>
<ul>
<li><p>大幅提升了读取的速度，降低了延迟</p>
</li>
<li><p>Binlog 的主从复制是基于 <strong>ACK</strong> 机制， 解决了分布式事务的问题</p>
<p>如果同步缓存失败了，被消费的 Binlog 不会被确认，下一次会重复消费，数据最终会写入缓存中</p>
</li>
</ul>
<p><strong>缺点</strong>不可避免：1、增加复杂度 2、消耗缓存资源 3、需要筛选和压缩数据 4、极端情况数据丢失</p>
<img src="/Users/suhongliu/Library/Application Support/typora-user-images/image-20210418185549520.png" alt="image-20210418185549520" style="zoom:50%;" />

<p>可以通过异步校准方案进行补齐，但是会损耗数据库性能。但是此方案会隐藏中间件使用错误的细节，线上环境前期更重要的是记录日志排查在做后续优化，不能本末倒置。</p>
<div style="page-break-after: always;"></div>

<h3 id="可用性-1"><a href="#可用性-1" class="headerlink" title="可用性"></a>可用性</h3><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a><strong>心跳检测</strong></h4><blockquote>
<p>以<strong>固定的频率</strong>向其他节点汇报当前节点状态的方式。收到心跳，说明网络和节点的状态是健康的。心跳汇报时，一般会携带一些附加的<strong>状态、元数据，以便管理</strong></p>
</blockquote>
<p><strong>周期检测心跳机制</strong>：超时未返回</p>
<p><strong>累计失效检测机制</strong>：重试超次数</p>
<h4 id="多机房实时热备"><a href="#多机房实时热备" class="headerlink" title="多机房实时热备"></a><strong>多机房实时热备</strong></h4><img src="/Users/suhongliu/Library/Application Support/typora-user-images/image-20210418185610597.png" alt="6.png" style="zoom:50%;" />

<p>两套缓存集群可以分别部署到不同城市的机房。读服务也相应地部署到不同城市或不同分区。在承接请求时，不同机房或分区的读服务只依赖同样属性的缓存集群。此方案有两个好处。</p>
<ol>
<li><strong>提升了性能。</strong>读服务不要分层，读服务要尽可能地和缓存数据源靠近。</li>
<li><strong>增加了可用。</strong>当单机房出现故障时，可以秒级将所有流量都切换至存活的机房或分区</li>
</ol>
<p>此方案虽然带来了性能和可用性的提升，但代价是资源成本的上升。</p>
<div style="page-break-after: always;"></div>

<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><blockquote>
<p>分布式系统对于错误包容的能力</p>
</blockquote>
<p>通过限流、降级、兜底、重试、负载均衡等方式增强系统的健壮性</p>
<h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p><img src="https://i.loli.net/2021/01/14/fmYEJy9N7Zjp2Xd.png" alt="image-20210114154435003"></p>
<ol>
<li><strong>Leader</strong>把指令添加到日志中，发起 RPC 给其他的服务器，让他们复制这条信息</li>
<li><strong>Leader</strong>会不断的重试，直到所有的 Follower响应了ACK并复制了所有的日志条目</li>
<li>通知所有的<strong>Follower</strong>提交，同时Leader该表这条日志的状态，并返回给客户端</li>
</ol>
<h4 id="主备（Master-Slave）"><a href="#主备（Master-Slave）" class="headerlink" title="主备（Master-Slave）"></a><strong>主备（Master-Slave）</strong></h4><p>​    主机宕机时，备机接管主机的一切工作，主机恢复正常后，以自动（<strong>热备</strong>）或手动（<strong>冷备</strong>）方式将服务切换到主机上运行，<strong>Mysql</strong>和<strong>Redis</strong>中常用。</p>
<p>​    MySQL之间数据复制的基础是<strong>二进制日志文件</strong>（binary log fifile）。它的数据库中所有操作都会以<strong>“事件”</strong>的方式记录在二进制日志中，其他数据库作为slave通过一个<strong>I&#x2F;O线程与主服务器保持通信</strong>，并<strong>监控</strong>master的二进制日志文件的变化，如果发现master二进制日志文件<strong>发生变化</strong>，则会把变化复制到自己的<strong>中继日志</strong>中，然后slave的一个SQL线程会把相关的“事件”<strong>执行</strong>到自己的数据库中，以此实现从数据库和主数据库的<strong>一致性</strong>，也就实现了<strong>主从复制</strong></p>
<h4 id="互备（Active-Active）"><a href="#互备（Active-Active）" class="headerlink" title="互备（Active-Active）"></a><strong>互备（Active-Active）</strong></h4><p>​    指两台主机<strong>同时运行</strong>各自的服务工作且<strong>相互监测</strong>情况。在数据库高可用部分，常见的互备是<strong>MM</strong>模式。MM模式即<strong>Multi-Master</strong>模式，指一个系统存在多个master，每个master都具有<strong>read-write</strong>能力，会根据<strong>时间戳</strong>或<strong>业务逻辑</strong>合并版本。</p>
<h4 id="集群（Cluster）模式"><a href="#集群（Cluster）模式" class="headerlink" title="集群（Cluster）模式"></a><strong>集群（Cluster）模式</strong></h4><p>​    是指有多个节点在运行，同时可以通过主控节点<strong>分担服务</strong>请求。如Zookeeper。集群模式需要解决主控节点<strong>本身的高可用</strong>问题，一般采用主备模式。</p>
<div style="page-break-after: always;"></div>

<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="XA方案-1"><a href="#XA方案-1" class="headerlink" title="XA方案"></a>XA方案</h4><p><strong>两阶段提交</strong> | <strong>三阶段提交</strong></p>
<ul>
<li>准备阶段的资源锁定，存在性能问题，严重时会造成死锁问题</li>
<li>提交事务请求后，出现网络异常，部分数据收到并执行，会造成一致性问</li>
</ul>
<h4 id="TCC方案"><a href="#TCC方案" class="headerlink" title="TCC方案"></a>TCC方案</h4><p><strong>Try Confirm Cancel &#x2F; 短事务</strong></p>
<ul>
<li><p><strong>Try</strong> 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong></p>
</li>
<li><p><strong>Confirm</strong> 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong></p>
</li>
<li><p><strong>Cancel</strong> 阶段：如果任何一个服务的业务方法执行出错，那么就需要<strong>进行补偿</strong>&#x2F;回滚</p>
</li>
</ul>
<h4 id="Saga方案"><a href="#Saga方案" class="headerlink" title="Saga方案"></a><strong>Saga方案</strong></h4><p>事务性补偿 &#x2F; 长事务</p>
<ul>
<li>流程<strong>长</strong>、流程<strong>多</strong>、调用第三方业务</li>
</ul>
<h4 id="本地消息表（eBay）"><a href="#本地消息表（eBay）" class="headerlink" title="本地消息表（eBay）"></a><strong>本地消息表（eBay）</strong></h4><h4 id="MQ最终一致性"><a href="#MQ最终一致性" class="headerlink" title="MQ最终一致性"></a><strong>MQ最终一致性</strong></h4><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmr1k3dfbxj31h00pkjy8.jpg" alt="image-20210117220405706" style="zoom:50%;" />

<p>比如阿里的 RocketMQ 就支持消息事务（核心：<strong>双端确认，重试幂等</strong>）</p>
<ol>
<li>A**(订单)** 系统先发送一个 <strong>prepared</strong> 消息到 mq，prepared 消息发送失败则取消操作不执行了</li>
<li>发送成功后，那么执行本地事务，执行成功和和失败发送<strong>确认和回滚</strong>消息到mq</li>
<li>如果发送了确认消息，那么此时 B**(仓储)** 系统会接收到确认消息，然后执行本地的事务</li>
<li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调的接口，确认事务执行状态</li>
<li>B 的事务失败后自动<strong>不断重试</strong>直到成功，达到一定次数后发送报警由人工来<strong>手工回滚</strong>和<strong>补偿</strong></li>
</ol>
<h4 id="最大努力通知方案（订单-gt-积分）"><a href="#最大努力通知方案（订单-gt-积分）" class="headerlink" title="最大努力通知方案（订单 -&gt; 积分）"></a>最大努力通知方案（订单 -&gt; 积分）</h4><ol>
<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>
<li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，接着调用系统 B 的接口；</li>
<li>要是系统 B 执行失败了，就定时尝试重新调用系统 B，<strong>反复 N 次</strong>，最后还是不行就<strong>放弃</strong></li>
</ol>
<p>你找一个严格<strong>资金</strong>要求绝对不能错的场景，你可以说你是用的 <strong>TCC 方案</strong>；</p>
<p>如果是一般的分布式事务场景，例如<strong>积分</strong>数据，可以用可靠消息<strong>最终一致性方案</strong></p>
<p>如果分布式场景<strong>允许不一致</strong>，可以使用最大努力通知方案</p>
<div style="page-break-after: always;"></div>

<h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分布式Session实现方案"><a href="#分布式Session实现方案" class="headerlink" title="分布式Session实现方案"></a>分布式Session实现方案</h4><ul>
<li>基于JWT的Token，数据从cache或者数据库中获取</li>
<li>基于Tomcat的Redis，简单配置conf文件</li>
<li>基于Spring的Redis，支持SpringCloud和Springb</li>
</ul>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/50cab45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/50cab45/" class="post-title-link" itemprop="url">滑动窗口</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/50cab45/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/50cab45/" data-xid="/posts/50cab45/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><h2 id="滑动窗口算法-1"><a href="#滑动窗口算法-1" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p><strong>滑动窗口框架套路详解</strong></p>
<p>在滑动窗口算法框架中，我编写一首小诗来歌颂滑动窗口算法的伟大：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdEsLiaY9d9CcVdNcPTAdO5MRwZhsxtTc6BaDMpHQtibCX5kY406sxFeaClrlft3j6XiaJ48jq0Gnj2dQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>关于双指针的快慢指针和左右指针的用法，可以参见前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484505&idx=1&sn=0e9517f7c4021df0e6146c6b2b0c4aba&chksm=9bd7fa51aca07347009c591c403b3228f41617806429e738165bd58d60220bf8f15f92ff8a2e&scene=21#wechat_redirect">双指针技巧汇总</a>，<strong>本文就解决一类最难掌握的双指针技巧：滑动窗口技巧，并总结出一套框架，可以保你闭着眼直接套出答案。</strong></p>
<p>说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法技巧的时间复杂度是 O(N)，比一般的字符串暴力算法要高效得多。</p>
<p><strong><em>其实困扰大家的</em>，不是算法的思路，而是各种细节问题</strong>。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<p><strong>所以今天我就写一套滑动窗口算法的代码框架，我连在哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出边界问题</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span>(<span class="params">string s, string t</span>) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; need, <span class="variable language_">window</span>;</span><br><span class="line">    <span class="keyword">for</span> (char c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    int left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    int valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="title function_">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        char c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">window</span> needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            char d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中两处<code>...</code>表示的更新窗口数据的地方，到时候你直接往里面填就行了</strong>。</p>
<p>而且，这两个<code>...</code>处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。</p>
<p><strong>说句题外话，其实有很多人喜欢执着于表象，不喜欢探求问题的本质。</strong>比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。</p>
<p>我也是服了，算法看的是时间复杂度，你能确保自己的时间复杂度最优就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……</p>
<p>重点在于算法思想，你把框架思维了然于心套出解法，然后随你再魔改代码好吧，你高兴就好。</p>
<p>言归正传，<strong>下面就直接上*<em>四道*</em> LeetCode 原题来套这个框架</strong>，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。</p>
<p>本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：</p>
<p><code>unordered_map</code>就是哈希表（字典），它的一个方法<code>count(key)</code>相当于 Java 的<code>containsKey(key)</code>可以判断键 key 是否存在。</p>
<p>可以使用方括号访问键对应的值<code>map[key]</code>。需要注意的是，如果该<code>key</code>不存在，C++ 会自动创建这个 key，并把<code>map[key]</code>赋值为 0。</p>
<p>所以代码中多次出现的<code>map[key]++</code>相当于 Java 的<code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p>
<h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p>LeetCode 76 题，Minimum Window Substring，难度 <strong>Hard</strong>，我带大家看看它到底有多 <strong>Hard</strong>：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowk6hiaxmGN6ibHiaTqxHMqYvCRA4lWuRCQicPSfZY78De1GmwkXviar4psjw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>就是说要在<code>S</code>(source) 中找到包含<code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.size(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p><em><strong>1、</strong></em>我们在字符串<code>S</code>中使用双指针中的左右指针技巧，初始化<code>left = right = 0</code>，<strong>把索引左闭右开区间<code>[left, right)</code>称为一个「窗口」</strong>。</p>
<p><em><strong>2、</strong></em>我们先不断地增加<code>right</code>指针扩大窗口<code>[left, right)</code>，直到窗口中的字符串符合要求（包含了<code>T</code>中的所有字符）。</p>
<p><em><strong>3、</strong></em>此时，我们停止增加<code>right</code>，转而不断增加<code>left</code>指针缩小窗口<code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含<code>T</code>中的所有字符了）。同时，每次增加<code>left</code>，我们都要更新一轮结果。</p>
<p><em><strong>4、</strong></em>重复第 2 和第 3 步，直到<code>right</code>到达字符串<code>S</code>的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code>和<code>window</code>相当于计数器，分别记录<code>T</code>中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEow6FwvAvsZKyCTCtrmLcvKDxhYAJEqI36cAZxfoIWLFibEhmz9IfHf24Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>增加<code>right</code>，直到窗口<code>[left, right)</code>包含了<code>T</code>中所有字符：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowCyAS47jbjAGEfqUVRzkKDWbT6Y8JiarUicPMVR2yI72X3X6hjBGj4bGw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>现在开始增加<code>left</code>，缩小窗口<code>[left, right)</code>。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowoE6BjdgVFKZwEb1q6VibCzIsNuoYmHuNicVdlDibQrQD6lRJbibjkBxO4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code>不再继续移动。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowZQrqU81dPoEicq1J93aicY0A70IdicorFC5kfhJKa66CibKQTJxY4A60jA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>之后重复上述过程，先移动<code>right</code>，再移动<code>left</code>…… 直到<code>right</code>指针到达字符串<code>S</code>的末端，算法结束。</p>
<p>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。<strong>现在我们来看看这个滑动窗口代码框架怎么用</strong>：</p>
<p>首先，初始化<code>window</code>和<code>need</code>两个哈希表，记录窗口中的字符和需要凑齐的字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br></pre></td></tr></table></figure>

<p>然后，使用<code>left</code>和<code>right</code>变量初始化窗口的两端，不要忘了，区间<code>[left, right)</code>是左闭右开的，所以初始情况下窗口没有包含任何元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中<code>valid</code>变量表示窗口中满足<code>need</code>条件的字符个数</strong>，如果<code>valid</code>和<code>need.size</code>的大小相同，则说明窗口已满足条件，已经完全覆盖了串<code>T</code>。</p>
<p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p>
<p><strong>1、</strong>当移动<code>right</code>扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p><strong>2、</strong>什么条件下，窗口应该暂停扩大，开始移动<code>left</code>缩小窗口？</p>
<p><strong>3、</strong>当移动<code>left</code>缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p><strong>4、</strong>我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加<code>window</code>计数器；如果一个字符将移出窗口的时候，应该减少<code>window</code>计数器；当<code>valid</code>满足<code>need</code>时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<p>下面是完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">string <span class="title function_">minWindow</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">len</span> <span class="operator">=</span>= INT_MAX ?</span><br><span class="line">        <span class="string">&quot;&quot;</span> : s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当我们发现某个字符在<code>window</code>的数量满足了<code>need</code>的需要，就要更新<code>valid</code>，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p>
<p>当<code>valid == need.size()</code>时，说明<code>T</code>中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。</p>
<p>移动<code>left</code>收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p>
<p>至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。<strong>以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿</strong>。</p>
<p>下面就直接利用这套框架秒杀几道题吧，你基本上一眼就能看出思路了。</p>
<h3 id="二、字符串排列"><a href="#二、字符串排列" class="headerlink" title="二、字符串排列"></a>二、字符串排列</h3><p>LeetCode 567 题，Permutation in String，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowmo3G9oN6XDmHeHjGic6tUauwoZia40pxjbicJXtN1RcjMMRDkfcGaVNVg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注意哦，输入的<code>s1</code>是可以包含重复字符的，所以这个题难度不小。</p>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个<code>S</code>和一个<code>T</code>，请问你<code>S</code>中是否存在一个子串，包含<code>T</code>中所有字符且不包含其他字符</strong>？</p>
<p>首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line">bool <span class="title function_">checkInclusion</span><span class="params">(string t, string s)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p><strong>1、</strong>本题移动<code>left</code>缩小窗口的时机是窗口大小大于<code>t.size()</code>时，因为排列嘛，显然长度应该是一样的。</p>
<p><strong>2、</strong>当发现<code>valid == need.size()</code>时，就说明窗口中就是一个合法的排列，所以立即返回<code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="三、找所有字母异位词"><a href="#三、找所有字母异位词" class="headerlink" title="三、找所有字母异位词"></a>三、找所有字母异位词</h3><p>这是 LeetCode 第 438 题，Find All Anagrams in a String，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowe98rknTABmhPaxgzV5Vv9gHdEpNUDia6CO0gxuPpNR5My6ogK8wuibTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？<strong>相当于，输入一个串<code>S</code>，一个串<code>T</code>，找到<code>S</code>中所有<code>T</code>的排列，返回它们的起始索引</strong>。</p>
<p>直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="title function_">findAnagrams</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入<code>res</code>即可。</p>
<h3 id="四、最长无重复子串"><a href="#四、最长无重复子串" class="headerlink" title="四、最长无重复子串"></a>四、最长无重复子串</h3><p>这是 LeetCode 第 3 题，Longest Substring Without Repeating Characters，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowdOEyLaTVTiabiabMHr2Z7SzZZ08fxMDZt4uzzRcfvoI7sJzfdORvH0tA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(string s)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是变简单了，连<code>need</code>和<code>valid</code>都不需要，而且更新窗口内数据也只需要简单的更新计数器<code>window</code>即可。</p>
<p>当<code>window[c]</code>值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动<code>left</code>缩小窗口了嘛。</p>
<p>唯一需要注意的是，在哪里更新结果<code>res</code>呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p>
<p>这里和之前不一样，**要在收缩窗口完成后更新<code>res</code>**，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p>
<h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p><strong>建议背诵并默写这套框架，顺便背诵一下文章开头的那首诗。以后就再也不怕子串、子数组问题了。</strong></p>
<p>我觉得吧，能够看到这的都是高手，要么就是在成为高手的路上。有了框架，任他窗口怎么滑，东哥这波车开得依然稳如老狗。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/87975f1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/87975f1/" class="post-title-link" itemprop="url">经典动态规划：0-1 背包问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/87975f1/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/87975f1/" data-xid="/posts/87975f1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：0-1-背包问题"><a href="#经典动态规划：0-1-背包问题" class="headerlink" title="经典动态规划：0-1 背包问题"></a>经典动态规划：0-1 背包问题</h1><p>后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。</p>
<p>今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题，简单描述一下吧：</p>
<p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>举个简单的例子，输入如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span></span><br><span class="line">wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>算法返回 6，选择前两件物品装进背包，总重量 3 小于<code>W</code>，可以获得最大价值 6。</p>
<p>题目就是这么简单，一个典型的动态规划问题。<strong>这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。</strong>这也许就是 0-1 背包这个名词的来历。</p>
<p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划套路详解</a> 中的套路，直接走流程就行了。</p>
<h2 id="动规标准套路"><a href="#动规标准套路" class="headerlink" title="动规标准套路"></a>动规标准套路</h2><p>看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的，今天再来手把手演示一下：</p>
<p><strong>第一步****要明确两点，「状态」和「选择」</strong>。</p>
<p>先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p>
<p>再说选择，也很容易想到啊，对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p>
<p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>PS：此框架出自历史文章 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a>。</p>
<p><strong>第二步**<strong>要明确</strong></strong><code>dp</code>数组的定义**。</p>
<p><code>dp</code>数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用<code>dp</code>数组把状态表示出来。</p>
<p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维<code>dp</code>数组，一维表示可选择的物品，一维表示背包的容量。</p>
<p><strong><code>dp[i][w]</code>的定义如下：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</strong></p>
<p>比如说，如果 <code>dp[3][5]</code> &#x3D; 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p>
<p>PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种动规套路都被扒得清清楚楚了。</p>
<p><strong>根据这个定义，我们想求的最终答案就是</strong>**<code>dp[N][W]</code>。base case 就是<code>dp[0][..] = dp[..][0] = 0</code>**，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p>
<p>细化上面的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = max(</span><br><span class="line">            把物品 i 装进背包,</span><br><span class="line">            不把物品 i 装进背包</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<p><strong>第三步****，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>简单说就是，上面伪码中「把物品<code>i</code>装进背包」和「不把物品<code>i</code>装进背包」怎么用代码体现出来呢？</p>
<p><strong>这一步要结合对</strong><strong><code>dp</code>数组的定义和我们的算法逻辑来分析：</strong></p>
<p>先重申一下刚才我们的<code>dp</code>数组的定义：</p>
<p><code>dp[i][w]</code>表示：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>时，这种情况下可以装下的最大价值是<code>dp[i][w]</code>。</p>
<p><strong>如果你没有把这第</strong><strong><code>i</code>个物品装入背包</strong>，那么很显然，最大价值<code>dp[i][w]</code>应该等于<code>dp[i-1][w]</code>。你不装嘛，那就继承之前的结果。</p>
<p><strong>如果你把这第</strong><strong><code>i</code>个物品装入了背包</strong>，那么<code>dp[i][w]</code>应该等于<code>dp[i-1][w-wt[i-1]] + val[i-1]</code>。</p>
<p>首先，由于<code>i</code>是从 1 开始的，所以对<code>val</code>和<code>wt</code>的取值是<code>i-1</code>。</p>
<p>而<code>dp[i-1][w-wt[i-1]]</code>也很好理解：你如果想装第<code>i</code>个物品，你怎么计算这时候的最大价值？<strong>换句话说，在装第</strong><strong><code>i</code>个物品的前提下，背包能装的最大价值是多少？</strong></p>
<p>显然，你应该寻求剩余重量<code>w-wt[i-1]</code>限制下能装的最大价值，加上第<code>i</code>个物品的价值<code>val[i-1]</code>，这就是装第<code>i</code>个物品的前提下，背包可以装的最大价值。</p>
<p>综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = max(</span><br><span class="line">            dp[i-<span class="number">1</span>][w],</span><br><span class="line">            dp[i-<span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>]</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<p><strong>最后一步****，把伪码翻译成代码，处理一些边界情况</strong>。</p>
<p>我用 C++ 写的代码，把上面的思路完全翻译了一遍，并且处理了<code>w - wt[i-1]</code>可能小于 0 导致数组索引越界的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> &#123;</span><br><span class="line">    <span class="comment">// vector 全填入 0，base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">dp</span><span class="params">(N + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>)</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i-<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你看这个解法代码，是不是感觉非常简单，就是把我们刚才分析的思路原封不动翻译了一下而已。</p>
<p>所以说，明确了动态规划的套路，思路就显得行云流水，非常自然就出答案了。</p>
<p>至此，背包问题就解决了。相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导逻辑比较容易想到，基本上你明确了<code>dp</code>数组的定义，就可以理所当然地确定状态转移了。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/20eb9dff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/20eb9dff/" class="post-title-link" itemprop="url">益智游戏克星：BFS暴力搜索算法</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/20eb9dff/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/20eb9dff/" data-xid="/posts/20eb9dff/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="益智游戏克星：BFS暴力搜索算法"><a href="#益智游戏克星：BFS暴力搜索算法" class="headerlink" title="益智游戏克星：BFS暴力搜索算法"></a>益智游戏克星：BFS暴力搜索算法</h1><h2 id="益智游戏克星：BFS暴力搜索算法-1"><a href="#益智游戏克星：BFS暴力搜索算法-1" class="headerlink" title="益智游戏克星：BFS暴力搜索算法"></a>益智游戏克星：BFS暴力搜索算法</h2><p>滑动拼图游戏大家应该都玩过，下图是一个 4x4 的滑动拼图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5zWwfF_20210507183108.png" alt="图片"></p>
<p>拼图中有一个格子是空的，可以利用这个空着的格子移动其他数字。你需要通过移动这些数字，得到某个特定排列顺序，这样就算赢了。</p>
<p>我小时候还玩过一款叫做「华容道」的益智游戏，也和滑动拼图比较类似：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ueMqO0_20210507183151.png" alt="图片"></p>
<p>那么这种游戏怎么玩呢？我记得是有一些套路的，类似于魔方还原公式。但是我们今天不来研究让人头秃的技巧，<strong>这些益智游戏通通可以用暴力搜索算法解决，所以今天我们就学以致用，用 BFS 算法框架来秒杀这些游戏</strong>。</p>
<h3 id="一、题目解析"><a href="#一、题目解析" class="headerlink" title="一、题目解析"></a>一、题目解析</h3><p>LeetCode 第 773 题就是滑动拼图问题，题目的意思如下：</p>
<p>给你一个 2x3 的滑动拼图，用一个 2x3 的数组<code>board</code>表示。拼图中有数字 0~5 六个数，其中数字 0 就表示那个空着的格子，你可以移动其中的数字，当<code>board</code>变为<code>[[1,2,3],[4,5,0]]</code>时，赢得游戏。</p>
<p>请你写一个算法，计算赢得游戏需要的最少移动次数，如果不能赢得游戏，返回 -1。</p>
<p>比如说输入的二维数组<code>board = [[4,1,2],[5,0,3]]</code>，算法应该返回 5：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/DnxfJo_20210507183245.png" alt="图片"></p>
<p>如果输入的是<code>board = [[1,2,3],[4,0,5]]</code>，则算法返回 -1，因为这种局面下无论如何都不能赢得游戏。</p>
<h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><p>对于这种计算最小步数的问题，我们就要敏感地想到 BFS 算法。</p>
<p>这个题目转化成 BFS 问题是有一些技巧的，我们面临如下问题：</p>
<p>1、一般的 BFS 算法，是从一个起点<code>start</code>开始，向终点<code>target</code>进行寻路，但是拼图问题不是在寻路，而是在不断交换数字，这应该怎么转化成 BFS 算法问题呢？</p>
<p>2、即便这个问题能够转化成 BFS 问题，如何处理起点<code>start</code>和终点<code>target</code>？它们都是数组哎，把数组放进队列，套 BFS 框架，想想就比较麻烦且低效。</p>
<p>首先回答第一个问题，<strong>BFS 算法并不只是一个寻路算法，而是一种暴力搜索算法</strong>，只要涉及暴力穷举的问题，BFS 就可以用，而且可以最快地找到答案。</p>
<p>你想想计算机怎么解决问题的？哪有那么多奇技淫巧，本质上就是把所有可行解暴力穷举出来，然后从中找到一个最优解罢了。</p>
<p>明白了这个道理，我们的问题就转化成了：<strong>如何穷举出<code>board</code>当前局面下可能衍生出的所有局面</strong>？这就简单了，看数字 0 的位置呗，和上下左右的数字进行交换就行了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KoSRd4_20210507183301.png" alt="图片"></p>
<p>这样其实就是一个 BFS 问题，每次先找到数字 0，然后和周围的数字进行交换，形成新的局面加入队列…… 当第一次到达<code>target</code>时，就得到了赢得游戏的最少步数。</p>
<p>对于第二个问题，我们这里的<code>board</code>仅仅是 2x3 的二维数组，所以可以压缩成一个一维字符串。<strong>其中比较有技巧性的点在于，二维数组有「上下左右」的概念，压缩成一维后，如何得到某一个索引上下左右的索引</strong>？</p>
<p>很简单，我们只要手动写出来这个映射就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**这个含义就是，在一维字符串中，索引<code>i</code>在二维数组中的的相邻索引为<code>neighbor[i]</code>**，：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CkiHlV_20210507183314.png" alt="图片"></p>
<p>至此，我们就把这个问题完全转化成标准的 BFS 问题了，借助前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485134&idx=1&sn=fd345f8a93dc4444bcc65c57bb46fc35&chksm=9bd7f8c6aca071d04c4d383f96f2b567ad44dc3e67d1c3926ec92d6a3bcc3273de138b36a0d9&scene=21#wechat_redirect">BFS 算法框架套路详解</a> 的代码框架，直接就可以套出解法代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">slidingPuzzle</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>, n = <span class="number">3</span>;</span><br><span class="line">    <span class="type">string</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">string</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;123450&quot;</span>;</span><br><span class="line">    <span class="comment">// 将 2x3 的数组转化成字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            start.push_back(board[i][j] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录一维字符串的相邻索引</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* BFS 算法框架开始 *******/</span></span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_set&lt;string&gt; visited;</span><br><span class="line">    q.push(start);</span><br><span class="line">    visited.insert(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">cur</span> <span class="operator">=</span> q.front(); q.pop();</span><br><span class="line">            <span class="comment">// 判断是否达到目标局面</span></span><br><span class="line">            <span class="keyword">if</span> (target == cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到数字 0 的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; cur[idx] != <span class="string">&#x27;0&#x27;</span>; idx++);</span><br><span class="line">            <span class="comment">// 将数字 0 和相邻的数字交换位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> adj : neighbor[idx]) &#123;</span><br><span class="line">                <span class="type">string</span> <span class="variable">new_board</span> <span class="operator">=</span> cur;</span><br><span class="line">                swap(new_board[adj], new_board[idx]);</span><br><span class="line">                <span class="comment">// 防止走回头路</span></span><br><span class="line">                <span class="keyword">if</span> (!visited.count(new_board)) &#123;</span><br><span class="line">                    q.push(new_board);</span><br><span class="line">                    visited.insert(new_board);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/******* BFS 算法框架结束 *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就解决了，其实框架完全没有变，套路都是一样的，我们只是花了比较多的时间将滑动拼图游戏转化成 BFS 算法。</p>
<p><strong>很多益智游戏都是这样，虽然看起来特别巧妙，但都架不住暴力穷举</strong>，常用的算法就是回溯算法或者 BFS 算法，感兴趣的话我们以后再聊。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/6e379f18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6e379f18/" class="post-title-link" itemprop="url">java学习路线问题整理</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/6e379f18/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/6e379f18/" data-xid="/posts/6e379f18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>123k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:52</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java学习路线问题整理"><a href="#java学习路线问题整理" class="headerlink" title="java学习路线问题整理"></a>java学习路线问题整理</h1><p><img src="https://pic1.zhimg.com/50/v2-62586d6789e1a081cc3dc6efd7bdd289_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-62586d6789e1a081cc3dc6efd7bdd289_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a><strong>Java 基础</strong></h2><p>为了能让自己写出更优秀的代码，《Effective Java》、《重构》 这两本书没事也可以看</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>一些关于并发的小问题，拿来自测：</p>
<h4 id="一、什么是线程和进程-线程与进程的关系-区别及优缺点？"><a href="#一、什么是线程和进程-线程与进程的关系-区别及优缺点？" class="headerlink" title="一、什么是线程和进程? 线程与进程的关系,区别及优缺点？"></a>一、什么是线程和进程? 线程与进程的关系,区别及优缺点？</h4><p>*<em>Linux</em>***的进程、线程、文件描述符是 什么</p>
<p>**答案:<strong>在</strong> <strong>Linux</strong> <strong>系统中，进程和线程几乎没有区别</strong>。</p>
<p>Linux 中的进程就是一个数据结构，看明白就可以理解文件描述符、重定 向、管道命令的底层工作原理，最后我们从操作系统的角度看看为什么说线 程和进程基本没有区别。</p>
<h5 id="1、进程是什么"><a href="#1、进程是什么" class="headerlink" title="1、进程是什么"></a><strong>1、进程是什么</strong></h5><p>首先，抽象地来说，我们的计算机就是这个东⻄:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FsPOLs_20210528153018.png" alt="进程"></p>
<p>   这个大的矩形表示计算机的<strong>内存空间</strong>，其中的小矩形代表<strong>进程</strong>，左下角的圆 形表示<strong>磁盘</strong>，右下角的图形表示一些<strong>输入输出设备</strong>，比如鼠标键盘显示器等 等。另外，注意到内存空间被划分为了两块，上半部分表示<strong>用户空间</strong>，下半部分表示<strong>内核空间</strong>。</p>
<p>   用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组， 这个数组肯定存在用户空间;内核空间存放内核进程需要加载的系统资源， 这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内 核空间的资源，比如一些动态链接库等等。</p>
<p>   我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运 行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新 建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后 执行，最后退出。</p>
<p>   <strong>你编译好的那个可执行程序只是一个文件</strong>，不是进程，可执行文件必须要载 入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的， 每个进程都有它的固有属性，比如进程号(PID)、进程状态、打开的文件 等等，进程创建好之后，读入你的程序，你的程序才被系统执行。</p>
<p>   那么，操作系统是如何创建进程的呢?<strong>对于操作系统，进程就是一个数据结 构</strong>，我们直接来看 Linux 的源码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span> </span><br><span class="line">    <span class="comment">// 进程状态</span></span><br><span class="line">	  <span class="type">long</span> state; </span><br><span class="line">  	<span class="comment">// 虚拟内存结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> </span><br><span class="line">  	<span class="comment">// 进程号</span></span><br><span class="line">	  <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 指向父进程的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> </span><br><span class="line">  	<span class="comment">// 子进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span> </span><br><span class="line">  	<span class="comment">// 存放文件系统信息的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="comment">// 一个数组，包含该进程打开的文件指针 </span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>task_struct 就是Linux内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，我这里就截取了一小部分比较常⻅的。</p>
<p>   其中比较有意思的是 mm 指针和 files 指针。 mm 指向的是进程的虚拟内 存，也就是载入资源和可执行文件的地方; files 指针指向一个数组，这 个数组里装着所有该进程打开的文件的指针。</p>
<h5 id="2、文件描述符是什么"><a href="#2、文件描述符是什么" class="headerlink" title="2、文件描述符是什么"></a><strong>2、文件描述符是什么</strong></h5><p>   先说 files ，它是一个文件指针数组。一般来说，一个进程会 从 files[0] 读取输入，将输出写入 files[1] ，将错误信息写 入 files[2] 。</p>
<p>   举个例子，以我们的角度 C 语言的 printf 函数是向命令行打印字符，但是 从进程的角度来看，就是向 files[1] 写入数据;同理， scanf函数就是进程试图从files[0] 这个文件中读取数据。</p>
<p>   <strong>每个进程被创建时，</strong> <strong>files</strong> <strong>的前三位被填入默认值，分别指向标准输入 流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件 指针数组的索引</strong>，所以程序的文件描述符默认情况下 0 是输入，1 是输出， 2 是错误。</p>
<p>   我们可以重新画一幅图:</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210528160949534_20210528160949.png"></p>
<p>   对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器， 所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的 进程需要通过「系统调用」让内核进程访问硬件资源。</p>
<p>   PS:不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读 和写。</p>
<p>   如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到 files 的第 4 个位置:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210528161138345_20210528161138.png"></p>
<p>   明白了这个原理，<strong>输入重定向</strong>就很好理解了，程序想读取数据的时候就会 去 files[0] 读取，所以我们只要把 files[0] 指向一个文件，那么程序就会 从这个文件中读取数据，而不是从键盘:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command &lt; file.txt</span><br></pre></td></tr></table></figure>
<p>同理，<strong>输出重定向</strong>就是把 files[1] 指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中:</p>
<p>错误重定向也是一样的，就不再赘述。<br><strong>管道符</strong>其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起 一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美:</p>
<p>   $ command &gt; file.txt</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/cBsve1_20210528161752.png"></p>
<p>到这里，你可能也看出「Linux 中一切皆文件」设计思路的高明了，不管是 设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一 装进一个简单的 files 数组，进程通过简单的文件描述符访问相应资源， 具体细节交于操作系统，有效解耦，优美高效。</p>
<h5 id="3、线程是什么"><a href="#3、线程是什么" class="headerlink" title="3、线程是什么"></a><strong>3、线程是什么</strong></h5><p>首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。</p>
<p>为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来 看，并没有把线程和进程区别对待。</p>
<p>我们知道系统调用 fork() 可以新建一个子进程，函数 pthread() 可以新建 一个线程。<strong>但无论线程还是进程，都是用task_struct结构表示的，唯一的 区别就是共享的数据区域不同</strong>。</p>
<p>   换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进 程是共享的，而子进程是拷⻉副本，而不是共享。就比如说， mm 结构 和 files 结构在线程中都是共享的，我画两张图你就明白了:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CJSUA2_20210528162328.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/AHziKB_20210528162403.png"></p>
<p>   所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写 入数据，否则可能造成数据错乱。</p>
<p>   那么你可能问，<strong>既然进程和线程差不多，而且多进程数据不共享，即不存在 数据错乱的问题，为什么多线程的使用比多进程普遍得多呢</strong>?</p>
<p>   因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元， 我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一 个账户的拷⻉，每个拷⻉账户减少十元。</p>
<p>   当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对 其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其 特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复 杂度。</p>
<p>   在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷 ⻉的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父 进程的内存空间，而是等到需要写操作时才去复制。<strong>所以</strong> <strong>Linux</strong> <strong>中新建进 程和新建线程都是很迅速的</strong>。</p>
<h4 id="二、说说并发与并行的区别"><a href="#二、说说并发与并行的区别" class="headerlink" title="二、说说并发与并行的区别?"></a>二、说说并发与并行的区别?</h4><ul>
<li>并发:一个处理器同时处理多个任务。</li>
<li>并行:多个处理器或者是多核的处理器同时处理多个不同的任务.</li>
</ul>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．</p>
</blockquote>
<ul>
<li>并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</li>
<li>并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</li>
</ul>
<blockquote>
<p>来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/r17aCh_20210603225408.png" alt="img"></p>
<p align="center">并发与并行的区别</p>

<p>下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况。假设每个核心有两个线程，那么每个CPU中两个线程会交替并发，两个CPU之间的操作会并行运算。单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，其本身运行效率并没有提高，多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/XjIFCX_20210603225422.png" alt="img"></p>
<center>双核四线程运行示意图</center>



<h4 id="三、为什么要使用多线程呢"><a href="#三、为什么要使用多线程呢" class="headerlink" title="三、为什么要使用多线程呢?"></a>三、为什么要使用多线程呢?</h4><h5 id="从系统应用上来思考："><a href="#从系统应用上来思考：" class="headerlink" title="从系统应用上来思考："></a>从系统应用上来思考：</h5><ul>
<li>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间切换和调度的成本远远小于进程。另外，多核 CPU 时代，意味着多个线程可以同时运行，这减少了线程上下文切换的开销；</li>
<li>如今的系统，动不动就要求百万级甚至亿万级的并发量，而多线程并发编程，正是开发高并发系统的基础，利用好多线程机制，可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h5 id="从计算机背后来探讨："><a href="#从计算机背后来探讨：" class="headerlink" title="从计算机背后来探讨："></a>从计算机背后来探讨：</h5><p><strong>单核时代：</strong> 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程工作的时候，会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。可以简单地理解成，这两者的利用率最高都是 50%左右。但是当有两个线程的时候就不一样了，一个线程执行 CPU 计算时，另外一个线程就可以进行 IO 操作，这样 CPU 和 IO 设备两个的利用率就可以在理想情况下达到 100%；</p>
<p><strong>多核时代：</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只有一个 CPU 核心被利用到，而创建多个线程，就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p>
<h4 id="四、创建线程有哪几种方式？（a-继承-Thread-类-b-实现-Runnable-接口-c-使用-Executor-框架-d-使用-FutureTask）"><a href="#四、创建线程有哪几种方式？（a-继承-Thread-类-b-实现-Runnable-接口-c-使用-Executor-框架-d-使用-FutureTask）" class="headerlink" title="四、创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）"></a>四、创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）</h4><h4 id="五、说说线程的生命周期和状态"><a href="#五、说说线程的生命周期和状态" class="headerlink" title="五、说说线程的生命周期和状态?"></a>五、说说线程的生命周期和状态?</h4><p>那么现在我们来了解线程一个完整的生命周期的运行过程，与下图可以看出有：新建 - 就绪 - 运行 - 阻塞 - 死亡五个过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/RqeQ7h_20210603234327.png" alt="img"></p>
<p>下面我们一个一个的来介绍：</p>
<ul>
<li>新建：刚刚创建还在内存当中，还没有在可调度线程池中，还不能被cpu调度执行工作。</li>
<li>就绪：进入调度池，可被调度。</li>
<li>运行：CPU负责调度”可调度线程池”中的处于”就绪状态”的线程，线程执行结束之前,状态可能会在”就绪”和”运行”之间来回的切换。“就绪”和”运行”之间的状态切换由CPU来完成,程序员无法干涉</li>
<li>阻塞：正在运行的线程,当满足某个条件时,可以用休眠或者锁来阻塞线程的执行，被移出调度池，进入内存，不可执行。</li>
<li>死亡：分为两种情况。正常死亡，线程执行结束。非正常死亡，程序突然崩溃&#x2F;当满足某个条件后，在线程内部强制线程退出,调用exit方法。<h5 id="exit方法的作用和总结"><a href="#exit方法的作用和总结" class="headerlink" title="exit方法的作用和总结"></a>exit方法的作用和总结</h5></li>
</ul>
<ol>
<li><p>使当前线程退出.</p>
</li>
<li><p>不能在主线程中调用该方法，会使主线程退出.</p>
</li>
<li><p>当前线程死亡之后,这个线程中的代码都不会被执行.</p>
</li>
<li><p>在调用此方法之前一定要注意释放之前由C语言框架创建的对象.</p>
</li>
</ol>
<h4 id="六、什么是上下文切换"><a href="#六、什么是上下文切换" class="headerlink" title="六、什么是上下文切换?"></a>六、什么是上下文切换?</h4><p>   现在<strong>linux</strong>是大多基于抢占式，CPU给每个任务一定的服务时间，当时间片轮转的时候，需要把当前状态保存下来，同时加载下一个任务，这个过程叫做<strong>上下文切换</strong>。时间片轮转的方式，使得多个任务利用一个CPU执行成为可能，但是保存现场和加载现场，也带来了性能消耗。 那线程上下文切换的次数和时间以及性能消耗如何看呢？</p>
<p>   上下文切换的性能消耗在哪里呢？<br>   context switch过高，会导致CPU像个搬运工，频繁在寄存器和运行队列直接奔波 ，更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。</p>
<p>   引起上下文切换的原因有哪些？<br>   对于抢占式操作系统而言， 大体有几种：<br>   1、当前任务的时间片用完之后，系统CPU正常调度下一个任务；<br>   2、当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；<br>   3、多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；<br>   4、用户代码挂起当前任务，让出CPU时间；<br>   5、硬件中断；<br>   监测Linux的应用的时候，当CPU的利用率非常高，但是系统的性能却上不去的时候，不妨监控一下线程&#x2F;进程的切换，看看是不是context switching导致的overhead过高。<br>   常用命令： pidstat vmstat</p>
<h4 id="七、什么是线程死锁-如何避免死锁"><a href="#七、什么是线程死锁-如何避免死锁" class="headerlink" title="七、什么是线程死锁?如何避免死锁?"></a>七、什么是线程死锁?如何避免死锁?</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p> 当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<p>下面用一个非常简单的死锁示例来帮助你理解死锁的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取String.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">线程b尝试获取String.class</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">无限阻塞下去</span><br></pre></td></tr></table></figure>

<h5 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h5><p>教科书般的回答应该是，结合“哲学家就餐“模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p>
<p>造成死锁必须达成的4个条件（原因）：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个线程使用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p>
<ol>
<li>互斥条件 —&gt; 独占锁的特点之一。</li>
<li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li>
<li>不剥夺条件 —&gt; 独占锁的特点之一。</li>
<li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li>
</ol>
<p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p>
<p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p>
<p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>是否能够简单明了的在面试中阐述清楚死锁产生的原因，并给出解决死锁的方案，可以体现程序员在面对对并发问题时思路是否清晰，对并发的基础掌握是否牢固等等。<br> 而且在实际项目中并发模块的逻辑往往比本文的示例复杂许多，所以写并发应用之前一定要充分理解本文所总结的要点，并切记，并发程序编程在不显著影响程序性能的情况下，一定要尽可能的保守。</p>
<h4 id="八、说说-sleep-方法和-wait-方法区别和共同点"><a href="#八、说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="八、说说 sleep() 方法和 wait() 方法区别和共同点?"></a>八、说说 sleep() 方法和 wait() 方法区别和共同点?</h4><h5 id="1-方法来源区别"><a href="#1-方法来源区别" class="headerlink" title="1.方法来源区别"></a>1.方法来源区别</h5><p>wait方法定义在Object上,Thread.sleep()定义在Thread上(这很重要,定义决定作用范围)</p>
<h5 id="2-关于锁和cpu"><a href="#2-关于锁和cpu" class="headerlink" title="2.关于锁和cpu"></a>2.关于锁和cpu</h5><p>结论:二者都释放cpu,wait()释放锁,Thread.sleep()不会释放锁.<br> 解释如下:<br> 1.别管是Object.wait()还是Thread.sleep(),都是暂停执行,所以这里都会释放cpu.<br> 2.Object.wait()方法是对象拥有,然后对象锁又是在synchronized同步代码块中使用,所以Object.wait()方法拥有锁的控制权,所以他会释放锁资源.而Thread.sleep()是Thread上的静态方法,所以只能使当前线程睡眠,但是它和锁没有任何关系,所以就没有锁的释放这一问题.</p>
<h5 id="3-作用范围"><a href="#3-作用范围" class="headerlink" title="3.作用范围"></a>3.作用范围</h5><ul>
<li><p>Object.wait()方法只能在synchronized快中调用,并且需要和notify和notifyAll配合使用.</p>
</li>
<li><p>Thread.sleep（）是可以在任何上下文调用的,注意是暂停当前的线程<br> 所以就方法而言,Object.wait()主要用在多线程之间的协同工作,Thread.sleep（）主要是控制一个线程的执行时间长短.</p>
<h5 id="4-关于异常"><a href="#4-关于异常" class="headerlink" title="4 关于异常"></a>4 关于异常</h5><p>Object.wait()方法和Thread.sleep()都抛出 InterruptedException,并且方法定义为final,<br> 所以方法不能被重写,那么在使用 该方法时就只能 try()catch(){}异常,(为什么说只能try,因为如果不捕获异常,那么也意味着你的方法抛出的异常就只能是InterruptedException,或者它的子类,所以这里一般都是捕获异常并处理异常,可以在catch中抛出其他异常)</p>
<h4 id="九、synchronized-关键字、volatile-关键字"><a href="#九、synchronized-关键字、volatile-关键字" class="headerlink" title="九、synchronized 关键字、volatile 关键字"></a>九、synchronized 关键字、volatile 关键字</h4></li>
<li><p>volatile是通知jvm当前变量在寄存器或者cpu中的值是不确定的，需要从主存中读取。不会阻塞线程。</p>
</li>
<li><p>synchronized则是通过锁机制来控制变量是否可以访问。当变量被锁时，其他线程访问变量将被阻塞，直至锁释放。</p>
</li>
</ul>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h5><ol>
<li>volatile保证其他线程对这个变量操作时是立即可见的，即操作的是从内存中读取的最新值</li>
<li>无法保证原子性</li>
<li>只能修饰变量</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="built_in">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;----&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        test.increase();        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台输出：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/A70Fzt_20210607142025.png" alt="img"></p>
<p>控制台输出</p>
<ul>
<li>使用场景(DCL双重检测锁)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h5><ol>
<li>保证原子性</li>
<li>即可修饰变量也可修饰方法</li>
<li>会阻塞线程<h6 id="1）synchronized非静态方法"><a href="#1）synchronized非静态方法" class="headerlink" title="1）synchronized非静态方法"></a>1）synchronized非静态方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;increase1----&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;increase2----&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    test.increase1();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    test.increase2();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>控制台输出：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/p830x9_20210607142306.png" alt="img"></p>
<ul>
<li>结论：</li>
</ul>
<p>如果一个对象有多个synchronized方法，多个线程同时调用该对象的方法，将会同步执行，即同时只能有一个synchronized方法被调用，其他调用将被阻塞直至该方法执行完</p>
<h6 id="2）synchronized静态方法"><a href="#2）synchronized静态方法" class="headerlink" title="2）synchronized静态方法"></a>2）synchronized静态方法</h6><blockquote>
<p>懒。。  直接给结论了</p>
</blockquote>
<p>synchronized静态方法和非静态方法的区别在于给方法上锁的对象不一样，非静态方法是给调用的对象上锁，静态方法是给类的Class对象上锁</p>
<h6 id="3）synchronized块"><a href="#3）synchronized块" class="headerlink" title="3）synchronized块"></a>3）synchronized块</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase1</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase1----------&gt; start&quot;</span>);</span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;increase1----&gt;&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase1----------&gt; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase2</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase2----------&gt; start&quot;</span>);</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;increase2----&gt;&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase2----------&gt; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    test.increase1();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    test.increase2();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台输出：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BgNds7_20210607142434.png" alt="img"></p>
<ul>
<li>结论</li>
</ul>
<p><strong>synchronized方法</strong>是控制同时只能有一个线程执行synchronized方法；<strong>synchronized块</strong>是控制同时只能有一个线程执行synchronized块中的内容</p>
<h4 id="十、ThreadLocal-有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？"><a href="#十、ThreadLocal-有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？" class="headerlink" title="十、ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？"></a>十、ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？</h4><h5 id="ThreadLoacl是什么"><a href="#ThreadLoacl是什么" class="headerlink" title="ThreadLoacl是什么"></a>ThreadLoacl是什么</h5><p>在了解ThreadLocal之前，我们先了解下什么是<strong>线程封闭</strong></p>
<blockquote>
<p>把对象封闭在一个线程里，即使这个对象不是线程安全的，也不会出现并发安全问题。</p>
</blockquote>
<p>实现线程封闭大致有三种方式：</p>
<ul>
<li>Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担，不推荐使用</li>
<li>栈封闭：就是用<strong>栈</strong>（stack）来保证线程安全</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">testThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">    sb.<span class="built_in">append</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder是线程不安全的，但是它只是个<strong>局部变量</strong>，局部变量存储在<strong>虚拟机栈</strong>，<strong>虚拟机栈</strong>是线程隔离的，所以不会有线程安全问题</p>
<ul>
<li>ThreadLocal线程封闭：简单易用</li>
</ul>
<p>第三种方式就是通过ThreadLocal来实现线程封闭，线程封闭的指导思想是<strong>封闭</strong>，而不是共享。所以说ThreadLocal是用来解决<strong>变量共享</strong>的并发安全问题，多少有些不精确。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>JDK1.2开始提供的java.lang.ThreadLocal的使用方式非常简单</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line"></span><br><span class="line">        final ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        threadLocal.<span class="keyword">set</span>(<span class="string">&quot;main-thread : Hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取不到主线程设置的值，所以为null</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">            threadLocal.<span class="keyword">set</span>(<span class="string">&quot;sub-thread : World&quot;</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 让子线程先执行完成，再继续执行主线</span></span><br><span class="line">        thread.<span class="keyword">join</span>();</span><br><span class="line">        <span class="comment">// 获取到的是主线程设置的值，而不是子线程设置的</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        threadLocal.<span class="keyword">remove</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line">sub-thread : World</span><br><span class="line">main-thread : Hello</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>运行结果说明了ThreadLocal只能获取本线程设置的值，也就是线程封闭。基本上，ThreadLocal对外提供的方法只有三个get()、set(T)、remove()。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>使用方式非常简单，所以我们来看看ThreadLocal的源码。ThreadLocal内部定义了一个静态ThreadLocalMap类，ThreadLocalMap内部又定义了一个Entry类，这里只看一些主要的属性和方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.<span class="built_in">currentThread</span>();</span><br><span class="line">        ThreadLocalMap map = <span class="built_in">getMap</span>(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.<span class="built_in">getEntry</span>(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                @<span class="built_in">SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setInitialValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.<span class="built_in">currentThread</span>();</span><br><span class="line">        ThreadLocalMap map = <span class="built_in">getMap</span>(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null)</span><br><span class="line">            map.<span class="built_in">set</span>(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">createMap</span>(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = <span class="built_in">getMap</span>(Thread.<span class="built_in">currentThread</span>());</span><br><span class="line">         <span class="keyword">if</span> (m != null)</span><br><span class="line">             m.<span class="built_in">remove</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这里可以看出ThreadLocalMap对象是被Thread类持有的</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="built_in">ThreadLocalMap</span>(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类ThreadLocalMap</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            <span class="comment">// 内部类Entity，实际存储数据的地方</span></span><br><span class="line">            <span class="comment">// Entry的key是ThreadLocal对象，不是当前线程ID或者名称</span></span><br><span class="line">            <span class="built_in">Entry</span>(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里维护的是Entry数组</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的源码，可以大致画出ThreadLocal在虚拟机内存中的结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Yr7agv_20210607143151.png" alt="img"></p>
<p>实线箭头表示强引用，虚线箭头表示弱引用。需要注意的是：</p>
<ul>
<li>ThreadLocalMap虽然是在ThreadLocal类中定义的，但是实际上被Thread持有。</li>
<li>Entry的key是（虚引用的）ThreadLocal对象，而不是当前线程ID或者线程名称。</li>
<li>ThreadLocalMap中持有的是Entry数组，而不是Entry对象。</li>
</ul>
<p>对于第一点，ThreadLocalMap被Thread持有是为了实现每个线程都有自己独立的ThreadLocalMap对象，以此为基础，做到线程隔离。第二点和第三点理解，我们先来想一个问题，如果同一个线程中定义了多个ThreadLocal对象，内存结构应该是怎样的？此时再来看一下ThreadLocal.set(T)方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据线程对象获取ThreadLocalMap对象（ThreadLocalMap被Thread持有）</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果ThreadLocalMap存在，则直接插入；不存在，则新建ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果程序定义了多个ThreadLocal，会共用一个ThreadLocalMap对象，所以内存结构应该是这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/t7McjA_20210607143222.png" alt="img"></p>
<p>这个内存结构图解释了第二点和第三点。假设Entry中key为当前线程ID或者名称的话，那么程序中定义多个ThreadLocal对象时，Entry数组中的所有Entry的key都一样（或者说只能存一个value）。ThreadLocalMap中持有的是Entry数组，而不是Entry，则是因为程序可定义多个ThreadLocal对象，自然需要一个数组。</p>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><strong>ThreadLocal会发生内存泄漏吗？</strong></p>
<blockquote>
<p>会</p>
</blockquote>
<p>仔细看下ThreadLocal内存结构就会发现，Entry数组对象通过ThreadLocalMap最终被Thread持有，并且是强引用。也就是说Entry数组对象的生命周期和当前线程一样。即使ThreadLocal对象被回收了，Entry数组对象也不一定被回收，这样就有可能发生内存泄漏。ThreadLocal在设计的时候就提供了一些补救措施：</p>
<ul>
<li>Entry的key是弱引用的ThreadLocal对象，很容易被回收，导致key为null（但是value不为null）。所以在调用get()、set(T)、remove()等方法的时候，会自动清理key为null的Entity。</li>
<li>remove()方法就是用来清理无用对象，防止内存泄漏的。所以每次用完ThreadLocal后需要手动remove()。</li>
</ul>
<p><strong>有些文章认为是弱引用导致了内存泄漏，其实是不对的。假设把弱引用变成强引用，这样无用的对象key和value都不为null，反而不利于GC，只能通过remove()方法手动清理，或者等待线程结束生命周期。也就是说ThreadLocalMap的生命周期由持有它的线程来决定，线程如果不进入terminated状态，ThreadLocalMap就不会被GC回收，这才是ThreadLocal内存泄露的原因。</strong></p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>维护JDBC的java.sql.Connection对象，因为每个线程都需要保持特定的Connection对象。</li>
<li>Web开发时，有些信息需要从controller传到service传到dao，甚至传到util类。看起来非常不优雅，这时便可以使用ThreadLocal来优雅的实现。</li>
<li>包括线程不安全的工具类，比如Random、SimpleDateFormat等</li>
</ul>
<h5 id="与synchronized的关系"><a href="#与synchronized的关系" class="headerlink" title="与synchronized的关系"></a>与synchronized的关系</h5><p>有些文章拿ThreadLocal和synchronized比较，其实它们的实现思想不一样。</p>
<ul>
<li>synchronized是同一时间最多只有一个线程执行，所以变量只需要存一份，算是一种时间换空间的思想</li>
<li>ThreadLocal是多个线程互不影响，所以每个线程存一份变量，算是一种空间换时间的思想</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>ThreadLocal是一种隔离的思想，当一个变量需要进行线程隔离时，就可以考虑使用ThreadLocal来优雅的实现。</p>
<h4 id="十一、为什么要用线程池？ThreadPoolExecutor-类的重要参数了解吗？ThreadPoolExecutor-饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？"><a href="#十一、为什么要用线程池？ThreadPoolExecutor-类的重要参数了解吗？ThreadPoolExecutor-饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？" class="headerlink" title="十一、为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？"></a>十一、为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？</h4><h4 id="十二、AQS-了解么？原理？AQS-常用组件：Semaphore-信号量-、CountDownLatch-（倒计时器）-CyclicBarrier-循环栅栏"><a href="#十二、AQS-了解么？原理？AQS-常用组件：Semaphore-信号量-、CountDownLatch-（倒计时器）-CyclicBarrier-循环栅栏" class="headerlink" title="十二、AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)"></a>十二、AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)</h4><h5 id="1-AQS-概述"><a href="#1-AQS-概述" class="headerlink" title="1 AQS 概述"></a>1 AQS 概述</h5><p><strong>AQS</strong> 的全称为（AbstractQueuedSynchronizer），中文即“<strong>队列同步器</strong>”，这个类放在 java.util.concurrent.locks 包下面。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739164" alt="img"></p>
<p>AQS是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如上篇文章写的ReentrantLock与ReentrantReadWriteLock。除此之外，AQS还能构造出Semaphore，FutureTask(jdk1.7) 等同步器。</p>
<h5 id="2-AQS-原理"><a href="#2-AQS-原理" class="headerlink" title="2 AQS 原理"></a>2 AQS 原理</h5><h6 id="2-1-同步队列"><a href="#2-1-同步队列" class="headerlink" title="2.1 同步队列"></a>2.1 同步队列</h6><p><strong>AQS 是依赖 CLH 队列锁来完成同步状态的管理</strong>。当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构建为一个**节点(Node)**并将其加入同步队列，同步会阻塞当前线程，当同步状态释放时，会将首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（<strong>FIFO双向队列</strong>）（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。<strong>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</strong>。</p>
</blockquote>
<p>同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点信息。</p>
<table>
<thead>
<tr>
<th>属性类型与名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int waitStatus</td>
<td>等待状态(如CANCELLED&#x3D;1、SIGNAL&#x3D;-1、CONDITION&#x3D;-2、PROPAGATE&#x3D;-3、INITIAL&#x3D;0)</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点(当节点加入同步队列时被设置，在尾部添加)</td>
</tr>
<tr>
<td>Node next</td>
<td>后继节点</td>
</tr>
<tr>
<td>Thread thread</td>
<td>当前获取同步状态的线程</td>
</tr>
</tbody></table>
<p>节点源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 表示该节点等待模式为共享式，通常记录于nextWaiter，</span></span><br><span class="line">    <span class="comment">// 通过判断nextWaiter的值可以判断当前结点是否处于共享模式</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="comment">// 表示节点处于独占式模式，与SHARED相对</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> Node EXCLUSIVE = null;</span><br><span class="line">    <span class="comment">// waitStatus的不同状态</span></span><br><span class="line">    <span class="comment">// 当前结点是因为超时或者中断取消的，进入该状态后将无法恢复</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前结点的后继结点是(或者将要)由park导致阻塞的，当结点被释放或者取消时，需要通过unpark唤醒后继结点</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> SIGNAL    = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 表明结点在等待队列中，结点线程等待在Condition上</span></span><br><span class="line">    <span class="comment">// 当其他线程对Condition调用了signal()方法时，会将其加入到同步队列中   </span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> CONDITION = <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 下一次共享式同步状态的获取将会无条件地向后继结点传播</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> PROPAGATE = <span class="number">-3</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 记录前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 记录后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 记录当前的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 用于记录共享模式(SHARED), 也可以用来记录CONDITION队列</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">// 通过nextWaiter的记录值判断当前结点的模式是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> nextWaiter == SHARED;&#125;</span><br><span class="line">    <span class="comment">// 获取当前结点的前置结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> throws NullPointerException </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// 用于初始化时创建head结点或者创建SHARED结点</span></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 在addWaiter方法中使用，用于创建一个新的结点</span></span><br><span class="line">    <span class="built_in">Node</span>(Thread thread, Node mode) &#123;     </span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在CONDITION队列中使用该构造函数新建结点</span></span><br><span class="line">    <span class="built_in">Node</span>(Thread thread, <span class="type">int</span> waitStatus) &#123; </span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录头结点</span></span><br><span class="line"><span class="keyword">private</span> transient <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 记录尾结点</span></span><br><span class="line"><span class="keyword">private</span> transient <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>节点是构成同步队列的基础，同步器拥有<strong>首节点（Head）和尾节点（Tail）</strong>，没有成功<strong>获取</strong>同步状态的线程将会成为节点加入该队列的尾部。同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739165" alt="img"></p>
<p><strong>首节点是获取同步状态成功的节点</strong>，首节点的线程在<strong>释放</strong>同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，不需要使用CAS来保证，只需将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739166" alt="img"></p>
<h6 id="2-2-同步状态"><a href="#2-2-同步状态" class="headerlink" title="2.2 同步状态"></a>2.2 同步状态</h6><h6 id="1）-独占式-EXCLUSIVE"><a href="#1）-独占式-EXCLUSIVE" class="headerlink" title="1） 独占式(EXCLUSIVE)"></a>1） 独占式(EXCLUSIVE)</h6><p>独占式(EXCLUSIVE)获取需重写<code>tryAcquire</code>、<code>tryRelease</code>方法，并访问<code>acquire</code>、<code>release</code>方法实现相应的功能。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(<span class="built_in">int</span> arg) &#123;</span><br><span class="line">    <span class="comment">// 如果线程直接获取成功，或者再尝试获取成功后都是直接工作，</span></span><br><span class="line">    <span class="comment">// 如果是从阻塞状态中唤醒开始工作的线程，将当前的线程中断        </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">        </span>acquire<span class="constructor">Queued(<span class="params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))</span><br><span class="line">        self<span class="constructor">Interrupt()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装线程，新建结点并加入到同步队列中</span></span><br><span class="line"><span class="keyword">private</span> Node add<span class="constructor">Waiter(Node <span class="params">mode</span>)</span> &#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> <span class="constructor">Node(Thread.<span class="params">currentThread</span>()</span>, mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 尝试入队， 成功返回</span></span><br><span class="line">    <span class="keyword">if</span> (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS操作设置队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compare<span class="constructor">AndSetTail(<span class="params">pred</span>, <span class="params">node</span>)</span>) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过CAS操作自旋完成node入队操作</span></span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在同步队列中等待获取同步状态</span></span><br><span class="line">final boolean acquire<span class="constructor">Queued(<span class="params">final</span> Node <span class="params">node</span>, <span class="params">int</span> <span class="params">arg</span>)</span> &#123;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor<span class="literal">()</span>;</span><br><span class="line">            <span class="comment">// 前驱节点是否为头节点&amp;&amp;tryAcquire获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p<span class="operator"> == </span>head<span class="operator"> &amp;&amp; </span><span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span>) &#123;</span><br><span class="line">                set<span class="constructor">Head(<span class="params">node</span>)</span>;</span><br><span class="line">                p.next = null;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取不到同步状态，将前置结点标为SIGNAL状态并且通过park操作将Node封装的线程阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (should<span class="constructor">ParkAfterFailedAcquire(<span class="params">p</span>, <span class="params">node</span>)</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">                </span>park<span class="constructor">AndCheckInterrupt()</span>)</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 如果获取失败，将node标记为CANCELLED</span></span><br><span class="line">            cancel<span class="constructor">Acquire(<span class="params">node</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式获取同步状态流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739167" alt="img"></p>
<p>通过调用同步器的<code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其<strong>后继节点</strong>（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先尝试释放并更新同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 检查是否需要唤醒后置结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后置结点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 通过CAS操作将waitStatus更新为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 检查后置结点，若为空或者状态为CANCELLED，找到后置非CANCELLED结点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继结点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2）共享式-SHARED"><a href="#2）共享式-SHARED" class="headerlink" title="2）共享式(SHARED)"></a>2）共享式(SHARED)</h6><p><strong>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态</strong>。</p>
<p>共享式(SHARED)获取需重写<code>tryAcquireShared</code>、<code>tryReleaseShared</code>方法，并访问<code>acquireShared</code>、<code>releaseShared</code>方法实现相应的功能。与独占式相对，共享式支持多个线程同时获取到同步状态并进行工作，如 Semaphore、CountDownLatch、 CyclicBarrier等。ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试共享式获取同步状态，如果成功获取则可以继续执行，否则执行doAcquireShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 以共享式不停得尝试获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 向同步队列中新增一个共享式的结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 标记获取失败状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记中断状态(若在该过程中被中断是不会响应的，需要手动中断)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前置结点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 若前置结点为头结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 若获取到同步状态。</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 此时，当前结点存储的线程恢复执行，需要将当前结点设置为头结点并且向后传播，</span></span><br><span class="line">                    <span class="comment">// 通知符合唤醒条件的结点一起恢复执行</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 需要中断，中断当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    <span class="comment">// 获取成功</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取同步状态失败，需要进入阻塞状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 获取失败，CANCELL node</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将node设置为同步队列的头结点，并且向后通知当前结点的后置结点，完成传播</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 向后传播</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(intarg)方法可以释放同步状态，释放同步状态成功后，会唤醒后置结点，并且保证传播性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 成功后唤醒后置结点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒后置结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 循环的目的是为了防止新结点在该过程中进入同步队列产生的影响，同时要保证CAS操作的完成</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            </span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3）超时获取方式"><a href="#3）超时获取方式" class="headerlink" title="3）超时获取方式"></a>3）超时获取方式</h6><p>通过调用同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以<strong>超时获取同步状态</strong>，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时的时间=当前虚拟机的时间+设置的超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 调用addWaiter将当前线程封装成独占模式的节点，并且加入到同步队列尾部。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点的前驱节点为头结点，则让当前节点去尝试获取锁。</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; </span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱节点不是头结点，或当前节点获取锁失败，</span></span><br><span class="line">            <span class="comment">// 则再次判断当前线程是否已经超时。</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点，马上进入</span></span><br><span class="line">            <span class="comment">// 等待状态了，即做好进入等待状态前的准备。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。</span></span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可知，超时获取也是调用addWaiter将当前线程封装成<strong>独占模式</strong>的节点，并且加入到同步队列尾部。</p>
<p>超时获取与独占式获取同步状态区别<strong>在于获取同步状态失败后的处理</strong>。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时）；如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待nanosTimeout纳秒（当已到设置的超时时间，该线程会从<code>LockSupport.parkNanos(Object blocker, long nanos)</code>方法返回）。</p>
<p>独占式超时获取同步状态流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739168" alt="img"></p>
<h6 id="2-3-模板方法"><a href="#2-3-模板方法" class="headerlink" title="2.3 模板方法"></a>2.3 模板方法</h6><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>同步状态<code>state</code>通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>方法进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CAS更新同步状态，该方法能够保证状态设置的原子性</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<p><strong>自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>同步器提供的模板方法基本上分为3类：<strong>独占式</strong>获取与释放同步状态、<strong>共享式</strong>获取与释放同步状态和查询同步队列中的等待线程情况。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后续动作。</p>
<p>但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>下面就来学习几个常用的并发同步工具。</p>
<h5 id="3-Semaphore-信号量"><a href="#3-Semaphore-信号量" class="headerlink" title="3 Semaphore(信号量)"></a>3 Semaphore(信号量)</h5><p>Semaphore（信号量）用来控制 <strong>同时访问特定资源的线程数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而<strong>Semaphore(信号量)可以指定多个线程同时访问某个资源</strong>。</p>
<p>以停车场为例。假设一个停车场只有10个车位，这时如果同时来了15辆车，则只允许其中10辆不受阻碍的进入。剩下的5辆车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，如果有5辆车离开停车场，放入5辆；如果又离开2辆，则又可以放入2辆，如此往复。</p>
<p>在这个停车场系统中，车位即是共享资源，每辆车就好比一个线程，信号量就是空车位的数目。</p>
<p>Semaphore中包含了一个实现了AQS的同步器Sync，以及它的两个子类FairSync和NonFairSync。查看Semaphore类结构：</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739169" alt="img"></p>
<p>可见Semaphore也是区分公平模式和非公平模式的。</p>
<ul>
<li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO。</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
<p>Semaphore 对应的两个构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">     sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<p>Semaphore实现原理这里就不分析了，可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903866329202701">死磕 java同步系列之Semaphore源码解析</a>这篇文章。</p>
<p>需要明白的是，<strong>Semaphore也是共享锁的一种实现</strong>。它默认构造AQS的state为permits。当执行任务的线程数量超出permits，那么多余的线程将会被放入阻塞队列Park，并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行，此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
<p>Semaphore常用于做<strong>流量控制</strong>，特别是公用资源有限的应用场景。</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>acquire()&#x2F;acquire(int permits)</td>
<td>获取许可证。获取许可失败，会进入AQS的队列中排队。</td>
</tr>
<tr>
<td>tryAcquire()&#x2F;tryAcquire(int permits)</td>
<td>获取许可证。获取许可失败，直接返回false。</td>
</tr>
<tr>
<td>tryAcquire(long timeout, TimeUnit unit)&#x2F; tryAcquire(int permits, long timeout, TimeUnit unit)</td>
<td>超时等待获取许可证。</td>
</tr>
<tr>
<td>release()</td>
<td>归还许可证。</td>
</tr>
<tr>
<td>intavailablePermits()</td>
<td>返回此信号量中当前可用的许可证数。</td>
</tr>
<tr>
<td>intgetQueueLength()</td>
<td>返回正在等待获取许可证的线程数。</td>
</tr>
<tr>
<td>booleanhasQueuedThreads()</td>
<td>是否有线程正在等待获取许可证。</td>
</tr>
<tr>
<td>void reducePermits（int reduction）</td>
<td>减少reduction个许可证，是个protected方法。</td>
</tr>
<tr>
<td>Collection getQueuedThreads()</td>
<td>返回所有等待获取许可证的线程集合，是个protected方法。</td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">        <span class="comment">// 一次只能允许执行的线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">// 获取1个许可，所以可运行线程数量为10/1=10</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release();<span class="comment">// 释放1个许可，所以可运行线程数量为10/1=10</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadNum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;threadNum:&quot;</span> + threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，虽然有50个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。</p>
<p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p>
<h5 id="4-CountDownLatch-倒计时器"><a href="#4-CountDownLatch-倒计时器" class="headerlink" title="4 CountDownLatch (倒计时器)"></a>4 CountDownLatch (倒计时器)</h5><h6 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h6><p>在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。jdk 1.5之前一般都使用线程的join()方法来实现这一点，但是join方法不够灵活，难以满足不同场景的需要，所以jdk 1.5之后concurrent包提供了CountDownLatch这个类。</p>
<p><strong>CountDownLatch</strong>是一种同步辅助工具，它<strong>允许一个或多个线程等待其他线程完成操作</strong>。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739171" alt="img"></p>
<p>CountDownLatch的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>调用该方法的线程等到构造方法传入的 N 减到 0 的时候，才能继续往下执行。</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit)</td>
<td>调用该方法的线程等到指定的 timeout 时间后，不管 N 是否减至为 0，都会继续往下执行。</td>
</tr>
<tr>
<td>countDown()</td>
<td>使 CountDownLatch 初始值 N 减 1。</td>
</tr>
<tr>
<td>getCount()</td>
<td>获取当前 CountDownLatch 维护的值，也就是AQS的state的值。</td>
</tr>
</tbody></table>
<p>CountDownLatch的实现原理，可以查看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/leesf456/p/5406191.html">【JUC】JDK1.8源码分析之CountDownLatch（五）</a>一文。</p>
<p>根据源码分析可知，<strong>CountDownLatch是AQS中共享锁的一种实现</strong>。AbstractQueuedSynchronizer中维护了一个volatile类型的整数state，volatile可以保证多线程环境下该变量的修改对每个线程都可见，并且由于该属性为整型，因而对该变量的修改也是原子的。</p>
<p>CountDownLatch默认构造 AQS 的 state 值为 count。创建一个CountDownLatch对象时，所传入的整数N就会赋值给state属性。</p>
<p>当调用countDown()方法时，其实是调用了<code>tryReleaseShared</code>方法以CAS的操作来对state减1；而调用await()方法时，当前线程就会判断state属性是否为0。如果为0，阻塞线程被唤醒继续往下执行；如果不为0，则使当前线程放入阻塞队列Park，直至最后一个线程调用了countDown()方法使得state &#x3D;&#x3D; 0，再唤醒在await()方法中等待的线程。</p>
<p><strong>特别注意的是</strong>：</p>
<p><strong>CountDownLatch 是一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。如果<strong>需要能重置计数，可以使用CyclicBarrier</strong>。</p>
<h6 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h6><p>CountDownLatch主要应用场景：</p>
<ol>
<li><strong>实现最大的并行性</strong>：同时启动多个线程，实现最大程度的并行性。例如110跨栏比赛中，所有运动员准备好起跑姿势，进入到预备状态，等待裁判一声枪响。裁判开了枪，所有运动员才可以开跑。</li>
<li><strong>开始执行前等待N个线程完成各自任务</strong>：例如一群学生在教室考试，学生们都完成了作答，老师才可以进行收卷操作。</li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREAD_COUNT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程:&quot;</span> + threadNum);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程启动...&quot;</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程执行完毕...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了请求的数量为30，当这 30 个请求被处理完成之后，才会打印<code>子线程执行完毕</code>。</p>
<p>主线程在启动其他线程后调用 <code>CountDownLatch.await()</code> 方法进入阻塞状态，直到其他线程完成各自的任务才被唤醒。</p>
<p>开启的30个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当30个线程都调用了这个方法后，count 的值才等于0，然后主线程就能通过 <code>await()</code>方法，继续执行自己的任务。</p>
<h5 id="5-CyclicBarrier-循环栅栏"><a href="#5-CyclicBarrier-循环栅栏" class="headerlink" title="5 CyclicBarrier(循环栅栏)"></a>5 CyclicBarrier(循环栅栏)</h5><h6 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h6><p><strong>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）</strong>。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier 的功能和应用场景与CountDownLatch都非常类似。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739170" alt="img"></p>
<p>CyclicBarrier常用方法：</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>在所有线程都已经在此 barrier上并调用 await 方法之前，将一直等待。</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit)</td>
<td>所有线程都已经在此屏障上调用 await 方法之前将一直等待，或者超出了指定的等待时间。</td>
</tr>
<tr>
<td>getNumberWaiting()</td>
<td>返回当前在屏障处等待的线程数目。</td>
</tr>
<tr>
<td>getParties()</td>
<td>返回要求启动此 barrier 的线程数目。</td>
</tr>
<tr>
<td>isBroken()</td>
<td>查询此屏障是否处于损坏状态。</td>
</tr>
<tr>
<td>reset()</td>
<td>将屏障重置为其初始状态。</td>
</tr>
</tbody></table>
<h6 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h6><p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作。</span></span><br><span class="line"><span class="comment">// 该操作由最后一个进入 barrier 的线程执行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>parties 就表示屏障拦截的线程数量</strong>。</p>
<p>CyclicBarrier 的最重要的方法就是 await 方法，<code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，<strong>当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。查看<code>dowait(boolean timed, long nanos)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取”独占锁“</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存“当前的generation”</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="comment">// 如果当前代损坏，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">        <span class="comment">// 如果线程中断，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将损坏状态设置为 true，并唤醒所有阻塞在此栅栏上的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将“count计数器”-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 当 count== 0，说明最后一个线程已经到达栅栏</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="comment">// 执行栅栏任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程，并更新generation。</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="comment">// 结束，等价于return index</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者条件之一发生</span></span><br><span class="line">        <span class="comment">// 当前线程才继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有时间限制，则直接等待，直到被唤醒。</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 如果有时间限制，则等待指定时间再唤醒(超时等待)。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 当前代没有损坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 让栅栏失效</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上面条件不满足,说明这个线程不是这代的。</span></span><br><span class="line">                    <span class="comment">// 就不会影响当前这代栅栏执行逻辑。中断。</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果“当前generation已经损坏”，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();  </span><br><span class="line">            <span class="comment">// 如果“generation已经换代”，则返回index。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index; </span><br><span class="line">            <span class="comment">// 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier</span></span><br><span class="line">            <span class="comment">// 唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“独占锁(lock)”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generation是CyclicBarrier的一个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Generation一代的意思。</span></span><br><span class="line"><span class="comment">  * CyclicBarrier是可以循环使用的，用它来标志本代和下一代。</span></span><br><span class="line"><span class="comment">  * broken：当前代是否损坏的标志。标志有线程发生了中断，或者异常，就是任务没有完成。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现独占锁</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">// 实现多个线程之间相互等待通知，就是满足某些条件之后，线程才能执行，否则就等待</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"> <span class="comment">// 初始化时屏障数量 </span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"> <span class="comment">// 当条件满足(即屏障数量为0)之后，会回调这个Runnable</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"> <span class="comment">//当前代</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 剩余的屏障数量count</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在CyclicBarrier中，<strong>同一批的线程属于同一代</strong>，即同一个generation；CyclicBarrier中通过generation对象，记录属于哪一代。<br>当有parties个线程到达barrier，generation就会被更新换代。</p>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h6><ol>
<li><code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏，那么就将计数器减1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就会将代更新并重置计数器，并唤醒所有之前等待在栅栏上的线程。</li>
<li>如果在等待的过程中，线程中断都也会抛出BrokenBarrierException异常，并且这个异常会传播到其他所有的线程，CyclicBarrier会被损坏。</li>
<li>如果超出指定的等待时间，当前线程会抛出 TimeoutException 异常，其他线程会抛出BrokenBarrierException异常，CyclicBarrier会被损坏。</li>
</ol>
<h6 id="5-3-应用场景"><a href="#5-3-应用场景" class="headerlink" title="5.3 应用场景"></a>5.3 应用场景</h6><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is ready&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待60秒，保证子线程完全执行结束</span></span><br><span class="line">                    cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">childThread:<span class="number">0</span> is ready</span><br><span class="line">childThread:<span class="number">1</span> is ready</span><br><span class="line">childThread:<span class="number">2</span> is ready</span><br><span class="line">childThread:<span class="number">3</span> is ready</span><br><span class="line">childThread:<span class="number">4</span> is ready</span><br><span class="line">childThread:<span class="number">4</span> is finish</span><br><span class="line">childThread:<span class="number">0</span> is finish</span><br><span class="line">childThread:<span class="number">1</span> is finish</span><br><span class="line">childThread:<span class="number">3</span> is finish</span><br><span class="line">childThread:<span class="number">2</span> is finish</span><br><span class="line">childThread:<span class="number">5</span> is ready</span><br><span class="line">childThread:<span class="number">6</span> is ready</span><br><span class="line">childThread:<span class="number">7</span> is ready</span><br><span class="line">childThread:<span class="number">8</span> is ready</span><br><span class="line">childThread:<span class="number">9</span> is ready</span><br><span class="line">childThread:<span class="number">9</span> is finish</span><br><span class="line">childThread:<span class="number">8</span> is finish</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>可以看到当线程数量也就是请求数量达定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p>
<p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------优先执行------&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is ready&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待60秒，保证子线程完全执行结束</span></span><br><span class="line">                    cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">childThread:<span class="number">0</span> is ready</span><br><span class="line">childThread:<span class="number">1</span> is ready</span><br><span class="line">childThread:<span class="number">2</span> is ready</span><br><span class="line">childThread:<span class="number">3</span> is ready</span><br><span class="line">childThread:<span class="number">4</span> is ready</span><br><span class="line">------优先执行------</span><br><span class="line">childThread:<span class="number">4</span> is finish</span><br><span class="line">childThread:<span class="number">0</span> is finish</span><br><span class="line">childThread:<span class="number">1</span> is finish</span><br><span class="line">childThread:<span class="number">3</span> is finish</span><br><span class="line">childThread:<span class="number">2</span> is finish</span><br><span class="line">childThread:<span class="number">5</span> is ready</span><br><span class="line">childThread:<span class="number">6</span> is ready</span><br><span class="line">childThread:<span class="number">7</span> is ready</span><br><span class="line">childThread:<span class="number">8</span> is ready</span><br><span class="line">childThread:<span class="number">9</span> is ready</span><br><span class="line">------优先执行------</span><br><span class="line">childThread:<span class="number">9</span> is finish</span><br><span class="line">childThread:<span class="number">6</span> is finish</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<h6 id="5-4-CyclicBarrier和CountDownLatch的区别"><a href="#5-4-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5.4 CyclicBarrier和CountDownLatch的区别"></a>5.4 CyclicBarrier和CountDownLatch的区别</h6><ol>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()方法重置，可多次使用。</li>
<li>侧重点不同。CountDownLatch多用于某一个线程等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于多个线程互相等待至一个同步点，然后这些线程再继续一起执行。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量；isBroken()方法用来了解阻塞的线程是否被中断。</li>
</ol>
<h4 id="十三、ReentrantLock-、-ReentrantReadWriteLock-、StampedLock（JDK8）"><a href="#十三、ReentrantLock-、-ReentrantReadWriteLock-、StampedLock（JDK8）" class="headerlink" title="十三、ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）"></a>十三、ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）</h4><h5 id="JDK8的一种新的读写锁StampedLock"><a href="#JDK8的一种新的读写锁StampedLock" class="headerlink" title="JDK8的一种新的读写锁StampedLock"></a>JDK8的一种新的读写锁StampedLock</h5><p>JDK8新增一种新的读写锁StampedLock。一个最重要的功能改进就是读写锁中<strong>解决写线程饥饿的问题</strong>。</p>
<h5 id="StampedLock与ReentrantReadWriteLock"><a href="#StampedLock与ReentrantReadWriteLock" class="headerlink" title="StampedLock与ReentrantReadWriteLock"></a>StampedLock与ReentrantReadWriteLock</h5><p>以StampedLock与ReentrantReadWriteLock两者比较为线索介绍StampedLock锁。关于ReentrantReadWriteLock锁参考文档<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e44202261319">ReentrantReadWriteLock源码解析</a>。</p>
<h5 id="StampedLock不基于AQS实现"><a href="#StampedLock不基于AQS实现" class="headerlink" title="StampedLock不基于AQS实现"></a>StampedLock不基于AQS实现</h5><p>之前包括ReentrantReadWriteLock，ReentrantLock和信号量等同步工具，都是基于AQS同步框架实现的。而在StampedLock中摒弃了AQS框架，为StampedLock实现提供了更多的灵活性。</p>
<h5 id="StampedLock增加乐观读锁机制"><a href="#StampedLock增加乐观读锁机制" class="headerlink" title="StampedLock增加乐观读锁机制"></a>StampedLock增加乐观读锁机制</h5><p>先获取记录下当前锁的版本号stamp，执行读取操作后，要验证这个版本号是否改变，如果没有改变继续执行接下来的逻辑。乐观读锁机制基于在系统中大多数时间线程并发竞争不严重，绝大多数读操作都可以在没有竞争的情况下完成的论断。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乐观读锁</span></span><br><span class="line">stamp = <span class="keyword">lock</span>.tryOptimisticRead();</span><br><span class="line"><span class="comment">//do some reading</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">lock</span>.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">//do somethinng</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际中，乐观读的实现是通过判断state的高25位是否有变化来实现的，获取乐观读锁也仅仅是返回当前锁的版本号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock锁的状态和版本号"><a href="#StampedLock锁的状态和版本号" class="headerlink" title="StampedLock锁的状态和版本号"></a>StampedLock锁的状态和版本号</h5><p>基于AQS实现实现的ReentrantReadWriteLock，高16位存储读锁被获取的次数，低16位存储写锁被获取的次数。<br> 而摒弃了AQS的StampedLock，自身维护了一个状态变量state。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</span><br></pre></td></tr></table></figure>

<p>StampedLock的状态变量state被分成3段：</p>
<ol>
<li>高24位存储版本号，只有写锁增加其版本号，而读锁不会增加其版本号；</li>
<li>低7位存储读锁被获取的次数；</li>
<li>第8位存储写锁被获取的次数，<strong>因为只有一位用于表示写锁，所以StampedLock不是可重入锁</strong>。</li>
</ol>
<p>关于状态变量state操作的变量设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">//读线程的个数占有低7位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for lock state and stamp operations</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RUNIT</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">//读线程个数每次增加的单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">//写线程个数所在的位置 1000 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">//读线程个数的掩码 111 1111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RFULL</span> <span class="operator">=</span> RBITS - <span class="number">1L</span>;<span class="comment">//最大读线程个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ABITS</span> <span class="operator">=</span> RBITS | WBIT;<span class="comment">//读线程个数和写线程个数的掩码 1111 1111</span></span><br><span class="line"><span class="comment">// Initial value for lock state; avoid failure value zero</span></span><br><span class="line"><span class="comment">//state的初始值。 1 0000 0000，也就是高24位最后一位为1，版本号初始值为1 0000 0000。锁获取失败返回版本号0。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock自旋"><a href="#StampedLock自旋" class="headerlink" title="StampedLock自旋"></a>StampedLock自旋</h5><p>如下代码片段，可以看到StampedLock锁获取时存在大量自旋逻辑(for循环)。自旋是一种锁优化技术，在并发程序中大多数的锁持有时间很短暂，通过自旋可以避免线程被阻塞和唤醒产生的开销。<br> 自旋技术对于系统中持有锁时间短暂的任务比较高效，但是对于持有锁时间长的任务是对CPU的浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireWrite</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123; <span class="comment">// spin while enqueuing</span></span><br><span class="line">          ....省略代码逻辑....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;</span><br><span class="line">        ....省略代码逻辑....</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">           ....省略代码逻辑....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireRead</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;</span><br><span class="line">        ....省略代码逻辑....</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> m, s, ns;;) &#123;</span><br><span class="line">            ....省略代码逻辑....</span><br><span class="line">        &#125;</span><br><span class="line">        ....省略代码逻辑....</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ....省略代码逻辑....</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">    ....省略代码逻辑....    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock的CLH队列"><a href="#StampedLock的CLH队列" class="headerlink" title="StampedLock的CLH队列"></a>StampedLock的CLH队列</h5><p>StampedLock的CLH队列是一个经过改良的队列，在ReentrantReadWriteLock的等待队列中每个线程节点是依次排队，然后责任链设计模式依次唤醒，这样就可能导致读线程全部唤醒，而写线程处于饥饿状态。StampedLock的等待队列，连续的读线程只有首个节点存储在队列中，其它的节点存储在首个节点的cowait队列中。</p>
<p>StampedLock唤醒读锁是一次性唤醒连续的读锁节点。</p>
<p>类WNode是StampedLock等待队列的节点，cowait存放连续的读线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">    <span class="keyword">volatile</span> WNode next;</span><br><span class="line">    <span class="comment">//cowait存放连续的读线程</span></span><br><span class="line">    <span class="keyword">volatile</span> WNode cowait; <span class="comment">// list of linked readers</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">//non-null while possibly parked</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">    WNode(<span class="type">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个读节点之间有一个写节点，那么这两个读节点就不是连续的，会分别排队。正是因为这样的机制，会按照到来顺序让先到的写线程先于它后面的读线程执行。</p>
<p>StampedLock只有非公平模式，线程到来就会尝试获取锁。</p>
<h4 id="十四、CAS-了解么？原理？"><a href="#十四、CAS-了解么？原理？" class="headerlink" title="十四、CAS 了解么？原理？"></a>十四、CAS 了解么？原理？</h4><h5 id="1、什么是CAS？"><a href="#1、什么是CAS？" class="headerlink" title="1、什么是CAS？"></a><strong>1、什么是CAS？</strong></h5><p>CAS：Compare and Swap，即比较再交换。</p>
<p>jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。</p>
<h5 id="2、CAS算法理解"><a href="#2、CAS算法理解" class="headerlink" title="2、CAS算法理解"></a><strong>2、CAS算法理解</strong></h5><p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>CAS比较与交换的伪代码可以表示为：</p>
<p>do{</p>
<p>备份旧数据；</p>
<p>基于旧数据构造新数据；</p>
<p>}while(!CAS( 内存地址，备份的旧数据，新数据 ))</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/zK9ke8_20210607145034.png" alt="img"></p>
<p>注：t1，t2线程是同时更新同一变量56的值</p>
<p>因为t1和t2线程都同时去访问同一变量56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。</p>
<p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p>
<p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>
<p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>
<h5 id="3、CAS开销"><a href="#3、CAS开销" class="headerlink" title="3、CAS开销"></a><strong>3、CAS开销</strong></h5><p>前面说过了，CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。但CAS就没有开销了吗？不！有cache miss的情况。这个问题比较复杂，首先需要了解CPU的硬件体系结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5ckVXA_20210607145057.png" alt="img"></p>
<p>上图可以看到一个8核CPU计算机系统，每个CPU有cache（CPU内部的高速缓存，寄存器），管芯内还带有一个互联模块，使管芯内的两个核可以互相通信。在图中央的系统互联模块可以让四个管芯相互通信，并且将管芯与主存连接起来。数据以“缓存线”为单位在系统中传输，“缓存线”对应于内存中一个 2 的幂大小的字节块，大小通常为 32 到 256 字节之间。当 CPU 从内存中读取一个变量到它的寄存器中时，必须首先将包含了该变量的缓存线读取到 CPU 高速缓存。同样地，CPU 将寄存器中的一个值存储到内存时，不仅必须将包含了该值的缓存线读到 CPU 高速缓存，还必须确保没有其他 CPU 拥有该缓存线的拷贝。</p>
<p>比如，如果 CPU0 在对一个变量执行“比较并交换”（CAS）操作，而该变量所在的缓存线在 CPU7 的高速缓存中，就会发生以下经过简化的事件序列：</p>
<p>CPU0 检查本地高速缓存，没有找到缓存线。</p>
<p>请求被转发到 CPU0 和 CPU1 的互联模块，检查 CPU1 的本地高速缓存，没有找到缓存线。</p>
<p>请求被转发到系统互联模块，检查其他三个管芯，得知缓存线被 CPU6和 CPU7 所在的管芯持有。</p>
<p>请求被转发到 CPU6 和 CPU7 的互联模块，检查这两个 CPU 的高速缓存，在 CPU7 的高速缓存中找到缓存线。</p>
<p>CPU7 将缓存线发送给所属的互联模块，并且刷新自己高速缓存中的缓存线。</p>
<p>CPU6 和 CPU7 的互联模块将缓存线发送给系统互联模块。</p>
<p>系统互联模块将缓存线发送给 CPU0 和 CPU1 的互联模块。</p>
<p>CPU0 和 CPU1 的互联模块将缓存线发送给 CPU0 的高速缓存。</p>
<p>CPU0 现在可以对高速缓存中的变量执行 CAS 操作了</p>
<p>以上是刷新不同CPU缓存的开销。最好情况下的 CAS 操作消耗大概 40 纳秒，超过 60 个时钟周期。这里的“最好情况”是指对某一个变量执行 CAS 操作的 CPU 正好是最后一个操作该变量的CPU，所以对应的缓存线已经在 CPU 的高速缓存中了，类似地，最好情况下的锁操作（一个“round trip 对”包括获取锁和随后的释放锁）消耗超过 60 纳秒，超过 100 个时钟周期。这里的“最好情况”意味着用于表示锁的数据结构已经在获取和释放锁的 CPU 所属的高速缓存中了。锁操作比 CAS 操作更加耗时，是因深入理解并行编程</p>
<p>为锁操作的数据结构中需要两个原子操作。缓存未命中消耗大概 140 纳秒，超过 200 个时钟周期。需要在存储新值时查询变量的旧值的 CAS 操作，消耗大概 300 纳秒，超过 500 个时钟周期。想想这个，在执行一次 CAS 操作的时间里，CPU 可以执行 500 条普通指令。这表明了细粒度锁的局限性。</p>
<p>以下是cache miss cas 和lock的性能对比：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/J5FBy2_20210607145123.png" alt="img"></p>
<h5 id="4、CAS算法在JDK中的应用"><a href="#4、CAS算法在JDK中的应用" class="headerlink" title="4、CAS算法在JDK中的应用"></a><strong>4、CAS算法在JDK中的应用</strong></h5><p>在原子类变量中，如java.util.concurrent.atomic中的AtomicXXX，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在java.util.concurrent中的大多数类在实现时都直接或间接的使用了这些原子变量类。</p>
<p>Java 1.7中AtomicInteger.incrementAndGet()的实现源码为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/E76D9I_20210607145148.png" alt="img"></p>
<p>由此可见，AtomicInteger.incrementAndGet的实现用了乐观锁技术，调用了类sun.misc.Unsafe库里面的 CAS算法，用CPU指令来实现无锁自增。所以，AtomicInteger.incrementAndGet的自增比用synchronized的锁效率倍增。</p>
<h4 id="十五、Atomic-原子类"><a href="#十五、Atomic-原子类" class="headerlink" title="十五、Atomic 原子类"></a>十五、Atomic 原子类</h4><h5 id="Atomic概览"><a href="#Atomic概览" class="headerlink" title="Atomic概览"></a>Atomic概览</h5><p>整个atomic包包含了17个类，如下图所示：根据其功能及其实现原理，可将其分为五个部分。本文主要针对图中序号1都部分进行源码阅读和分析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/n8IQyt_20210607145409.png" alt="img"></p>
<h5 id="核心对象——Unsafe"><a href="#核心对象——Unsafe" class="headerlink" title="核心对象——Unsafe"></a>核心对象——Unsafe</h5><p>整个atomic都是基于<code>Unsafe</code>实现的，Unsafe通过通过单例模式来提供实例对象，这里我们主要关注它提供的几个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单1 sun.misc.Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final native boolean <span class="title">compareAndSwapInt</span>(<span class="params">Object var1, <span class="built_in">long</span> var2, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> var4, <span class="built_in">int</span> var5</span>)</span>;      <span class="comment">// 核心方法CAS</span></span><br><span class="line"><span class="comment">// 参数释义：var1为类对象，参数var2为Field的偏移量，var4为旧值，var5为更新后的值</span></span><br><span class="line"><span class="comment">//（对象和偏移量构成唯一的内存地址，如果对源码JVM有兴趣，可下载源码参考，非本文范畴，不赘述）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> native <span class="built_in">long</span> <span class="title">staticFieldOffset</span>(<span class="params">Field var1</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> native <span class="built_in">long</span> <span class="title">objectFieldOffset</span>(<span class="params">Field var1</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Unsafe提供的大多是native方法，<code>compareAndSwapInt()</code>通过原子的方式将期望值和内存中的值进行对比，如果两者相等，则执行更新操作。<br> <code>staticFieldOffset()</code>和<code>objectFieldOffset()</code>两方法分别提供两静态、非静态域的偏移量计算方法。</p>
<p>注意：之所以命名为Unsafe，因为该对于大部分Java开发者来说是不安全的，它像C一样，拥有操作指针、分配和回收内存的能力，由该对象申请的内存是无法被JVM回收的，因此轻易别用。当然，如果对并发有非常浓厚的兴趣，就要好好研究下它，许多高性能的框架都使用它作为底层实现，如Netty、Kafka。</p>
<h5 id="AtomicInteger的基本实现"><a href="#AtomicInteger的基本实现" class="headerlink" title="AtomicInteger的基本实现"></a>AtomicInteger的基本实现</h5><p>接着再来看<code>AtomicInteger</code>的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 清单<span class="number">2</span> AtomicInteger</span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.<span class="built_in">getUnsafe</span>();    <span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;    <span class="comment">// 偏移量</span></span><br><span class="line"><span class="type">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        valueOffset = unsafe.<span class="built_in">objectFieldOffset</span></span><br><span class="line">                (AtomicInteger.<span class="keyword">class</span>.<span class="built_in">getDeclaredField</span>(<span class="string">&quot;value&quot;</span>))    <span class="comment">// 计算偏移量</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(Exception ex)&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ex);&#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;    <span class="comment">// 使用volatile修饰，保证可见性</span></span><br></pre></td></tr></table></figure>

<p>私有的静态域Unsafe对象和偏移量都是final修饰的，在静态代码块中，通过Unsafe实例计算出域value的偏移地址。<br> value使用volatile来修饰，保证了其可见性。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单3 getAndSetInt的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final <span class="built_in">int</span> <span class="title">getAndSetInt</span>(<span class="params">Object var1, <span class="built_in">long</span> var2, <span class="built_in">int</span> var4</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);        <span class="comment">// 原子获取变量的值</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line">                                                       <span class="comment">// CAS操作，失败重试</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过方法名可知清单3中的方法<code>getAndSetInt()</code>为获取旧值并赋予新值的操作，通过CAS失败重试的机制来实现原子操作，这就是乐观锁的思想，也是整个并发包的核心思想。</p>
<h4 id="扩展-灵活的函数式编程"><a href="#扩展-灵活的函数式编程" class="headerlink" title="扩展-灵活的函数式编程"></a>扩展-灵活的函数式编程</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/42TeKb_20210607145444.png" alt="img"></p>
<p>AtomicInteger方法</p>
<p>AtomicInteger的方法中，除了简单的加、减、更新和获取的原子操作外，在JDK1.8中增加了4个方法，即图上标红的方法。通过函数式编程，可以灵活的实现更加复杂的原子操作。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单5 IntUnaryOperator接口</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">applyAsInt</span>(<span class="params"><span class="built_in">int</span> operand</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="literal">default</span> IntUnaryOperator <span class="title">compose</span>(<span class="params">IntUnaryOperator before</span>)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span> v) -&gt; applyAsInt(before.applyAsInt(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="literal">default</span> IntUnaryOperator <span class="title">andThen</span>(<span class="params">IntUnaryOperator after</span>)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span> t) -&gt; after.applyAsInt(applyAsInt(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口定义了一个待实现方法和两个默认方法，通过compose和andThen即可实现多个IntUnaryOperator的组合调用。在AtomicInteger中做如下调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单6 AtomicInteger代码片段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final <span class="built_in">int</span> <span class="title">getAndUpdate</span>(<span class="params">IntUnaryOperator updateFunction</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">get</span>();   <span class="comment">// 获取当前值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);  <span class="comment">// 函数调用计算</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));   <span class="comment">// CAS更新操作</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同代码清单7，通过函数式编程，可以轻易地完成复杂计算的原子操作。除了IntUnaryOperator接口，还有一个IntBinaryOperator接口，该接口支持额外增加的参数参与计算，两者有相似之处</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单7 IntUnaryOperatorTest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    IntOperatorAdd <span class="keyword">add</span> = <span class="keyword">new</span> IntOperatorAdd();</span><br><span class="line">    IntOperatorMul mul = <span class="keyword">new</span> IntOperatorMul();</span><br><span class="line">    <span class="built_in">int</span> result = <span class="keyword">new</span> AtomicInteger(<span class="number">3</span>).updateAndGet(<span class="keyword">add</span>);   <span class="comment">// 结果为6 -&gt; 3+3</span></span><br><span class="line">    <span class="built_in">int</span> result2 = <span class="keyword">new</span> AtomicInteger(<span class="number">3</span>).updateAndGet(mul);  <span class="comment">// 结果为9 -&gt; 3*3</span></span><br><span class="line">    <span class="built_in">int</span> result3 = <span class="keyword">new</span> AtomicInteger(<span class="number">3</span>).updateAndGet(<span class="keyword">add</span>.andThen(mul));</span><br><span class="line">                                         <span class="comment">// 结果为36 -&gt; 3+3=6, 6*6=36</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">IntOperatorAdd</span> <span class="title">implements</span> <span class="title">IntUnaryOperator</span> &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">applyAsInt</span>(<span class="params"><span class="built_in">int</span> operand</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> operand + operand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">IntOperatorMul</span> <span class="title">implements</span> <span class="title">IntUnaryOperator</span> &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">applyAsInt</span>(<span class="params"><span class="built_in">int</span> operand</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> operand * operand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他原子操作类"><a href="#其他原子操作类" class="headerlink" title="其他原子操作类"></a>其他原子操作类</h5><p>除了AtomicInteger外，还有AtomicLong、AtomicReference以及AtomicBoolean三个原子包装类。其实现原理都是一致的，均可举一反三。</p>
<h4 id="十六、并发容器：ConcurrentHashMap-、-CopyOnWriteArrayList-、-ConcurrentLinkedQueue-BlockingQueue-、ConcurrentSkipListMap"><a href="#十六、并发容器：ConcurrentHashMap-、-CopyOnWriteArrayList-、-ConcurrentLinkedQueue-BlockingQueue-、ConcurrentSkipListMap" class="headerlink" title="十六、并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap"></a>十六、并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>不考虑多线程并发的情况下，容器类一般使用ArrayList、HashMap等线程不安全的类，效率更高。在并发场景下，常会用到ConcurrentHashMap、ArrayBlockingQueue等线程安全的容器类，虽然牺牲了一些效率，但却得到了安全。</p>
<p>上面提到的线程安全容器都在java.util.concurrent包下，这个包下并发容器不少，今天全部翻出来鼓捣一下。</p>
<p>仅做简单介绍，后续再分别深入探索。</p>
<h5 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a>并发容器介绍</h5><ol>
<li>ConcurrentHashMap：并发版HashMap</li>
<li>CopyOnWriteArrayList：并发版ArrayList</li>
<li>CopyOnWriteArraySet：并发Set</li>
<li>ConcurrentLinkedQueue：并发队列(基于链表)</li>
<li>ConcurrentLinkedDeque：并发队列(基于双向链表)</li>
<li>ConcurrentSkipListMap：基于跳表的并发Map</li>
<li>ConcurrentSkipListSet：基于跳表的并发Set</li>
<li>ArrayBlockingQueue：阻塞队列(基于数组)</li>
<li>LinkedBlockingQueue：阻塞队列(基于链表)</li>
<li>LinkedBlockingDeque：阻塞队列(基于双向链表)</li>
<li>PriorityBlockingQueue：线程安全的优先队列</li>
<li>SynchronousQueue：读写成对的队列</li>
<li>LinkedTransferQueue：基于链表的数据交换队列</li>
<li>DelayQueue：延时队列</li>
</ol>
<h6 id="1-ConcurrentHashMap-并发版HashMap"><a href="#1-ConcurrentHashMap-并发版HashMap" class="headerlink" title="1.ConcurrentHashMap 并发版HashMap"></a><strong>1.ConcurrentHashMap 并发版HashMap</strong></h6><p>最常见的并发容器之一，可以用作并发场景下的缓存。底层依然是哈希表，但在JAVA 8中有了不小的改变，而JAVA 7和JAVA 8都是用的比较多的版本，因此经常会将这两个版本的实现方式做一些比较（比如面试中）。</p>
<p>一个比较大的差异就是，JAVA 7中采用分段锁来减少锁的竞争，JAVA 8中放弃了分段锁，采用CAS（一种乐观锁），同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）。</p>
<h6 id="2-CopyOnWriteArrayList-并发版ArrayList"><a href="#2-CopyOnWriteArrayList-并发版ArrayList" class="headerlink" title="2.CopyOnWriteArrayList 并发版ArrayList"></a><strong>2.CopyOnWriteArrayList 并发版ArrayList</strong></h6><p>并发版ArrayList，底层结构也是数组，和ArrayList不同之处在于：当新增和删除元素时会创建一个新的数组，在新的数组中增加或者排除指定对象，最后用新增数组替换原来的数组。</p>
<p>适用场景：由于读操作不加锁，写（增、删、改）操作加锁，因此适用于读多写少的场景。</p>
<p>局限：由于读的时候不会加锁（读的效率高，就和普通ArrayList一样），读取的当前副本，因此可能读取到脏数据。如果介意，建议不用。</p>
<p>看看源码感受下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Zi01aI_20210607145655.png" alt="img"></p>
<h6 id="3-CopyOnWriteArraySet-并发Set"><a href="#3-CopyOnWriteArraySet-并发Set" class="headerlink" title="3.CopyOnWriteArraySet 并发Set"></a><strong>3.CopyOnWriteArraySet 并发Set</strong></h6><p>基于CopyOnWriteArrayList实现（内含一个CopyOnWriteArrayList成员变量），也就是说底层是一个数组，意味着每次add都要遍历整个集合才能知道是否存在，不存在时需要插入（加锁）。</p>
<p>适用场景：在CopyOnWriteArrayList适用场景下加一个，集合别太大（全部遍历伤不起）。</p>
<h6 id="4-ConcurrentLinkedQueue-并发队列-基于链表"><a href="#4-ConcurrentLinkedQueue-并发队列-基于链表" class="headerlink" title="4.ConcurrentLinkedQueue 并发队列(基于链表)"></a><strong>4.ConcurrentLinkedQueue 并发队列(基于链表)</strong></h6><p>基于链表实现的并发队列，使用乐观锁(CAS)保证线程安全。因为数据结构是链表，所以理论上是没有队列大小限制的，也就是说添加数据一定能成功。</p>
<h6 id="5-ConcurrentLinkedDeque-并发队列-基于双向链表"><a href="#5-ConcurrentLinkedDeque-并发队列-基于双向链表" class="headerlink" title="5.ConcurrentLinkedDeque 并发队列(基于双向链表)"></a><strong>5.ConcurrentLinkedDeque 并发队列(基于双向链表)</strong></h6><p>基于双向链表实现的并发队列，可以分别对头尾进行操作，因此除了先进先出(FIFO)，也可以先进后出（FILO），当然先进后出的话应该叫它栈了。</p>
<h6 id="6-ConcurrentSkipListMap-基于跳表的并发Map"><a href="#6-ConcurrentSkipListMap-基于跳表的并发Map" class="headerlink" title="6.ConcurrentSkipListMap 基于跳表的并发Map"></a><strong>6.ConcurrentSkipListMap 基于跳表的并发Map</strong></h6><p>SkipList即跳表，跳表是一种空间换时间的数据结构，通过冗余数据，将链表一层一层索引，达到类似二分查找的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ECYW6E_20210607145723.png" alt="img"></p>
<h6 id="7-ConcurrentSkipListSet-基于跳表的并发Set"><a href="#7-ConcurrentSkipListSet-基于跳表的并发Set" class="headerlink" title="7.ConcurrentSkipListSet 基于跳表的并发Set"></a><strong>7.ConcurrentSkipListSet 基于跳表的并发Set</strong></h6><p>类似HashSet和HashMap的关系，ConcurrentSkipListSet里面就是一个ConcurrentSkipListMap，就不细说了。</p>
<h6 id="8-ArrayBlockingQueue-阻塞队列-基于数组"><a href="#8-ArrayBlockingQueue-阻塞队列-基于数组" class="headerlink" title="8.ArrayBlockingQueue 阻塞队列(基于数组)"></a><strong>8.ArrayBlockingQueue 阻塞队列(基于数组)</strong></h6><p>基于数组实现的可阻塞队列，构造时必须制定数组大小，往里面放东西时如果数组满了便会阻塞直到有位置（也支持直接返回和超时等待），通过一个锁ReentrantLock保证线程安全。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/P65yAF_20210607145757.png" alt="img"></p>
<p>乍一看会有点疑惑，读和写都是同一个锁，那要是空的时候正好一个读线程来了不会一直阻塞吗？</p>
<p>答案就在notEmpty、notFull里，这两个出自lock的小东西让锁有了类似synchronized + wait + notify的功能。传送门 → 终于搞懂了sleep&#x2F;wait&#x2F;notify&#x2F;notifyAll</p>
<h6 id="9-LinkedBlockingQueue-阻塞队列-基于链表"><a href="#9-LinkedBlockingQueue-阻塞队列-基于链表" class="headerlink" title="9.LinkedBlockingQueue 阻塞队列(基于链表)"></a><strong>9.LinkedBlockingQueue 阻塞队列(基于链表)</strong></h6><p> 基于链表实现的阻塞队列，想比与不阻塞的ConcurrentLinkedQueue，它多了一个容量限制，如果不设置默认为int最大值。</p>
<h6 id="10-LinkedBlockingDeque-阻塞队列-基于双向链表"><a href="#10-LinkedBlockingDeque-阻塞队列-基于双向链表" class="headerlink" title="10.LinkedBlockingDeque 阻塞队列(基于双向链表)"></a><strong>10.LinkedBlockingDeque 阻塞队列(基于双向链表)</strong></h6><p>类似LinkedBlockingQueue，但提供了双向链表特有的操作。</p>
<h6 id="11-PriorityBlockingQueue-线程安全的优先队列"><a href="#11-PriorityBlockingQueue-线程安全的优先队列" class="headerlink" title="11.PriorityBlockingQueue 线程安全的优先队列"></a><strong>11.PriorityBlockingQueue 线程安全的优先队列</strong></h6><p>构造时可以传入一个比较器，可以看做放进去的元素会被排序，然后读取的时候按顺序消费。某些低优先级的元素可能长期无法被消费，因为不断有更高优先级的元素进来。</p>
<h6 id="12-SynchronousQueue-数据同步交换的队列"><a href="#12-SynchronousQueue-数据同步交换的队列" class="headerlink" title="12.SynchronousQueue 数据同步交换的队列"></a><strong>12.SynchronousQueue 数据同步交换的队列</strong></h6><p>一个虚假的队列，因为它实际上没有真正用于存储元素的空间，每个插入操作都必须有对应的取出操作，没取出时无法继续放入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/yzfXal_20210607145843.png" alt="img"></p>
<p>可以看到，写入的线程没有任何sleep，可以说是全力往队列放东西，而读取的线程又很不积极，读一个又sleep一会。输出的结果却是读写操作成对出现。</p>
<p>JAVA中一个使用场景就是Executors.newCachedThreadPool()，创建一个缓存线程池。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607145908632_20210607145909.png" alt="img"></p>
<h6 id="13-LinkedTransferQueue-基于链表的数据交换队列"><a href="#13-LinkedTransferQueue-基于链表的数据交换队列" class="headerlink" title="13.LinkedTransferQueue 基于链表的数据交换队列"></a><strong>13.LinkedTransferQueue 基于链表的数据交换队列</strong></h6><p>实现了接口TransferQueue，通过transfer方法放入元素时，如果发现有线程在阻塞在取元素，会直接把这个元素给等待线程。如果没有人等着消费，那么会把这个元素放到队列尾部，并且此方法阻塞直到有人读取这个元素。和SynchronousQueue有点像，但比它更强大。</p>
<h6 id="14-DelayQueue-延时队列"><a href="#14-DelayQueue-延时队列" class="headerlink" title="14.DelayQueue 延时队列"></a><strong>14.DelayQueue 延时队列</strong></h6><p>可以使放入队列的元素在指定的延时后才被消费者取出，元素需要实现Delayed接口。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>上面简单介绍了JAVA并发包下的一些容器类，知道有这些东西，遇到合适的场景时就能想起有个现成的东西可以用了。想要知其所以然，后续还得再深入探索一番。</p>
<h4 id="十七、Future-和-CompletableFuture"><a href="#十七、Future-和-CompletableFuture" class="headerlink" title="十七、Future 和 CompletableFuture"></a>十七、Future 和 CompletableFuture</h4><p>CompletableFuture是java 8引入的，用于Java异步编程。异步编程是一种通过在与主应用程序线程不同的线程上运行任务并通知主线程其进度，完成或失败的方法来编写非阻塞代码的方法。<br> 这样，您的主线程就不会阻塞&#x2F;等待任务完成，并且可以并行执行其他任务。具有这种并行性可以大大提高程序的性能。</p>
<h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>Future被用作异步计算结果的参考。它提供了一个isDone（）方法来检查计算是否完成，以及一个get（）方法来检索计算完成后的结果。</p>
<h5 id="Future-VS-CompletableFuture："><a href="#Future-VS-CompletableFuture：" class="headerlink" title="Future VS CompletableFuture："></a>Future VS CompletableFuture：</h5><h6 id="1-手动完成"><a href="#1-手动完成" class="headerlink" title="1.手动完成"></a>1.手动完成</h6><p>Future提供了一个isDone（）方法来检查计算是否完成，以及get（）方法来检索计算结果。但是，Future不提供手动完成的方法。CompletableFuture的complete（）方法可帮助我们手动完成Future</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Manual Completion 手动完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">manualCompletion</span>() throws ExecutionException, InterruptedException</span> &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1111&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手动结束核心</span></span><br><span class="line">        future.complete(<span class="string">&quot;手动完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.<span class="keyword">out</span>.println(future.<span class="keyword">get</span>());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Future的get()方法在完成计算的之前是阻塞的，我们可以使用complete()方法来手动完成计算。</p>
<h6 id="2-多个Future组成调用链"><a href="#2-多个Future组成调用链" class="headerlink" title="2.多个Future组成调用链"></a>2.多个Future组成调用链</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callbackChain</span>() throws ExecutionException, InterruptedException</span> &#123;</span><br><span class="line">    CompletableFuture completableFuture</span><br><span class="line">            = CompletableFuture</span><br><span class="line">            .supplyAsync(() -&gt; <span class="string">&quot;Knolders!&quot;</span>)</span><br><span class="line">            .thenRun(() -&gt; System.<span class="keyword">out</span>.println(<span class="string">&quot;Example with thenRun().&quot;</span>));</span><br><span class="line">    System.<span class="keyword">out</span>.println(completableFuture.<span class="keyword">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-组合多个CompletableFuture结果"><a href="#3-组合多个CompletableFuture结果" class="headerlink" title="3.组合多个CompletableFuture结果"></a>3.组合多个CompletableFuture结果</h6><p>如果是Future，则无法创建异步工作流程，即长时间运行的计算。但是CompletableFuture为我们提供了方法来实现此功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private <span class="keyword">static</span> void <span class="title function_ invoke__">thenCompose</span>() &#123;</span><br><span class="line">    CompletableFuture&lt;<span class="type">String</span>&gt; completableFuture =</span><br><span class="line">            CompletableFuture.<span class="title function_ invoke__">supplyAsync</span>(() <span class="punctuation">-&gt;</span> <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                    .<span class="title function_ invoke__">thenCompose</span>(value <span class="punctuation">-&gt;</span></span><br><span class="line">                            CompletableFuture.<span class="title function_ invoke__">supplyAsync</span>(</span><br><span class="line">                                    () <span class="punctuation">-&gt;</span> value + <span class="string">&quot; Knolders! Its thenCompose&quot;</span>));</span><br><span class="line">    completableFuture.<span class="title function_ invoke__">thenAccept</span>(System.out::println); <span class="comment">// Hello Knolders! Its thenCompose</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你希望合并要并行运行的100种不同的Future，然后在所有这些Future完成后再运行某些功能。可是使用如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合所有的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> void allOf() <span class="keyword">throws</span> <span class="type">ExecutionException</span>, <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">String</span>&gt; completableFuture1</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">String</span>&gt; completableFuture2</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.supplyAsync(() -&gt; <span class="string">&quot;lv!&quot;</span>);</span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">String</span>&gt; completableFuture3</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.supplyAsync(() -&gt; <span class="string">&quot;Its allOf&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个方法并不直接返回结果只是返回一个CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">Void</span>&gt; combinedFuture</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.allOf(completableFuture1, completableFuture2, completableFuture3);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(combinedFuture.get()); <span class="comment">//输出null</span></span><br><span class="line"></span><br><span class="line">        assert (completableFuture1.isDone());</span><br><span class="line">        assert (completableFuture2.isDone());</span><br><span class="line">        assert (completableFuture3.isDone());</span><br><span class="line">        <span class="comment">//使用以下两种方法获取最终结果</span></span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt; listCompletableFuture <span class="operator">=</span> combinedFuture.thenApply(v -&gt;</span><br><span class="line">                <span class="type">Stream</span>.of(completableFuture1, completableFuture2, completableFuture3).</span><br><span class="line">                        map(CompletableFuture::join).</span><br><span class="line">                        collect(<span class="type">Collectors</span>.toList()));</span><br><span class="line">        <span class="type">System</span>.out.println(listCompletableFuture.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> combined <span class="operator">=</span> <span class="type">Stream</span>.of(completableFuture1, completableFuture2, completableFuture3)</span><br><span class="line">                .map(CompletableFuture::join)</span><br><span class="line">                .collect(<span class="type">Collectors</span>.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        <span class="type">System</span>.out.println(combined);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h6><p>如果发生异常，调用链将会停止调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static void exception() &#123;</span><br><span class="line">    Integer age = -<span class="number">1</span>;</span><br><span class="line">    CompletableFuture&lt;String&gt; exceptionFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    exceptionFuture.thenAccept(System.<span class="keyword">out</span>::println); <span class="comment">//Unknown!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static void exceptionUsingHandle() &#123;</span><br><span class="line">    Integer age = -<span class="number">1</span>;</span><br><span class="line">    CompletableFuture&lt;String&gt; exceptionFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    exceptionFuture.thenAccept(System.<span class="keyword">out</span>::println); <span class="comment">// Unknown!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十八、……"><a href="#十八、……" class="headerlink" title="十八、……"></a>十八、……</h4><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h2><p>对于 Java 程序员来说，JVM 帮助我们做了很多事情比如内存管理、垃圾回收等等。在 JVM 的帮助下，我们的程序出现内存泄漏这些问题的概率相对来说是比较低的。但是，这并不代表我们在日常开发工作中不会遇到。万一你在工作中遇到了 OOM 问题，你至少要知道如何去排查和解决问题吧！<br>并且，就单纯从面试角度来说，JVM 是 Java 后端面试（大厂）中非常重要的一环。不论是应届还是社招，面试国内的一些大厂，你都会被问到很多 JVM 相关的问题（应届的话侧重理论，社招实践）。</p>
<p>只有搞懂了 JVM 才有可能真正把 Java 语言“吃透”。学习 JVM 这部分的内容，一定要注意要实战和理论结合。</p>
<p>书籍的话，**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a>** 这本书是首先要推荐的。</p>
<p>下面是我总结的一些关于 JVM 的小问题，你可以拿来自测：</p>
<h3 id="一、什么是虚拟机？"><a href="#一、什么是虚拟机？" class="headerlink" title="一、什么是虚拟机？"></a>一、什么是虚拟机？</h3><h4 id="1、-什么是JVM？"><a href="#1、-什么是JVM？" class="headerlink" title="1、 什么是JVM？"></a>1、 什么是JVM？</h4><p>　　JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<p>　　Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>
<h4 id="2、JRE-x2F-JDK-x2F-JVM是什么关系？"><a href="#2、JRE-x2F-JDK-x2F-JVM是什么关系？" class="headerlink" title="2、JRE&#x2F;JDK&#x2F;JVM是什么关系？"></a>2、JRE&#x2F;JDK&#x2F;JVM是什么关系？</h4><p>JRE(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。 </p>
<p>JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。 </p>
<p>JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p>
<h4 id="3、JVM原理"><a href="#3、JVM原理" class="headerlink" title="3、JVM原理"></a>3、JVM原理</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/vsFMvy_20210607151034.png" alt="img"></p>
<p>　　Java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。</p>
<p>我刚整理了一套2018最新的0基础入门和进阶教程，无私分享，加Java学习裙 ：678-241-563 即可获取，内附：开发工具和安装包，以及系统学习路线图</p>
<h4 id="4、JVM的体系结构"><a href="#4、JVM的体系结构" class="headerlink" title="4、JVM的体系结构"></a>4、JVM的体系结构</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/h5akfA_20210607151049.png" alt="img"></p>
<p>（1）java栈内存，它等价于C语言中的栈， 栈的内存地址是不连续的， 每个线程都拥有自己的栈。 栈里面存储着的是StackFrame，在《JVM Specification》中文版中被译作java虚拟机框架，也叫做栈帧。StackFrame包含三类信息：局部变量，执行环境，操作数栈。局部变量用来存储一个类的方法中所用到的局部变量。执行环境用于保存解析器对于java字节码进行解释过程中需要的信息，包括：上次调用的方法、局部变量指针和 操作数栈的栈顶和栈底指针。操作数栈用于存储运算所需要的操作数和结果。StackFrame在方法被调用时创建，在某个线程中，某个时间点上，只有一个 框架是活跃的，该框架被称为Current Frame，而框架中的方法被称为Current Method，其中定义的类为Current Class。局部变量和操作数栈上的操作总是引用当前框架。当Stack Frame中方法被执行完之后，或者调用别的StackFrame中的方法时，则当前栈变为另外一个StackFrame。Stack的大小是由两种类 型，固定和动态的，动态类型的栈可以按照线程的需要分配。 下面两张图是关于栈之间关系以及栈和非堆内存的关系基本描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FK51y8_20210607151103.png" alt="img"></p>
<p>（2） Java堆是用来存放对象信息的，和Stack不同，Stack代表着一种运行时的状态。换句话说，栈是运行时单位，解决程序该如何执行的问题，而堆是存储的单位， 解决数据存储的问题。Heap是伴随着JVM的启动而创建，负责存储所有对象实例和数组的。堆的存储空间和栈一样是不需要连续的。</p>
<p>（3）程序计数寄存器，程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>　　由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p>
<p>（4）方法区域（Method Area），在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p>
<p>（5）运行时常量池（Runtime Constant Pool），存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。</p>
<p>（6）本地方法堆栈（Native Method Stacks），JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。</p>
<h3 id="二、Java-内存区域是怎么划分的？大对象放在哪个内存区域？"><a href="#二、Java-内存区域是怎么划分的？大对象放在哪个内存区域？" class="headerlink" title="二、Java 内存区域是怎么划分的？大对象放在哪个内存区域？"></a>二、Java 内存区域是怎么划分的？大对象放在哪个内存区域？</h3><h4 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/isI7wn_20210607151456.png" alt="img"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>记录正在执行的虚拟机字节码指令地址（如果正在执行的是本地的方法则为空）。</p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/i4F7mi_20210607151531.png" alt="img"></p>
<p>可以通过-Xss这个虚拟机参数来指定一个Java虚拟机栈内存大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss = 512M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：<br>  1、当线程请求的栈深度超过最大值，会抛出StackOverflowError异常；<br>  2、栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法不是用Java实现，对待这些方法需要特别处理。<br> 与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7A6VYF_20210607151605.png" alt="img"></p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>所有对象实例都在这里分配内存。</p>
<p>是垃圾收集器的主要区域（”GC堆”），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把Java堆分成以下三块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://www.cnblogs.com/orientsun/archive/2012/07/25/2608548.html">Tenured Generation</a>）</li>
<li>永久代（Permanent Generation）</li>
</ul>
<p>当一个对象被创建时，首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效率地进行垃圾回收，把新生代分成以下三个空间：</p>
<ul>
<li>Eden</li>
<li>From Survivor</li>
<li>To Survivor</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/I1PicV_20210607151634.png" alt="img"></p>
<p>Java堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OutOfMenmoryError异常。<br> 可以通过-Xms和-Xmx两个虚拟机参数来指定一个程序的Java堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms = 1M -Xmx = 2M HackTheJava</span><br></pre></td></tr></table></figure>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br> 和Java堆不一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。<br> 对这块区域进行垃圾回收的主要目标是对常量池的回收和类的卸载，但是一般比较难实现，HotSpot把它当成永久代来进行垃圾回收。</p>
<h5 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h5><p>运行常量池是方法区的一部分。<br> Class文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。<br> 除了在编译期生成的常量，还允许动态生成，例如String类的intern()。这部分常量也会被放入运行时常量池。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h4 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h4><h4 id="重拾Markdown，一些用法的使用记录"><a href="#重拾Markdown，一些用法的使用记录" class="headerlink" title="重拾Markdown，一些用法的使用记录"></a>重拾Markdown，一些用法的使用记录</h4><h5 id="1、空行"><a href="#1、空行" class="headerlink" title="1、空行"></a>1、空行</h5><p>  起作用的：正文内容。<br>  不起作用的：各级标题、分隔线、代码框编辑前后。<strong>使用前后都添加空行</strong></p>
<h5 id="2、缩进控制"><a href="#2、缩进控制" class="headerlink" title="2、缩进控制"></a>2、缩进控制</h5><p>  <code> </code>&amp;ensp;缩进一个空格。<br>  <code> </code>&amp;emsp;缩进两个空格。<br> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9d94660a96f1">https://www.jianshu.com/p/9d94660a96f1</a></p>
<h5 id="3、代码展示"><a href="#3、代码展示" class="headerlink" title="3、代码展示"></a>3、代码展示</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/m7N6bX_20210607151405.png" alt="img"></p>
<p>&#96;&#96;&#96;和&#96;两者包含的代码框有什么不同？ </p>
<p>&#96;&#96;&#96;代码框。</p>
<p>&#96;代码片。</p>
<p> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9b582bb6760">https://www.jianshu.com/p/b9b582bb6760</a></p>
<h5 id="4、Markdown是否有转义字符的使用？"><a href="#4、Markdown是否有转义字符的使用？" class="headerlink" title="4、Markdown是否有转义字符的使用？"></a>4、Markdown是否有转义字符的使用？</h5><p>  比如代码框符号&#96;&#96;&#96;，引用符号&gt;等。这个转义字符就是反斜杠 \。<br> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9b582bb6760">https://www.jianshu.com/p/b9b582bb6760</a></p>
<h5 id="5、简数编辑区域的Markdown怎么设置图片的位置？"><a href="#5、简数编辑区域的Markdown怎么设置图片的位置？" class="headerlink" title="5、简数编辑区域的Markdown怎么设置图片的位置？"></a>5、简数编辑区域的Markdown怎么设置图片的位置？</h5><p>  <em>暂时没有解决。</em></p>
<h5 id="6、一些说明："><a href="#6、一些说明：" class="headerlink" title="6、一些说明："></a>6、一些说明：</h5><p>  <strong>图片连接地址前后都设置一个空行。</strong>简书的markdown文章中的图片不用做其他设置都是默认居中，而在个人博客中却默认左对齐，具体效果如下图。对于有轻微强迫症的笔者决定将所有图片修改为居中对齐，搜索了一下，只需在markdown文件中的图片引用前后加上 HTML <div> 标签即可实现居中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----空行----</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">![]()</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">-----空行----</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.php-master.com/post/68996.html">http://www.php-master.com/post/68996.html</a></p>
<h5 id="7、强制换行"><a href="#7、强制换行" class="headerlink" title="7、强制换行"></a>7、强制换行</h5><p>  markdown编辑器下直接回车，预览时换行是显示不了的。这时就需要强制换行了。<br>  强制换行语法：<code>&lt;br&gt;</code>。可以直接使用，在简书编辑区域同样有效。</p>
<h5 id="8、杂"><a href="#8、杂" class="headerlink" title="8、杂"></a>8、杂</h5><p>  <code>&lt;br&gt;</code>与<code>&lt;br/&gt;</code>？<br>  不同的标准下的产物，使用上没什么差异，相互兼容。</p>
<p>  分隔符还是统一使用***；使用—如果它的上面没有空行，文字将会被误解析成标题。</p>
<p>  Markdown编辑的文本在不同的解析器下面，换行的长度会不同。</p>
<h3 id="三、垃圾回收有哪些算法？GC-的流程"><a href="#三、垃圾回收有哪些算法？GC-的流程" class="headerlink" title="三、垃圾回收有哪些算法？GC 的流程"></a>三、垃圾回收有哪些算法？GC 的流程</h3><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>1、一个对象一生经历了什么？<br>2、如何判断对象是否可用？<br>3、引用计数法和可达性分析算法各自优缺点?<br>4、哪些对象可以作为GC ROOT?<br>5、垃圾回收的时候如何快速寻找根节点？<br>6、垃圾回收算法有哪些？各自优缺点？<br>7、有哪些垃圾回收器？各自优缺点？适用什么场景？</p>
<h4 id="1、对象回收处理过程"><a href="#1、对象回收处理过程" class="headerlink" title="1、对象回收处理过程"></a>1、对象回收处理过程</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607152935713_20210607152936.png" alt="img"></p>
<h4 id="2、判断用户是否可用计算"><a href="#2、判断用户是否可用计算" class="headerlink" title="2、判断用户是否可用计算"></a>2、判断用户是否可用计算</h4><h5 id="2-1、引用计数算法"><a href="#2-1、引用计数算法" class="headerlink" title="2.1、引用计数算法"></a>2.1、引用计数算法</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/zQbhzP_20210607153405.png" alt="img"></p>
<p>如上图，给对象一个引用技术refCount。每有一个对象引用它，计时器加1，当它为0时，表示对象补课在用。</p>
<p>缺点。  </p>
<p>很难解决循环引用的问题。</p>
<p>objA.instance &#x3D; objB</p>
<p>objB.instance &#x3D; objA</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/O85ZFh_20210607153439.png" alt="img"></p>
<p>如上，即使objA和objB 都不在被访问后，但是它们还在 相互引用，所以计数器不会为0</p>
<h5 id="2-2、可达性分析算法"><a href="#2-2、可达性分析算法" class="headerlink" title="2.2、可达性分析算法"></a>2.2、可达性分析算法</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lsM8Kz_20210607153506.png" alt="img"></p>
<p>如上图，从GC Roots开始向下搜索，连接的路径为引用链；</p>
<p>GC Roots不可达的对象被判为不可用；<br><strong>可作为GC Root的对象</strong></p>
<p><strong>如上图，虚拟机栈帧中本地变量表引用的对象，本地方法栈中，JNI引用的对象，方法区中的类静态属性引入的对象和常量引用对象都可以作为GC Root。</strong></p>
<p><strong>引用类型</strong></p>
<ul>
<li>强引用：<br>类似 object a &#x3D; new object();</li>
<li>软引用：<br>SoftReference<String> ref &#x3D; new SoftReference<String>(“Hello World”);OOM前，JVM会把这些对象列入回收范围进行二次回收，如果回收后内存还是不做，则OOM。</li>
<li>弱引用：<br>WeakReference<Car> weakCar &#x3D; new WeakReference<Car>(car);每次垃圾收集，弱引用的对象就会被清理</li>
<li>虚引用：<br>幽灵引用，不能用来获取一个对象的实例，唯一用途：当一个虚引用引用的对象被回收，系统会收到这个对象被回收的通知。</li>
</ul>
<h4 id="3、HotSpot中如何实现判断是否存在与GC-Roots相连接的引用链"><a href="#3、HotSpot中如何实现判断是否存在与GC-Roots相连接的引用链" class="headerlink" title="3、HotSpot中如何实现判断是否存在与GC Roots相连接的引用链"></a>3、HotSpot中如何实现判断是否存在与GC Roots相连接的引用链</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607153915850_20210607153916.png" alt="img"></p>
<p>第一小节流程图里的是否存在与GC Roots相连接的引用链 这个判断子流程是怎么实现的呢，这节我们来仔细探讨下。</p>
<p>一般的，我们都是选取可达性分析算法，这里主要阐述怎么寻找GC Root以及如何检查引用链。</p>
<h5 id="3-1、枚举根节点"><a href="#3-1、枚举根节点" class="headerlink" title="3.1、枚举根节点"></a>3.1、枚举根节点</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607153933179_20210607153933.png" alt="img"></p>
<p>如上图，在一个调用关系为：</p>
<p>ClassA.invokeA() –&gt; ClassB.invokeB() –&gt;doinvokeB() –&gt;ClassC.execute()</p>
<p>的情况下，每个调用对应一个栈帧，栈帧里面的本地变量表存储了GC Roots的引用。</p>
<p>如果直接遍历所有的栈去查找GC Roots，效率太低了。为此我们引入了OopMap和安全点的概念。</p>
<p><strong>安全点和OopMap</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/eNYInZ_20210607154007.png" alt="img"></p>
<p>如上图，在源代码编译的时候，会在特定位置下记录安全点，一般为：</p>
<p>1、循环的末尾</p>
<p>2、方法返回前 或者调用方法的call指令后</p>
<p>3、可能抛出异常的位置</p>
<p>通过安全点把代码分成几段，每段代码一个OopMap。</p>
<p>OopMap记录栈上本地变量到堆上对象的引用关系，每当触发GC的时候，程序都先跑的最近的安全点，然后自动挂起，然后在触发更新OopMap，然后进行枚举类GC ROOT，进行垃圾回收：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/4Wn0gn_20210607154023.png" alt="img"></p>
<p>安全区域：在一段代码片段之中，引用关系不会发生变化，因此在这个区域中的任意位置开始 GC 都是安全的。如处于Sleep或者Blocked状态的线程。</p>
<p>为了在枚举GC Roots的过程中，对象的引用关系不会变更，所以需要一个GC停顿。</p>
<p>还有一种抢先式中断的方式，几乎没有虚拟机采用：先中断所有线程，发现线程没中断在安全点，恢复它，继续执行到安全点。</p>
<p>找到了该回收的对象，下一步就是清掉这些对象了，HotSpot将去交给CG收集器。</p>
<h4 id="4、垃圾回收算法"><a href="#4、垃圾回收算法" class="headerlink" title="4、垃圾回收算法"></a>4、垃圾回收算法</h4><p>概览图</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TtxwIM_20210607154038.png" alt="img"></p>
<h5 id="4-1、标记-清除算法"><a href="#4-1、标记-清除算法" class="headerlink" title="4.1、标记-清除算法"></a>4.1、标记-清除算法</h5><h6 id="4-1-1、算法描述"><a href="#4-1-1、算法描述" class="headerlink" title="4.1.1、算法描述"></a>4.1.1、算法描述</h6><p>标记阶段：标记处所有需要回收的对象；</p>
<p>清除阶段：标记成功后，统一回收所有被标记的对象；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/502JCL_20210607154055.png" alt="img"></p>
<h6 id="4-1-2、不足"><a href="#4-1-2、不足" class="headerlink" title="4.1.2、不足"></a>4.1.2、不足</h6><p>效率不高：标记和清除两个过程效率都不高；</p>
<p>空间问题：产生大量不连续的内存碎片，进而无法容纳大对象提早触发另一次GC.。</p>
<h5 id="4-2、复制算法"><a href="#4-2、复制算法" class="headerlink" title="4.2、复制算法"></a>4.2、复制算法</h5><h6 id="4-2-1、算法描述"><a href="#4-2-1、算法描述" class="headerlink" title="4.2.1、算法描述"></a>4.2.1、算法描述</h6><p>将可用内存分为容量大小相等的两块，每次只使用其中一块；</p>
<p>当一块用完，就将存活着的对象复制到另一块，然后将这块全部内存清理掉；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/0duyuk_20210607154116.png" alt="img"></p>
<h6 id="4-2-2、优点"><a href="#4-2-2、优点" class="headerlink" title="4.2.2、优点"></a>4.2.2、优点</h6><p>不会产生不连续的内存碎片</p>
<p>提高效率： </p>
<p>​    回收：每次都是对整个半区进行回收；</p>
<p>​    分配：分配时也不用考虑内存碎片的问题，只要移动指针，按顺序分配内存即可。</p>
<h6 id="4-2-3、缺点"><a href="#4-2-3、缺点" class="headerlink" title="4.2.3、缺点"></a>4.2.3、缺点</h6><p>可用内存缩小为原来的一半了，适合GC过后只有少量存活的新生代，可以根据实际情况，将内存块大小比例适当调整；</p>
<p>如果存活对象数量比较大，复制性能会变得很差。</p>
<h5 id="4-2-4、JVM中新生代的垃圾回收"><a href="#4-2-4、JVM中新生代的垃圾回收" class="headerlink" title="4.2.4、JVM中新生代的垃圾回收"></a>4.2.4、JVM中新生代的垃圾回收</h5><p>如下图，分为新生代和老年代。其中新生代又分为一个Eden区和两个Survivor去(from区和to区)，默认Eden : from : to 比例为8:1:1。</p>
<p>可通过JVM参数：-XX:SurvivorRatio配置比例，-XX:SurvivorRatio&#x3D;8 表示 Eden区大小 &#x2F; 1块Survivor区大小 &#x3D; 8。</p>
<p><strong>第一次Young GC</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HDxRFt_20210607154131.png" alt="img"></p>
<p>再次触发Young GC，扫描Eden区和from区，把存活的对象复制到To区，清空Eden区和from区。如果此时Survivor区的空间不够了，就会提前把对象放入老年代。</p>
<p>默认的，这样来回交换15次后，如果对象最终还是存活，就放入老年代。</p>
<p>交换次数可以通过JVM参数MaxTenuringThreshold进行设置。</p>
<h5 id="4-2-5、JVM内存模型"><a href="#4-2-5、JVM内存模型" class="headerlink" title="4.2.5、JVM内存模型"></a>4.2.5、JVM内存模型</h5><p>JDK8之前</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/gjNNif_20210607154155.png" alt="img"></p>
<p>JDK8</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KUvMoR_20210607154209.png" alt="img"></p>
<p>如上图，JDK8的方法区实现变成了元空间，元空间在本地内存中。</p>
<h5 id="4-3、标记-整理算法"><a href="#4-3、标记-整理算法" class="headerlink" title="4.3、标记-整理算法"></a>4.3、标记-整理算法</h5><h6 id="4-3-1、算法描述"><a href="#4-3-1、算法描述" class="headerlink" title="4.3.1、算法描述"></a>4.3.1、算法描述</h6><p>标记过程与标记-清楚算法一样；</p>
<p>标记完成后，将存活对象向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/66TPGn_20210607154247.png" alt="img"></p>
<h6 id="4-3-2、优点"><a href="#4-3-2、优点" class="headerlink" title="4.3.2、优点"></a>4.3.2、优点</h6><p>不会产生内存碎片；</p>
<p>不需要浪费额外的空间进行分配担保；</p>
<h6 id="4-3-3、不足"><a href="#4-3-3、不足" class="headerlink" title="4.3.3、不足"></a>4.3.3、不足</h6><p>整理阶段存在效率问题，适合老年代这种垃圾回收频率不是很高的场景；</p>
<h5 id="4-4、分代收集算法"><a href="#4-4、分代收集算法" class="headerlink" title="4.4、分代收集算法"></a>4.4、分代收集算法</h5><p>当前商业虚拟机都采用该算法。</p>
<p>新生代：复制算法(CG后只有少量的对象存活)</p>
<p>老年代：标记-整理算法 或者 标记-清理算法(GC后对象存活率高)</p>
<h4 id="5、垃圾回收器"><a href="#5、垃圾回收器" class="headerlink" title="5、垃圾回收器"></a>5、垃圾回收器</h4><p>这一步就是我们真正进行垃圾回收的过程了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NYLE3J_20210607154302.png" alt="img"></p>
<p>本节概念约定：并发：用户线程与垃圾收集线程同时执行，但不一定是并行，可能交替执行；并行：多条垃圾收集线程并行工作，单用户线程仍处于等待状态。</p>
<p>以下是垃圾收集器概览图</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/D6zV3r_20210607154323.png" alt="img"></p>
<h5 id="5-1、Serial收集器"><a href="#5-1、Serial收集器" class="headerlink" title="5.1、Serial收集器"></a>5.1、Serial收集器</h5><h6 id="5-1-1、特点"><a href="#5-1-1、特点" class="headerlink" title="5.1.1、特点"></a>5.1.1、特点</h6><p>串行化：在垃圾回收时，必须赞同其他所有工作线程，知道收集结束，Stop The World；</p>
<p>在单CPU模式下无线程交互开销，专心做垃圾收集，简单高效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Eb3q5X_20210607154332.png" alt="img"></p>
<h6 id="5-1-2、适用场景"><a href="#5-1-2、适用场景" class="headerlink" title="5.1.2、适用场景"></a>5.1.2、适用场景</h6><p>特别适合限定单CPU的环境；</p>
<p>Client模式下的默认新生代收集器，用户桌面应用场景分配给虚拟机的内存一般不会很大，所以停顿时间也是在一百多毫秒以内，影响不大。</p>
<h5 id="5-2、ParNew收集器"><a href="#5-2、ParNew收集器" class="headerlink" title="5.2、ParNew收集器"></a>5.2、ParNew收集器</h5><p>Parallel New?</p>
<h6 id="5-2-1、特点"><a href="#5-2-1、特点" class="headerlink" title="5.2.1、特点"></a>5.2.1、特点</h6><p>Serial收集器的多线程版本；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/iZVXHy_20210607154350.png" alt="img"></p>
<h6 id="5-2-2、适用场景"><a href="#5-2-2、适用场景" class="headerlink" title="5.2.2、适用场景"></a>5.2.2、适用场景</h6><p>许多运行在Server模式下的虚拟机中的首选新生代收集器；</p>
<p>除了Serial收集器外，只有它能和CMS收集器搭配使用。</p>
<p>-XX:+UseConcMarkSweepGC选型默认使用ParNew收集器。也可以使用-XX:+UseParNewGC选项强制指定它。</p>
<p>ParNew收集器在单CPU环境比Serial收集器效果差(存在线程交互开销)。</p>
<p>CPU数量越多，ParNew效果越好，默认开启收集线程数&#x3D;CPU数量。可以使用-XX:ParallelGCThreads参数限制垃圾收集器的线程数。</p>
<h5 id="5-3、Parallel-Scavenge收集器"><a href="#5-3、Parallel-Scavenge收集器" class="headerlink" title="5.3、Parallel Scavenge收集器"></a>5.3、Parallel Scavenge收集器</h5><h6 id="5-3-1、特点"><a href="#5-3-1、特点" class="headerlink" title="5.3.1、特点"></a>5.3.1、特点</h6><p>新生代收集器，使用复制算法，并行多线程；</p>
<p>吞吐量优先收集器：CMS等收集器会关注如何缩短停顿时间，而这个收集器是为了吞吐量而设计的。</p>
<p>吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )</p>
<p>也就是说整体垃圾收集时间越短，吞吐量越高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/EDV0Fw_20210607154405.png" alt="img"></p>
<h6 id="5-3-2、适用场景"><a href="#5-3-2、适用场景" class="headerlink" title="5.3.2、适用场景"></a>5.3.2、适用场景</h6><p>可以高效利用CPU时间，尽快完成程序的运算任务，适合后台运算不需要太多交互的任务；</p>
<h6 id="5-3-3、相关参数"><a href="#5-3-3、相关参数" class="headerlink" title="5.3.3、相关参数"></a>5.3.3、相关参数</h6><p>-XXMaxGCPauseMillis：设置最大垃圾收集停顿时间，大于0的毫秒数；</p>
<p>缩短GC停顿时间会牺牲吞吐量和新生代空间。新生代空间小，GC回收就快，但是同时会导致GC更加频繁，整体垃圾回收时间更长。</p>
<p>-XX:GCTimeRatio：设置吞吞量大小。0~100的整数，垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</p>
<p>19: 1&#x2F;(1+19)&#x3D; 5%，即最大GC时间占比5%；</p>
<p>99: 1&#x2F;(1+99)&#x3D;1%，即最大GC时间占比1%；</p>
<p>-XX:+UseAdaptiveSizePolicy：GC自适应调节策略开关，打开开关，无需手工指定-Xmn(新生代大小)、-XX:SurvivorRatio(Eden与Survivor区比例)、-XX:PretenureSizeThreshold(晋升老年代对象年龄)等参数，虚拟机会收集性能监控信息，动态调整这些参数，确保提供最合适的 停顿时间或者最大吞吐量。</p>
<h5 id="5-4、Serial-Old收集器"><a href="#5-4、Serial-Old收集器" class="headerlink" title="5.4、Serial Old收集器"></a>5.4、Serial Old收集器</h5><h6 id="5-4-1、特点"><a href="#5-4-1、特点" class="headerlink" title="5.4.1、特点"></a>5.4.1、特点</h6><p>Serial收集器的老年代版本。使用单线程，标记-整理算法。</p>
<h6 id="5-4-2、适用场景"><a href="#5-4-2、适用场景" class="headerlink" title="5.4.2、适用场景"></a>5.4.2、适用场景</h6><p>主要给Client模式下的虚拟机使用；</p>
<p>Server模式下，量大用途：</p>
<p>JDK1.5版本之前的版本与Parallel Scavenge收集器搭配使用；</p>
<p>作为CMS收集器的后备预案，发生Concurrent Mode Failure时使用。</p>
<h5 id="5-5、Parallel-Olde收集器"><a href="#5-5、Parallel-Olde收集器" class="headerlink" title="5.5、Parallel Olde收集器"></a>5.5、Parallel Olde收集器</h5><h6 id="5-5-1、特点"><a href="#5-5-1、特点" class="headerlink" title="5.5.1、特点"></a>5.5.1、特点</h6><p>Parallel Scavenge收集器的老年代版本，使用多线程，标记整理算法。</p>
<h6 id="5-5-2、使用场景"><a href="#5-5-2、使用场景" class="headerlink" title="5.5.2、使用场景"></a>5.5.2、使用场景</h6><p>主要配合Parallel Scavenge使用，提高吞吐量。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑这个组合。</p>
<p>JDK1.6之后提供，之前Parallel Scavenge只能与Serial Old配合使用，老年代Serial Old无法充分利用服务器多CPU处理器能力，拖累了实际的吞吐量，效果不如ParNew+CMS组合；</p>
<h5 id="5-6、CMS收集器"><a href="#5-6、CMS收集器" class="headerlink" title="5.6、CMS收集器"></a>5.6、CMS收集器</h5><p>Concurrent Mark Sweep</p>
<h6 id="5-6-1、特点"><a href="#5-6-1、特点" class="headerlink" title="5.6.1、特点"></a>5.6.1、特点</h6><p>设计目标：获得最短回收停顿时间；</p>
<p>注重服务响应速度；</p>
<p>标记-清除算法；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/nC3LQY_20210607154423.png" alt="img"></p>
<h6 id="5-6-2、缺点"><a href="#5-6-2、缺点" class="headerlink" title="5.6.2、缺点"></a>5.6.2、缺点</h6><p>对CPU资源敏感，虽然不会导致用户线程停顿，但是会占用一部分线程(CPU资源)而导致应用程序变慢，吞吐量降低；</p>
<p>CMS收集器无法处理浮动垃圾。在CMS并发清理阶段，用户线程会产生垃圾。如果出现Concurrent Mode Failure失败，会启动后备预案：临时启动Serial Old收集器重新进行老年代垃圾收集，停顿时间更长了。-XX:CM SInitiatingOccupancyFraction设置的太高容易导致这个问题；</p>
<p>基于标记-清除算法，会产生大量空间碎片。</p>
<h6 id="5-6-3、使用场景"><a href="#5-6-3、使用场景" class="headerlink" title="5.6.3、使用场景"></a>5.6.3、使用场景</h6><p>互联网网站或者B&#x2F;S系统的服务器；</p>
<h6 id="5-6-4、相关参数"><a href="#5-6-4、相关参数" class="headerlink" title="5.6.4、相关参数"></a>5.6.4、相关参数</h6><p>-XX:+UseCMSCompactAtFullCollection：在CMS要进行Full GC时进行内存碎片整理(默认开启)。内存整理过程无法并发，会增加停顿时间；</p>
<p>-XX:CMSFullGCsBeforeCompaction：在多少次 Full GC 后进行一次空间整理(默认0，即每一次 Full GC 后都进行一次空间整理)；</p>
<p>-XX:CM SInitiatingOccupancyFraction：触发GC的内存百分比，设置的太高容易导致Concurrent Mode Failure失败(GC过程中，用户线程新增的浮动垃圾，导致触发另一个Full GC)。</p>
<p>CMS为什么要采用标记-清除算法？</p>
<p>CMS主要关注低延迟，所以采用并发方式清理垃圾，此时程序还在运行，如果采用压缩算法，则会涉及到移动应用程序的存活对象，这种场景下不做停顿是很难处理的，一般需要停顿下来移动存活对象，再让应用程序继续运行，但是这样停顿时间就边长了，延迟变长。CMS是容忍了空间碎片来换取回收的低延迟。</p>
<h5 id="5-7、G1收集器"><a href="#5-7、G1收集器" class="headerlink" title="5.7、G1收集器"></a>5.7、G1收集器</h5><p>G1：Garbage-First，即优先回收价值最大的Region(注1)。</p>
<p>注1：G1与收集器将整个Java堆换分为多个代销相等的独立区域，跟踪各个Region里面的垃圾堆积的价值大小，优先回收价值最大的Region。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/jtj1A0_20210607154438.png" alt="img"></p>
<p>如上图，G1收集器分为四个阶段：</p>
<p>初始标记：只标记GC Roots能直接关联到的对象，速度很快。并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能够在正确可用的Region中创建新对象，这阶段需要停顿线程；</p>
<p>并发标记：GC RootsTracing过程。该阶段对象变化记录在线程Remembered Set Logs中。</p>
<p>最终标记：修正并发期间因用户程序运作而导致标记产生变动的部分对象的标记记录。把Remembered Set Logs数据合并到Remembered Set中。这个阶段需要停顿，但是可并行执行；</p>
<p>筛选回收：对各个Region回收价值和成本进行排序，根据用户期望Gc停顿时间制定回收计划。与CMS不一样，这里不用和用户线程并发执行，提高收集效率，使用标记-整理算法，不产生空间碎片。</p>
<h6 id="5-7-1、特点"><a href="#5-7-1、特点" class="headerlink" title="5.7.1、特点"></a>5.7.1、特点</h6><p>并行与并发：并发标记，并行最终标记与筛选回收；</p>
<p>分代收集</p>
<p>空间整合：基于标记-整理算法，不会产生碎片。</p>
<p>可预测的停顿：G与收集器将整个Java堆换分为多个代销相等的独立区域，避免在整个Java堆中进行全区域的垃圾回收，跟踪各个Region里面垃圾堆积的价值大小，后台维护一个优先列表，每次根据运行的收集时间，优先回收价值最大的Region。</p>
<h3 id="四、什么是类加载？何时类加载？类加载流程？"><a href="#四、什么是类加载？何时类加载？类加载流程？" class="headerlink" title="四、什么是类加载？何时类加载？类加载流程？"></a>四、什么是类加载？何时类加载？类加载流程？</h3><h4 id="类的加载过程介绍"><a href="#类的加载过程介绍" class="headerlink" title="类的加载过程介绍"></a>类的加载过程介绍</h4><ol>
<li><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul>
<li><p>类的加载指的是将类的 .class 文件中的二进制数据读入到 JVM 内存中，将其放在运行时数据区的 <strong>方法区</strong> 内，然后在 <strong>堆区</strong> 创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。类的加载的最终是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且提供了访问方法区内的数据结构的接口。</p>
</li>
<li><p>类的加载过程分为 3 个步骤：<strong>加载；连接（验证、准备、解析）；初始化</strong>，一般情况下 JVM 会连续完成 3 个步骤，有时也会只完成前两步。</p>
</li>
<li><p>如图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18194036-69d59af96d828f3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1158/format/webp" alt="img"></p>
<p>类加载过程.jpg</p>
</li>
</ul>
</li>
<li><h5 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a80db3beb21a">类加载介绍</a></li>
<li>系统可能在第一次使用某一个类时，加载该类，但也可能采用 <strong>预先加载机制</strong> 来加载该类，不管怎样类的加载必须由 <strong>类加载器</strong> 来完成。通常类加载器是由 JVM 提供。</li>
<li>类的加载必须由类加载器完成，通常情况下类加载器由 JVM 提供，但也可以通过自定义。<ol>
<li>JVM 提供的类加载器被称之为 <strong>系统类加载器</strong></li>
<li>开发者还可以通过继承 <strong>ClassLoader</strong> 接口来创建 <strong>自定义类加载器</strong></li>
</ol>
</li>
<li>通过不同的类加载器，可以从不同的 “来源” 加载类的 .class 文件（二进制文件）<ol>
<li>从本地系统中直接读取 .class 文件，大部分的加载方式。</li>
<li>从 ZIP、JAR 等归档文件中加载 .class 文件，很常见。</li>
<li>从网络下载 .class 文件数据。</li>
<li>从专有数据库中读取 .class 文件</li>
<li>将 Java 的源文件数据，上传到服务器中，进行动态编译产生 .class 文件，并加以执行。</li>
</ol>
</li>
<li>但是不管 .class 文件数据来源何处，加载的结果都是相同的<ol>
<li>将字节码文件数据加载到 JVM 内存中，将其放在运行时数据区的 <strong>方法区</strong> 内，然后在 <strong>堆区</strong> 创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。类的加载的最终是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且提供了访问方法区内的数据结构的接口。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>通过一个类的全限定名来获取其定义的字节码（二进制字节流），将字节码文件加载到 JVM 内存中，此过程由类加载器完成（可控）</li>
</ul>
</li>
<li><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h5><ul>
<li>加载阶段是可控性最强的阶段，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</li>
</ul>
</li>
</ol>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ol>
<li><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><ul>
<li>校验 .class 文件是否合法，遵循 .class 文件格式 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a682f9cc5fea">参考地址</a></li>
</ul>
</li>
<li><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul>
<li>为类变量（<code>static</code> 修饰的变量）在 JVM 方法区中分配内存，并进行 <strong>默认初始化</strong><ol>
<li><code>int</code> 默认初始化为 <code>0</code></li>
<li>引用默认初始化为 <code>null</code></li>
<li>等等</li>
</ol>
</li>
<li>静态常量（<code>static final</code>） ，有所不同，直接在 JVM 方法去中 <strong>显示初始化</strong></li>
</ul>
</li>
<li><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ul>
<li>JVM 将常量池的符号引用。替换为直接（地址）引用</li>
</ul>
</li>
<li><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li><strong>此时在堆区中已经创建一个 java.lang.Class 对象，指向方法区中的数据</strong></li>
</ul>
</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ul>
<li>主要是对类静态的类变量进行 <strong>显示初始化</strong>  <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/u013309870/article/details/72975536">参考地址</a><ol>
<li>init 对非静态变量解析初始化</li>
<li>clinit 是 java.lang.class 类构造器对静态变量，静态代码块进行初始化</li>
</ol>
</li>
<li>类构造器方法（clinit）由编译器收集类中所有类变量的 <strong>显示赋值和静态代码块中的语句合并产生</strong></li>
</ul>
</li>
<li><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul>
<li>当初始化某个类时，如果其父类没有初始化，则先触发父类的初始化动作</li>
<li>JVM 保证一个类的初始化，在多线中中正确加锁和同步</li>
</ul>
</li>
</ol>
<h4 id="何时会或者不会触发类初始化动作呢？"><a href="#何时会或者不会触发类初始化动作呢？" class="headerlink" title="何时会或者不会触发类初始化动作呢？"></a>何时会或者不会触发类初始化动作呢？</h4><ol>
<li><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><ul>
<li>上面已经介绍，类的加载过程分为 3 步，大部分 3 步按顺序完成，有时也会只完成前两步</li>
</ul>
</li>
<li><h5 id="如何区分会不会触发类的初始化"><a href="#如何区分会不会触发类的初始化" class="headerlink" title="如何区分会不会触发类的初始化"></a>如何区分会不会触发类的初始化</h5><ul>
<li><p>如表</p>
<table>
<thead>
<tr>
<th>会触发类的初始化</th>
<th>不会触发类的初始化</th>
</tr>
</thead>
<tbody><tr>
<td>当虚拟机启动时，先初始化 <code>main()</code> 方法所在的类</td>
<td>引用静态常量不会触发此类的初始化</td>
</tr>
<tr>
<td>一次 <code>new</code> 一个类的对象（在 JVM 中一个类的 Class 对象只有一个）</td>
<td>当访问一个静态域时，只有真正声明该域的类才会被初始化（子类继承父类的静态变量，在子类使用该静态变量时，只有父类会初始化，子类不会初始化）</td>
</tr>
<tr>
<td>调用该类的静态变量（<code>static final</code> 除外，因为其在连接时已经显示初始化完成）和静态方法</td>
<td>通过数组定义类引用时，不会触发类初始化（<code>A[] as = new A[2]</code> A 是类，此时不会初始化 A类）</td>
</tr>
<tr>
<td>当初始化某个类时，其父类没有被初始化时，则会先初始化其父类</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h3 id="五、知道哪些类加载器。类加载器之间的关系？"><a href="#五、知道哪些类加载器。类加载器之间的关系？" class="headerlink" title="五、知道哪些类加载器。类加载器之间的关系？"></a>五、知道哪些类加载器。类加载器之间的关系？</h3><h4 id="一、三种类加载器"><a href="#一、三种类加载器" class="headerlink" title="一、三种类加载器"></a>一、三种类加载器</h4><p>当 JVM 启动的时候，Java 缺省开始使用如下三种类型的类加载器：</p>
<p><strong>启动（Bootstrap）类加载器</strong>：引导类加载器是用 本地代码实现的类加载器，它负责将 <JAVA_HOME>&#x2F;lib 下面的核心类库 或 -Xbootclasspath 选项指定的 jar 包等 虚拟机识别的类库 加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以 不允许直接通过引用进行操作。</p>
<p><strong>扩展（Extension）类加载器</strong>：扩展类加载器是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将 <JAVA_HOME>&#x2F;lib&#x2F;ext 或者由系统变量 - Djava.ext.dir 指定位置中的类库 加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
<p><strong>系统（System）类加载器</strong>：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将 用户类路径 (java -classpath 或 - Djava.class.path 变量所指的目录，即当前类所在路径及其引用的第三方类库的路径。开发者可以直接使用系统类加载器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/a3hwNw_20210607160522.png"></p>
<p>通过这两张图我们可以看出，扩展类加载器和系统类加载器均是继承自 java.lang.ClassLoader 抽象类。</p>
<h4 id="二、类加载器的关系"><a href="#二、类加载器的关系" class="headerlink" title="二、类加载器的关系"></a>二、类加载器的关系</h4><p>关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ap1Obm_20210607160540.png"></p>
<p>上面图片给人的直观印象是：系统类加载器的父类加载器是标准扩展类加载器，标准扩展类加载器的父类加载器是启动类加载器。</p>
<p>事实上，由于启动类加载器无法被 Java 程序直接引用，因此 JVM 默认直接使用 null 代表启动类加载器。</p>
<p>此外：</p>
<p>1．<strong>系统类加载器（AppClassLoader）调用 ClassLoader (ClassLoader parent) 构造函数将父类加载器设置为标准扩展类加载器 (ExtClassLoader)。</strong>（因为如果不强制设置，默认会通过调用 getSystemClassLoader () 方法获取并设置成系统类加载器。）</p>
<p>2．<strong>扩展类加载器（ExtClassLoader）调用 ClassLoader (ClassLoader parent) 构造函数将父类加载器设置为 null</strong>（null 本身就代表着引导类加载器）。（因为如果不强制设置，默认会通过调用 getSystemClassLoader () 方法获取并设置成系统类加载器，。）</p>
<h3 id="六、类加载器的双亲委派了解么？-结合-Tomcat-说一下双亲委派（Tomcat-如何打破双亲委托机制？…）。"><a href="#六、类加载器的双亲委派了解么？-结合-Tomcat-说一下双亲委派（Tomcat-如何打破双亲委托机制？…）。" class="headerlink" title="六、类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。"></a>六、类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。</h3><p>这是我们研究Tomcat的第四篇文章，前三篇文章我们搭建了源码框架，了解了tomcat的大致的设计架构， 还写了一个简单的服务器。按照我们最初订的计划，今天，我们要开始研究tomcat的几个主要组件（组件太多，无法一一解析，解析几个核心），包括核心的类加载器，连接器和容器，还有生命周期，还有pipeline 和 valve。一个一个来，今天来研究类加载器。</p>
<p>我们分为4个部分来探讨:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 什么是类加载机制？</span><br><span class="line">2. 什么是双亲委任模型？</span><br><span class="line">3. 如何破坏双亲委任模型？</span><br><span class="line">4. Tomcat 的类加载器是怎么设计的？</span><br></pre></td></tr></table></figure>

<p>我想，在研究tomcat 类加载之前，我们复习一下或者说巩固一下java 默认的类加载器。楼主以前对类加载也是懵懵懂懂，借此机会，也好好复习一下。</p>
<p>楼主翻开了神书《深入理解Java虚拟机》第二版，p227, 关于类加载器的部分。请看：</p>
<h5 id="1-什么是类加载机制？"><a href="#1-什么是类加载机制？" class="headerlink" title="1. 什么是类加载机制？"></a>1. 什么是类加载机制？</h5><blockquote>
<p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p>
</blockquote>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以呗虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
</blockquote>
<blockquote>
<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p>
</blockquote>
<h6 id="类与类加载器的关系"><a href="#类与类加载器的关系" class="headerlink" title="类与类加载器的关系"></a>类与类加载器的关系</h6><blockquote>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由<strong>加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，<code>只有在这两个类是由同一个类加载器加载的前提下才有意义</code>，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p>
</blockquote>
<h5 id="2-什么是双亲委任模型"><a href="#2-什么是双亲委任模型" class="headerlink" title="2. 什么是双亲委任模型"></a>2. 什么是双亲委任模型</h5><ol>
<li>从Java虚拟机的角度来说，只存在两种不同类加载器：一种是**启动类加载器(Bootstrap ClassLoader)**，这个类加载器使用C++语言实现（只限HotSpot），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>.</li>
<li>从Java开发人员的角度来看，类加载还可以划分的更细致一些，绝大部分Java程序员都会使用以下3种系统提供的类加载器：<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME&#x2F;lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。</li>
<li>扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME&#x2F;lib&#x2F;ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 种的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</li>
</ol>
<p>这些类加载器之间的关系一般如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ZjCurq_20210607161016.png" alt="img"></p>
<p>图中各个类加载器之间的关系成为 <strong>类加载器的双亲委派模型（Parents Dlegation Mode）</strong>。双亲委派模型要求除了顶层的启动类加载器之外，<strong>其余的类加载器都应当由自己的父类加载器加载</strong>，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2 期间被引入并被广泛应用于之后的所有Java程序中，但他并不是个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h6 id="为什么要这么做呢？"><a href="#为什么要这么做呢？" class="headerlink" title="为什么要这么做呢？"></a><strong>为什么要这么做呢？</strong></h6><blockquote>
<p>如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，<strong>那系统将会出现多个不同的Object类</strong>， Java类型体系中最基础的行为就无法保证。应用程序也将会变得一片混乱。</p>
</blockquote>
<h6 id="双亲委任模型时如何实现的？"><a href="#双亲委任模型时如何实现的？" class="headerlink" title="双亲委任模型时如何实现的？"></a><strong>双亲委任模型时如何实现的？</strong></h6><blockquote>
<p>非常简单：所有的代码都在java.lang.ClassLoader中的loadClass方法之中，代码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/rL2L6J_20210607161108.png" alt="img"></p>
</blockquote>
<p>逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法， 如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass方法进行加载。</p>
<h5 id="3-如何破坏双亲委任模型？"><a href="#3-如何破坏双亲委任模型？" class="headerlink" title="3. 如何破坏双亲委任模型？"></a>3. 如何破坏双亲委任模型？</h5><p>刚刚我们说过，双亲委任模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型，但也有例外，到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。<br> <strong>第一次</strong>：在双亲委派模型出现之前—–即JDK1.2发布之前。<br> <strong>第二次</strong>：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，<strong>如果基础类调用会用户的代码</strong>怎么办呢？</p>
<p>这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。</p>
<p>嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，<strong>JDBC</strong>，JCE，JAXB，JBI等。</p>
<p><strong>第三次</strong>：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</p>
<p>书中还说到：</p>
<blockquote>
<p>Java 程序中基本有一个共识：OSGI对类加载器的使用时值得学习的，弄懂了OSGI的实现，就可以算是掌握了类加载器的精髓。</p>
</blockquote>
<p>牛逼啊！！！</p>
<p>现在，我们已经基本明白了Java默认的类加载的作用了原理，也知道双亲委派模型。说了这么多，差点把我们的tomcat给忘了，我们的题目是Tomcat 加载器为何违背双亲委派模型？下面就好好说说我们的tomcat的类加载器。</p>
<h5 id="4-Tomcat-的类加载器是怎么设计的？"><a href="#4-Tomcat-的类加载器是怎么设计的？" class="headerlink" title="4. Tomcat 的类加载器是怎么设计的？"></a>4. Tomcat 的类加载器是怎么设计的？</h5><p>首先，我们来问个问题：</p>
<h6 id="Tomcat-如果使用默认的类加载机制行不行？"><a href="#Tomcat-如果使用默认的类加载机制行不行？" class="headerlink" title="Tomcat 如果使用默认的类加载机制行不行？"></a>Tomcat 如果使用默认的类加载机制行不行？</h6><p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖<strong>同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。</li>
</ol>
<p>再看看我们的问题：Tomcat 如果使用默认的类加载机制行不行？<br> 答案是不行的。为什么？我们看，第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。第三个问题和第一个问题一样。我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改（楼主起的名字），jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<h5 id="Tomcat-如何实现自己独特的类加载机制？"><a href="#Tomcat-如何实现自己独特的类加载机制？" class="headerlink" title="Tomcat 如何实现自己独特的类加载机制？"></a>Tomcat 如何实现自己独特的类加载机制？</h5><p>所以，Tomcat 是怎么实现的呢？牛逼的Tomcat团队已经设计好了。我们看看他们的设计图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9Fh6Id_20210607161152.png" alt="img"></p>
<p>我们看到，前面3个类加载和默认的一致，CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，<strong>每一个Web应用程序</strong>对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<blockquote>
<p>CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。</p>
</blockquote>
<blockquote>
<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>
</blockquote>
<blockquote>
<p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</p>
</blockquote>
<p>好了，至此，我们已经知道了tomcat为什么要这么设计，以及是如何设计的，那么，tomcat 违背了java 推荐的双亲委派模型了吗？答案是：违背了。 我们前面说过：</p>
<blockquote>
<p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。</p>
</blockquote>
<p>很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p>
<h5 id="我们扩展出一个问题：如果tomcat-的-Common-ClassLoader-想加载-WebApp-ClassLoader-中的类，该怎么办？"><a href="#我们扩展出一个问题：如果tomcat-的-Common-ClassLoader-想加载-WebApp-ClassLoader-中的类，该怎么办？" class="headerlink" title="我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？"></a>我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？</h5><p>看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。牛逼吧。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>好了，终于，我们明白了Tomcat 为何违背双亲委派模型，也知道了tomcat的类加载器是如何设计的。顺便复习了一下 Java 默认的类加载器机制，也知道了如何破坏Java的类加载机制。这一次收获不小哦！！！ 嘿嘿。</p>
<h3 id="七、常见调优参数有哪些？"><a href="#七、常见调优参数有哪些？" class="headerlink" title="七、常见调优参数有哪些？"></a>七、常见调优参数有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：堆最大内存为 2g；</span><br><span class="line">-XX:NewRatio=<span class="number">4</span>：设置年轻的和老年代的内存比例为 <span class="number">1</span>:<span class="number">4</span>；</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>：设置新生代 Eden 和 Survivor 比例为 <span class="number">8</span>:<span class="number">2</span>；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure>

<h3 id="八、……"><a href="#八、……" class="headerlink" title="八、……"></a>八、……</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p><strong>学习了 MySQL 之后，务必确保自己掌握下面这些知识点：</strong></p>
<h3 id="一、MySQL-常用命令-："><a href="#一、MySQL-常用命令-：" class="headerlink" title="一、MySQL 常用命令 ："></a>一、MySQL 常用命令 ：</h3><h4 id="1、MySQL常用命令"><a href="#1、MySQL常用命令" class="headerlink" title="1、MySQL常用命令"></a>1、MySQL常用命令</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create database name; 创建数据库</span><br><span class="line">use databasename; 选择数据库</span><br><span class="line">drop database name 直接删除数据库，不提醒</span><br><span class="line">show tables; 显示表</span><br><span class="line">describe tablename; 表的详细描述</span><br><span class="line">select 中加上distinct去除重复字段</span><br><span class="line">mysqladmin drop databasename 删除数据库前，有提示。</span><br><span class="line">显示当前mysql版本和当前日期</span><br><span class="line">select <span class="title function_">version</span><span class="params">()</span>,current_date;</span><br></pre></td></tr></table></figure>

<h4 id="2、修改mysql中root的密码："><a href="#2、修改mysql中root的密码：" class="headerlink" title="2、修改mysql中root的密码："></a>2、修改mysql中root的密码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell&gt;mysql -u root -p</span><br><span class="line"> mysql&gt; update user set password=password(”xueok654123″) where user=’root’;</span><br><span class="line"> mysql&gt; flush privileges <span class="comment">//刷新数据库</span></span><br><span class="line"> mysql&gt;use dbname； 打开数据库：</span><br><span class="line"> mysql&gt;show databases; 显示所有数据库</span><br><span class="line"> mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后</span><br><span class="line"> mysql&gt;describe user; 显示表mysql数据库中user表的列信息）；</span><br></pre></td></tr></table></figure>

<h4 id="3、grant"><a href="#3、grant" class="headerlink" title="3、grant"></a>3、grant</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个</span><br><span class="line"> mysql&gt; grant all privileges on *.* to user<span class="meta">@localhost</span> identified by ’something’ with</span><br><span class="line"> 增加新用户</span><br><span class="line"> 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”</span><br><span class="line"> GRANT ALL PRIVILEGES ON *.* TO monty<span class="meta">@localhost</span> IDENTIFIED BY ’something’ WITH GRANT OPTION;</span><br><span class="line"> GRANT ALL PRIVILEGES ON *.* TO monty@”%” IDENTIFIED BY ’something’ WITH GRANT OPTION;</span><br><span class="line"> 删除授权：</span><br><span class="line"> mysql&gt; revoke all privileges on *.* from root@”%”;</span><br><span class="line"> mysql&gt; delete from user where user=”root” and host=”%”;</span><br><span class="line"> mysql&gt; flush privileges;</span><br><span class="line"> 创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb</span><br><span class="line"> mysql &gt;grant select, insert, update, delete, create,drop on fangchandb.* to custom@ [it363.com](https:<span class="comment">//link.jianshu.com?t=http://it363.com) identified by ‘ passwd’</span></span><br><span class="line"> 重命名表:</span><br><span class="line"> mysql &gt; alter table t1 rename t2;</span><br></pre></td></tr></table></figure>

<h4 id="4、mysqldump"><a href="#4、mysqldump" class="headerlink" title="4、mysqldump"></a>4、mysqldump</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">备份数据库</span><br><span class="line"> shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql</span><br><span class="line"> 恢复数据库</span><br><span class="line"> shell&gt; mysqladmin -h myhost -u root -p create dbname</span><br><span class="line"> shell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql</span><br><span class="line"> 如果只想卸出建表指令，则命令如下：</span><br><span class="line"> shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql</span><br><span class="line"> 如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：</span><br><span class="line"> shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql</span><br><span class="line"> 那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？</span><br><span class="line"> 　 mysqldump -T./ phptest driver</span><br><span class="line"> 其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver 表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。</span><br></pre></td></tr></table></figure>

<h4 id="5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。"><a href="#5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。" class="headerlink" title="5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。"></a>5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，如果在文件my_file.sql 中存放有查</span><br><span class="line"> 询，可如下执行这些查询：</span><br><span class="line"> 例如，如果您想将建表语句提前写在sql.txt中:</span><br><span class="line"> mysql &gt; mysql -h myhost -u root -p database &lt; sql.txt</span><br></pre></td></tr></table></figure>

<h3 id="二、MySQL-中常用的数据类型、字符集编码"><a href="#二、MySQL-中常用的数据类型、字符集编码" class="headerlink" title="二、MySQL 中常用的数据类型、字符集编码"></a>二、MySQL 中常用的数据类型、字符集编码</h3><p>MySQL 支持多种数据类型，主要有数值类型、日期&#x2F;时间类型和字符串类型。</p>
<ul>
<li>数值类型：包括整数类型 <code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>、浮点小数数据类型 <code>FLOAT</code>和 <code>DOUBLE</code>、定点小数类型 <code>DECIMAL</code>。</li>
<li>日期&#x2F;时间类型：<code>YEAR</code> 、<code>TIME</code>、 <code>DATE</code>、 <code>DATETIME</code> 和 <code>TIMESTAMP</code>。</li>
<li>字符串类型： <code>CHAR</code> 、<code>VARCHAR</code>、 <code>BINARY</code>、 <code>VARBINARY</code>、 <code>BLOB</code>、 <code>TEXT</code>、 <code>ENUM</code>、 <code>SET</code> 。</li>
</ul>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中的整数型数据类型：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th align="center">存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td align="center">2个字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td align="center">3个字节</td>
</tr>
<tr>
<td>INT(INTEGER)</td>
<td align="center">4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td align="center">8个字节</td>
</tr>
</tbody></table>
<h4 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h4><table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901~2155</td>
<td>1个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59~838:59:59</td>
<td>3个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01~9999-12-3</td>
<td>3个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00~9999-12-31 23:59:59</td>
<td>8个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:01 UTC ~2038-01-19 03:14:07 UTC</td>
<td>4个字节</td>
</tr>
</tbody></table>
<p>在这里提一下** CURRENT_DATE 和 NOW() 的区别**：CURRENT_DATE 返回当前日期值，不包括时间部分，NOW() 函数返回日期和时间值。</p>
<p>提示：TIMESTAMP 和 DATATIME 除了存储字节和支持的范围不同外，还有一个最大的区别就是：DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；而 TIMESTAMP 值的存储是以 UTC （世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M字节，1&lt;&#x3D;M&lt;&#x3D; 255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，L&lt;&#x3D;M和1&lt;&#x3D;M&lt;&#x3D;255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此L&lt;2^32</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能存一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目（最大值65535）</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或多个 SET 成员</td>
<td>1、2、3、4或8个字节，取决于集合成员的数量（最多64个成员）</td>
</tr>
</tbody></table>
<h3 id="三、MySQL-简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……"><a href="#三、MySQL-简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……" class="headerlink" title="三、MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……"></a>三、MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……</h3><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607163257520_20210607163257.png" alt="image-20210607163257520"></p>
<h3 id="四、MySQL-中使用索引、视图、存储过程、游标、触发器"><a href="#四、MySQL-中使用索引、视图、存储过程、游标、触发器" class="headerlink" title="四、MySQL 中使用索引、视图、存储过程、游标、触发器"></a>四、MySQL 中使用索引、视图、存储过程、游标、触发器</h3><blockquote>
<p>1 索引<br> 2 触发器<br> 3 存储过程和函数<br> 4 视图<br> 5 基本的数据库建表语句练习</p>
</blockquote>
<h4 id="1-索引"><a href="#1-索引" class="headerlink" title="1 索引"></a>1 索引</h4><h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/buhuikanjian/article/details/52966039">https://blog.csdn.net/buhuikanjian/article/details/52966039</a></p>
<h5 id="（2）建立索引的原则"><a href="#（2）建立索引的原则" class="headerlink" title="（2）建立索引的原则"></a>（2）建立索引的原则</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspwebchh/p/6652855.html">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></p>
<h5 id="（3）具体操作语句"><a href="#（3）具体操作语句" class="headerlink" title="（3）具体操作语句"></a>（3）具体操作语句</h5><p>步骤1  创建表test_table1,添加三个索引</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test_table1(</span><br><span class="line"><span class="keyword">id</span> INT NOT <span class="literal">NULL</span>  PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">address CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">description CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">UNIQUE INDEX UniqIdx(<span class="keyword">id</span>),</span><br><span class="line">INDEX MultiColIdx(NAME(<span class="number">20</span>), address(<span class="number">30</span>)),</span><br><span class="line">INDEX ComIdx(description(<span class="number">30</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>步骤2  创建表test_table1,添加三个索引创建表test_table2，存储引擎为MyISAM</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">test_table2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">id         INT NOT <span class="literal">NULL</span>  PRIMARY KEY AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="params"><span class="function">firstname   CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">middlename CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">lastname   CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">birth      DATE NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">title       CHAR(<span class="number">100</span>) <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> ENGINE</span>=MYISAM;</span><br></pre></td></tr></table></figure>

<p>步骤3  创建表test_table1,添加三个索引使用ALTER TABLE语句在表test_table2的birth字段上，建立名称为ComDateIdx的普通索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALTER TABLE test_table2 ADD INDEX <span class="title">ComDateIdx</span><span class="params">(birth)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤4 创建表test_table1,添加三个索引使用ALTER TABLE语句在表test_table2的id字段上，添加名称为UniqIdx2的唯一索引，并以降序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALTER TABLE test_table2 ADD UNIQUE INDEX <span class="title">UniqIdx2</span> <span class="params">(id DESC)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤5  创建表test_table1,添加三个索引使用CREATE INDEX在firstname、middlename和lastname3个字段上建立名称为MultiColIdx2的组合索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE INDEX MultiColIdx2 ON <span class="title">test_table2</span><span class="params">(firstname, middlename, lastname)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤6 创建表test_table1,添加三个索引使用CREATE INDEX在title字段上建立名称为FTIdx的全文索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE FULLTEXT INDEX FTIdx ON <span class="title">test_table2</span><span class="params">(title)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤7 创建表test_table1,添加三个索引使用ALTER TABLE语句删除表test_table1中名称为UniqIdx的唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test_table1 DROP INDEX UniqIdx;</span><br></pre></td></tr></table></figure>

<p>步骤8 创建表test_table1,添加三个索引使用DROP INDEX语句删除表test_table2中名称为MultiColIdx2的组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX MultiColIdx2 ON test_table2;</span><br></pre></td></tr></table></figure>

<h4 id="2-触发器"><a href="#2-触发器" class="headerlink" title="2 触发器"></a>2 触发器</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Bfkva0_20210607165356.png" alt="img"></p>
<h5 id="（2）触发器使用"><a href="#（2）触发器使用" class="headerlink" title="（2）触发器使用"></a>（2）触发器使用</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yank/p/4193820.html">https://www.cnblogs.com/yank/p/4193820.html</a></p>
<h4 id="3-存储过程和函数"><a href="#3-存储过程和函数" class="headerlink" title="3 存储过程和函数"></a>3 存储过程和函数</h4><h5 id="（1）存储过程优缺点"><a href="#（1）存储过程优缺点" class="headerlink" title="（1）存储过程优缺点"></a>（1）存储过程优缺点</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jackmacro/article/details/5688687">https://blog.csdn.net/jackmacro/article/details/5688687</a></p>
<h5 id="（2）存储过程、函数、游标"><a href="#（2）存储过程、函数、游标" class="headerlink" title="（2）存储过程、函数、游标"></a>（2）存储过程、函数、游标</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/doudouxiaoye/p/5811836.html">https://www.cnblogs.com/doudouxiaoye/p/5811836.html</a><br> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jacketlin/p/7874009.html">https://www.cnblogs.com/jacketlin/p/7874009.html</a></p>
<h5 id="（3）代码详解"><a href="#（3）代码详解" class="headerlink" title="（3）代码详解"></a>（3）代码详解</h5><p>1 创建查看fruits表的存储过程，创建了一个查看fruits表的存储过程，每次调用这个存储过程的时候都会执行SELECT语句查看表的内容。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE Proc()</span><br><span class="line">     <span class="keyword">BEGIN</span></span><br><span class="line">        SELECT * FROM fruits;</span><br><span class="line">     <span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>

<p>2 创建名称为CountProc的存储过程，获取fruits表记录条数。COUNT(*) 计算后把结果放入参数param1中。<br> 当使用DELIMITER命令时，应该避免使用反斜杠（’\’）字符，因为反斜线是MySQL的转义字符。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE CountProc (OUT param1 INT)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">SELECT COUNT(*) INTO param1 FROM fruits;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>3 创建存储函数NameByZip，该函数返回SELECT语句的查询结果，数值类型为字符串型。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION <span class="title function_ invoke__">NameByZip</span> ()</span><br><span class="line">  RETURNS <span class="title function_ invoke__">CHAR</span>(<span class="number">50</span>)</span><br><span class="line">  <span class="title function_ invoke__">RETURN</span>  (SELECT s_name FROM suppliers WHERE s_call= <span class="string">&#x27;48075&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>4 定义名称为myparam的变量，类型为INT类型，默认值为100。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  myparam  INT  DEFAULT <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>5 声明3个变量，分别为var1、var2和var3，数据类型为INT，使用SET为变量赋值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE var1, var2, var3 INT;</span><br><span class="line">SET var1 = <span class="number">10</span>, var2 = <span class="number">20</span>;</span><br><span class="line">SET var3 = var1 + var2;</span><br></pre></td></tr></table></figure>

<p>MySQL中还可以通过SELECT … INTO为一个或多个变量赋值，语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_name<span class="selector-attr">[,...]</span> INTO var_name<span class="selector-attr">[,...]</span> table_expr;</span><br></pre></td></tr></table></figure>

<p>这个SELECT语法把选定的列直接存储到对应位置的变量。col_name表示字段名称；var_name表示定义的变量名称；table_expr表示查询条件表达式，包括表名称和WHERE子句。</p>
<p>6 声明变量fruitname和fruitprice，通过SELECT，INTO语句查询指定记录并为变量赋值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DECLARE fruitname <span class="title">CHAR</span>(<span class="params"><span class="number">50</span></span>)</span>;</span><br><span class="line"><span class="function">DECLARE fruitprice <span class="title">DECIMAL</span>(<span class="params"><span class="number">8</span>,<span class="number">2</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">SELECT f_name,f_price INTO fruitname, fruitprice</span><br><span class="line">FROM fruits WHERE f_id =<span class="string">&#x27;a1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>7 声明名称为cursor_fruit的光标</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_fruit CURSOR FOR SELECT f_name, f_price FROM fruits ;</span><br></pre></td></tr></table></figure>

<p>8 使用名称为cursor_fruit的光标。将查询出来的数据存入fruit_name和fruit_price这两个变量中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH  cursor_fruit INTO fruit_name, fruit_price ;</span><br></pre></td></tr></table></figure>

<p>9 IF语句的示例</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF val IS <span class="literal">NULL</span></span><br><span class="line">  THEN SELECT <span class="string">&#x27;val is NULL&#x27;</span>;</span><br><span class="line">  ELSE SELECT <span class="string">&#x27;val is not NULL&#x27;</span>;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<p>10 使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE val</span><br><span class="line">  WHEN <span class="number">1</span> THEN SELECT <span class="string">&#x27;val is 1&#x27;</span>;</span><br><span class="line">  WHEN <span class="number">2</span> THEN SELECT <span class="string">&#x27;val is 2&#x27;</span>;</span><br><span class="line">  ELSE SELECT <span class="string">&#x27;val is not 1 or 2&#x27;</span>;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<p>11 使用LOOP语句进行循环操作，id值小于等于10之前，将重复执行循环过程。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE <span class="keyword">id</span> INT DEFAULT <span class="number">0</span>;</span><br><span class="line">add_loop: LOOP  </span><br><span class="line">SET <span class="keyword">id</span> = <span class="keyword">id</span> + <span class="number">1</span>;</span><br><span class="line">  IF <span class="keyword">id</span> &gt;= <span class="number">10</span> THEN  LEAVE add_loop;</span><br><span class="line">  END IF;</span><br><span class="line">END LOOP add_ loop; </span><br></pre></td></tr></table></figure>

<p>12 使用LEAVE语句退出循环。循环执行count加1的操作。当count的值等于50时，使用LEAVE语句跳出循环。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_num: LOOP  </span><br><span class="line">SET @count=@count+<span class="number">1</span>;</span><br><span class="line">IF <span class="keyword">@count</span>=50 THEN LEAVE add_num ;</span><br><span class="line">END LOOP add_num ; </span><br></pre></td></tr></table></figure>

<p>13 ITERATE语句示例。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE doiterate()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DECLARE p1 INT DEFAULT <span class="number">0</span>;</span><br><span class="line"><span class="symbol">my_loop:</span> LOOP</span><br><span class="line">  SET p1= p1 + <span class="number">1</span>;</span><br><span class="line">  IF p1 &lt; <span class="number">10</span> THEN ITERATE my_loop;</span><br><span class="line">  ELSEIF p1 &gt; <span class="number">20</span> THEN LEAVE my_loop;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line">  SELECT <span class="string">&#x27;p1 is between 10 and 20&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> LOOP my_loop;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>14 REPEAT语句示例，id值小于等于10之前，将重复执行循环过程。<br> 该示例循环执行id加1的操作。当id值小于10时，循环重复执行；当id值大于或者等于10时，使用LEAVE语句退出循环。REPEAT循环都以END REPEAT结束。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE <span class="keyword">id</span> INT DEFAULT <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line">SET <span class="keyword">id</span> = <span class="keyword">id</span> + <span class="number">1</span>;</span><br><span class="line">UNTIL  <span class="keyword">id</span> &gt;= <span class="number">10</span></span><br><span class="line">END REPEAT; </span><br></pre></td></tr></table></figure>

<p>15 WHILE语句示例，id值小于等于10之前，将重复执行循环过程。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE i INT DEFAULT <span class="number">0</span>;</span><br><span class="line">WHILE i &lt; <span class="number">10</span> DO</span><br><span class="line">SET i = i + <span class="number">1</span>;</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>

<p>16 定义名为CountProc1的存储过程，然后调用这个存储过程。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE CountProc1 (IN sid INT, OUT <span class="built_in">num</span> INT)</span><br><span class="line">     BEGIN</span><br><span class="line">       SELECT COUNT(*) INTO <span class="built_in">num</span> FROM fruits WHERE s_id = sid;</span><br><span class="line">     END <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="4-视图"><a href="#4-视图" class="headerlink" title="4 视图"></a>4 视图</h4><h5 id="（1）视图的含义和作用"><a href="#（1）视图的含义和作用" class="headerlink" title="（1）视图的含义和作用"></a>（1）视图的含义和作用</h5><p>视图是数据库中的一个虚拟表。同真实的表一样，视图包含一系列的行和列数据。行和列数据来源于自由定义视图查询所引用的表，并且在引用视图是动态生成。</p>
<h5 id="（2）视图和表的联系、区别"><a href="#（2）视图和表的联系、区别" class="headerlink" title="（2）视图和表的联系、区别"></a>（2）视图和表的联系、区别</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607165527302_20210607165528.png" alt="img"></p>
<h5 id="（3）视图基本操作"><a href="#（3）视图基本操作" class="headerlink" title="（3）视图基本操作"></a>（3）视图基本操作</h5><p>步骤1：创建学生表stu，插入3条记录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">stu</span> </span></span><br><span class="line"><span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">s_id INT PRIMARY KEY,</span></span></span><br><span class="line"><span class="params"><span class="function">s_name VARCHAR(<span class="number">20</span></span>),</span></span><br><span class="line"><span class="function">addr <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>),</span></span><br><span class="line"><span class="function">tel <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>)</span></span><br><span class="line"><span class="function">)</span>; </span><br><span class="line"><span class="function">INSERT INTO stu </span></span><br><span class="line"><span class="function"><span class="title">VALUES</span>(<span class="params"><span class="number">1</span>,<span class="string">&#x27;XiaoWang&#x27;</span>,<span class="string">&#x27;Henan&#x27;</span>,<span class="string">&#x27;0371-12345678&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">2</span>,<span class="string">&#x27;XiaoLi&#x27;</span>,<span class="string">&#x27;Hebei&#x27;</span>,<span class="string">&#x27;13889072345&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">3</span>,<span class="string">&#x27;XiaoTian&#x27;</span>,<span class="string">&#x27;Henan&#x27;</span>,<span class="string">&#x27;0371-12345670&#x27;</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤2：创建报名表sign，插入3条记录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">sign</span> </span></span><br><span class="line"><span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">s_id INT PRIMARY KEY,</span></span></span><br><span class="line"><span class="params"><span class="function">s_name VARCHAR(<span class="number">20</span></span>),</span></span><br><span class="line"><span class="function">s_sch <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>),</span></span><br><span class="line"><span class="function">s_sign_sch <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>)</span></span><br><span class="line"><span class="function">)</span>; </span><br><span class="line"><span class="function">INSERT INTO sign </span></span><br><span class="line"><span class="function"><span class="title">VALUES</span>(<span class="params"><span class="number">1</span>,<span class="string">&#x27;XiaoWang&#x27;</span>,<span class="string">&#x27;Middle School1&#x27;</span>,<span class="string">&#x27;Peking University&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">2</span>,<span class="string">&#x27;XiaoLi&#x27;</span>,<span class="string">&#x27;Middle School2&#x27;</span>,<span class="string">&#x27;Tsinghua University&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">3</span>,<span class="string">&#x27;XiaoTian&#x27;</span>,<span class="string">&#x27;Middle School3&#x27;</span>,<span class="string">&#x27;Tsinghua University&#x27;</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建成绩表stu_mark，插入3条记录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">stu_mark</span> (<span class="params">s_id INT PRIMARY KEY ,s_name VARCHAR(<span class="number">20</span></span>) ,mark <span class="built_in">int</span> )</span>; </span><br><span class="line"><span class="function">INSERT INTO stu_mark <span class="title">VALUES</span>(<span class="params"><span class="number">1</span>,<span class="string">&#x27;XiaoWang&#x27;</span>,<span class="number">80</span></span>),(<span class="params"><span class="number">2</span>,<span class="string">&#x27;XiaoLi&#x27;</span>,<span class="number">71</span></span>),(<span class="params"><span class="number">3</span>,<span class="string">&#x27;XiaoTian&#x27;</span>,<span class="number">70</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤4：创建考上Peking University的学生的视图</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE VIEW <span class="title">beida</span> (<span class="params">id,name,mark,sch</span>)</span></span><br><span class="line"><span class="function">AS SELECT stu_mark.s_id,stu_mark.s_name,stu_mark.mark, sign.s_sign_sch</span></span><br><span class="line"><span class="function">FROM stu_mark ,sign</span></span><br><span class="line"><span class="function">WHERE stu_mark.s_id</span>=sign.s_id AND stu_mark.mark&gt;=<span class="number">41</span></span><br><span class="line">AND sign.s_sign_sch=<span class="string">&#x27;Peking University&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤5：创建考上qinghua University的学生的视图</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE VIEW <span class="title">qinghua</span> (<span class="params">id,name,mark,sch</span>) </span></span><br><span class="line"><span class="function">AS SELECT stu_mark.s_id, stu_mark.s_name, stu_mark.mark, sign.s_sign_sch </span></span><br><span class="line"><span class="function">FROM stu_mark ,sign</span></span><br><span class="line"><span class="function">WHERE stu_mark.s_id</span>=sign.s_id  AND stu_mark.mark&gt;=<span class="number">40</span> </span><br><span class="line">AND sign.s_sign_sch=<span class="string">&#x27;Tsinghua University&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤6：XiaoTian的成绩在录入的时候录入错误多录了50分，对其录入成绩进行更正。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu_mark SET mark = mark-50 WHERE stu_mark.s_name =<span class="string">&#x27;XiaoTian&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤7：查看更新过后视图和表的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu_mark;</span><br><span class="line">SELECT * FROM qinghua;</span><br><span class="line">SELECT * FROM beida;</span><br></pre></td></tr></table></figure>

<p>步骤8：查看视图的创建信息。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="selector-tag">FROM</span> information_schema<span class="selector-class">.views</span></span><br></pre></td></tr></table></figure>

<p>步骤9：删除创建的视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW beida;</span><br><span class="line">DROP VIEW qinghua;</span><br></pre></td></tr></table></figure>

<h4 id="5-基本的数据库建表语句练习（这个好像我真的是不会……）"><a href="#5-基本的数据库建表语句练习（这个好像我真的是不会……）" class="headerlink" title="5 基本的数据库建表语句练习（这个好像我真的是不会……）"></a>5 基本的数据库建表语句练习（这个好像我真的是不会……）</h4><blockquote>
<p>建立一个数据库，逻辑名称为Student，包含1个数据文件和1个日志文件。数据文件初始大小为10M</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">exists</span>(<span class="params"><span class="keyword">select</span> * <span class="keyword">from</span> sys.sysdatabases <span class="keyword">where</span> name=<span class="string">&#x27;Student&#x27;</span></span>)</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">use master</span></span><br><span class="line"><span class="function">drop database Student</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">go</span></span><br><span class="line"><span class="function">create database Student</span></span><br><span class="line"><span class="function"><span class="keyword">on</span></span></span><br><span class="line"><span class="function">--路径根据实际情况自行修改</span></span><br><span class="line"><span class="function">(<span class="params">name=N<span class="string">&#x27;Student&#x27;</span>,filename=N<span class="string">&#x27;E:\Student.mdf&#x27;</span>,size=<span class="number">10</span>mb,maxsize=unlimited,filegrowth=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">log <span class="title">on</span></span></span><br><span class="line"><span class="function">(<span class="params">name=N<span class="string">&#x27;Student&#x27;</span>,filename=N<span class="string">&#x27;E:\Student_log.ldf&#x27;</span>,size=<span class="number">10</span>mb,maxsize=unlimited,filegrowth=<span class="number">1</span></span>)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/accumulater/p/6158294.html">https://www.cnblogs.com/accumulater/p/6158294.html</a></p>
<blockquote>
<p>创建表，增加约束。包括：主键约束、非空约束、性别范围约束、出生日期约束、年龄约束、外键约束、唯一性约束、评论约束、默认关键词约束</p>
</blockquote>
<p>下面的语句可能不通顺，但是这些约束都有。check也可以使用enum代替。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="title function_ invoke__">tblstudent</span>(</span><br><span class="line">    stuID BIGINT PRIMARY KEY NOT <span class="literal">NULL</span>,</span><br><span class="line">    stuName <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">10</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">    stuSex <span class="title function_ invoke__">NCHAR</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;男&#x27;</span> <span class="title function_ invoke__">CHECK</span> (stuSex <span class="title function_ invoke__">IN</span> (<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">    stuBirth DATETIME <span class="title function_ invoke__">CHECK</span> (stuBirth &lt; <span class="title function_ invoke__">getdate</span>()) COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">    stuNum <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">18</span>) UNIQUE</span><br><span class="line">    Math INT <span class="title function_ invoke__">CHECK</span>(Sage &gt; <span class="number">18</span> AND Sage &lt; <span class="number">30</span>) COMMENT <span class="string">&#x27;数学&#x27;</span></span><br><span class="line">    stuID BIGINT REFERENCES <span class="title function_ invoke__">tblstudent</span>(stuID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghost-xyx/p/3795679.html">https://www.cnblogs.com/ghost-xyx/p/3795679.html</a></p>
<blockquote>
<p>drop，alter，insert，update，delete</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leftwukaixing/article/details/44415875">https://blog.csdn.net/leftwukaixing/article/details/44415875</a></p>
<hr>
<p>这个东西属于基础知识，可能不需要深入了解，但是不知道一定会有问题。</p>
<p><strong>如果你想让自己更加了解 MySQL ，同时也是为了准备面试的话，下面这些知识点要格外注意：</strong></p>
<h3 id="一、索引：索引优缺点、B-树和-B-树、聚集索引与非聚集索引、覆盖索引"><a href="#一、索引：索引优缺点、B-树和-B-树、聚集索引与非聚集索引、覆盖索引" class="headerlink" title="一、索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引"></a>一、索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h4><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>为什么要用索引?索引的优缺点分析</p>
<h4 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h4><p><strong>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。</strong>  另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>索引的缺点</p>
<p><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</p>
<p><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</p>
<h4 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="B树和B+树区别"></a>B树和B+树区别</h4><p>B树的所有节点既存放 键(key) 也存放 数据(data);而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。</p>
<p>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
<p>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7xaotb_20210607165833.png" alt="img"></p>
<h4 id="Hash索引和-B-树索引优劣分析"><a href="#Hash索引和-B-树索引优劣分析" class="headerlink" title="Hash索引和 B+树索引优劣分析"></a>Hash索引和 B+树索引优劣分析</h4><p><strong>Hash索引定位快</strong></p>
<p>Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。</p>
<p><strong>Hash冲突问题</strong></p>
<p>知道HashMap或HashTable的同学，相信都知道它们最大的缺点就是Hash冲突了。不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询是它最大的缺点。</strong></p>
<p>试想一种情况:</p>
<p>SELECT * FROM tb1 WHERE id &lt; 500;</p>
<p>B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。而Hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗?这就是Hash最大的缺点了。</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li><h5 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h5></li>
</ul>
<p><strong>数据表的主键列使用的就是主键索引。</strong></p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</strong></p>
<p><strong>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</strong></p>
<ul>
<li><h5 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h5></li>
</ul>
<p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p><strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>
<p><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p>
<p><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></p>
<p><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</p>
<p><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</p>
<p>二级索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lOhKAX_20210607170015.png" alt="img"></p>
<h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><ul>
<li><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5></li>
</ul>
<p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p>聚集索引的优点</p>
<p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p>聚集索引的缺点</p>
<p><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</p>
<p><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</p>
<ul>
<li><h5 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h5></li>
</ul>
<p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<p>MYISAM引擎的表的.MYI文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
<p>非聚集索引的优点</p>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p>非聚集索引的缺点</p>
<p>跟聚集索引一样，非聚集索引也依赖于有序的数据</p>
<p><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p>
<p>这是Mysql的表的文件截图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/JhKeja_20210607170103.png" alt="img"></p>
<p>聚集索引和非聚集索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/SZAydC_20210607170114.png" alt="img"></p>
<p>非聚集索引一定回表查询吗(覆盖索引)?</p>
<p><strong>非聚集索引不一定回表查询。</strong></p>
<p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p>
<p> SELECT name FROM table WHERE username&#x3D;’guang19’;</p>
<p>那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。</p>
<p><strong>即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</strong></p>
<p>SELECT id FROM table WHERE id&#x3D;1;</p>
<p>主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p>
<p>覆盖索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FQSLlU_20210607170146.png" alt="img"></p>
<h5 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h5><ul>
<li>单列索引</li>
</ul>
<p>单列索引即由一列属性组成的索引。</p>
<p>联合索引(多列索引)</p>
<p>联合索引即由多列属性组成索引。</p>
<ul>
<li>最左前缀原则</li>
</ul>
<p>假设创建的联合索引由三个字段组成:</p>
<p>ALTER TABLE table ADD INDEX index_name (num,name,age)</p>
<p>那么当查询的条件有为:num &#x2F; (num AND name) &#x2F; (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<p>但可能由于版本原因(我的mysql版本为8.0.x),我创建的联合索引，相当于在联合索引的每个字段上都创建了相同的索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607170240035_20210607170240.png" alt="img"></p>
<p>无论是否符合最左前缀原则，每个字段的索引都生效:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607170253830_20210607170254.png" alt="img"></p>
<h4 id="索引创建注意点"><a href="#索引创建注意点" class="headerlink" title="索引创建注意点"></a>索引创建注意点</h4><ul>
<li><h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5></li>
</ul>
<p>虽然我目前的Mysql版本较高，好像不遵守最左前缀原则，索引也会生效。但是我们仍应遵守最左前缀原则，以免版本更迭带来的麻烦。</p>
<ul>
<li><h5 id="选择合适的字段"><a href="#选择合适的字段" class="headerlink" title="选择合适的字段"></a>选择合适的字段</h5></li>
</ul>
<p>1.不为NULL的字段</p>
<p>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p>
<p>2.被频繁查询的字段</p>
<p>我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p>3.被作为条件查询的字段</p>
<p>被作为WHERE条件查询的字段，应该被考虑建立索引。</p>
<p>4.被经常频繁用于连接的字段</p>
<p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<ul>
<li><h5 id="不合适创建索引的字段"><a href="#不合适创建索引的字段" class="headerlink" title="不合适创建索引的字段"></a>不合适创建索引的字段</h5></li>
</ul>
<p>1.被频繁更新的字段应该慎重建立索引</p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p>2.不被经常查询的字段没有必要建立索引</p>
<p>3.尽可能的考虑建立联合索引而不是单列索引</p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p>4.注意避免冗余索引</p>
<p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<p>使用索引一定能提高查询性能吗?</p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h3 id="二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别"><a href="#二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别" class="headerlink" title="二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别"></a>二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别</h3><p>事务具有四大特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称为事务的ACID特性。</p>
<h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。</p>
<ul>
<li>全部成功执行</li>
<li>全部不执行</li>
</ul>
<p>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤消并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>
<h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。因此当事务全部成功提交时，就能说数据库处于一致性状态，如果数据库运行过程中出现故障，导致有些事务尚未完成就被迫中断，这些未完成的事务中的部分操作已经写入的物理数据库，这时数据库就处于一种不一致的状态。</p>
<h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p>隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其它事务干扰。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>在标准的SQL规范中，定义了四个事务隔离级别，不同的隔离级别对事务的处理不同</p>
<ul>
<li><strong>未授权读取</strong><br> 也称读未提交（Read Uncommitted），该隔离级别允许脏读，隔离级别最低。</li>
</ul>
<p>什么是脏读？</p>
<p>如果一个事务正在处理某一数据，对其进行了更新，但尚未提交事务，与此同时，另一个事务能够访问该事务更新后的数据。也就是说，事务的中间状态对其它事务是可见的。</p>
<p>举例说明：<br> 用户A原工资为1000元<br> 第一步：事务1执行修改操作，为用户A增加工资1000元，事务1尚未提交事务<br> 第二步：事务2执行读取操作，查询到用户A的工资为2000元。</p>
<p>事务2读取到了事务1中尚未提交的修改结果，但是事务1尚未提交，有可能会因为后续操作失败而产生回滚。</p>
<ul>
<li><strong>授权读取</strong><br> 也称读已提交（Read Committed），该隔离级别禁止脏读，允许不可重复读。</li>
</ul>
<p>什么是不可重复读？</p>
<p>一个事务过程中，对同一数据进行多次查询，查询的数据可能不一样，原因可能是两次查询过程中，另一个事务对该数据进行了修改并成功提交事务。也就是说，事务的结束状态对其它事务是可见的。</p>
<p>举例说明：<br> 用户A原工资为1000元<br> 第一步：事务1执行查询操作，查询到用户A的工资为1000元，事务1尚未提交事务。<br> 第二步：事务2执行修改操作，为用户A的增加工资1000元。<br> 第三步：事务1执行查询操作，查询到用户A的工资为2000元。</p>
<p>对于事务1来说，同一个事务里的多次查询，结果并不稳定。</p>
<ul>
<li><strong>可重复读取</strong><br> 可重复读取（Repeatable Read），该隔离级别禁止不可重复读和脏读，允许幻读。保证在事务处理过程中，多次读取同一数据，其值都和事务开始时刻是一致的。</li>
</ul>
<p>什么是幻读？</p>
<p>不可重复读针对的是数据的修改，而幻读针对的是数据的新增。</p>
<p>举例说明：<br> 用户表，用户名为唯一键<br> 第一步：事务1执行查询操作，查询是否存在用户名为<code>aaa</code>的数据，事务1尚未提交</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> user <span class="keyword">where</span> username = <span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第二步：事务2执行插入操作，插入用户名为<code>aaa</code>的数据<br> 第三步：事务1执行插入操作，插入用户为为<code>aaa</code>的数据，提示唯一键错误，插入失败。</p>
<p>对于事务一来说，查询用户<code>aaa</code>不存在，保存却报唯一键错误，如梦如幻，故名幻读。</p>
<ul>
<li><strong>串行化</strong><br> 串行化（Serializable）是最严格的事务隔离级别，它要求所有事务都被串行执行，即事务只能一个一个地进行处理，不能并发执行。</li>
</ul>
<blockquote>
<p>mysql 默认使用 Repeatable Read 级别，其它数据库大部分默认使用 Read Committed 级别</p>
</blockquote>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未授权读取</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>授权读取</td>
<td>不存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>可重复读取</td>
<td>不存在</td>
<td>不存在</td>
<td>存在</td>
</tr>
<tr>
<td>串行化</td>
<td>不存在</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody></table>
<h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p>持久性是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。也就是说，它对数据库所做的更新就必须被永久保存一下，即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p>
<h3 id="三、存储引擎（MyISAM-和-InnoDB）"><a href="#三、存储引擎（MyISAM-和-InnoDB）" class="headerlink" title="三、存储引擎（MyISAM 和 InnoDB）"></a>三、存储引擎（MyISAM 和 InnoDB）</h3><h4 id="1、MySQL默认存储引擎的变迁"><a href="#1、MySQL默认存储引擎的变迁" class="headerlink" title="1、MySQL默认存储引擎的变迁"></a><strong>1、MySQL默认存储引擎的变迁</strong></h4><p>在MySQL 5.1之前的版本中，默认的搜索引擎是MyISAM，从MySQL 5.5之后的版本中，默认的搜索引擎变更为InnoDB。</p>
<h4 id="2、MyISAM与InnoDB存储引擎的主要特点"><a href="#2、MyISAM与InnoDB存储引擎的主要特点" class="headerlink" title="2、MyISAM与InnoDB存储引擎的主要特点"></a><strong>2、MyISAM与InnoDB存储引擎的主要特点</strong></h4><p>MyISAM存储引擎的特点是：表级锁、不支持事务和全文索引，适合一些CMS内容管理系统作为后台数据库使用，但是使用大并发、重负荷生产系统上，表锁结构的特性就显得力不从心；</p>
<p>以下是MySQL 5.7 MyISAM存储引擎的版本特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/1rNi5X_20210607170801.png" alt="img"></p>
<p>InnoDB存储引擎的特点是：行级锁、事务安全（ACID兼容）、支持外键、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。InnoDB是为处理巨大量时拥有最大性能而设计的。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。</p>
<p>以下是MySQL 5.7 InnoDB存储引擎的版本特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/AigyQF_20210607170822.png" alt="img"></p>
<p>注意：</p>
<p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如<code>update table set num=1 where name like “a%”</code>。</p>
<p>两种类型最主要的差别就是InnoDB支持事务处理与外键和行级锁。而MyISAM不支持。所以MyISAM往往就容易被人认为只适合在小项目中使用。</p>
<h4 id="3、MyISAM与InnoDB性能测试"><a href="#3、MyISAM与InnoDB性能测试" class="headerlink" title="3、MyISAM与InnoDB性能测试"></a><strong>3、MyISAM与InnoDB性能测试</strong></h4><p>下边两张图是官方提供的MyISAM与InnoDB的压力测试结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9Adido_20210607170839.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/al7WB3_20210607170855.png" alt="img"></p>
<p>可以看出，随着CPU核数的增加，InnoDB的吞吐量反而越好，而MyISAM，其吞吐量几乎没有什么变化，显然，MyISAM的表锁定机制降低了读和写的吞吐量。</p>
<h4 id="4、事务支持与否"><a href="#4、事务支持与否" class="headerlink" title="4、事务支持与否"></a><strong>4、事务支持与否</strong></h4><p>MyISAM是一种非事务性的引擎，使得MyISAM引擎的MySQL可以提供高速存储和检索，以及全文搜索能力，适合数据仓库等查询频繁的应用；</p>
<p>InnoDB是事务安全的；</p>
<p>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p>
<h4 id="5、MyISAM与InnoDB构成上的区别"><a href="#5、MyISAM与InnoDB构成上的区别" class="headerlink" title="5、MyISAM与InnoDB构成上的区别"></a><strong>5、MyISAM与InnoDB构成上的区别</strong></h4><p>（1）每个MyISAM在磁盘上存储成三个文件：</p>
<blockquote>
<p>第一个文件的名字以表的名字开始，扩展名指出文件类型，.frm文件存储表定义。<br> 第二个文件是数据文件，其扩展名为.MYD (MYData)。<br> 第三个文件是索引文件，其扩展名是.MYI (MYIndex)。</p>
</blockquote>
<p>（2）基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的 大小只受限于操作系统文件的大小，一般为 2GB。</p>
<h4 id="6、MyISAM与InnoDB表锁和行锁的解释"><a href="#6、MyISAM与InnoDB表锁和行锁的解释" class="headerlink" title="6、MyISAM与InnoDB表锁和行锁的解释"></a><strong>6、MyISAM与InnoDB表锁和行锁的解释</strong></h4><p>MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。什么意思呢，就是说对MyISAM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；而对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。</p>
<p>InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁！行级锁在每次获取锁和释放锁的操作需要消耗比表锁更多的资源。在InnoDB两个事务发生死锁的时候，会计算出每个事务影响的行数，然后回滚行数少的那个事务。当锁定的场景中不涉及Innodb的时候，InnoDB是检测不到的。只能依靠锁定超时来解决。</p>
<h4 id="7、是否保存数据库表中表的具体行数"><a href="#7、是否保存数据库表中表的具体行数" class="headerlink" title="7、是否保存数据库表中表的具体行数"></a><strong>7、是否保存数据库表中表的具体行数</strong></h4><p>InnoDB 中不保存表的具体行数，也就是说，执行<code>select count(*) from table</code>时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。</p>
<p>注意的是，当<code>count(*)</code>语句包含<code>where</code>条件时，两种表的操作是一样的。也就是 上述“6”中介绍到的InnoDB使用表锁的一种情况。</p>
<h4 id="8、如何选择"><a href="#8、如何选择" class="headerlink" title="8、如何选择"></a><strong>8、如何选择</strong></h4><p>MyISAM适合：</p>
<ul>
<li>（1）做很多count 的计算；</li>
<li>（2）插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择；</li>
<li>（3）没有事务。</li>
</ul>
<p>InnoDB适合：</p>
<ul>
<li>（1）可靠性要求比较高，或者要求事务；</li>
<li>（2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建；</li>
<li>（3）如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表；</li>
<li>（4）DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除；</li>
<li>（5）LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。</li>
</ul>
<p>要注意，创建每个表格的代码是相同的，除了最后的 TYPE参数，这一参数用来指定数据引擎。</p>
<h4 id="其他区别："><a href="#其他区别：" class="headerlink" title="其他区别："></a><strong>其他区别：</strong></h4><p>1、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>2、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>3、LOAD TABLE FROMMASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>4、 InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</p>
<p>5、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p>
<p>6、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。</p>
<h3 id="四、锁机制与-InnoDB-锁算法"><a href="#四、锁机制与-InnoDB-锁算法" class="headerlink" title="四、锁机制与 InnoDB 锁算法"></a>四、锁机制与 InnoDB 锁算法</h3><h4 id="1、-锁分类（按粒度分）"><a href="#1、-锁分类（按粒度分）" class="headerlink" title="1、 锁分类（按粒度分）"></a>1、 锁分类（按粒度分）</h4><p><strong>解决并发、数据安全的问题，用锁。</strong></p>
<h5 id="1-表级锁"><a href="#1-表级锁" class="headerlink" title="(1)表级锁"></a><strong>(1)表级锁</strong></h5><p><strong>粒度最大</strong>，对整表加锁，实现简单 <strong>，资源消耗也比较少，加锁快，不会出现死锁</strong> 。其锁定<strong>粒度最大</strong>，触发锁冲突的概率最高，<strong>并发度最低</strong>，MyISAM和 InnoDB引擎都支持表级锁。</p>
<h5 id="2-行级锁"><a href="#2-行级锁" class="headerlink" title="(2)行级锁"></a><strong>(2)行级锁</strong></h5><p><strong>粒度最小</strong>。 <strong>减少数据库冲突。加锁粒度最小，并发度高，加锁开销最大，加锁慢，会出现死锁。</strong> InnoDB支持的行级锁：</p>
<p><strong>1)行锁 Record Lock:</strong> 对<strong>索引</strong>项<strong>加锁</strong>，锁定符合条件的行。其他事务不能修改和删除加锁项；</p>
<p><strong>2)间隙锁 Gap Lock:</strong> 对<strong>索引项之间</strong>的“<strong>间隙</strong>”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p>
<p><strong>3)行锁和间隙锁组合 Next-key Lock：</strong> 锁定<strong>索引项本身</strong>和<strong>索引范围</strong>。解决幻读问题。</p>
<p><strong>虽行级索粒度小、并发度高等特点，但表级锁有时候非常必要</strong>：</p>
<p>事务<strong>更新大表</strong>中的<strong>大部分数据</strong>直接使用表级锁<strong>效率更高</strong>；用行级索很可能引起<strong>死锁</strong>导致回滚。</p>
<h4 id="2、另外两个表级锁：IS和IX"><a href="#2、另外两个表级锁：IS和IX" class="headerlink" title="2、另外两个表级锁：IS和IX"></a><strong>2、另外两个表级锁：IS和IX</strong></h4><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而<strong>意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</strong></p>
<p><strong>InnoDB另外的两个表级锁：</strong></p>
<p><strong>意向共享锁（IS）：</strong> 事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p><strong>意向排他锁（IX）：</strong> 事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p><strong>注意：</strong></p>
<p><strong>这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干预。</strong></p>
<p><strong>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</strong></p>
<p><strong>InnoDB的锁机制兼容情况如下：</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/STIhyH_20210607171136.png" alt="img"></p>
<h4 id="3、死锁和避免死锁"><a href="#3、死锁和避免死锁" class="headerlink" title="3、死锁和避免死锁"></a>3、死锁和避免死锁</h4><p><strong>InnoDB的行级锁是基于索引实现的，</strong>如果查询语句为<strong>命中任何索引，用表级锁.</strong> 对索引加的锁，不针对数据记录，访问不同行记录，如用<strong>相同索引</strong>键仍锁<strong>冲突</strong>，</p>
<p>SELECT…LOCKINSHARE MODE 或 SELECT…FORUPDATE;</p>
<p><strong>用锁</strong>时，如<strong>没有</strong>定义<strong>索引</strong>，<strong>InnoDB****创建</strong>隐藏聚簇索引<strong>加记录锁</strong>。</p>
<p><strong>InnoDB锁逐步获得，两个事务都要获得对方持有的锁，都等待，产生死锁。</strong> 可<strong>检测到</strong>，并使一个事务<strong>释放锁回退</strong>，另一个<strong>获取锁完成事务</strong>，避免死锁：</p>
<p><strong>(1)表级锁来减少死锁</strong></p>
<p><strong>(2)多个程序尽量相同顺序访问表</strong>（解决并发理论中哲学家就餐问题一种思路）</p>
<p><strong>(3)同一个事务尽可能一次锁定所有资源。</strong></p>
<h4 id="4、总结与补充"><a href="#4、总结与补充" class="headerlink" title="4、总结与补充"></a>4、总结与补充</h4><p><strong>页级锁：</strong> 介于行级锁和表级锁中间。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级折衷，一次<strong>锁定相邻一组</strong>记录。BDB支持页级锁。<strong>开销和加锁时间</strong>界于表锁和行锁之间，会出现<strong>死锁</strong>。并发度一般。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><p>下面是我总结的一些关于并发的小问题，你可以拿来自测：</p>
<h3 id="一、Redis-和-Memcached-的区别和共同点"><a href="#一、Redis-和-Memcached-的区别和共同点" class="headerlink" title="一、Redis 和 Memcached 的区别和共同点"></a>一、Redis 和 Memcached 的区别和共同点</h3><h4 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h4><p>在大多数Web应用都将数据保存到关系型数据库中，WWW服务器从中读取数据并在浏览器中显示。但随着数据量的增大、访问的集中，就会出现关系型数据的负担加重、数据库响应缓慢、网站打开延迟等问题。</p>
<p>通过在内存中缓存数据库的查询结果，减少数据访问次数，以提高动态Web应用的速度，提高网站架构的并发能力和可扩展性</p>
<p>传统开发中用的数据库最多的就是MySQL了，随着数据量上千万或上亿级后，它的关系型数据库的读取速度可能并不能满足我们对数据的需求，所以内存式的缓存系统就出现了</p>
<h4 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h4><p>Memcache 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。</p>
<p>Memcache基于一个存储键&#x2F;值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcache协议与守护进程通信。</p>
<p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
<p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应用数据量不能大于硬件内存。</p>
<p>在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</p>
<p>同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
<h4 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h4><p>Redis与memcached有什么不同</p>
<p>什么是原子性,什么是原子性操作？</p>
<h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h4><p>Memcached</p>
<p>内部的数据存储，使用基于Slab的内存管理方式，有利于减少内存碎片和频繁分配销毁内存所带来的开销。各个Slab按需动态分配一个page的内存</p>
<p>（和4Kpage的概念不同，这里默认page为1M），page内部按照不同slab class的尺寸再划分为内存chunk供服务器存储KV键值对使用</p>
<p>Redis内部的数据结构最终也会落实到key-Value对应的形式，不过从暴露给用户的数据结构来看，</p>
<p>要比memcached丰富，除了标准的通常意义的键值对，Redis还支持List，Set， Hashes，Sorted Set等数据结构</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>Memcached的命令或者说通讯协议非常简单，Server所支持的命令基本就是对特定key的添加，删除，替换，原子更新，读取等，具体包括 Set, Get, Add, Replace, Append, Inc&#x2F;Dec 等等</p>
<p>Memcached的通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如telnet）和对性能要求更高的客户端的不同需求</p>
<p>Redis的命令在KV（String类型）上提供与Memcached类似的基本操作，在其它数据结构上也支持基本类似的操作（当然还有这些数据结构所特有的操作，如Set的union，List的pop等）而支持更多的数据结构，在一定程度上也就意味着更加广泛的应用场合</p>
<p>除了多种数据结构的支持，</p>
<p>Redis相比Memcached还提供了许多额外的特性，比如Subscribe&#x2F;publish命令，以支持发布&#x2F;订阅模式这样的通知机制等等，这些额外的特性同样有助于拓展它的应用场景Redis的客户端-服务器通讯协议完全采用文本格式（在将来可能的服务器间通讯会采用二进制格式）</p>
<h4 id="分布式实现："><a href="#分布式实现：" class="headerlink" title="分布式实现："></a>分布式实现：</h4><p>（1）memcached的分布式由客户端实现，通过一致性哈希算法来保证访问的缓存命中率；Redis的分布式由服务器端实现，通过服务端配置来实现分布式；</p>
<p>（2）事务性，memcached没有事务的概念，但是可以通过CAS协议来保证数据的完整性，一致性。Redis引入数据库中的事务概念来保证数据的完整性和一致性。</p>
<p>（3）简单性，memcached是纯KV缓存，协议简单，学习和使用成本比redis小很多</p>
<p>Memcached也不做数据的持久化工作，但是有许多基于memcached协议的项目实现了数据的持久化，例如memcacheDB使用BerkeleyDB进行数据存储，但本质上它已经不是一个Cache Server，而只是一个兼容Memcached的协议key-valueData Store了</p>
<p>Redis可以以master-slave的方式配置服务器，Slave节点对数据进行replica备份，Slave节点也可以充当Read only的节点分担数据读取的工作</p>
<p>Redis内建支持两种持久化方案，snapshot快照和AOF 增量Log方式。快照顾名思义就是隔一段时间将完整的数据Dump下来存储在文件中。AOF增量Log则是记录对数据的修改操作（实际上记录的就是每个对数据产生修改的命令本身）.</p>
<h3 id="二、为什么要用-Redis-x2F-为什么要用缓存？"><a href="#二、为什么要用-Redis-x2F-为什么要用缓存？" class="headerlink" title="二、为什么要用 Redis&#x2F;为什么要用缓存？"></a>二、为什么要用 Redis&#x2F;为什么要用缓存？</h3><p><strong>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</strong></p>
<p>下面我们主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QoQDu9_20210607171659.png" alt="img"></p>
<p><strong>高性能 ：</strong><br> 对照上面<br> 假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。<br> 这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。<br> 不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong><br> 一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。<br> <strong>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</strong><br> 所以，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发</p>
<h3 id="三、Redis-常见数据结构以及使用场景分析"><a href="#三、Redis-常见数据结构以及使用场景分析" class="headerlink" title="三、Redis 常见数据结构以及使用场景分析"></a>三、Redis 常见数据结构以及使用场景分析</h3><ul>
<li><em>string</em><br>1、介绍 ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。<br>2、常用命令: set,get,strlen,exists,dect,incr,setex 等等。<br>3、应用场景 ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。<br> 下面我们简单看看它的使用！</li>
</ul>
<p><strong>普通字符串的基本操作：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set key value #设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get key # 根据 key 获得对应的 value</span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists key  # 判断某个 key 是否存在</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; strlen key # 返回 key 所储存的字符串值的长度。</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del key # 删除某个 key 对应的值</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>批量设置 :</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset key1 value1 key2 value2 # 批量设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mget key1 key2 # 批量获取多个 key 对应的 value</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set number <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; incr number # 将 key 中储存的数字值增一</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; decr number # 将 key 中储存的数字值减一</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>过期：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire key  <span class="number">60</span> # 数据在 <span class="number">60s</span> 后过期</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; setex key <span class="number">60</span> value # 数据在 <span class="number">60s</span> 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) <span class="number">56</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>list</em><br> 1.介绍 ：list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br> 2.常用命令: rpush,lpop,lpush,rpop,lrange、llen 等。<br> 3.应用场景: 发布与订阅或者说消息队列、慢查询。<br> 下面我们简单看看它的使用</li>
</ul>
<p><strong>通过 rpush&#x2F;lpop 实现队列：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush myList value1 # 向 list 的头部（右边）添加元素</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush myList value2 value3 # 向list的头部（最右边）添加多个元素</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop myList # 将 list的尾部(最左边)元素取出</span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange myList <span class="number">0</span> <span class="number">1</span> # 查看对应下标的list列表， <span class="number">0</span> 为 start,<span class="number">1</span>为 end</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange myList <span class="number">0</span> -<span class="number">1</span> # 查看列表中的所有元素，-<span class="number">1</span>表示倒数第一</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>通过 rpush&#x2F;rpop 实现栈：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop myList2 # 将 list的头部(最右边)元素取出</span><br><span class="line"><span class="string">&quot;value3&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>我专门花了一个图方便小伙伴们来理解：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607172058285_20210607172058.png" alt="img"></p>
<p><strong>通过 lrange 查看对应下标范围的列表元素：</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> rpush myList value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> lrange myList <span class="number">0</span> <span class="number">1</span> <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> lrange myList <span class="number">0</span> -<span class="number">1</span> <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value3&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>通过 lrange 命令，你可以基于 list 实现分页查询，性能非常高！</strong></p>
<p><strong>通过 llen 查看链表长度：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen myList</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>hash</em></li>
</ul>
<ol>
<li>介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li>常用命令： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。</li>
<li>应用场景: 系统中对象数据的存储。<br> 下面我们简单看看它的使用！</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>Set</em><br> 1.介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。<br> 2.常用命令： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。<br> 3.应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景<br> 下面我们简单看看它的使用！</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scard mySet # 查看 set 的长度</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd mySet2 value2 value3</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers mySet3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>sorted set</em><br> 1.介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。<br> 2.常用命令： zadd,zcard,zscore,zrange,zrevrange,zrem 等。<br> 3.应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。<br> 下面我们简单看看它的使用！</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myZset <span class="number">3.0</span> value1 # 添加元素到 sorted set 中 <span class="number">3.0</span> 为权重</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myZset <span class="number">2.0</span> value2 <span class="number">1.0</span> value3 # 一次添加多个元素</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange  myZset <span class="number">0</span> -<span class="number">1</span> # 顺序输出某个范围区间的元素，<span class="number">0</span> -<span class="number">1</span> 表示输出所有元素</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange  myZset <span class="number">0</span> <span class="number">1</span> # 顺序输出某个范围区间的元素，<span class="number">0</span> 为 start  <span class="number">1</span> 为 stop</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrange  myZset <span class="number">0</span> <span class="number">1</span> # 逆序输出某个范围区间的元素，<span class="number">0</span> 为 start  <span class="number">1</span> 为 stop</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="四、Redis-没有使用多线程？为什么不使用多线程？Redis6-0-之后为何引入了多线程？"><a href="#四、Redis-没有使用多线程？为什么不使用多线程？Redis6-0-之后为何引入了多线程？" class="headerlink" title="四、Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？"></a>四、Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？</h3><p>Redis 6.0 新特性，多线程连环 13 问！</p>
<p>Redis 6.0 来了</p>
<p>—</p>
<p>在全国一片祥和IT民工欢度五一节假日的时候，Redis 6.0不声不响地于5 月 2 日正式发布了，吓得我赶紧从床上爬起来，学无止境！学无止境！</p>
<p>对于6.0版本，Redis之父Antirez在RC1版本发布时（2019-12-19）在他的博客上连续用了几个“EST”词语来评价：</p>
<p>the most “enterprise” Redis version to date &#x2F;&#x2F; 最”企业级”的</p>
<p>the largest release of Redis ever as far as I can tell &#x2F;&#x2F; 最大的</p>
<p>the one where the biggest amount of people participated &#x2F;&#x2F; 参与人数最多的</p>
<p>这个版本提供了诸多令人心动的新特性及功能改进，比如新网络协议RESP3，新的集群代理，ACL等，其中关注度最高的应该是“多线程”了，笔者也第一时间体验了一下，带着众多疑问，我们来一起开始“Redis 6.0 新特性-多线程连环13问”。</p>
<p>Redis 6.0 多线程连环13问</p>
<p>—</p>
<p><strong>1.Redis6.0之前的版本真的是单线程吗？</strong></p>
<p>Redis在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。</p>
<p>但如果严格来讲从Redis4.0之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。</p>
<p><strong>2.Redis6.0之前为什么一直不使用多线程？</strong></p>
<p>官方曾做过类似问题的回复：使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。</p>
<p>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p>
<p>Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。</p>
<p><strong>3.Redis6.0为什么要引入多线程呢？</strong></p>
<p>Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p>
<p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读&#x2F;写问题；数据偏斜，重新分配和放大&#x2F;缩小变得更加复杂等等。</p>
<p>从Redis自身角度来说，因为读写网络的read&#x2F;write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p>
<p> • 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</p>
<p> • 使用多线程充分利用多核，典型的实现比如 Memcached。</p>
<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：</p>
<p> • 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</p>
<p> • 多线程任务可以分摊 Redis 同步 IO 读写负荷</p>
<p><strong>4.Redis6.0默认是否开启了多线程？</strong></p>
<p>Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：io-threads-do-reads yes</p>
<p><strong>5.Redis6.0多线程开启时，线程数如何设置？</strong></p>
<p>开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件</p>
<p>关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。</p>
<p><strong>6.Redis6.0采用多线程后，性能的提升效果如何？</strong></p>
<p>Redis 作者 antirez 在 RedisConf 2019分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。国内也有大牛曾使用unstable版本在阿里云esc进行过测试，GET&#x2F;SET 命令在4线程 IO时性能相比单线程是几乎是翻倍了。</p>
<p><strong>测试环境：</strong></p>
<p>Redis Server: 阿里云 Ubuntu 18.04，8 CPU 2.5 GHZ, 8G 内存，主机型号 ecs.ic5.2xlarge</p>
<p>Redis Benchmark Client: 阿里云 Ubuntu 18.04，8 2.5 GHZ CPU, 8G 内存，主机型号 ecs.ic5.2xlarge</p>
<p><strong>测试结果：</strong></p>
<p><strong>说明1</strong>：这些性能验证的测试并没有针对严谨的延时控制和不同并发的场景进行压测。数据仅供验证参考而不能作为线上指标。</p>
<p><strong>说明2</strong>：如果开启多线程，至少要4核的机器，且Redis实例已经占用相当大的CPU耗时的时候才建议采用，否则使用多线程没有意义。所以估计80%的公司开发人员看看就好。</p>
<hr>
<p><strong>7.Redis6.0多线程的实现机制？</strong></p>
<hr>
<p><strong>流程简述如下：</strong></p>
<p>1、主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列</p>
<p>2、主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程</p>
<p>3、主线程阻塞等待 IO 线程读取 socket 完毕</p>
<p>4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行</p>
<p>5、主线程阻塞等待 IO 线程将数据回写 socket 完毕</p>
<p>6、解除绑定，清空等待队列</p>
<p><strong>该设计有如下特点：</strong></p>
<p>1、IO 线程要么同时在读 socket，要么同时在写，不会同时读或写</p>
<p>2、IO 线程只负责读写 socket 解析命令，不负责命令处理</p>
<p><strong>8.开启多线程后，是否会存在线程并发安全问题？</strong></p>
<p>从上面的实现机制可以看出，Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p>
<p><strong>9.Linux环境上如何安装Redis6.0.1（6.0的正式版是6.0.1）？</strong></p>
<p>这个和安装其他版本的redis没有任何区别，整个流程跑下来也没有任何的坑，所以这里就不做描述了。唯一要注意的就是配置多线程数一定要小于cpu的核心数，查看核心数量命令：</p>
<p>[<a href="mailto:&#114;&#111;&#111;&#116;&#64;&#x63;&#101;&#x6e;&#x74;&#111;&#x73;&#x37;&#46;&#x35;">&#114;&#111;&#111;&#116;&#64;&#x63;&#101;&#x6e;&#x74;&#111;&#x73;&#x37;&#46;&#x35;</a> ~]# lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 4On-line CPU(s) list: 0-3</p>
<p><strong>10.Redis6.0的多线程和Memcached多线程模型进行对比</strong></p>
<p>前些年memcached 是各大互联网公司常用的缓存方案，因此redis 和 memcached 的区别基本成了面试官缓存方面必问的面试题，最近几年memcached用的少了，基本都是 redis。</p>
<p>不过随着Redis6.0加入了多线程特性，类似的问题可能还会出现，接下来我们只针对多线程模型来简单比较一下。</p>
<p>如上图所示：Memcached 服务器采用 master-woker 模式进行工作，服务端采用 socket 与客户端通讯。主线程、工作线程 采用 pipe管道进行通讯。主线程采用 libevent 监听 listen、accept 的读事件，事件响应后将连接信息的数据结构封装起来，根据算法选择合适的工作线程，将连接任务携带连接信息分发出去，相应的线程利用连接描述符建立与客户端的socket连接 并进行后续的存取数据操作。</p>
<p>Redis6.0与Memcached多线程模型对比：</p>
<p>相同点：都采用了 master线程-worker 线程的模型</p>
<p>不同点：Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</p>
<p><strong>11.Redis作者是如何点评 “多线程”这个新特性的？</strong></p>
<p>关于多线程这个特性，在6.0 RC1时，Antirez曾做过说明：</p>
<p>Redis支持多线程有2种可行的方式：第一种就是像“memcached”那样，一个Redis实例开启多个线程，从而提升GET&#x2F;SET等简单命令中每秒可以执行的操作。这涉及到I&#x2F;O、命令解析等多线程处理，因此，我们将其称之为“I&#x2F;O threading”。另一种就是允许在不同的线程中执行较耗时较慢的命令，以确保其它客户端不被阻塞，我们将这种线程模型称为“Slow commands threading”。</p>
<p>经过深思熟虑，Redis不会采用“I&#x2F;O threading”，redis在运行时主要受制于网络和内存，所以提升redis性能主要是通过在多个redis实例，特别是redis集群。接下来我们主要会考虑改进两个方面：</p>
<p>\1. Redis集群的多个实例通过编排能够合理地使用本地实例的磁盘，避免同时重写AOF。</p>
<p>2.提供一个Redis集群代理，便于用户在没有较好的集群协议客户端时抽象出一个集群。</p>
<p>补充说明一下，Redis和memcached一样是一个内存系统，但不同于Memcached。多线程是复杂的，必须考虑使用简单的数据模型，执行LPUSH的线程需要服务其他执行LPOP的线程。</p>
<p>我真正期望的实际是“slow operations threading”，在redis6或redis7中，将提供“key-level locking”，使得线程可以完全获得对键的控制以处理缓慢的操作。</p>
<p><strong>12.Redis线程中经常提到IO多路复用，如何理解？</strong></p>
<p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p>
<p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h3 id="五、Redis-给缓存数据设置过期时间有啥用？"><a href="#五、Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="五、Redis 给缓存数据设置过期时间有啥用？"></a>五、Redis 给缓存数据设置过期时间有啥用？</h3><h3 id="六、Redis-是如何判断数据是否过期的呢？"><a href="#六、Redis-是如何判断数据是否过期的呢？" class="headerlink" title="六、Redis 是如何判断数据是否过期的呢？"></a>六、Redis 是如何判断数据是否过期的呢？</h3><h3 id="七、过期的数据的删除策略了解么？"><a href="#七、过期的数据的删除策略了解么？" class="headerlink" title="七、过期的数据的删除策略了解么？"></a>七、过期的数据的删除策略了解么？</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a><strong>定时删除</strong></h4><p>定时删除是指在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快的被删除，并释放过期键所占用的内存。</p>
<p>定时删除策略的缺点是，他对CPU时间是最不友好的：再过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件。而当前时间事件的实现方式—-无序链表，查找一个事件的时间复杂度为O(N)—-并不能高效地处理大量时间事件。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h4><p>惰性删除是指放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回该键。</p>
<p>惰性删除策略对CPU时间来说是最友好的，但对内存是最不友好的。如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么他们也许永远也不会被删除。</p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h4><p>定期删除是指每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。</p>
<p>定期删除策略是前两种策略的一种整合和折中:</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键带来的内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率：</p>
<ul>
<li>如果删除操作执行的太频繁或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多的消耗在删除过期键上面。</li>
<li>如果删除操作执行的太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li>
</ul>
<h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a><strong>Redis的过期键删除策略</strong></h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好的在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a><strong>定期删除策略的实现</strong></h4><p>过期键的定期删除策略由函数redis.c&#x2F;activeExpireCycle实现，每当Redis服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h3 id="八、Redis-内存淘汰机制了解么？"><a href="#八、Redis-内存淘汰机制了解么？" class="headerlink" title="八、Redis 内存淘汰机制了解么？"></a>八、Redis 内存淘汰机制了解么？</h3><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><p>内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？</p>
<p>Redis 提供了下面几种淘汰策略供用户选择，其中默认的策略为 <code>noeviction</code> 策略：</p>
<ul>
<li>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错</li>
<li>allkeys-lru：在主键空间中，优先移除最近未使用的key</li>
<li>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的 key</li>
<li>allkeys-random：在主键空间中，随机移除某个 key</li>
<li>volatile-random：在设置了过期时间的键空间中，随机移除某个 key</li>
<li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除</li>
</ul>
<p>这里补充一下主键空间和设置了过期时间的键空间，举个例子，假设我们有一批键存储在Redis中，则有那么一个哈希表用于存储这批键及其值，如果这批键中有一部分设置了过期时间，那么这批键还会被存储到另外一个哈希表中，这个哈希表中的值对应的是键被设置的过期时间。设置了过期时间的键空间为主键空间的子集。</p>
<h4 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h4><p>我们了解了 Redis 大概提供了这么几种淘汰策略，那么如何选择呢？淘汰策略的选择可以通过下面的配置指定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure>

<p>但是这个值填什么呢？为解决这个问题，我们需要了解我们的应用请求对于 Redis 中存储的数据集的访问方式以及我们的诉求是什么。同时 Redis 也支持 Runtime 修改淘汰策略，这使得我们不需要重启 Redis 实例而实时的调整内存淘汰策略。</p>
<p>下面看看几种策略的适用场景：</p>
<ul>
<li>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略</li>
<li>allkeys-random：如果我们的应用对于缓存 key 的访问概率相等，则可以使用这个策略</li>
<li>volatile-ttl：这种策略使得我们可以向 Redis 提示哪些 key 更适合被 eviction</li>
</ul>
<p>另外，<code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</p>
<h4 id="非精准的-LRU"><a href="#非精准的-LRU" class="headerlink" title="非精准的 LRU"></a>非精准的 LRU</h4><p>上面提到的 LRU（Least Recently Used）策略，实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的，这里涉及到一个权衡的问题，如果需要在全部键空间内搜索最优解，则必然会增加系统的开销，Redis 是单线程的，也就是同一个实例在每一个时刻只能服务于一个客户端，所以耗时的操作一定要谨慎。为了在一定成本内实现相对的 LRU，早期的 Redis 版本是基于采样的 LRU，也就是放弃全部键空间内搜索解改为采样空间搜索最优解。自从 Redis3.0 版本之后，Redis 作者对于基于采样的 LRU 进行了一些优化，目的是在一定的成本内让结果更靠近真实的 LRU。</p>
<h3 id="九、Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#九、Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="九、Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>九、Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h3><p>Redis是常用的基于内存的缓存服务，能为我们缓存数据减少数据库访问从而提升性能，也能作为NoSQL数据库存储数据或借助有序队列做排队系统等。当仅作为数据缓存用时，Redis服务的可用性要求没那么高， 毕竟挂了还能从数据库获取， 但如果作为数据库或队列使用时，Redis挂了可能会影响到业务。本文整理了Redis的持久化方案，使用它们来对Redis的内存数据进行持久化，保障数据的安全性。</p>
<p>Redis支持RDB与AOF两种持久化机制，持久化可以避免因进程异常退出或down机导致的数据丢失问题，在下次重启时能利用之前的持久化文件实现数据恢复。</p>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a><strong>RDB持久化</strong></h4><p>RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。RDB持久化的触发包括手动触发与自动触发两种方式。</p>
<h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a><strong>手动触发</strong></h5><ol>
<li>save， 在命令行执行save命令，将以同步的方式创建rdb文件保存快照，会阻塞服务器的主进程，生产环境中不要用</li>
<li>bgsave, 在命令行执行bgsave命令，将通过fork一个子进程以异步的方式创建rdb文件保存快照，除了fork时有阻塞，子进程在创建rdb文件时，主进程可继续处理请求</li>
</ol>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a><strong>自动触发</strong></h5><ol>
<li>在redis.conf中配置 <code>save m n</code> 定时触发，如 <code>save 900 1</code>表示在900s内至少存在一次更新就触发</li>
<li>主从复制时，如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li>
<li>执行debug reload命令重新加载Redis时</li>
<li>执行shutdown且没有开启AOF持久化</li>
</ol>
<p>redis.conf中RDB持久化配置</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 只要满足下列条件之一，则会执行bgsave命令</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="meta"># 在900s内存在至少一次写操作</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># 禁用RBD持久化，可在最后加 save &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当备份进程出错时主进程是否停止写入操作</span></span><br><span class="line">stop-writes-<span class="keyword">on</span>-bgsave-error yes</span><br><span class="line"><span class="meta"># 是否压缩rdb文件 推荐no 相对于硬盘成本cpu资源更贵</span></span><br><span class="line">rdbcompression no</span><br></pre></td></tr></table></figure>

<h5 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a><strong>AOF持久化</strong></h5><p>AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，就可以通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。</p>
<p>redis.conf中AOF持久化配置如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认关闭AOF，若要开启将no改为yes</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># append文件的名字</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔一秒将缓存区内容写入文件 默认开启的写入方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当AOF文件大小大于该配置项时自动开启重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>AOF持久化的实现包括3个步骤:</p>
<ol>
<li>命令追加：将命令追加到AOF缓冲区</li>
<li>文件写入：缓冲区内容写到AOF文件</li>
<li>文件保存：AOF文件保存到磁盘</li>
</ol>
<p>其中后两步的频率通过appendfsync来配置，appendfsync的选项包括</p>
<ul>
<li>always， 每执行一个命令就保存一次，安全性最高，最多只丢失一个命令的数据，但是性能也最低（频繁的磁盘IO）</li>
<li>everysec，每一秒保存一次，推荐使用，在安全性与性能之间折中，最多丢失一秒的数据</li>
<li>no， 依赖操作系统来执行（一般大概30s一次的样子），安全性最低，性能最高，丢失操作系统最后一次对AOF文件触发SAVE操作之后的数据</li>
</ul>
<p>AOF通过保存命令来持久化，随着时间的推移，AOF文件会越来越大，Redis通过AOF文件重写来解决AOF文件不断增大的问题（可以减少文件的磁盘占有量，加快数据恢复的速度），原理如下：</p>
<ol>
<li>调用fork，创建一个子进程</li>
<li>子进程读取当前数据库的状态来“重写”一个新的AOF文件（这里虽然叫“重写”，但实际并没有对旧文件进行任何读取，而是根据数据库的当前状态来形成指令）</li>
<li>主进程持续将新的变动同时写到AOF重写缓冲区与原来的AOF缓冲区中</li>
<li>主进程获取到子进程重写AOF完成的信号，调用信号处理函数将AOF重写缓冲区内容写入新的AOF文件中，并对新文件进行重命名，原子地覆盖原有AOF文件，完成新旧文件的替换</li>
</ol>
<p>AOF的重写也分为手动触发与自动触发</p>
<ul>
<li>手动触发：直接调用bgrewriteaof命令</li>
<li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。其中auto-aof-rewrite-min-size表示运行AOF重写时文件最小体积，默认为64MB。auto-aof-rewrite-percentage表示当前AOF文件大小（aof_current_size）和上一次重写后AOF文件大小（aof_base_size）的比值。自动触发时机为 aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp;（aof_current_size - aof_base_size）&#x2F;aof_base_size&gt; &#x3D; auto-aof-rewrite-percentage</li>
</ul>
<h5 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a><strong>RDB vs AOF</strong></h5><p>RDB与AOF两种方式各有优缺点。</p>
<p>RDB的优点：与AOF相比，RDB文件相对较小，恢复数据比较快（原因见数据恢复部分）<br> RDB的缺点：服务器宕机，RBD方式会丢失掉上一次RDB持久化后的数据；使用bgsave fork子进程时会耗费内存。</p>
<p>AOF的优点：AOF只是追加文件，对服务器性能影响较小，速度比RDB快，消耗内存也少，同时可读性高。<br> AOF的缺点：生成的文件相对较大，即使通过AOF重写，仍然会比较大；恢复数据的速度比RDB慢。</p>
<h5 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a><strong>数据库的恢复</strong></h5><p>服务器启动时，如果没有开启AOF持久化功能，则会自动载入RDB文件，期间会阻塞主进程。如果开启了AOF持久化功能，服务器则会优先使用AOF文件来还原数据库状态，因为AOF文件的更新频率通常比RDB文件的更新频率高，保存的数据更完整。</p>
<p>redis数据库恢复的处理流程如下，</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/qJZdWt_20210607200126.png" alt="img"></p>
<p>在数据恢复方面，RDB的启动时间会更短，原因有两个：</p>
<ol>
<li>RDB 文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了，文件相对较小。</li>
<li>RDB 文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。</li>
</ol>
<p>但是在进行RDB持久化时，fork出来进行dump操作的子进程会占用与父进程一样的内存，采用的copy-on-write机制，对性能的影响和内存的消耗都是比较大的。比如16G内存，Redis已经使用了10G，这时save的话会再生成10G，变成20G，大于系统的16G。这时候会发生交换，要是虚拟内存不够则会崩溃，导致数据丢失。所以在用redis的时候一定对系统内存做好容量规划。</p>
<h4 id="RDB、AOF混合持久化"><a href="#RDB、AOF混合持久化" class="headerlink" title="RDB、AOF混合持久化"></a><strong>RDB、AOF混合持久化</strong></h4><p>Redis从4.0版开始支持RDB与AOF的混合持久化方案。首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。</p>
<p>开启混合持久化</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-<span class="keyword">use</span>-<span class="title">rdb</span>-<span class="title">preamble</span> <span class="title">yes</span></span><br></pre></td></tr></table></figure>

<p>数据恢复加载过程就是先按照RDB进行加载，然后把AOF命令追加写入。</p>
<h4 id="持久化方案的建议"><a href="#持久化方案的建议" class="headerlink" title="持久化方案的建议"></a><strong>持久化方案的建议</strong></h4><ol>
<li>如果Redis只是用来做缓存服务器，比如数据库查询数据后缓存，那可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。</li>
<li>如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。如果你可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。</li>
<li>通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。</li>
</ol>
<h3 id="十、Redis-缓存穿透、缓存雪崩？"><a href="#十、Redis-缓存穿透、缓存雪崩？" class="headerlink" title="十、Redis 缓存穿透、缓存雪崩？"></a>十、Redis 缓存穿透、缓存雪崩？</h3><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h4><p>通过某个key比如A进行查询时，每次都不能从缓存中获取到数据，因此每次都是访问数据库进行查询（数据库中也没有）。</p>
<p><strong>解决方案</strong><br> 当key值A从数据库未查询到数据时，在缓存中将A的值设为空并设置过期时间。</p>
<h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h4><p>某个热点key A在高并发的请求的情况下，缓存失效的瞬间，大量请求击穿缓存访问数据库。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>1.业务允许的情况下，热点数据不过期；</li>
<li>2.构建互斥锁，在第一个请求创建完成缓存后再释放锁，从而其他请求可以通过key访问缓存；</li>
</ul>
<h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h4><p>雪崩是指缓存中大量数据过期导致系统涌入大量查询请求时，因大部分数据在Redis层已经失效，请求渗透到数据库层，大批量请求引起数据库压力造成查询堵塞甚至宕机。</p>
<p><strong>代码层面，设置数据过期时间：</strong></p>
<ul>
<li>1.数据失效时间分散，不要在同一个时间大量缓存数据失效；</li>
<li>2.业务允许的情况下，数据不失效；</li>
</ul>
<p><strong>架构层面：</strong></p>
<ul>
<li>1.redis高可用，Redis Cluster，主从同步，避免redis全盘奔溃；</li>
<li>2.缓存分级，ehcache + redis + mysql模式，本地内存中无数据再从redis中查找；再者，MySQL实现限流和降级，避免宕机。</li>
<li>3.redis必须要持久化，重启后从磁盘加载数据，快速恢复缓存数据；</li>
</ul>
<h3 id="十一、如何保证缓存和数据库数据的一致性？"><a href="#十一、如何保证缓存和数据库数据的一致性？" class="headerlink" title="十一、如何保证缓存和数据库数据的一致性？"></a>十一、如何保证缓存和数据库数据的一致性？</h3><p>看到好些人在写更新缓存数据代码时，<strong>先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中</strong>。然而，这个是逻辑是错误的。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
<p>这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。</p>
<p>这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。</p>
<p>更新缓存的的Design Pattern有四种：</p>
<ul>
<li>Cache aside （旁路缓存 ）</li>
<li>Read through</li>
<li>Write through</li>
<li>Write behind caching</li>
</ul>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li><strong>失效：</strong>应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中：</strong>应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新：</strong>先把数据存到数据库中，成功后，<strong>再让缓存失效</strong>。</li>
</ul>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。</p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<p>这是标准的design pattern，包括Facebook的论文《<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">Scaling Memcache at Facebook</a>》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p><strong>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</strong></p>
<h4 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h4><p>我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read&#x2F;Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。<strong>可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</strong></p>
<h5 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h5><p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<h5 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h5><p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）<br> 下图自来Wikipedia的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Cache_(computing)">Cache词条</a>。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5yRk3U_20210607200416.png" alt="img"></p>
<h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>Write Behind 又叫 Write Back。<strong>一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。</strong>所以，基础很重要，我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I&#x2F;O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix&#x2F;Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/gV226v_20210607200455.png" alt="img"></p>
<h4 id="再多唠叨一些"><a href="#再多唠叨一些" class="headerlink" title="再多唠叨一些"></a>再多唠叨一些</h4><p>1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache&#x2F;redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。<strong>基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略</strong>，所以这也就是，工程学上所谓的Best Practice，遵从就好了。</p>
<p>2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I&#x2F;O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以，<strong>请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。</strong></p>
<p>3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，<strong>看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子</strong>。千万不要似是而非地，想当然的做软件设计。</p>
<p>4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit&#x2F;rollback，比如Java 7 的XAResource，还有MySQL 5.7的 XA Transaction，有些cache也支持XA，比如EhCache。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://coolshell.cn/articles/10910.html">分布式系统的事务处理</a>》一文。</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><p>非常重要！非常重要！特别是 Git 和 Docker。</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h3><p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p>
<p>Docker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：</p>
<ol>
<li>一致的运行环境，能够更轻松地迁移</li>
<li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源</li>
<li>可以通过镜像复制多个一致的容器</li>
</ol>
<p>Docker 常见概念解读，可以看这篇 Github 上开源的这篇<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker">《Docker 基本概念解读》</a> ，从零到上手实战可以看<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98">《Docker 从入门到上手干事》</a>这篇文章，内容非常详细！</p>
<p>另外，再给大家推荐一本质量非常高的开源书籍<a href="https://link.zhihu.com/?target=https://yeasy.gitbook.io/docker_practice/introduction/why">《Docker 从入门到实践》</a> ，这本书的内容非常新，毕竟书籍的内容是开源的，可以随时改进。</p>
<p><img src="https://pic1.zhimg.com/50/v2-f5d0bf0587f742c9a65f985e7fc12f93_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-f5d0bf0587f742c9a65f985e7fc12f93_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a><strong>常用框架</strong></h2><p><a href="https://link.zhihu.com/?target=https://t.1yb.co/mBsy">2021 最新Java实战项目源码打包下载t.1yb.co<img src="https://pic2.zhimg.com/v2-5c70f2d4123edf16afab8b4bed070b4d_180x120.jpg" alt="图标"></a></p>
<h2 id="Spring-x2F-SpringBoot"><a href="#Spring-x2F-SpringBoot" class="headerlink" title="Spring&#x2F;SpringBoot"></a><strong>Spring&#x2F;SpringBoot</strong></h2><p><strong>Spring 和 SpringBoot 真的很重要！</strong></p>
<p>一定要搞懂 AOP 和 IOC 这两个概念。Spring 中 bean 的作用域与生命周期、SpringMVC 工作原理详解等等知识点都是非常重要的，一定要搞懂。</p>
<p>企业中做 Java 后端，你一定离不开 SpringBoot ，这个是必备的技能了！一定一定一定要学好！</p>
<p>像 SpringBoot 和一些常见技术的整合你也要知识怎么做，比如 SpringBoot 整合 MyBatis、 ElasticSearch、SpringSecurity、Redis 等等。</p>
<p>学习 Spring 的话，可以多看看 **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-framework%23learn">《Spring 的官方文档》</a>**，写的很详细。你可以在这里找到 Spring 全家桶的学习资源。</p>
<p><img src="https://pic4.zhimg.com/50/v2-617c73716c914ce3ee4c9a32be97daa3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-617c73716c914ce3ee4c9a32be97daa3_720w.jpg?source=1940ef5c" alt="img"></p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34949443/">《Spring 实战》</a></strong> 这本书作为学习 Spring 的参考资料。 这本书还是比较新的，目前已经出到了第 5 版，基于 Spring 5 来讲。</p>
<p><img src="https://pic2.zhimg.com/50/v2-27116d84a7876e40fe9e008d0bd1927e_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-27116d84a7876e40fe9e008d0bd1927e_720w.jpg?source=1940ef5c" alt="img"></p>
<p>了解了 Spring 中的一些常见概念和基本用法之后，你就可以开始学习 Spring Boot 了。</p>
<p>当然了，Spring 其实并不是学习 Spring Boot 的前置基础，相比于 Spring 来说，Spring Boot 要更容易上手一些！如果你只是想使用 Spring Boot 来做项目的话，直接学 Spring Boot 就可以了。</p>
<p>不过，我建议你在学习 Spring Boot 之前，可以看看 <strong><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">《Spring 常见问题总结》</a></strong> 。这些问题都是 Spring 比较重要的知识点，也是面试中经常会被问到的。</p>
<p>学习 Spring Boot 的话，还是建议可以多看看  **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-boot%23learn">《Spring Boot 的官方文档》</a>**，写的很详细。</p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26857423/">《Spring Boot 实战》</a></strong> 这本书作为学习 Spring Boot 的参考资料。</p>
<p><img src="https://pic2.zhimg.com/50/v2-ccd869cdada64fb595d5e2c524180eba_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-ccd869cdada64fb595d5e2c524180eba_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书的整体质量实际一般，你当做参考书来看就好了!</p>
<p>相比于 《Spring Boot 实战》这本书，我更推荐国人写的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34894533/">《Spring Boot 实战派》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-347c02b27d1c8074dd6423c11c867b95_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-347c02b27d1c8074dd6423c11c867b95_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书使用的 Spring Boot 2.0+的版本，还算比较新。整本书采用“知识点+实例”的形式编写，书籍的最后两章还有 2 个综合性的企业实战项目：</p>
<ul>
<li>开发企业级通用的后台系统</li>
<li>实现一个类似“京东”的电子商务商城</li>
</ul>
<p>作者在注意实战的过程中还不忘记对于一些重要的基础知识的讲解。</p>
<p>如果你想专研 Spring Boot 底层原理的话，可以看看 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/33390560/">《Spring Boot 编程思想（核心篇）》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书稍微有点啰嗦，不过，原理介绍的比较清楚（不适合初学者）。</p>
<p>如果你比较喜欢看视频的话，推荐尚硅谷雷神的**<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV19K4y1L7MT">《2021 版 Spring Boot2 零基础入门》</a>** 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-8edcdf9da09d431d5a827737df1326f8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-8edcdf9da09d431d5a827737df1326f8_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这可能是全网质量最高并且免费的 Spring Boot 教程了，好评爆炸！</p>
<p>另外，Spring Boot 这块还有很多优质的开源教程，我已经整理好放到 <a href="https://link.zhihu.com/?target=https://github.com/CodingDocs/awesome-java%23springboot">awesome-java@SpringBoot</a> 中了。</p>
<p><img src="https://pic4.zhimg.com/50/v2-bd98e686b9da09ebbe25bfc843364147_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-bd98e686b9da09ebbe25bfc843364147_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a><strong>Netty</strong></h2><p>但凡涉及到网络通信就必然必然离不开网络编程。 Netty 目前作为 Java 网络编程最热门的框架，毫不夸张地说是每个 Java 程序员必备的技能之一。</p>
<p><strong>为什么说学好 Netty 很有必要呢？</strong></p>
<ol>
<li>Netty 基于 NIO （NIO 是一种同步非阻塞的 I&#x2F;O 模型，在 Java 1.4 中引入了 NIO ）。使用 Netty 可以极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面都非常优秀。</li>
<li>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC、Spark、Elasticsearch 等等热门开源项目都用到了 Netty。</li>
<li>大部分微服务框架底层涉及到网络通信的部分都是基于 Netty 来做的，比如说 Spring Cloud 生态系统中的网关 Spring Cloud Gateway 。</li>
</ol>
<p>下面是一些比较推荐的书籍&#x2F;专栏。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/27038538/">《Netty 实战》</a></strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-8a4c942af44520f5d2c99c3d6f37b4dc_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-8a4c942af44520f5d2c99c3d6f37b4dc_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书可以用来入门 Netty ，内容从 BIO 聊到了 NIO、之后才详细介绍为什么有 Netty 、Netty 为什么好用以及 Netty 重要的知识点讲解。</p>
<p>这本书基本把 Netty 一些重要的知识点都介绍到了，而且基本都是通过实战的形式讲解。</p>
<p><strong>《Netty 进阶之路：跟着案例学 Netty》</strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-214ed872bb89b37b2b3c06b4c8c022e5_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-214ed872bb89b37b2b3c06b4c8c022e5_720w.jpg?source=1940ef5c" alt="img"></p>
<p>内容都是关于使用 Netty 的实践案例比如内存泄露这些东西。如果你觉得你的 Netty 已经完全入门了，并且你想要对 Netty 掌握的更深的话，推荐你看一下这本书。</p>
<p><strong>《Netty 入门与实战：仿写微信 IM 即时通讯系统》</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-31d3de0843d01caea292fc461ca00d55_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-31d3de0843d01caea292fc461ca00d55_720w.jpg?source=1940ef5c" alt="img"></p>
<p>通过一个基于 Netty 框架实现 IM 核心系统为引子，带你学习 Netty。整个小册的质量还是很高的，即使你没有 Netty 使用经验也能看懂。</p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h2><p>搜索引擎用于提高搜索效率，功能和浏览器搜索引擎类似。比较常见的搜索引擎是 Elasticsearch（推荐） 和 Solr。</p>
<p>如果你要学习 Elasticsearch 的话，<a href="https://link.zhihu.com/?target=http://www.elasticsearch.cn/">Elastic 中文社区</a> 以及 <a href="https://link.zhihu.com/?target=https://www.elastic.co/cn/blog/">Elastic 官方博客</a> 都是非常不错的资源，上面会分享很多具体的实践案例。</p>
<p>除此之外，极客时间的<a href="https://link.zhihu.com/?target=http://gk.link/a/10bcT">《Elasticsearch 核心技术与实战》</a>这门课程非常赞！这门课基于 Elasticsearch 7.1 版本讲解，比较新。并且，作者是 eBay 资深技术专家，有 20 年的行业经验，课程质量有保障！</p>
<p><img src="https://pic1.zhimg.com/50/v2-057c22f1e83338a78f2e6b22e5da777d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-057c22f1e83338a78f2e6b22e5da777d_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想看书的话，可以考虑一下 《Elasticsearch 实战》 这本书。不过，需要说明的是，这本书中的 Elasticsearch 版本比较老，你可以将其作为一个参考书籍来看，有一些原理性的东西可以在上面找找答案。</p>
<p><img src="https://pic2.zhimg.com/50/v2-d2048059f45eac3a26001579c7826d8f_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d2048059f45eac3a26001579c7826d8f_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想进一步深入研究 Elasticsearch 原理的话，可以看看张超老师的《Elasticsearch 源码解析与优化实战》这本书。这是市面上唯一一本写 Elasticsearch 源码的书。</p>
<p><img src="https://pic4.zhimg.com/50/v2-85d4049c868a55ecbc76ae6c329eaebf_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-85d4049c868a55ecbc76ae6c329eaebf_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>下面我们开始学习分布式以及高并发、高可用了。</p>
<p>这块内容的话，对于每一个知识点没有特定的书籍。我就推荐 2 本我觉得还不错的书籍吧！这两把书籍基本把下面涉及到的知识点给涵盖了。</p>
<p>第一本是李运华老师的**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30335935/">《从零开始学架构》</a>** 。</p>
<p><img src="https://pic2.zhimg.com/50/v2-145c577cd6856daca487eec730ffc394_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-145c577cd6856daca487eec730ffc394_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书对应的有一个极客时间的专栏—<a href="https://link.zhihu.com/?target=http://gk.link/a/10pKZ">《从零开始学架构》</a>，里面的很多内容都是这个专栏里面的，两者买其一就可以了。</p>
<p>第二本是余老师的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30443578/">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-fe7286730c9ea0f94196b5e9f1dd3e07_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-fe7286730c9ea0f94196b5e9f1dd3e07_720w.jpg?source=1940ef5c" alt="img"></p>
<p>事务与锁、分布式（CAP、分布式事务……）、高并发、高可用这本书都有介绍到。值得推荐！良心好书！</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a><strong>理论</strong></h3><h4 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a><strong>CAP 理论</strong></h4><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">《CAP 理论解读》</a>。</p>
<h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a><strong>BASE 理论</strong></h4><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/BASE%E7%90%86%E8%AE%BA">《BASE 理论解读》</a>。</p>
<h4 id="Paxos-算法和-Raft-算法"><a href="#Paxos-算法和-Raft-算法" class="headerlink" title="Paxos 算法和 Raft 算法"></a><strong>Paxos 算法和 Raft 算法</strong></h4><p><strong>Paxos 算法</strong>诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—<strong>Raft 算法</strong>。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><strong>RPC</strong></h3><p>RPC 让调用远程服务调用像调用本地方法那样简单。</p>
<p>Dubbo 是一款国产的 RPC 框架，由阿里开源。相关阅读：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/Dubbo">Dubbo 常见问题总结</a></li>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC">服务之间的调用为啥不直接用 HTTP 而用 RPC？</a></li>
</ul>
<h4 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a><strong>服务注册与发现</strong></h4><p>Eureka、Zookeeper、Consul、Nacos 都可以提供服务注册与发现的功能。</p>
<p><img src="https://pic1.zhimg.com/50/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_720w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a><strong>API 网关</strong></h3><p>网关主要用于请求转发、安全认证、协议转换、容灾。</p>
<p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，为了取代 Netflix Zuul。</p>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a><strong>配置中心</strong></h4><p>微服务下，业务的发展一般会导致服务数量的增加，进而导致程序配置（服务地址、数据库参数等等）增多。</p>
<p>传统的配置文件的方式已经无法满足当前需求，主要有两点原因：一是安全性得不到保障（配置放在代码库中容易泄露）；二是时效性不行 （修改配置需要重启服务才能生效）。</p>
<p>Spring Cloud Config、Nacos 、Apollo、K8s ConfigMap 都可以用来做配置中心。</p>
<p>Apollo 和 Nacos 我个人更喜欢。Nacos 使用起来更加顺手，Apollo 在配置管理方面做的更加全面。</p>
<h3 id="分布式-id"><a href="#分布式-id" class="headerlink" title="分布式 id"></a><strong>分布式 id</strong></h3><p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>
<p><img src="https://pic1.zhimg.com/50/v2-21c5fb2a333d04d70ccf2554e4a66995_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-21c5fb2a333d04d70ccf2554e4a66995_720w.jpg?source=1940ef5c" alt="img"></p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>
<p>我简单举一个分库分表的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。</p>
<p>单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>
<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-1f699f3733924441f3707926da884744_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-1f699f3733924441f3707926da884744_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<p>分布式 ID 的解决方案有很多比如 ：</p>
<ul>
<li>算法 ：UUID、Snowflake</li>
<li>开源框架 ： UidGenerator、Leaf 、Tinyid</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><strong>分布式事务</strong></h3><p>微服务架构下，一个系统被拆分为多个小的微服务。</p>
<p>每个微服务都可能存在不同的机器上，并且每个微服务可能都有一个单独的数据库供自己使用。这种情况下，一组操作可能会涉及到多个微服务以及多个数据库。</p>
<p>举个例子：电商系统中，你创建一个订单往往会涉及到订单服务（订单数加一）、库存服务（库存减一）等等服务，这些服务会有供自己单独使用的数据库。</p>
<p><img src="https://pic2.zhimg.com/50/v2-feaa7d9765154fa367bc008444d208c3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-feaa7d9765154fa367bc008444d208c3_720w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>那么如何保证这一组操作要么都执行成功，要么都执行失败呢？</strong></p>
<p>这个时候单单依靠数据库事务就不行了！我们就需要引入 <strong>分布式事务</strong> 这个概念了！</p>
<p>常用分布式事务解决方案有 Seata 和 Hmily。</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://seata.io/zh-cn/index.html">Seata</a></strong> :Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://gitee.com/shuaiqiyu/hmily">Hmily</a></strong> : 金融级分布式事务解决方案</li>
</ol>
<h3 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a><strong>分布式链路追踪</strong></h3><p>不同于单体架构，在分布式架构下，请求需要在多个服务之间调用，排查问题会非常麻烦。我们需要分布式链路追踪系统来解决这个痛点。</p>
<p>目前分布式链路追踪系统基本都是根据谷歌的《Dapper 大规模分布式系统的跟踪系统》这篇论文发展而来，主流的有 Pinpoint，Skywalking ，CAT（当然也有其他的例如 Zipkin，Jaeger 等产品，不过总体来说不如前面选取的 3 个完成度高）等。</p>
<p>Zipkin 是 Twitter 公司开源的一个分布式链路追踪工具，Spring Cloud Sleuth 实际是基于 Zipkin 的。</p>
<p>SkyWalking 是国人吴晟（华为）开源的一款分布式追踪，分析，告警的工具，现在是 Apache 旗下开源项目</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><p>微服务的很多东西实际在分布式这一节已经提到了。</p>
<p>我这里就再补充一些微服务架构中，经常使用到的一些组件。</p>
<ul>
<li><strong>声明式服务调用</strong> : Feign</li>
<li><strong>负载均衡</strong> : Ribbon</li>
<li>……</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a><strong>高并发</strong></h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h4><p><img src="https://pic2.zhimg.com/50/v2-4903cf7307350d41a16d0277112d5424_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4903cf7307350d41a16d0277112d5424_720w.jpg?source=1940ef5c" alt="img"></p>
<p>消息队列在分布式系统中主要是为了解耦和削峰。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/message-queue/message-queue">消息队列常见问题总结</a>。</p>
<p>常用的消息队列如下：</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/rocketmq">RocketMQ</a></strong> ：阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/kafka">Kafaka</a></strong>: Kafka 是一种分布式的，基于发布 &#x2F; 订阅的消息系统。关于它的入门可以查看：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md">Kafka 入门看这一篇就够了</a></li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/rabbitmq">RabbitMQ</a></strong> :由 erlang 开发的基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。</li>
</ol>
<h3 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a><strong>读写分离&amp;分库分表</strong></h3><p>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。主服务器负责写，从服务器负责读。另外，一主一从或者一主多从都可以。</p>
<p>读写分离可以大幅提高读性能，小幅提高写的性能。因此，读写分离更适合单机并发读请求比较多的场景。</p>
<p><img src="https://pic3.zhimg.com/50/v2-36f2ed6de6018bb4cebab32623373864_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-36f2ed6de6018bb4cebab32623373864_720w.jpg?source=1940ef5c" alt="img"></p>
<p>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</p>
<p>常见的分库分表工具有：sharding-jdbc（当当）、TSharding（蘑菇街）、MyCAT（基于 Cobar）、Cobar（阿里巴巴）…。 推荐使用 sharding-jdbc。 因为，sharding-jdbc 是一款轻量级 Java 框架，以 jar 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。</p>
<p><img src="https://pic2.zhimg.com/50/v2-635a97b84f0e3b718b1cfdc61a0bbe08_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-635a97b84f0e3b718b1cfdc61a0bbe08_720w.jpg?source=1940ef5c" alt="img"></p>
<p>相关阅读： <a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">读写分离&amp;分库分表常见问题总结</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。</p>
<p>常见的负载均衡系统包括 3 种：</p>
<ol>
<li><strong>DNS 负载均衡</strong> ：一般用来实现地理级别的均衡。</li>
<li><strong>硬件负载均衡</strong> ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li>
<li><strong>软件负载均衡</strong> ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li>
</ol>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h2><p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的 。</p>
<p>相关阅读： <strong>《<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9">如何设计一个高可用系统？要考虑哪些地方？</a>》</strong> 。</p>
<h3 id="限流-amp-降级-amp-熔断"><a href="#限流-amp-降级-amp-熔断" class="headerlink" title="限流&amp;降级&amp;熔断"></a><strong>限流&amp;降级&amp;熔断</strong></h3><p>限流是从用户访问压力的角度来考虑如何应对系统故障。限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。比如某一接口的请求限制为 100 个每秒, 对超过限制的请求放弃处理或者放到队列中等待处理。限流可以有效应对突发请求过多。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/limit-request">限流算法有哪些？</a></p>
<p>降级是从系统功能优先级的角度考虑如何应对系统故障。服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<p>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。</p>
<p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Netflix/Hystrix">Hystrix</a> 和 <a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel">Sentinel</a> 都能实现限流、降级、熔断。</p>
<p>Hystrix 是 Netflix 开源的熔断降级组件，Sentinel 是阿里中间件团队开源的一款不光具有熔断降级功能，同时还支持系统负载保护的组件。</p>
<p>两者都是主要做熔断降级 ，那么两者到底有啥异同呢？该如何选择呢？</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94">Sentinel 的 wiki 中已经详细描述了其与 Hystrix 的区别</a>，你可以看看。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a><strong>排队</strong></h3><p>另类的一种限流，类比于现实世界的排队。玩过英雄联盟的小伙伴应该有体会，每次一有活动，就要经历一波排队才能进入游戏。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><p>相同的服务部署多份，避免单点故障。</p>
<h3 id="超时和重试机制"><a href="#超时和重试机制" class="headerlink" title="超时和重试机制"></a><strong>超时和重试机制</strong></h3><p><strong>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</strong> 如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。</p>
<h4 id="另外，重试的次数一般设为-3-次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。"><a href="#另外，重试的次数一般设为-3-次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。" class="headerlink" title="另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。"></a>另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</h4>
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/93bfdc7a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/93bfdc7a/" class="post-title-link" itemprop="url">经典动态规划：戳气球问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/93bfdc7a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/93bfdc7a/" data-xid="/posts/93bfdc7a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：戳气球问题"><a href="#经典动态规划：戳气球问题" class="headerlink" title="经典动态规划：戳气球问题"></a>经典动态规划：戳气球问题</h1><p>今天我们要聊的这道题「Burst Balloon」和之前我们写过的那篇 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋问题</a> 分析过的高楼扔鸡蛋问题类似，知名度很高，但难度确实也很大。因此 labuladong 公众号就给这道题赐个座，来看一看这道题目到底有多难。</p>
<p>它是 LeetCode 第 312 题，题目如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NNiTSq_20210507180038.png" alt="图片"></p>
<p>首先必须要说明，这个题目的状态转移方程真的比较巧妙，所以说如果你看了题目之后完全没有思路恰恰是正常的。虽然最优答案不容易想出来，但基本的思路分析是我们应该力求做到的。所以本文会先分析一下常规思路，然后再引入动态规划解法。</p>
<h2 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="一、回溯思路"></a>一、回溯思路</h2><p>先来顺一下解决这种问题的套路：</p>
<p><strong>我们前文多次强调过，很显然只要涉及求最值，没有任何奇技淫巧，一定是穷举所有可能的结果，然后对比得出最值</strong>。</p>
<p>所以说，只要遇到求最值的算法问题，首先要思考的就是：如何穷举出所有可能的结果？</p>
<p>穷举主要有两种算法，就是回溯算法和动态规划，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」。</p>
<p>如何将我们的扎气球问题转化成回溯算法呢？这个应该不难想到的，<strong>我们其实就是想穷举戳气球的顺序</strong>，不同的戳气球顺序可能得到不同的分数，我们需要把所有可能的分数中最高的那个找出来，对吧。</p>
<p>那么，这不就是一个「全排列」问题嘛，我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法框架套路详解</a> 中有全排列算法的详解和代码，其实只要稍微改一下逻辑即可，伪码思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/* 输入一组气球，返回戳破它们获得的最大分数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回溯算法的伪码解法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> socre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums 为空) &#123;</span><br><span class="line">        res = max(res, score);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> nums[i-<span class="number">1</span>] * nums[i] * nums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        在 nums 中删除元素 nums[i]</span><br><span class="line">        <span class="comment">// 递归回溯</span></span><br><span class="line">        backtrack(nums, score + point);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        将 temp 还原到 nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法就是这么简单粗暴，但是相应的，算法的效率非常低。这个解法等同于全排列，所以时间复杂度是阶乘级别，非常高，题目说了<code>nums</code>的大小<code>n</code>最多为 500，所以回溯算法肯定是不能通过所有测试用例的。</p>
<h2 id="二、动态规划思路"><a href="#二、动态规划思路" class="headerlink" title="二、动态规划思路"></a>二、动态规划思路</h2><p>这个动态规划问题和我们之前的动态规划系列文章相比有什么特别之处？为什么它比较难呢？</p>
<p><strong>原因在于，这个问题中我们每戳破一个气球<code>nums[i]</code>，得到的分数和该气球相邻的气球<code>nums[i-1]</code>和<code>nums[i+1]</code>是有相关性的</strong>。</p>
<p>我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划套路框架详解</a> 说过运用动态规划算法的一个重要条件：<strong>子问题必须独立</strong>。所以对于这个戳气球问题，如果想用动态规划，必须巧妙地定义<code>dp</code>数组的含义，避免子问题产生相关性，才能推出合理的状态转移方程。</p>
<p>如何定义<code>dp</code>数组呢，这里需要对问题进行一个简单地转化。题目说可以认为<code>nums[-1] = nums[n] = 1</code>，那么我们先直接把这两个边界加进去，形成一个新的数组<code>points</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 两端加入两个虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在气球的索引变成了从<code>1</code>到<code>n</code>，<code>points[0]</code>和<code>points[n+1]</code>可以认为是两个「虚拟气球」。</p>
<p>那么我们可以改变问题：<strong>在一排气球<code>points</code>中，请你戳破气球<code>0</code>和气球<code>n+1</code>之间的所有气球（不包括<code>0</code>和<code>n+1</code>），使得最终只剩下气球<code>0</code>和气球<code>n+1</code>两个气球，最多能够得到多少分</strong>？</p>
<p>现在可以定义<code>dp</code>数组的含义：</p>
<p>**<code>dp[i][j] = x</code>表示，戳破气球<code>i</code>和气球<code>j</code>之间（开区间，不包括<code>i</code>和<code>j</code>）的所有气球，可以获得的最高分数为<code>x</code>**。</p>
<p>那么根据这个定义，题目要求的结果就是<code>dp[0][n+1]</code>的值，而 base case 就是<code>dp[i][j] = 0</code>，其中<code>0 &lt;= i &lt;= n+1, j &lt;= i+1</code>，因为这种情况下，开区间<code>(i, j)</code>中间根本没有气球可以戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>现在我们要根据这个<code>dp</code>数组来推导状态转移方程了，根据我们前文的套路，所谓的推导「状态转移方程」，实际上就是在思考怎么「做选择」，也就是这道题目最有技巧的部分：</p>
<p>不就是想求戳破气球<code>i</code>和气球<code>j</code>之间的最高分数吗，如果「正向思考」，就只能写出前文的回溯算法；<strong>我们需要「反向思考」，想一想气球<code>i</code>和气球<code>j</code>之间最后一个被戳破的气球可能是哪一个</strong>？</p>
<p>其实气球<code>i</code>和气球<code>j</code>之间的所有气球都可能是最后被戳破的那一个，不防假设为<code>k</code>。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：<code>i</code>和<code>j</code>就是两个「状态」，最后戳破的那个气球<code>k</code>就是「选择」。</p>
<p><strong>根据刚才对<code>dp</code>数组的定义，如果最后一个戳破气球<code>k</code>，<code>dp[i][j]</code>的值应该为</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][k] + dp[k][j] </span><br><span class="line">         + points[i]*points[k]*points[j]</span><br></pre></td></tr></table></figure>

<p>你不是要最后戳破气球<code>k</code>吗？那得先把开区间<code>(i, k)</code>的气球都戳破，再把开区间<code>(k, j)</code>的气球都戳破；最后剩下的气球<code>k</code>，相邻的就是气球<code>i</code>和气球<code>j</code>，这时候戳破<code>k</code>的话得到的分数就是<code>points[i]*points[k]*points[j]</code>。</p>
<p>那么戳破开区间<code>(i, k)</code>和开区间<code>(k, j)</code>的气球最多能得到的分数是多少呢？嘿嘿，就是<code>dp[i][k]</code>和<code>dp[k][j]</code>，这恰好就是我们对<code>dp</code>数组的定义嘛！</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BgWf3s_20210507180154.png" alt="图片"></p>
<p>结合这个图，就能体会出<code>dp</code>数组定义的巧妙了。由于是开区间，<code>dp[i][k]</code>和<code>dp[k][j]</code>不会影响气球<code>k</code>；而戳破气球<code>k</code>时，旁边相邻的就是气球<code>i</code>和气球<code>j</code>了，最后还会剩下气球<code>i</code>和气球<code>j</code>，这也恰好满足了<code>dp</code>数组开区间的定义。</p>
<p>那么，对于一组给定的<code>i</code>和<code>j</code>，我们只要穷举<code>i &lt; k &lt; j</code>的所有气球<code>k</code>，选择得分最高的作为<code>dp[i][j]</code>的值即可，这也就是状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">    <span class="comment">// 择优做选择，使得 dp[i][j] 最大</span></span><br><span class="line">    dp[i][j] = Math.max(</span><br><span class="line">        dp[i][j], </span><br><span class="line">        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写出状态转移方程就完成这道题的一大半了，但是还有问题：对于<code>k</code>的穷举仅仅是在做「选择」，但是应该如何穷举「状态」<code>i</code>和<code>j</code>呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(</span><br><span class="line">                dp[i][j], </span><br><span class="line">                dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">            );</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="三、写出代码"><a href="#三、写出代码" class="headerlink" title="三、写出代码"></a>三、写出代码</h2><p><strong>关于「状态」的穷举，最重要的一点就是：状态转移所依赖的状态必须被提前计算出来</strong>。</p>
<p>拿这道题举例，<code>dp[i][j]</code>所依赖的状态是<code>dp[i][k]</code>和<code>dp[k][j]</code>，那么我们必须保证：在计算<code>dp[i][j]</code>时，<code>dp[i][k]</code>和<code>dp[k][j]</code>已经被计算出来了（其中<code>i &lt; k &lt; j</code>）。</p>
<p>那么应该如何安排<code>i</code>和<code>j</code>的遍历顺序，来提供上述的保证呢？我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484832&idx=1&sn=44ad2505ac5c276bf36eea1c503b78c3&chksm=9bd7fba8aca072be32f66e6c39d76ef4e91bdbf4ef993014d4fee82896687ad61da4f4fc4eda&scene=21#wechat_redirect">动态规划答疑篇</a> 写过处理这种问题的一个鸡贼技巧：<strong>根据 base case 和最终状态进行推导</strong>。</p>
<p>PS：最终状态就是指题目要求的结果，对于这道题目也就是<code>dp[0][n+1]</code>。</p>
<p>我们先把 base case 和最终的状态在 DP table 上画出来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/u3gd6W_20210507180507.png" alt="图片"></p>
<p>对于任一<code>dp[i][j]</code>，我们希望所有<code>dp[i][k]</code>和<code>dp[k][j]</code>已经被计算，画在图上就是这种情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Nhk1gt_20210507180419.png" alt="图片"></p>
<p>那么，为了达到这个要求，可以有两种遍历方法，要么斜着遍历，要么从下到上从左到右遍历：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/F2pPqp_20210507180541.png" alt="图片"></p>
<p>斜着遍历有一点难写，所以一般我们就从下往上遍历，下面看完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i][j], </span><br><span class="line">                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就完全解决了，十分巧妙，但也不是那么难，对吧？</p>
<p>关键在于<code>dp</code>数组的定义，需要避免子问题互相影响，所以我们反向思考，将<code>dp[i][j]</code>的定义设为开区间，考虑最后戳破的气球是哪一个，以此构建了状态转移方程。</p>
<p>对于如何穷举「状态」，我们使用了小技巧，通过 base case 和最终状态推导出<code>i,j</code>的遍历方向，保证正确的状态转移。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/e7520fcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e7520fcc/" class="post-title-link" itemprop="url">经典动态规划：高楼扔鸡蛋</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/e7520fcc/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/e7520fcc/" data-xid="/posts/e7520fcc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：高楼扔鸡蛋"><a href="#经典动态规划：高楼扔鸡蛋" class="headerlink" title="经典动态规划：高楼扔鸡蛋"></a>经典动态规划：高楼扔鸡蛋</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484675&from_itemidx=1&count=3&nolastread=1#wechat_redirect">手把手刷动态规划 25个</a></p>
<h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p>
<p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了不太划算。</p>
<p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p>
<h2 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h2><p>题目是这样：你面前有一栋从 1 到<code>N</code>共<code>N</code>层的楼，然后给你<code>K</code>个鸡蛋（<code>K</code>至少为 1）。现在确定这栋楼存在楼层<code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于<code>F</code>的楼层都会碎，低于<code>F</code>的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层<code>F</code>呢？</p>
<p>PS：F 可以为 0，比如说鸡蛋在 1 层都能摔碎，那么 F &#x3D; 0。</p>
<p>也就是让你找摔不碎鸡蛋的最高楼层<code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p>
<p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p>
<p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p>
<p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p>
<p>现在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p>
<p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p>
<p>最好的策略是使用二分查找思路，我先去第<code>(1 + 7) / 2 = 4</code>层扔一下：</p>
<p>如果碎了说明<code>F</code>小于 4，我就去第<code>(1 + 3) / 2 = 2</code>层试……</p>
<p>如果没碎说明<code>F</code>大于等于 4，我就去第<code>(5 + 7) / 2 = 6</code>层试……</p>
<p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试<code>log7</code>向上取整等于 3 次，比刚才的 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p>
<p>PS：这有点像 Big O 表示法计算算法的复杂度。</p>
<p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制<code>K</code>，直接使用二分思路就不行了</strong>。</p>
<p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层<code>F</code>了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。</p>
<p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p>
<p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p>
<p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。</p>
<p>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p>
<p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p>
<h2 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h2><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p>
<p>**「状态」很明显，就是当前拥有的鸡蛋数<code>K</code>和需要测试的楼层数<code>N</code>**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p>
<p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p>
<p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的<code>dp</code>数组或者带有两个状态参数的<code>dp</code>函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 当前状态为 (K 个鸡蛋，N 层楼)</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="type">int</span> res</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        res = min(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p>
<p>我们在第<code>i</code>层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p>
<p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数<code>K</code>应该减一，搜索的楼层区间应该从<code>[1..N]</code>变为<code>[1..i-1]</code>共<code>i-1</code>层楼；</p>
<p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数<code>K</code>不变，搜索的楼层区间应该从 <code>[1..N]</code>变为<code>[i+1..N]</code>共<code>N-i</code>层楼。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CvIp2u_20210429194724.png" alt="图片"></p>
<p>PS：细心的读者可能会问，在第<code>i</code>层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第<code>i</code>层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第<code>i</code>层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p>
<p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第<code>i</code>层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>递归的 base case 很容易理解：当楼层数<code>N</code>等于 0 时，显然不需要扔鸡蛋；当鸡蛋数<code>K</code>为 1 时，显然只能线性扫描所有楼层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">    <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">superEggDrop</span><span class="params">(K: <span class="type">int</span>, N: <span class="type">int</span>)</span>:</span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="title function_">dp</span><span class="params">(K, N)</span> -&gt; <span class="type">int</span>:</span><br><span class="line">        # base <span class="keyword">case</span></span><br><span class="line">        <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        # 避免重复计算</span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        res = <span class="type">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        # 穷举所有可能的选择</span><br><span class="line">        <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">1</span>, N + <span class="number">1</span>)</span>:</span><br><span class="line">            res = min(res, </span><br><span class="line">                      max(</span><br><span class="line">                            dp(K, N - i), </span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                         ) + <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)。</p>
<h2 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h2><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录&#x2F;DP table 优化，真的没啥新意。</p>
<p>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层<code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p>
<p>比方说你有 2 个鸡蛋，面对 10 层楼，你得拿一个鸡蛋去某一层楼扔对吧？那选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于鸡蛋碎没碎，下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。</p>
<p>其实，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K<em>N</em>logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p>
<p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最小值。</p>
<p>这里就不展开以上解法了，有兴趣的读者可以点击「阅读原文」查看。</p>
<p>我觉得吧，我们这种解法就够了：<strong>找状态，做选择</strong>，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，二分查找的优化应该可以看懂，之后的优化也就随缘吧。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/d0fbc9db/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/d0fbc9db/" class="post-title-link" itemprop="url">经典动态规划：高楼扔鸡蛋（进阶篇）</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/d0fbc9db/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/d0fbc9db/" data-xid="/posts/d0fbc9db/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：高楼扔鸡蛋（进阶篇）"><a href="#经典动态规划：高楼扔鸡蛋（进阶篇）" class="headerlink" title="经典动态规划：高楼扔鸡蛋（进阶篇）"></a>经典动态规划：高楼扔鸡蛋（进阶篇）</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484675&from_itemidx=1&count=3&nolastread=1#wechat_redirect">手把手刷动态规划 25个</a></p>
<h2 id="预计阅读时间：9-分钟"><a href="#预计阅读时间：9-分钟" class="headerlink" title="预计阅读时间：9 分钟"></a>预计阅读时间：9 分钟</h2><p>我们在 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">上篇文章</a> 聊了高楼扔鸡蛋问题，讲了一种效率不是很高，但是较为容易理解的动态规划解法。后台很多读者问如何更高效地解决这个问题，今天就谈两种思路，来优化一下这个问题，分别是二分查找优化和重新定义状态转移。</p>
<p>如果还不知道高楼扔鸡蛋问题的读者可以看下 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋</a>，<strong>那篇文章详解了题目的含义和基本的动态规划解题思路，请确保理解前文，<strong><strong>因为</strong></strong>今天的优化都是基于这个基本解法的</strong>。</p>
<p>二分搜索的优化思路也许是我们可以尽力尝试写出的，而修改状态转移的解法可能是不容易想到的，可以借此见识一下动态规划算法设计的玄妙，当做思维拓展。</p>
<h2 id="一、二分搜索优化"><a href="#一、二分搜索优化" class="headerlink" title="一、二分搜索优化"></a>一、二分搜索优化</h2><p>之前提到过这个解法，核心是因为状态转移方程的单调性，这里可以具体展开看看。</p>
<p>题目要求最坏情况下至少需要扔几次鸡蛋才能测出鸡蛋恰好摔不碎的楼层<code>F</code>。首先简述一下原始动态规划的思路：</p>
<p><strong>1</strong>、暴力穷举尝试在所有楼层<code>1 &lt;= i &lt;= N</code>扔鸡蛋，每次选择尝试次数<strong>最少</strong>的那一层；</p>
<p><strong>2</strong>、每次扔鸡蛋有两种可能，要么碎，要么没碎；</p>
<p><strong>3</strong>、如果鸡蛋碎了，<code>F</code>应该在第<code>i</code>层下面，否则，<code>F</code>应该在第<code>i</code>层上面；</p>
<p><strong>4</strong>、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数<strong>更多</strong>，因为我们想求的是最坏情况下的结果。</p>
<p>核心的状态转移代码是这段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当前状态为 K 个鸡蛋，面对 N 层楼</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CyPTgO_20210429195258.png" alt="图片"></p>
<p>如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。</p>
<p>首先我们根据<code>dp(K, N)</code>数组的定义（有<code>K</code>个鸡蛋面对<code>N</code>层楼，最少需要扔 dp(K, N) 次），<strong>很容易知道<code>K</code>固定时，这个函数随着<code>N</code>的增加一定是单调递增的</strong>，无论你策略多聪明，楼层增加的话，测试次数一定要增加。</p>
<p>那么注意<code>dp(K - 1, i - 1)</code>和<code>dp(K, N - i)</code>这两个函数，其中<code>i</code>是从 1 到<code>N</code>单增的，如果我们固定<code>K</code>和<code>N</code>，<strong>把这两个函数看做关于<code>i</code>的函数，前者随着<code>i</code>的增加应该也是单调递增的，而后者随着<code>i</code>的增加应该是单调递减的</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/6NYUjf_20210429195215.png" alt="图片"></p>
<p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。</p>
<p>我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484598&idx=1&sn=69edaf4a7f6bfd0b1185cae5d0689c1d&chksm=9bd7fabeaca073a8820bc93cb67a8e26fa9eaa1ab9717b7e3ac41b4aac12235067c8af3520d5&scene=21#wechat_redirect">二分搜索只能用来查找元素吗？</a>讲过，二分查找的运用很广泛，形如下面这种形式的 for 循环代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOK(i))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个<code>dp</code>函数的曲线，我们要找的最低点其实就是这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp(K - <span class="number">1</span>, i - <span class="number">1</span>) == dp(K, N - i))</span><br><span class="line">        <span class="keyword">return</span> dp(K, N - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">superEggDrop</span><span class="params">(self, K: <span class="type">int</span>, N: <span class="type">int</span>)</span> -&gt; <span class="type">int</span>:</span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">        <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        # <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        #     res = min(res, </span><br><span class="line">        #             max( </span><br><span class="line">        #                 dp(K - <span class="number">1</span>, i - <span class="number">1</span>), </span><br><span class="line">        #                 dp(K, N - i)      </span><br><span class="line">        #                 ) + <span class="number">1</span> </span><br><span class="line">        #             )</span><br><span class="line"></span><br><span class="line">        res = <span class="type">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        # 用二分搜索代替线性搜索</span><br><span class="line">        lo, hi = <span class="number">1</span>, N</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) <span class="comment">// 2</span></span><br><span class="line">            broken = dp(K - <span class="number">1</span>, mid - <span class="number">1</span>) # 碎</span><br><span class="line">            not_broken = dp(K, N - mid) # 没碎</span><br><span class="line">            # res = min(max(碎，没碎) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> broken &gt; not_broken:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">                res = min(res, broken + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">                res = min(res, not_broken + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K<em>N</em>logN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效不少。</p>
<h2 id="二、重写状态转移"><a href="#二、重写状态转移" class="headerlink" title="二、重写状态转移"></a>二、重写状态转移</h2><p>前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484469&idx=1&sn=e8d321c8ad62483874a997e9dd72da8f&chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 就提过，找动态规划的状态转移本就是见仁见智，比较玄学的事情。不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异。这里就是一个很好的例子。</p>
<p>再回顾一下我们之前定义的<code>dp</code>数组含义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(k, n)</span> -&gt; <span class="type">int</span></span><br><span class="line"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="line"># 返回这个状态下最少的扔鸡蛋次数</span><br></pre></td></tr></table></figure>

<p>用 dp 数组表示的话也是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[k][n] = m</span><br><span class="line"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="line"># 这个状态下最少的扔鸡蛋次数为 m</span><br></pre></td></tr></table></figure>

<p>按照这个定义，就是<strong>确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数</strong>。最终我们想要的答案就是<code>dp(K, N)</code>的结果。</p>
<p>这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，只不过是更聪明的穷举。</p>
<p>现在，我们稍微修改<code>dp</code>数组的定义，<strong>确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定<code>F</code>的最高楼层数</strong>。</p>
<p>有点绕口，具体来说是这个意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[k][m] = n</span><br><span class="line"># 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋</span><br><span class="line"># 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼</span><br><span class="line"></span><br><span class="line"># 比如说 dp[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">7</span> 表示：</span><br><span class="line"># 现在有 <span class="number">1</span> 个鸡蛋，允许你扔 <span class="number">7</span> 次;</span><br><span class="line"># 这个状态下最多给你 <span class="number">7</span> 层楼，</span><br><span class="line"># 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎</span><br><span class="line"># （一层一层线性探查嘛）</span><br></pre></td></tr></table></figure>

<p>这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？</p>
<p>我们最终要求的其实是扔鸡蛋次数<code>m</code>，但是这时候<code>m</code>在状态之中而不是<code>dp</code>数组的结果，可以这样处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="comment">// 状态转移...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目不是<strong>给你<code>K</code>鸡蛋，<code>N</code>层楼，让你求最坏情况下最少的测试次数<code>m</code></strong> 吗？<code>while</code>循环结束的条件是<code>dp[K][m] == N</code>，也就是<strong>给你<code>K</code>个鸡蛋，允许测试<code>m</code>次，最坏情况下最多能测试<code>N</code>层楼</strong>。</p>
<p>注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210429195434229_20210429195434.png" alt="图片"></p>
<p>这个图描述的仅仅是某一个楼层<code>i</code>，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种<code>dp</code>定义根本不需要这些了，基于下面两个事实：</p>
<p><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上</strong>。</p>
<p><strong>2、无论你上楼还是下楼，总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</strong>。</p>
<p>根据这个特点，可以写出下面的状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k][m] = dp[k][m-<span class="number">1</span>] + dp[k-<span class="number">1</span>][m-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong><code>dp[k][m - 1]</code>就是楼上的楼层数</strong>，因为鸡蛋个数<code>k</code>不变，也就是鸡蛋没碎，扔鸡蛋次数<code>m</code>减一；</p>
<p><strong><code>dp[k - 1][m - 1]</code>就是楼下的楼层数</strong>，因为鸡蛋个数<code>k</code>减一，也就是鸡蛋碎了，同时扔鸡蛋次数<code>m</code>减一。</p>
<p>PS：这个<code>m</code>为什么要减一而不是加一？之前定义得很清楚，这个<code>m</code>是一个允许的次数上界，而不是扔了几次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/72KWkN_20210429195454.png" alt="图片"></p>
<p>至此，整个思路就完成了，只要把状态转移方程填进框架即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case:</span></span><br><span class="line">    <span class="comment">// dp[0][..] = 0</span></span><br><span class="line">    <span class="comment">// dp[..][0] = 0</span></span><br><span class="line">    <span class="comment">// Java 默认初始化数组都为 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">            dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你还觉得这段代码有点难以理解，其实它就等同于这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; dp[K][m] &lt; N; m++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>看到这种代码形式就熟悉多了吧，因为我们要求的不是<code>dp</code>数组里的值，而是某个符合条件的索引<code>m</code>，所以用<code>while</code>循环来找到这个<code>m</code>而已。</p>
<p>这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。</p>
<p>另外注意到<code>dp[m][k]</code>转移只和左边和左上的两个状态有关，所以很容易优化成一维<code>dp</code>数组，这里就不写了。</p>
<h2 id="三、进一步思考"><a href="#三、进一步思考" class="headerlink" title="三、进一步思考"></a>三、进一步思考</h2><p>再往下就要用一些数学方法了，不具体展开，就简单提一下思路吧。</p>
<p>在刚才的思路之上，<strong>注意函数<code>dp(m, k)</code>是随着<code>m</code>单增的，因为鸡蛋个数<code>k</code>不变时，允许的测试次数越多，可测试的楼层就越高。</strong></p>
<p>这里又可以借助二分搜索算法快速逼近<code>dp[K][m] == N</code>这个终止条件，时间复杂度进一步下降为 O(KlogN)，我们可以设<code>g(k,m)</code>等于……</p>
<p>算了算了，打住吧。我觉得我们能够写出 O(K<em>N</em>logN) 的二分优化算法就行了，后面的这些解法呢，听个响鼓个掌就行了，把欲望限制在能力的范围之内才能拥有快乐！</p>
<p>不过可以肯定的是，根据二分搜索代替线性扫描 m 的取值，代码的大致框架肯定是修改穷举 m 的 for 循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把线性搜索改成二分搜索</span></span><br><span class="line"><span class="comment">// for (int m = 1; dp[K][m] &lt; N; m++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = N;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (... &lt; N) &#123;</span><br><span class="line">        lo = ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结一下吧，<strong>第一个二分优化是利用了<code>dp</code>函数的单调性</strong>，用二分查找技巧快速搜索答案；<strong>第二种优化是巧妙地修改了状态转移方程</strong>，简化了求解了流程，但相应的，解题逻辑比较难以想到；后续还可以用一些数学方法和二分搜索进一步优化第二种解法，不过看了看镜子中的发量，算了。</p>
<p>本文终，希望对你有一点启发。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/afbd7c28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/afbd7c28/" class="post-title-link" itemprop="url">经典面试题：如何寻找最⻓回文子串</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/afbd7c28/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/afbd7c28/" data-xid="/posts/afbd7c28/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典面试题：如何寻找最⻓回文子串"><a href="#经典面试题：如何寻找最⻓回文子串" class="headerlink" title="经典面试题：如何寻找最⻓回文子串"></a>经典面试题：如何寻找最⻓回文子串</h1><h2 id="预计阅读时间：5-分钟"><a href="#预计阅读时间：5-分钟" class="headerlink" title="预计阅读时间：5 分钟"></a>预计阅读时间：5 分钟</h2><p>回文串是面试常常遇到的问题（虽然问题本身没啥意义），本文就告诉你回文串问题的核心思想是什么。</p>
<p>首先，明确一下什：<strong>回文串就是正着读和反着读都一样的字符串</strong>。</p>
<p>比如说字符串<code>aba</code>和<code>abba</code>都是回文串，因为它们对称，反过来还是和本身一样。反之，字符串<code>abac</code>就不是回文串。</p>
<p>可以看到回文串的的长度可能是奇数，也可能是偶数，这就添加了回文串问题的难度，解决该类问题的核心是<strong>双指针</strong>。下面就通过一道最长回文子串的问题来具体理解一下回文串问题：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4lLwdm05DtOeOPia4eSQF3HJWKPuI6XXSumtytXXkvgQPwO1szjiaWicF84yMiaIwmFyRic4RmocZz3qvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h3><p>对于这个问题，我们首先应该思考的是，给一个字符串<code>s</code>，如何在<code>s</code>中找到一个回文子串？</p>
<p>有一个很有趣的思路：既然回文串是一个正着反着读都一样的字符串，那么如果我们把<code>s</code>反转，称为<code>s&#39;</code>，然后在<code>s</code>和<code>s&#39;</code>中寻找<strong>最长公共子串</strong>，这样应该就能找到最长回文子串。</p>
<p>比如说字符串<code>abacd</code>，反过来是<code>dcaba</code>，它俩的最长公共子串是<code>aba</code>，也就是最长回文子串。</p>
<p>但是这个思路是错误的，比如说字符串<code>aacxycaa</code>，反转之后是<code>aacyxcaa</code>，最长公共子串是<code>aac</code>，但是最长回文子串应该是<code>aa</code>。</p>
<p>虽然这个思路不正确，但是<strong>这种把问题转化为其他形式的思考方式是非常值得提倡的</strong>。</p>
<p>下面，就来说一下正确的思路，如何使用双指针。</p>
<p><strong>寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串</strong>。对于最长回文子串，就是这个意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>但是呢，我们刚才也说了，回文串的长度可能是奇数也可能是偶数，如果是<code>abba</code>这种情况，没有一个中心字符，上面的算法就没辙了。所以我们可以修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>PS：读者可能发现这里的索引会越界，等会会处理。</p>
<h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p>按照上面的思路，先要实现一个函数来寻找最长回文串，这个函数是有点技巧的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HpyEbX_20210507183744.png" alt="图片"></p>
<p>为什么要传入两个指针<code>l</code>和<code>r</code>呢？<strong>因为这样实现可以同时处理回文串长度为奇数和偶数的情况</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    # 找到以 s[i] 为中心的回文串</span><br><span class="line">    palindrome(s, i, i)</span><br><span class="line">    # 找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>下面看下<code>longestPalindrome</code>的完整代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/VFGLHs_20210507183807.png" alt="图片"></p>
<p>至此，这道最长回文子串的问题就解决了，时间复杂度 O(N^2)，空间复杂度 O(1)。</p>
<p>值得一提的是，这个问题可以用动态规划方法解决，时间复杂度一样，但是空间复杂度至少要 O(N^2) 来存储 DP table。这道题是少有的动态规划非最优解法的问题。</p>
<p>另外，这个问题还有一个巧妙的解法，时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为没必要掌握。该算法的名字叫 Manacher’s Algorithm（马拉车算法），有兴趣的读者可以自行搜索一下。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/e215f7cb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e215f7cb/" class="post-title-link" itemprop="url">NAS上搭建SS客户端</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/e215f7cb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/e215f7cb/" data-xid="/posts/e215f7cb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="群辉NAS上搭建SS客户端来连接远程并提供本地HTTP-x2F-Socks5代理"><a href="#群辉NAS上搭建SS客户端来连接远程并提供本地HTTP-x2F-Socks5代理" class="headerlink" title="群辉NAS上搭建SS客户端来连接远程并提供本地HTTP&#x2F;Socks5代理"></a>群辉NAS上搭建SS客户端来连接远程并提供本地HTTP&#x2F;Socks5代理</h1><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/mxF2RW_20220217094542.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://odcn.top/2018/10/24/854/%E7%BE%A4%E6%99%96ss%E5%90%8C%E6%AD%A5dropbox%E5%92%8Cgoogledrive/">主要参考了这片文章。</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://odcn.top/2018/10/24/854/%E7%BE%A4%E6%99%96ss%E5%90%8C%E6%AD%A5dropbox%E5%92%8Cgoogledrive/">shadowsocks的Http代理桥接为SOCKS5代理，使群晖SS同步Dropbox和GoogleDrive</a></p>
</blockquote>
<iframe title="《shadowsocks的Http代理桥接为SOCKS5代理，使群晖SS同步Dropbox和GoogleDrive》—oD^Blog" class="wp-embedded-content" sandbox="allow-scripts" security="restricted" src="https://odcn.top/2018/10/24/854/%e7%be%a4%e6%99%96ss%e5%90%8c%e6%ad%a5dropbox%e5%92%8cgoogledrive/embed/#?secret=hiN7sQcs2t" data-secret="hiN7sQcs2t" width="600" height="338" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; max-width: 100%; position: absolute; clip: rect(1px, 1px, 1px, 1px);"></iframe>
**Contents**  [hide](https://1024.ee/index.php/2020/04/06/群辉nas上搭建ss客户端来连接远程并提供本地http-socks5代理/#) 

<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#xia_zaidocker_-_ss-privoxy">1 下载docker – ss-privoxy</a></p>
<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#gao_ji_she_zhi">2 高级设置</a></p>
<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#she_zhi_duan_kou">3 设置端口</a></p>
<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#zui_hou_cha_yi_cha">4 最后查一查</a></p>
<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#kai_qi_hou_cha_cha_ri_zhi_yi_qie_zheng_chang_ji_ke">5 开启后查查日志，一切正常即可</a></p>
<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#qun_hui_zi_ji_de_shi_yong_kai_zhe_li_jiu_xing">6 群辉自己的使用，看这里就行。</a></p>
<p><a target="_blank" rel="noopener" href="https://1024.ee/index.php/2020/04/06/%E7%BE%A4%E8%BE%89nas%E4%B8%8A%E6%90%AD%E5%BB%BAss%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%9C%AC%E5%9C%B0http-socks5%E4%BB%A3%E7%90%86/#qun_hui_zi_ji_de_shi_yong_kai_zhe_li_jiu_xing">7指令</a></p>
<h2 id="下载docker-–-ss-privoxy"><a href="#下载docker-–-ss-privoxy" class="headerlink" title="下载docker – ss-privoxy"></a>下载docker – ss-privoxy</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2NcHvz_20220217094617.png" alt="img"></p>
<h2 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/JTDf8S_20220217094637.png" alt="img">注意是<strong>文件</strong>，不是文件夹。而且，文件名就是<strong>config</strong>, 不是config.conf之类。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件</span></span><br><span class="line"></span><br><span class="line">confdir /etc/privoxy</span><br><span class="line">logdir /var/log/privoxy</span><br><span class="line"></span><br><span class="line">actionsfile match-all.action <span class="comment"># Actions that are applied to all sites and maybe overruled later on.</span></span><br><span class="line">actionsfile default.action <span class="comment"># Main actions file</span></span><br><span class="line">actionsfile <span class="keyword">user</span>.action <span class="comment"># User customizations</span></span><br><span class="line"></span><br><span class="line">filterfile default.filter</span><br><span class="line">filterfile <span class="keyword">user</span>.filter <span class="comment"># User customizations</span></span><br><span class="line"></span><br><span class="line">logfile privoxy.log</span><br><span class="line"><span class="comment">#下面这行的意思是监听来自任意地址的8118访问</span></span><br><span class="line">listen-address :<span class="number">8118</span></span><br><span class="line">toggle <span class="number">1</span></span><br><span class="line"></span><br><span class="line">enable-remote-toggle <span class="number">0</span></span><br><span class="line">enable-remote-http-toggle <span class="number">0</span></span><br><span class="line">enable-edit-actions <span class="number">0</span></span><br><span class="line">enforce-blocks <span class="number">0</span></span><br><span class="line"></span><br><span class="line">buffer-limit <span class="number">4096</span></span><br><span class="line">enable-proxy-authentication-forwarding <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用这段全局代理模式#####################################</span></span><br><span class="line"><span class="comment">##下面一行表示将所有网址转发给本地7070端口，也就是本地的SS客户端所开放的端口。</span></span><br><span class="line"><span class="comment">#forward-socks5 / 127.0.0.1:7070 .</span></span><br><span class="line"><span class="comment">#启动这段只有部分网址走代理###############################</span></span><br><span class="line">forward / .</span><br><span class="line"><span class="comment">#下面这一段表示需要走代理的规则</span></span><br><span class="line">forward-socks5 .dropbox*.com <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7070</span> .</span><br><span class="line">forward-socks5 .*google*.* <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7070</span> .</span><br><span class="line">forward-socks5 .*facebook*.* <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7070</span> .</span><br><span class="line">forward-socks5 .*twitter*.* <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7070</span> .</span><br><span class="line"><span class="comment">#forward-socks5 .*youtube*.* 127.0.0.1:7070 .</span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line">forwarded-connect-retries <span class="number">0</span></span><br><span class="line"></span><br><span class="line">accept-intercepted-requests <span class="number">0</span></span><br><span class="line">allow-cgi-request-crunching <span class="number">0</span></span><br><span class="line">split-large-forms <span class="number">0</span></span><br><span class="line">keep-alive-timeout <span class="number">300</span></span><br><span class="line">tolerate-pipelining <span class="number">1</span></span><br><span class="line">default-server-timeout <span class="number">60</span></span><br><span class="line">socket-timeout <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件结束</span></span><br></pre></td></tr></table></figure>

<h2 id="设置端口"><a href="#设置端口" class="headerlink" title="设置端口"></a>设置端口</h2><ul>
<li>7070 For Socks5 – All Traffic</li>
<li>8118 for Http&#x2F;Https – 部分域名翻墙，改conf文件即可</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/t5PYQv_20220217094721.png" alt="img"></p>
<h2 id="最后查一查"><a href="#最后查一查" class="headerlink" title="最后查一查"></a>最后查一查</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/iwGoJB_20220217094740.png" alt="img"></p>
<h2 id="开启后查查日志，一切正常即可"><a href="#开启后查查日志，一切正常即可" class="headerlink" title="开启后查查日志，一切正常即可"></a>开启后查查日志，一切正常即可</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/S5u8G1_20220217094809.png" alt="img"></p>
<h2 id="群辉自己的使用，开这里就行。"><a href="#群辉自己的使用，开这里就行。" class="headerlink" title="群辉自己的使用，开这里就行。"></a>群辉自己的使用，开这里就行。</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/L0Nwl6_20220217094828.png" alt="img"></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -e SERVER_ADDR=n47.boom.party -e SERVER_PORT=31100 -e PASSWORD=Uk92CS -e METHOD=aes-256-cfb -e PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin -e TIME_OUT=300 -p 7070:7070 -p 8118:8118 -v /share/CACHEDEV1_DATA/Container/etc/privoxy/config:/etc/privoxy/config oldiy/ss-privoxy</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swimminghao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">838k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:41</span>
  </span>
</div>

<span id="sitetime"></span>
<script language=javascript>
    function siteTime(){
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2022,02,28,00,00,00); //你的建站时间
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById("sitetime").innerHTML=" 本站已安全运行 "+diffYears+" Year "+diffDays+" Days "+diffHours+" Hours "+diffMinutes+" m "+diffSeconds+" s";
    }
    siteTime();
</script>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        访问人数：<span id="busuanzi_value_site_uv"></span>
      </span>人
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
       访问总量：<span id="busuanzi_value_site_pv"></span>
      </span>次
    </span>


<!--
  本文总阅读量：<span id="busuanzi_value_page_pv"></span>次
-->

</div>


<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

--><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-nu.vercel.app","placeholder":"请文明评论呀","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/page/5/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "middleCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
</body>
</html>
