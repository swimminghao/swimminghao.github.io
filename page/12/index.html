<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-loading-bar.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="swimminghao的学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swimminghao&#39;s blog">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="swimminghao&#39;s blog">
<meta property="og:description" content="swimminghao的学习博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swimminghao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>swimminghao's blog</title>
  




<link rel="dns-prefetch" href="waline-server-nu.vercel.app"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">swimminghao's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">31</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">131</span></a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="swimminghao"
      src="/images/lion.png">
  <p class="site-author-name" itemprop="name">swimminghao</p>
  <div class="site-description" itemprop="description">swimminghao的学习博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/swimminghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swimminghao0@gmail.com" title="E-Mail → mailto:swimminghao0@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/swimminghao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- recent posts -->
    <div class="links-of-blogroll motion-element links-of-blogroll-block">
        <div class="links-of-blogroll-title recent-posts-title">
	    <i class="fa fa-history " aria-hidden="true"></i>
            近期文章
	</div>
	<ul class="links-of-blogroll-list recent-posts-list">
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/6aa1f673/" title="命令行的艺术" target="">
		    命令行的艺术
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/a70bb1ff/" title="手把手教你黑白群晖NAS安装破解版ROON音乐播放器1.6" target="">
		    手把手教你黑白群晖NAS安装破解版ROON音乐播放器1.6
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/61fc1c97/" title="emby-server媒体库硬链接" target="">
		    emby-server媒体库硬链接
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/55ff28b4/" title="Spring Boot 2.0 集成 redis" target="">
		    Spring Boot 2.0 集成 redis
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/55ff28b4/" title="renren-fast开发文档3.0最新版" target="">
		    renren-fast开发文档3.0最新版
		    </a>
		</li>
	</ul>
    </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/759e745e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/759e745e/" class="post-title-link" itemprop="url">6、【对线面试官】CAS</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 09:48:07" itemprop="dateModified" datetime="2022-03-10T09:48:07+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/759e745e/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/759e745e/" data-xid="/posts/759e745e/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="6、【对线面试官】CAS"><a href="#6、【对线面试官】CAS" class="headerlink" title="6、【对线面试官】CAS"></a>6、【对线面试官】CAS</h1><h2 id="今天我们来聊聊CAS吧？你对CAS了解多少？"><a href="#今天我们来聊聊CAS吧？你对CAS了解多少？" class="headerlink" title="今天我们来聊聊CAS吧？你对CAS了解多少？"></a>今天我们来聊聊CAS吧？你对CAS了解多少？</h2><ol>
<li>CAS的全称为compare and swap，比较并交换</li>
<li>虽然翻译过来是「比较并交换」，但它是一个原子性的操作，对应到CPU指令为cmpxchg</li>
<li>cpu指令你都知道？-&gt;这没什么，都是背的。</li>
<li>回到CAS上吧，CAS的操作其实非常简单。</li>
<li>CAS有三个操作数：当前值A、内存值V、要修改的新值B</li>
<li>假设当前值A跟内存值V相等，那就将内存值V改成B</li>
<li>假设当前值A跟内存值V不相等，要么就重试，要么就放弃更新</li>
<li>将当前值与内存值进行对比，判断是否有被修改过，这就是CAS的核心</li>
</ol>
<h2 id="确实，那为什么要用CAS呢？"><a href="#确实，那为什么要用CAS呢？" class="headerlink" title="确实，那为什么要用CAS呢？"></a>确实，那为什么要用CAS呢？</h2><ol>
<li>嗯，要讲到CAS就不得不说synchronized锁了，它是Java锁..然后..</li>
<li>ok，其实就是synchronized锁每次只会让一个线程去操作共享资源</li>
<li>而CAS相当于没有加锁，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断能否修改成功</li>
<li>在很多的情况下会synchronized锁要高效很多</li>
<li>比如，对一个值进行累加，就没必要使用synchronized锁，使用juc包下的Atomic类就足以。</li>
</ol>
<h2 id="了解，那你知道CAS会有什么缺点吗？"><a href="#了解，那你知道CAS会有什么缺点吗？" class="headerlink" title="了解，那你知道CAS会有什么缺点吗？"></a>了解，那你知道CAS会有什么缺点吗？</h2><ol>
<li>CAS有个缺点就是会带来ABA的问题</li>
<li>从CAS更新的时候，我们可以发现它只比对当前值和内存值是否相等，这会带来个问题，下面我举例说明下：</li>
<li>假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10。</li>
<li>等到线程A拿到执行权时，因为当前值和内存值是一致的，线程A是可以修改的！</li>
<li>站在线程A的角度来说，这个值是从未被修改的（：</li>
<li>这是不合理的，因为我们从上帝的角度来看，这个变量已经被线程B和线程C修改过了。</li>
<li>这就是所谓的ABA问题</li>
<li>要解决ABA的问题，Java也提供了AtomicStampedReference类供我们用，说白了就是加了个版本，比对的就是内存值+版本是否一致</li>
</ol>
<h2 id="阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）"><a href="#阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）" class="headerlink" title="阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）"></a>阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）</h2><ol>
<li>AtomicLong做累加的时候实际上就是多个线程操作同一个目标资源</li>
<li>在高并发时，只有一个线程是执行成功的，其他的线程都会失败，不断自旋（重试），自旋会成为瓶颈</li>
<li>而LongAdder的思想就是把要操作的目标资源「分散」到数组Cell中</li>
<li>每个线程对自己的Cell变量的value进行原子操作，大大降低了失败的次数</li>
<li>这就是为什么在高并发场景下，推荐使用LongAdder的原因</li>
</ol>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/844cde9b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/844cde9b/" class="post-title-link" itemprop="url">7、【对线面试官】synchronized</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 09:48:07" itemprop="dateModified" datetime="2022-03-10T09:48:07+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/844cde9b/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/844cde9b/" data-xid="/posts/844cde9b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7、【对线面试官】synchronized"><a href="#7、【对线面试官】synchronized" class="headerlink" title="7、【对线面试官】synchronized"></a>7、【对线面试官】synchronized</h1><h2 id="今天我们来聊聊synchronized吧？"><a href="#今天我们来聊聊synchronized吧？" class="headerlink" title="今天我们来聊聊synchronized吧？"></a>今天我们来聊聊synchronized吧？</h2><ol>
<li>synchronized是一种互斥锁，一次只能允许一个线程进入被锁住的代码块</li>
<li>synchronized是Java的一个关键字，它能够将代码块&#x2F;方法锁起来</li>
<li>如果synchronized修饰的是实例方法，对应的锁则是对象实例</li>
<li>如果synchronized修饰的是静态方法，对应的锁则是当前类的Class实例</li>
<li>如果synchronized修饰的是代码块，对应的锁则是传入synchronized的对象实例</li>
</ol>
<h2 id="嗯，要不你来讲讲synchronized的原理呗？"><a href="#嗯，要不你来讲讲synchronized的原理呗？" class="headerlink" title="嗯，要不你来讲讲synchronized的原理呗？"></a>嗯，要不你来讲讲synchronized的原理呗？</h2><ol>
<li>通过反编译可以发现</li>
<li>当修饰方法时，编译器会生成ACC_SYNCHRONIZED关键字用来标识</li>
<li>当修饰代码块时，会依赖monitorenter和monitorexit指令</li>
<li>但前面已经说了，无论synchronized修饰的是方法还是代码块，对应的锁都是一个实例（对象）</li>
<li>在内存中，对象一般由三部分组成，分别是对象头、对象实际数据和对齐填充</li>
<li>重点在于对象头，对象头又由几部分组成，但我们重点关注对象头Mark Word的信息就好了</li>
<li>Mark Word会记录对象关于锁的信息</li>
<li>又因为每个对象都会有一个与之对应的monitor对象，monitor对象中存储着当前持有锁的线程以及等待锁的线程队列</li>
<li>了解Mark Word和monitor对象是理解synchronized原理的前提</li>
</ol>
<h2 id="嗯，听说synchronized锁在JDK1-6之后做了很多的优化，这块你了解多少呢？"><a href="#嗯，听说synchronized锁在JDK1-6之后做了很多的优化，这块你了解多少呢？" class="headerlink" title="嗯，听说synchronized锁在JDK1.6之后做了很多的优化，这块你了解多少呢？"></a>嗯，听说synchronized锁在JDK1.6之后做了很多的优化，这块你了解多少呢？</h2><ol>
<li>其实是这样的，在JDK1.6之前是重量级锁，线程进入同步代码块&#x2F;方法时</li>
<li>monitor对象就会把当前进入线程的Id进行存储，设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中</li>
<li>它加锁是依赖底层操作系统的mutex相关指令实现，所以会有用户态和内核态之间的切换，性能损耗十分明显</li>
<li>而JDK1.6以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，就没有切换的消耗</li>
<li>所以，Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</li>
</ol>
<h3 id="简单来说说偏向锁、轻量级锁和重量级锁吧"><a href="#简单来说说偏向锁、轻量级锁和重量级锁吧" class="headerlink" title="简单来说说偏向锁、轻量级锁和重量级锁吧"></a>简单来说说偏向锁、轻量级锁和重量级锁吧</h3><ol>
<li>偏向锁指的就是JVM会认为只有某个线程才会执行同步代码（没有竞争的环境）</li>
<li>所以在Mark Word会直接记录线程ID，只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码</li>
<li>如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码</li>
<li>如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为轻量级锁。</li>
<li>在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，LockRecord会把 Mark Word的信息拷贝进去，且有个Owner指针指向加锁的对象由由</li>
<li>线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的LockRecord，假设CAS修改成功，则获取得到轻量级锁</li>
<li>假设修改失败，则自旋（重试），自旋一定次数后，则升级为重量级锁</li>
<li>简单总结一下<ul>
<li>synchronized锁原来只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗十分明显</li>
<li>重量级锁用到monitor对象而偏向锁则在Mark Word记录线程ID进行比对、轻量级锁则是拷贝Mark Word到Lock Record，用CAS+自旋的方式获取。</li>
</ul>
</li>
<li>引入了偏向锁和轻量级锁，就是为了在不同的使用场景使用不同的锁，进而提高效率。<br>锁只有升级，没有降级<ul>
<li>只有一个线程进入临界区，偏向锁</li>
<li>多个线程交替进入临界区，轻量级锁</li>
<li>多线程同时进入临界区，重量级锁</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/3c567306/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3c567306/" class="post-title-link" itemprop="url">8、【对线面试官】AQS & ReentrantLock</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 09:48:07" itemprop="dateModified" datetime="2022-03-10T09:48:07+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/3c567306/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/3c567306/" data-xid="/posts/3c567306/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="8、【对线面试官】AQS-amp-ReentrantLock"><a href="#8、【对线面试官】AQS-amp-ReentrantLock" class="headerlink" title="8、【对线面试官】AQS &amp; ReentrantLock"></a>8、【对线面试官】AQS &amp; ReentrantLock</h1><h2 id="今天我们来聊聊lock锁吧？"><a href="#今天我们来聊聊lock锁吧？" class="headerlink" title="今天我们来聊聊lock锁吧？"></a>今天我们来聊聊lock锁吧？</h2><h2 id="你知道什么叫做公平和非公平锁吗"><a href="#你知道什么叫做公平和非公平锁吗" class="headerlink" title="你知道什么叫做公平和非公平锁吗"></a>你知道什么叫做公平和非公平锁吗</h2><ol>
<li>公平锁指的就是：在竞争环境下，先到临界区的线程比后到的线程一定更快地获取得到锁</li>
<li>那非公平就很好理解了：先到临界区的线程未必比后到的线程更快地获取得到锁</li>
</ol>
<h2 id="如果让你实现的话，你怎么实现公平和非公平锁？"><a href="#如果让你实现的话，你怎么实现公平和非公平锁？" class="headerlink" title="如果让你实现的话，你怎么实现公平和非公平锁？"></a>如果让你实现的话，你怎么实现公平和非公平锁？</h2><ol>
<li>公平锁可以把竞争的线程放在一个先进先出的队列上</li>
<li>只要持有锁的线程执行完了，唤醒队列的下一个线程去获取锁就好了</li>
<li>非公平锁的概念上面已经提到了：后到的线程可能比前到临界区的线程获取得到锁</li>
<li>那实现也很简单，线程先尝试能不能获取得到锁，如果获取得到锁了就执行同步代码了</li>
<li>如果获取不到锁，那就再把这个线程放到队列呗</li>
<li>所以公平和非公平的区别就是：线程执行同步代码块时，是否会去尝试获取锁。</li>
<li>如果会尝试获取锁，那就是非公平的。如果不会尝试获取锁，直接进队列，再等待唤醒，那就是公平的。</li>
</ol>
<h2 id="为什么要进队列呢？线程一直尝试获取锁不就行了么？"><a href="#为什么要进队列呢？线程一直尝试获取锁不就行了么？" class="headerlink" title="为什么要进队列呢？线程一直尝试获取锁不就行了么？"></a>为什么要进队列呢？线程一直尝试获取锁不就行了么？</h2><ol>
<li>一直尝试获取锁，专业点就叫做自旋，需要耗费资源的。</li>
<li>多个线程一直在自旋，而且大多数都是竞争失败的，哪有人会这样实现的</li>
<li>不会吧，不会吧，你不会就是这样实现的吧</li>
</ol>
<h2 id="那上次面试所问的synchronized锁是公平的还是非公平的？"><a href="#那上次面试所问的synchronized锁是公平的还是非公平的？" class="headerlink" title="那上次面试所问的synchronized锁是公平的还是非公平的？"></a>那上次面试所问的synchronized锁是公平的还是非公平的？</h2><ol>
<li>非公平的。</li>
<li>偏向锁很好理解，如果当前线程ID与markword存储的不相等，则CAS尝试更换线程ID，CAS成功就获取得到锁了</li>
<li>CAS失败则升级为轻量级锁</li>
<li>轻量级锁实际上也是通过CAS来抢占锁资源（只不过多了拷贝Mark Word到Lock Record的过程）</li>
<li>抢占成功到锁就归属给该线程了，但自旋失败一定次数后升级重量级锁</li>
<li>重量级锁通过monitor对象中的队列存储线程，但线程进入队列前，还是会先尝试获取得到锁，如果能获取不到才进入线程等待队列中</li>
<li>综上所述，synchronized无论处理哪种锁，都是先尝试获取，获取不到才升级||放到队列上的，所以是非公平的</li>
</ol>
<h2 id="嗯，讲得挺仔细的。AQS你了解吗？"><a href="#嗯，讲得挺仔细的。AQS你了解吗？" class="headerlink" title="嗯，讲得挺仔细的。AQS你了解吗？"></a>嗯，讲得挺仔细的。AQS你了解吗？</h2><ol>
<li>嗯嗯，AQS全称叫做AbstractQueuedSynchronizer</li>
<li>是可以给我们实现锁的一个 「框架」，内部实现的关键就是维护了一个先进先出的队列以及state状态变量</li>
<li>先进先出队列存储的载体叫做Node节点，该节点标识着当前的状态值、是独占还是共享模式以及它的前驱和后继节点等等信息</li>
<li>简单理解就是：AQS定义了模板，具体实现由各个子类完成。</li>
<li>总体的流程可以总结为：会把需要等待的线程以Node的形式放到这个先进先出的队列上，state变量则表示为当前锁的状态。</li>
<li>像ReentrantLock、 ReentrantReadWrite Lock、 CountDownLatch、 Semaphore 这些常用的实现类都是基于AQS实现的</li>
<li>AQS支持两种模式：独占（锁只会被一个线程独占）和共享（多个线程可同时执行）</li>
</ol>
<h2 id="你以ReentrantLock来讲讲加锁和解锁的过程呗"><a href="#你以ReentrantLock来讲讲加锁和解锁的过程呗" class="headerlink" title="你以ReentrantLock来讲讲加锁和解锁的过程呗"></a>你以ReentrantLock来讲讲加锁和解锁的过程呗</h2><ul>
<li>以非公平锁为了，我们在外界调用lock方法的时候，源码是这样实现的<ol>
<li>CAS尝试获取锁，获取成功则可以执行同步代码</li>
<li>CAS获取失败，则调用acquire方法acquire方法实际上就是AQS的模板方法</li>
<li>acquire首先会调用子类的tryAcquire 方法（又回到了ReentrantLock中）</li>
<li>tryAcquire方法实际上会判断当前的state是否等于0，等于0说明没有线程持有锁，则又尝试CAS直接获取锁</li>
<li>如果CAS获取成功，则可以执行同步代码</li>
<li>如果CAS获取失败，那判断当前线程是否就持有锁，如果是持有的锁，那更新state的值，获取得到锁（这里其实就是处理可重入的逻辑）</li>
<li>CAS失败&amp;&amp;非重入的情况，则回到try Acquire方法执行「入队列」的操作</li>
<li>将节点入队列之后，会判断「前驱节点」是不是头节点，如果是头结点又会用CAS尝试获取锁</li>
<li>如果是「前驱节点」是头节点并获取得到锁，则把当前节点设置为头结点，并且将前驱节点置空（实际上就是原有的头节点已经释放锁了）</li>
<li>没获取得到锁，则判断前驱节点的状态是否为SIGNAL，如果不是，则找到合法的前驱节点，并使用CAS将状态设置为SIGNAL</li>
<li>最后调用park将当前线程挂起</li>
</ol>
</li>
</ul>
<h2 id="你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。"><a href="#你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。" class="headerlink" title="你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。"></a>你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。</h2><p>压缩后：当线程CAS获取锁失败，将当前线程入队列，把前驱节点状态设置为SIGNAL状态，并将自己挂起。</p>
<h2 id="为什么要设置前驱节点为-SIGNAL状态，有啥用？"><a href="#为什么要设置前驱节点为-SIGNAL状态，有啥用？" class="headerlink" title="为什么要设置前驱节点为 SIGNAL状态，有啥用？"></a>为什么要设置前驱节点为 SIGNAL状态，有啥用？</h2><ol>
<li>其实就是表示后继节点需要被唤醒,你咋啥都不知道啊？跟你沟通有点烦.我先把解锁的过程说下吧<ul>
<li>外界调用unlock方法时，实际上会调用AQS的release方法，而release方法会调用子类tryRelease方法（又回到了ReentrantLock中）</li>
<li>tryRelease会把state一直减（锁重入可使state&gt;1），直至到0，说明当前线程已经把锁释放了</li>
<li>随后从队尾往前找节点状态需要&lt;0，并离头节点最近的节点进行唤醒</li>
</ul>
</li>
<li>唤醒之后，被唤醒的线程则尝试使用CAS获取锁，假设获取锁得到则把头节点给干掉，把自己设置为头节点成</li>
<li>解锁的逻辑非常简单哈</li>
<li>压缩一下：把state置0，唤醒头结点下一个合法的节点，被唤醒的节点线程自然就会去获取锁</li>
<li>回到上一个问题，为什么要设置前驱节点为SIGNAL状态</li>
<li>其实归终结底就是为了判断节点的状态，去做些处理。</li>
<li>Node中节点的状态有4种，分别是：CA NCELLED(1)、 SIGNAL(-1)、 CONDITI ON（-2）、 PROPAGATE（-3）和0。</li>
<li>在ReentrantLock解锁的时候，会判断节点的状态是否小于0，小于等于0才说明需要被唤醒</li>
<li>另外一提的是：公平锁的实现与非公平锁是很像的，只不过在获取锁时不会直接尝试使用CAS来获取锁。</li>
<li>只有当队列没节点并且state为0时才会去获取锁，不然都会把当前线程放到队列中</li>
</ol>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/eK7qe3_20211027174549.png"></p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/6e379f18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6e379f18/" class="post-title-link" itemprop="url">java学习路线问题整理</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-13 12:56:04" itemprop="dateModified" datetime="2022-03-13T12:56:04+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/6e379f18/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/6e379f18/" data-xid="/posts/6e379f18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>123k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:52</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java学习路线问题整理"><a href="#java学习路线问题整理" class="headerlink" title="java学习路线问题整理"></a>java学习路线问题整理</h1><p><img src="https://pic1.zhimg.com/50/v2-62586d6789e1a081cc3dc6efd7bdd289_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-62586d6789e1a081cc3dc6efd7bdd289_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a><strong>Java 基础</strong></h2><p>为了能让自己写出更优秀的代码，《Effective Java》、《重构》 这两本书没事也可以看</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>一些关于并发的小问题，拿来自测：</p>
<h4 id="一、什么是线程和进程-线程与进程的关系-区别及优缺点？"><a href="#一、什么是线程和进程-线程与进程的关系-区别及优缺点？" class="headerlink" title="一、什么是线程和进程? 线程与进程的关系,区别及优缺点？"></a>一、什么是线程和进程? 线程与进程的关系,区别及优缺点？</h4><p>*<em>Linux</em>***的进程、线程、文件描述符是 什么</p>
<p>**答案:<strong>在</strong> <strong>Linux</strong> <strong>系统中，进程和线程几乎没有区别</strong>。</p>
<p>Linux 中的进程就是一个数据结构，看明白就可以理解文件描述符、重定 向、管道命令的底层工作原理，最后我们从操作系统的角度看看为什么说线 程和进程基本没有区别。</p>
<h5 id="1、进程是什么"><a href="#1、进程是什么" class="headerlink" title="1、进程是什么"></a><strong>1、进程是什么</strong></h5><p>首先，抽象地来说，我们的计算机就是这个东⻄:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FsPOLs_20210528153018.png" alt="进程"></p>
<p>   这个大的矩形表示计算机的<strong>内存空间</strong>，其中的小矩形代表<strong>进程</strong>，左下角的圆 形表示<strong>磁盘</strong>，右下角的图形表示一些<strong>输入输出设备</strong>，比如鼠标键盘显示器等 等。另外，注意到内存空间被划分为了两块，上半部分表示<strong>用户空间</strong>，下半部分表示<strong>内核空间</strong>。</p>
<p>   用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组， 这个数组肯定存在用户空间;内核空间存放内核进程需要加载的系统资源， 这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内 核空间的资源，比如一些动态链接库等等。</p>
<p>   我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运 行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新 建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后 执行，最后退出。</p>
<p>   <strong>你编译好的那个可执行程序只是一个文件</strong>，不是进程，可执行文件必须要载 入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的， 每个进程都有它的固有属性，比如进程号(PID)、进程状态、打开的文件 等等，进程创建好之后，读入你的程序，你的程序才被系统执行。</p>
<p>   那么，操作系统是如何创建进程的呢?<strong>对于操作系统，进程就是一个数据结 构</strong>，我们直接来看 Linux 的源码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span> </span><br><span class="line">    <span class="comment">// 进程状态</span></span><br><span class="line">	  <span class="type">long</span> state; </span><br><span class="line">  	<span class="comment">// 虚拟内存结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> </span><br><span class="line">  	<span class="comment">// 进程号</span></span><br><span class="line">	  <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 指向父进程的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> </span><br><span class="line">  	<span class="comment">// 子进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span> </span><br><span class="line">  	<span class="comment">// 存放文件系统信息的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="comment">// 一个数组，包含该进程打开的文件指针 </span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>task_struct 就是Linux内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，我这里就截取了一小部分比较常⻅的。</p>
<p>   其中比较有意思的是 mm 指针和 files 指针。 mm 指向的是进程的虚拟内 存，也就是载入资源和可执行文件的地方; files 指针指向一个数组，这 个数组里装着所有该进程打开的文件的指针。</p>
<h5 id="2、文件描述符是什么"><a href="#2、文件描述符是什么" class="headerlink" title="2、文件描述符是什么"></a><strong>2、文件描述符是什么</strong></h5><p>   先说 files ，它是一个文件指针数组。一般来说，一个进程会 从 files[0] 读取输入，将输出写入 files[1] ，将错误信息写 入 files[2] 。</p>
<p>   举个例子，以我们的角度 C 语言的 printf 函数是向命令行打印字符，但是 从进程的角度来看，就是向 files[1] 写入数据;同理， scanf函数就是进程试图从files[0] 这个文件中读取数据。</p>
<p>   <strong>每个进程被创建时，</strong> <strong>files</strong> <strong>的前三位被填入默认值，分别指向标准输入 流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件 指针数组的索引</strong>，所以程序的文件描述符默认情况下 0 是输入，1 是输出， 2 是错误。</p>
<p>   我们可以重新画一幅图:</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210528160949534_20210528160949.png"></p>
<p>   对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器， 所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的 进程需要通过「系统调用」让内核进程访问硬件资源。</p>
<p>   PS:不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读 和写。</p>
<p>   如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到 files 的第 4 个位置:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210528161138345_20210528161138.png"></p>
<p>   明白了这个原理，<strong>输入重定向</strong>就很好理解了，程序想读取数据的时候就会 去 files[0] 读取，所以我们只要把 files[0] 指向一个文件，那么程序就会 从这个文件中读取数据，而不是从键盘:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command &lt; file.txt</span><br></pre></td></tr></table></figure>
<p>同理，<strong>输出重定向</strong>就是把 files[1] 指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中:</p>
<p>错误重定向也是一样的，就不再赘述。<br><strong>管道符</strong>其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起 一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美:</p>
<p>   $ command &gt; file.txt</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/cBsve1_20210528161752.png"></p>
<p>到这里，你可能也看出「Linux 中一切皆文件」设计思路的高明了，不管是 设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一 装进一个简单的 files 数组，进程通过简单的文件描述符访问相应资源， 具体细节交于操作系统，有效解耦，优美高效。</p>
<h5 id="3、线程是什么"><a href="#3、线程是什么" class="headerlink" title="3、线程是什么"></a><strong>3、线程是什么</strong></h5><p>首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。</p>
<p>为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来 看，并没有把线程和进程区别对待。</p>
<p>我们知道系统调用 fork() 可以新建一个子进程，函数 pthread() 可以新建 一个线程。<strong>但无论线程还是进程，都是用task_struct结构表示的，唯一的 区别就是共享的数据区域不同</strong>。</p>
<p>   换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进 程是共享的，而子进程是拷⻉副本，而不是共享。就比如说， mm 结构 和 files 结构在线程中都是共享的，我画两张图你就明白了:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CJSUA2_20210528162328.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/AHziKB_20210528162403.png"></p>
<p>   所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写 入数据，否则可能造成数据错乱。</p>
<p>   那么你可能问，<strong>既然进程和线程差不多，而且多进程数据不共享，即不存在 数据错乱的问题，为什么多线程的使用比多进程普遍得多呢</strong>?</p>
<p>   因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元， 我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一 个账户的拷⻉，每个拷⻉账户减少十元。</p>
<p>   当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对 其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其 特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复 杂度。</p>
<p>   在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷 ⻉的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父 进程的内存空间，而是等到需要写操作时才去复制。<strong>所以</strong> <strong>Linux</strong> <strong>中新建进 程和新建线程都是很迅速的</strong>。</p>
<h4 id="二、说说并发与并行的区别"><a href="#二、说说并发与并行的区别" class="headerlink" title="二、说说并发与并行的区别?"></a>二、说说并发与并行的区别?</h4><ul>
<li>并发:一个处理器同时处理多个任务。</li>
<li>并行:多个处理器或者是多核的处理器同时处理多个不同的任务.</li>
</ul>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．</p>
</blockquote>
<ul>
<li>并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</li>
<li>并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</li>
</ul>
<blockquote>
<p>来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/r17aCh_20210603225408.png" alt="img"></p>
<p align="center">并发与并行的区别</p>

<p>下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况。假设每个核心有两个线程，那么每个CPU中两个线程会交替并发，两个CPU之间的操作会并行运算。单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，其本身运行效率并没有提高，多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/XjIFCX_20210603225422.png" alt="img"></p>
<center>双核四线程运行示意图</center>



<h4 id="三、为什么要使用多线程呢"><a href="#三、为什么要使用多线程呢" class="headerlink" title="三、为什么要使用多线程呢?"></a>三、为什么要使用多线程呢?</h4><h5 id="从系统应用上来思考："><a href="#从系统应用上来思考：" class="headerlink" title="从系统应用上来思考："></a>从系统应用上来思考：</h5><ul>
<li>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间切换和调度的成本远远小于进程。另外，多核 CPU 时代，意味着多个线程可以同时运行，这减少了线程上下文切换的开销；</li>
<li>如今的系统，动不动就要求百万级甚至亿万级的并发量，而多线程并发编程，正是开发高并发系统的基础，利用好多线程机制，可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h5 id="从计算机背后来探讨："><a href="#从计算机背后来探讨：" class="headerlink" title="从计算机背后来探讨："></a>从计算机背后来探讨：</h5><p><strong>单核时代：</strong> 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程工作的时候，会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。可以简单地理解成，这两者的利用率最高都是 50%左右。但是当有两个线程的时候就不一样了，一个线程执行 CPU 计算时，另外一个线程就可以进行 IO 操作，这样 CPU 和 IO 设备两个的利用率就可以在理想情况下达到 100%；</p>
<p><strong>多核时代：</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只有一个 CPU 核心被利用到，而创建多个线程，就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p>
<h4 id="四、创建线程有哪几种方式？（a-继承-Thread-类-b-实现-Runnable-接口-c-使用-Executor-框架-d-使用-FutureTask）"><a href="#四、创建线程有哪几种方式？（a-继承-Thread-类-b-实现-Runnable-接口-c-使用-Executor-框架-d-使用-FutureTask）" class="headerlink" title="四、创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）"></a>四、创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）</h4><h4 id="五、说说线程的生命周期和状态"><a href="#五、说说线程的生命周期和状态" class="headerlink" title="五、说说线程的生命周期和状态?"></a>五、说说线程的生命周期和状态?</h4><p>那么现在我们来了解线程一个完整的生命周期的运行过程，与下图可以看出有：新建 - 就绪 - 运行 - 阻塞 - 死亡五个过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/RqeQ7h_20210603234327.png" alt="img"></p>
<p>下面我们一个一个的来介绍：</p>
<ul>
<li>新建：刚刚创建还在内存当中，还没有在可调度线程池中，还不能被cpu调度执行工作。</li>
<li>就绪：进入调度池，可被调度。</li>
<li>运行：CPU负责调度”可调度线程池”中的处于”就绪状态”的线程，线程执行结束之前,状态可能会在”就绪”和”运行”之间来回的切换。“就绪”和”运行”之间的状态切换由CPU来完成,程序员无法干涉</li>
<li>阻塞：正在运行的线程,当满足某个条件时,可以用休眠或者锁来阻塞线程的执行，被移出调度池，进入内存，不可执行。</li>
<li>死亡：分为两种情况。正常死亡，线程执行结束。非正常死亡，程序突然崩溃&#x2F;当满足某个条件后，在线程内部强制线程退出,调用exit方法。<h5 id="exit方法的作用和总结"><a href="#exit方法的作用和总结" class="headerlink" title="exit方法的作用和总结"></a>exit方法的作用和总结</h5></li>
</ul>
<ol>
<li><p>使当前线程退出.</p>
</li>
<li><p>不能在主线程中调用该方法，会使主线程退出.</p>
</li>
<li><p>当前线程死亡之后,这个线程中的代码都不会被执行.</p>
</li>
<li><p>在调用此方法之前一定要注意释放之前由C语言框架创建的对象.</p>
</li>
</ol>
<h4 id="六、什么是上下文切换"><a href="#六、什么是上下文切换" class="headerlink" title="六、什么是上下文切换?"></a>六、什么是上下文切换?</h4><p>   现在<strong>linux</strong>是大多基于抢占式，CPU给每个任务一定的服务时间，当时间片轮转的时候，需要把当前状态保存下来，同时加载下一个任务，这个过程叫做<strong>上下文切换</strong>。时间片轮转的方式，使得多个任务利用一个CPU执行成为可能，但是保存现场和加载现场，也带来了性能消耗。 那线程上下文切换的次数和时间以及性能消耗如何看呢？</p>
<p>   上下文切换的性能消耗在哪里呢？<br>   context switch过高，会导致CPU像个搬运工，频繁在寄存器和运行队列直接奔波 ，更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。</p>
<p>   引起上下文切换的原因有哪些？<br>   对于抢占式操作系统而言， 大体有几种：<br>   1、当前任务的时间片用完之后，系统CPU正常调度下一个任务；<br>   2、当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；<br>   3、多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；<br>   4、用户代码挂起当前任务，让出CPU时间；<br>   5、硬件中断；<br>   监测Linux的应用的时候，当CPU的利用率非常高，但是系统的性能却上不去的时候，不妨监控一下线程&#x2F;进程的切换，看看是不是context switching导致的overhead过高。<br>   常用命令： pidstat vmstat</p>
<h4 id="七、什么是线程死锁-如何避免死锁"><a href="#七、什么是线程死锁-如何避免死锁" class="headerlink" title="七、什么是线程死锁?如何避免死锁?"></a>七、什么是线程死锁?如何避免死锁?</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p> 当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<p>下面用一个非常简单的死锁示例来帮助你理解死锁的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取String.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">线程b尝试获取String.class</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">无限阻塞下去</span><br></pre></td></tr></table></figure>

<h5 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h5><p>教科书般的回答应该是，结合“哲学家就餐“模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p>
<p>造成死锁必须达成的4个条件（原因）：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个线程使用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p>
<ol>
<li>互斥条件 —&gt; 独占锁的特点之一。</li>
<li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li>
<li>不剥夺条件 —&gt; 独占锁的特点之一。</li>
<li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li>
</ol>
<p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p>
<p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p>
<p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">td2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>是否能够简单明了的在面试中阐述清楚死锁产生的原因，并给出解决死锁的方案，可以体现程序员在面对对并发问题时思路是否清晰，对并发的基础掌握是否牢固等等。<br> 而且在实际项目中并发模块的逻辑往往比本文的示例复杂许多，所以写并发应用之前一定要充分理解本文所总结的要点，并切记，并发程序编程在不显著影响程序性能的情况下，一定要尽可能的保守。</p>
<h4 id="八、说说-sleep-方法和-wait-方法区别和共同点"><a href="#八、说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="八、说说 sleep() 方法和 wait() 方法区别和共同点?"></a>八、说说 sleep() 方法和 wait() 方法区别和共同点?</h4><h5 id="1-方法来源区别"><a href="#1-方法来源区别" class="headerlink" title="1.方法来源区别"></a>1.方法来源区别</h5><p>wait方法定义在Object上,Thread.sleep()定义在Thread上(这很重要,定义决定作用范围)</p>
<h5 id="2-关于锁和cpu"><a href="#2-关于锁和cpu" class="headerlink" title="2.关于锁和cpu"></a>2.关于锁和cpu</h5><p>结论:二者都释放cpu,wait()释放锁,Thread.sleep()不会释放锁.<br> 解释如下:<br> 1.别管是Object.wait()还是Thread.sleep(),都是暂停执行,所以这里都会释放cpu.<br> 2.Object.wait()方法是对象拥有,然后对象锁又是在synchronized同步代码块中使用,所以Object.wait()方法拥有锁的控制权,所以他会释放锁资源.而Thread.sleep()是Thread上的静态方法,所以只能使当前线程睡眠,但是它和锁没有任何关系,所以就没有锁的释放这一问题.</p>
<h5 id="3-作用范围"><a href="#3-作用范围" class="headerlink" title="3.作用范围"></a>3.作用范围</h5><ul>
<li><p>Object.wait()方法只能在synchronized快中调用,并且需要和notify和notifyAll配合使用.</p>
</li>
<li><p>Thread.sleep（）是可以在任何上下文调用的,注意是暂停当前的线程<br> 所以就方法而言,Object.wait()主要用在多线程之间的协同工作,Thread.sleep（）主要是控制一个线程的执行时间长短.</p>
<h5 id="4-关于异常"><a href="#4-关于异常" class="headerlink" title="4 关于异常"></a>4 关于异常</h5><p>Object.wait()方法和Thread.sleep()都抛出 InterruptedException,并且方法定义为final,<br> 所以方法不能被重写,那么在使用 该方法时就只能 try()catch(){}异常,(为什么说只能try,因为如果不捕获异常,那么也意味着你的方法抛出的异常就只能是InterruptedException,或者它的子类,所以这里一般都是捕获异常并处理异常,可以在catch中抛出其他异常)</p>
<h4 id="九、synchronized-关键字、volatile-关键字"><a href="#九、synchronized-关键字、volatile-关键字" class="headerlink" title="九、synchronized 关键字、volatile 关键字"></a>九、synchronized 关键字、volatile 关键字</h4></li>
<li><p>volatile是通知jvm当前变量在寄存器或者cpu中的值是不确定的，需要从主存中读取。不会阻塞线程。</p>
</li>
<li><p>synchronized则是通过锁机制来控制变量是否可以访问。当变量被锁时，其他线程访问变量将被阻塞，直至锁释放。</p>
</li>
</ul>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h5><ol>
<li>volatile保证其他线程对这个变量操作时是立即可见的，即操作的是从内存中读取的最新值</li>
<li>无法保证原子性</li>
<li>只能修饰变量</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="built_in">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;----&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        test.increase();        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台输出：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/A70Fzt_20210607142025.png" alt="img"></p>
<p>控制台输出</p>
<ul>
<li>使用场景(DCL双重检测锁)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h5><ol>
<li>保证原子性</li>
<li>即可修饰变量也可修饰方法</li>
<li>会阻塞线程<h6 id="1）synchronized非静态方法"><a href="#1）synchronized非静态方法" class="headerlink" title="1）synchronized非静态方法"></a>1）synchronized非静态方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;increase1----&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;increase2----&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    test.increase1();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    test.increase2();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>控制台输出：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/p830x9_20210607142306.png" alt="img"></p>
<ul>
<li>结论：</li>
</ul>
<p>如果一个对象有多个synchronized方法，多个线程同时调用该对象的方法，将会同步执行，即同时只能有一个synchronized方法被调用，其他调用将被阻塞直至该方法执行完</p>
<h6 id="2）synchronized静态方法"><a href="#2）synchronized静态方法" class="headerlink" title="2）synchronized静态方法"></a>2）synchronized静态方法</h6><blockquote>
<p>懒。。  直接给结论了</p>
</blockquote>
<p>synchronized静态方法和非静态方法的区别在于给方法上锁的对象不一样，非静态方法是给调用的对象上锁，静态方法是给类的Class对象上锁</p>
<h6 id="3）synchronized块"><a href="#3）synchronized块" class="headerlink" title="3）synchronized块"></a>3）synchronized块</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase1</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase1----------&gt; start&quot;</span>);</span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;increase1----&gt;&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase1----------&gt; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase2</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase2----------&gt; start&quot;</span>);</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;increase2----&gt;&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;increase2----------&gt; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    test.increase1();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    test.increase2();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台输出：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BgNds7_20210607142434.png" alt="img"></p>
<ul>
<li>结论</li>
</ul>
<p><strong>synchronized方法</strong>是控制同时只能有一个线程执行synchronized方法；<strong>synchronized块</strong>是控制同时只能有一个线程执行synchronized块中的内容</p>
<h4 id="十、ThreadLocal-有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？"><a href="#十、ThreadLocal-有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？" class="headerlink" title="十、ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？"></a>十、ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？</h4><h5 id="ThreadLoacl是什么"><a href="#ThreadLoacl是什么" class="headerlink" title="ThreadLoacl是什么"></a>ThreadLoacl是什么</h5><p>在了解ThreadLocal之前，我们先了解下什么是<strong>线程封闭</strong></p>
<blockquote>
<p>把对象封闭在一个线程里，即使这个对象不是线程安全的，也不会出现并发安全问题。</p>
</blockquote>
<p>实现线程封闭大致有三种方式：</p>
<ul>
<li>Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担，不推荐使用</li>
<li>栈封闭：就是用<strong>栈</strong>（stack）来保证线程安全</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">testThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">    sb.<span class="built_in">append</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder是线程不安全的，但是它只是个<strong>局部变量</strong>，局部变量存储在<strong>虚拟机栈</strong>，<strong>虚拟机栈</strong>是线程隔离的，所以不会有线程安全问题</p>
<ul>
<li>ThreadLocal线程封闭：简单易用</li>
</ul>
<p>第三种方式就是通过ThreadLocal来实现线程封闭，线程封闭的指导思想是<strong>封闭</strong>，而不是共享。所以说ThreadLocal是用来解决<strong>变量共享</strong>的并发安全问题，多少有些不精确。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>JDK1.2开始提供的java.lang.ThreadLocal的使用方式非常简单</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line"></span><br><span class="line">        final ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        threadLocal.<span class="keyword">set</span>(<span class="string">&quot;main-thread : Hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取不到主线程设置的值，所以为null</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">            threadLocal.<span class="keyword">set</span>(<span class="string">&quot;sub-thread : World&quot;</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 让子线程先执行完成，再继续执行主线</span></span><br><span class="line">        thread.<span class="keyword">join</span>();</span><br><span class="line">        <span class="comment">// 获取到的是主线程设置的值，而不是子线程设置的</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        threadLocal.<span class="keyword">remove</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line">sub-thread : World</span><br><span class="line">main-thread : Hello</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>运行结果说明了ThreadLocal只能获取本线程设置的值，也就是线程封闭。基本上，ThreadLocal对外提供的方法只有三个get()、set(T)、remove()。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>使用方式非常简单，所以我们来看看ThreadLocal的源码。ThreadLocal内部定义了一个静态ThreadLocalMap类，ThreadLocalMap内部又定义了一个Entry类，这里只看一些主要的属性和方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.<span class="built_in">currentThread</span>();</span><br><span class="line">        ThreadLocalMap map = <span class="built_in">getMap</span>(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.<span class="built_in">getEntry</span>(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                @<span class="built_in">SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setInitialValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.<span class="built_in">currentThread</span>();</span><br><span class="line">        ThreadLocalMap map = <span class="built_in">getMap</span>(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null)</span><br><span class="line">            map.<span class="built_in">set</span>(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">createMap</span>(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = <span class="built_in">getMap</span>(Thread.<span class="built_in">currentThread</span>());</span><br><span class="line">         <span class="keyword">if</span> (m != null)</span><br><span class="line">             m.<span class="built_in">remove</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这里可以看出ThreadLocalMap对象是被Thread类持有的</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="built_in">ThreadLocalMap</span>(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类ThreadLocalMap</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            <span class="comment">// 内部类Entity，实际存储数据的地方</span></span><br><span class="line">            <span class="comment">// Entry的key是ThreadLocal对象，不是当前线程ID或者名称</span></span><br><span class="line">            <span class="built_in">Entry</span>(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里维护的是Entry数组</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的源码，可以大致画出ThreadLocal在虚拟机内存中的结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Yr7agv_20210607143151.png" alt="img"></p>
<p>实线箭头表示强引用，虚线箭头表示弱引用。需要注意的是：</p>
<ul>
<li>ThreadLocalMap虽然是在ThreadLocal类中定义的，但是实际上被Thread持有。</li>
<li>Entry的key是（虚引用的）ThreadLocal对象，而不是当前线程ID或者线程名称。</li>
<li>ThreadLocalMap中持有的是Entry数组，而不是Entry对象。</li>
</ul>
<p>对于第一点，ThreadLocalMap被Thread持有是为了实现每个线程都有自己独立的ThreadLocalMap对象，以此为基础，做到线程隔离。第二点和第三点理解，我们先来想一个问题，如果同一个线程中定义了多个ThreadLocal对象，内存结构应该是怎样的？此时再来看一下ThreadLocal.set(T)方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据线程对象获取ThreadLocalMap对象（ThreadLocalMap被Thread持有）</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果ThreadLocalMap存在，则直接插入；不存在，则新建ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果程序定义了多个ThreadLocal，会共用一个ThreadLocalMap对象，所以内存结构应该是这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/t7McjA_20210607143222.png" alt="img"></p>
<p>这个内存结构图解释了第二点和第三点。假设Entry中key为当前线程ID或者名称的话，那么程序中定义多个ThreadLocal对象时，Entry数组中的所有Entry的key都一样（或者说只能存一个value）。ThreadLocalMap中持有的是Entry数组，而不是Entry，则是因为程序可定义多个ThreadLocal对象，自然需要一个数组。</p>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><strong>ThreadLocal会发生内存泄漏吗？</strong></p>
<blockquote>
<p>会</p>
</blockquote>
<p>仔细看下ThreadLocal内存结构就会发现，Entry数组对象通过ThreadLocalMap最终被Thread持有，并且是强引用。也就是说Entry数组对象的生命周期和当前线程一样。即使ThreadLocal对象被回收了，Entry数组对象也不一定被回收，这样就有可能发生内存泄漏。ThreadLocal在设计的时候就提供了一些补救措施：</p>
<ul>
<li>Entry的key是弱引用的ThreadLocal对象，很容易被回收，导致key为null（但是value不为null）。所以在调用get()、set(T)、remove()等方法的时候，会自动清理key为null的Entity。</li>
<li>remove()方法就是用来清理无用对象，防止内存泄漏的。所以每次用完ThreadLocal后需要手动remove()。</li>
</ul>
<p><strong>有些文章认为是弱引用导致了内存泄漏，其实是不对的。假设把弱引用变成强引用，这样无用的对象key和value都不为null，反而不利于GC，只能通过remove()方法手动清理，或者等待线程结束生命周期。也就是说ThreadLocalMap的生命周期由持有它的线程来决定，线程如果不进入terminated状态，ThreadLocalMap就不会被GC回收，这才是ThreadLocal内存泄露的原因。</strong></p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>维护JDBC的java.sql.Connection对象，因为每个线程都需要保持特定的Connection对象。</li>
<li>Web开发时，有些信息需要从controller传到service传到dao，甚至传到util类。看起来非常不优雅，这时便可以使用ThreadLocal来优雅的实现。</li>
<li>包括线程不安全的工具类，比如Random、SimpleDateFormat等</li>
</ul>
<h5 id="与synchronized的关系"><a href="#与synchronized的关系" class="headerlink" title="与synchronized的关系"></a>与synchronized的关系</h5><p>有些文章拿ThreadLocal和synchronized比较，其实它们的实现思想不一样。</p>
<ul>
<li>synchronized是同一时间最多只有一个线程执行，所以变量只需要存一份，算是一种时间换空间的思想</li>
<li>ThreadLocal是多个线程互不影响，所以每个线程存一份变量，算是一种空间换时间的思想</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>ThreadLocal是一种隔离的思想，当一个变量需要进行线程隔离时，就可以考虑使用ThreadLocal来优雅的实现。</p>
<h4 id="十一、为什么要用线程池？ThreadPoolExecutor-类的重要参数了解吗？ThreadPoolExecutor-饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？"><a href="#十一、为什么要用线程池？ThreadPoolExecutor-类的重要参数了解吗？ThreadPoolExecutor-饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？" class="headerlink" title="十一、为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？"></a>十一、为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？</h4><h4 id="十二、AQS-了解么？原理？AQS-常用组件：Semaphore-信号量-、CountDownLatch-（倒计时器）-CyclicBarrier-循环栅栏"><a href="#十二、AQS-了解么？原理？AQS-常用组件：Semaphore-信号量-、CountDownLatch-（倒计时器）-CyclicBarrier-循环栅栏" class="headerlink" title="十二、AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)"></a>十二、AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)</h4><h5 id="1-AQS-概述"><a href="#1-AQS-概述" class="headerlink" title="1 AQS 概述"></a>1 AQS 概述</h5><p><strong>AQS</strong> 的全称为（AbstractQueuedSynchronizer），中文即“<strong>队列同步器</strong>”，这个类放在 java.util.concurrent.locks 包下面。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739164" alt="img"></p>
<p>AQS是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如上篇文章写的ReentrantLock与ReentrantReadWriteLock。除此之外，AQS还能构造出Semaphore，FutureTask(jdk1.7) 等同步器。</p>
<h5 id="2-AQS-原理"><a href="#2-AQS-原理" class="headerlink" title="2 AQS 原理"></a>2 AQS 原理</h5><h6 id="2-1-同步队列"><a href="#2-1-同步队列" class="headerlink" title="2.1 同步队列"></a>2.1 同步队列</h6><p><strong>AQS 是依赖 CLH 队列锁来完成同步状态的管理</strong>。当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构建为一个**节点(Node)**并将其加入同步队列，同步会阻塞当前线程，当同步状态释放时，会将首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（<strong>FIFO双向队列</strong>）（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。<strong>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</strong>。</p>
</blockquote>
<p>同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点信息。</p>
<table>
<thead>
<tr>
<th>属性类型与名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int waitStatus</td>
<td>等待状态(如CANCELLED&#x3D;1、SIGNAL&#x3D;-1、CONDITION&#x3D;-2、PROPAGATE&#x3D;-3、INITIAL&#x3D;0)</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点(当节点加入同步队列时被设置，在尾部添加)</td>
</tr>
<tr>
<td>Node next</td>
<td>后继节点</td>
</tr>
<tr>
<td>Thread thread</td>
<td>当前获取同步状态的线程</td>
</tr>
</tbody></table>
<p>节点源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 表示该节点等待模式为共享式，通常记录于nextWaiter，</span></span><br><span class="line">    <span class="comment">// 通过判断nextWaiter的值可以判断当前结点是否处于共享模式</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="comment">// 表示节点处于独占式模式，与SHARED相对</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> Node EXCLUSIVE = null;</span><br><span class="line">    <span class="comment">// waitStatus的不同状态</span></span><br><span class="line">    <span class="comment">// 当前结点是因为超时或者中断取消的，进入该状态后将无法恢复</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前结点的后继结点是(或者将要)由park导致阻塞的，当结点被释放或者取消时，需要通过unpark唤醒后继结点</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> SIGNAL    = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 表明结点在等待队列中，结点线程等待在Condition上</span></span><br><span class="line">    <span class="comment">// 当其他线程对Condition调用了signal()方法时，会将其加入到同步队列中   </span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> CONDITION = <span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 下一次共享式同步状态的获取将会无条件地向后继结点传播</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> PROPAGATE = <span class="number">-3</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 记录前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 记录后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 记录当前的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 用于记录共享模式(SHARED), 也可以用来记录CONDITION队列</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">// 通过nextWaiter的记录值判断当前结点的模式是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> nextWaiter == SHARED;&#125;</span><br><span class="line">    <span class="comment">// 获取当前结点的前置结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> throws NullPointerException </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// 用于初始化时创建head结点或者创建SHARED结点</span></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 在addWaiter方法中使用，用于创建一个新的结点</span></span><br><span class="line">    <span class="built_in">Node</span>(Thread thread, Node mode) &#123;     </span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在CONDITION队列中使用该构造函数新建结点</span></span><br><span class="line">    <span class="built_in">Node</span>(Thread thread, <span class="type">int</span> waitStatus) &#123; </span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录头结点</span></span><br><span class="line"><span class="keyword">private</span> transient <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 记录尾结点</span></span><br><span class="line"><span class="keyword">private</span> transient <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>节点是构成同步队列的基础，同步器拥有<strong>首节点（Head）和尾节点（Tail）</strong>，没有成功<strong>获取</strong>同步状态的线程将会成为节点加入该队列的尾部。同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739165" alt="img"></p>
<p><strong>首节点是获取同步状态成功的节点</strong>，首节点的线程在<strong>释放</strong>同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，不需要使用CAS来保证，只需将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739166" alt="img"></p>
<h6 id="2-2-同步状态"><a href="#2-2-同步状态" class="headerlink" title="2.2 同步状态"></a>2.2 同步状态</h6><h6 id="1）-独占式-EXCLUSIVE"><a href="#1）-独占式-EXCLUSIVE" class="headerlink" title="1） 独占式(EXCLUSIVE)"></a>1） 独占式(EXCLUSIVE)</h6><p>独占式(EXCLUSIVE)获取需重写<code>tryAcquire</code>、<code>tryRelease</code>方法，并访问<code>acquire</code>、<code>release</code>方法实现相应的功能。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(<span class="built_in">int</span> arg) &#123;</span><br><span class="line">    <span class="comment">// 如果线程直接获取成功，或者再尝试获取成功后都是直接工作，</span></span><br><span class="line">    <span class="comment">// 如果是从阻塞状态中唤醒开始工作的线程，将当前的线程中断        </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">        </span>acquire<span class="constructor">Queued(<span class="params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))</span><br><span class="line">        self<span class="constructor">Interrupt()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装线程，新建结点并加入到同步队列中</span></span><br><span class="line"><span class="keyword">private</span> Node add<span class="constructor">Waiter(Node <span class="params">mode</span>)</span> &#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> <span class="constructor">Node(Thread.<span class="params">currentThread</span>()</span>, mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 尝试入队， 成功返回</span></span><br><span class="line">    <span class="keyword">if</span> (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS操作设置队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compare<span class="constructor">AndSetTail(<span class="params">pred</span>, <span class="params">node</span>)</span>) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过CAS操作自旋完成node入队操作</span></span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在同步队列中等待获取同步状态</span></span><br><span class="line">final boolean acquire<span class="constructor">Queued(<span class="params">final</span> Node <span class="params">node</span>, <span class="params">int</span> <span class="params">arg</span>)</span> &#123;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor<span class="literal">()</span>;</span><br><span class="line">            <span class="comment">// 前驱节点是否为头节点&amp;&amp;tryAcquire获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p<span class="operator"> == </span>head<span class="operator"> &amp;&amp; </span><span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span>) &#123;</span><br><span class="line">                set<span class="constructor">Head(<span class="params">node</span>)</span>;</span><br><span class="line">                p.next = null;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取不到同步状态，将前置结点标为SIGNAL状态并且通过park操作将Node封装的线程阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (should<span class="constructor">ParkAfterFailedAcquire(<span class="params">p</span>, <span class="params">node</span>)</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">                </span>park<span class="constructor">AndCheckInterrupt()</span>)</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 如果获取失败，将node标记为CANCELLED</span></span><br><span class="line">            cancel<span class="constructor">Acquire(<span class="params">node</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式获取同步状态流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739167" alt="img"></p>
<p>通过调用同步器的<code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其<strong>后继节点</strong>（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先尝试释放并更新同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 检查是否需要唤醒后置结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后置结点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 通过CAS操作将waitStatus更新为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 检查后置结点，若为空或者状态为CANCELLED，找到后置非CANCELLED结点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继结点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2）共享式-SHARED"><a href="#2）共享式-SHARED" class="headerlink" title="2）共享式(SHARED)"></a>2）共享式(SHARED)</h6><p><strong>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态</strong>。</p>
<p>共享式(SHARED)获取需重写<code>tryAcquireShared</code>、<code>tryReleaseShared</code>方法，并访问<code>acquireShared</code>、<code>releaseShared</code>方法实现相应的功能。与独占式相对，共享式支持多个线程同时获取到同步状态并进行工作，如 Semaphore、CountDownLatch、 CyclicBarrier等。ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试共享式获取同步状态，如果成功获取则可以继续执行，否则执行doAcquireShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 以共享式不停得尝试获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 向同步队列中新增一个共享式的结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 标记获取失败状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记中断状态(若在该过程中被中断是不会响应的，需要手动中断)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前置结点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 若前置结点为头结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 若获取到同步状态。</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 此时，当前结点存储的线程恢复执行，需要将当前结点设置为头结点并且向后传播，</span></span><br><span class="line">                    <span class="comment">// 通知符合唤醒条件的结点一起恢复执行</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 需要中断，中断当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    <span class="comment">// 获取成功</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取同步状态失败，需要进入阻塞状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 获取失败，CANCELL node</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将node设置为同步队列的头结点，并且向后通知当前结点的后置结点，完成传播</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 向后传播</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(intarg)方法可以释放同步状态，释放同步状态成功后，会唤醒后置结点，并且保证传播性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 成功后唤醒后置结点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒后置结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 循环的目的是为了防止新结点在该过程中进入同步队列产生的影响，同时要保证CAS操作的完成</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            </span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3）超时获取方式"><a href="#3）超时获取方式" class="headerlink" title="3）超时获取方式"></a>3）超时获取方式</h6><p>通过调用同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以<strong>超时获取同步状态</strong>，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时的时间=当前虚拟机的时间+设置的超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 调用addWaiter将当前线程封装成独占模式的节点，并且加入到同步队列尾部。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点的前驱节点为头结点，则让当前节点去尝试获取锁。</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; </span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱节点不是头结点，或当前节点获取锁失败，</span></span><br><span class="line">            <span class="comment">// 则再次判断当前线程是否已经超时。</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点，马上进入</span></span><br><span class="line">            <span class="comment">// 等待状态了，即做好进入等待状态前的准备。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。</span></span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可知，超时获取也是调用addWaiter将当前线程封装成<strong>独占模式</strong>的节点，并且加入到同步队列尾部。</p>
<p>超时获取与独占式获取同步状态区别<strong>在于获取同步状态失败后的处理</strong>。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时）；如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待nanosTimeout纳秒（当已到设置的超时时间，该线程会从<code>LockSupport.parkNanos(Object blocker, long nanos)</code>方法返回）。</p>
<p>独占式超时获取同步状态流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739168" alt="img"></p>
<h6 id="2-3-模板方法"><a href="#2-3-模板方法" class="headerlink" title="2.3 模板方法"></a>2.3 模板方法</h6><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>同步状态<code>state</code>通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>方法进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CAS更新同步状态，该方法能够保证状态设置的原子性</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<p><strong>自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>同步器提供的模板方法基本上分为3类：<strong>独占式</strong>获取与释放同步状态、<strong>共享式</strong>获取与释放同步状态和查询同步队列中的等待线程情况。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后续动作。</p>
<p>但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>下面就来学习几个常用的并发同步工具。</p>
<h5 id="3-Semaphore-信号量"><a href="#3-Semaphore-信号量" class="headerlink" title="3 Semaphore(信号量)"></a>3 Semaphore(信号量)</h5><p>Semaphore（信号量）用来控制 <strong>同时访问特定资源的线程数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而<strong>Semaphore(信号量)可以指定多个线程同时访问某个资源</strong>。</p>
<p>以停车场为例。假设一个停车场只有10个车位，这时如果同时来了15辆车，则只允许其中10辆不受阻碍的进入。剩下的5辆车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，如果有5辆车离开停车场，放入5辆；如果又离开2辆，则又可以放入2辆，如此往复。</p>
<p>在这个停车场系统中，车位即是共享资源，每辆车就好比一个线程，信号量就是空车位的数目。</p>
<p>Semaphore中包含了一个实现了AQS的同步器Sync，以及它的两个子类FairSync和NonFairSync。查看Semaphore类结构：</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739169" alt="img"></p>
<p>可见Semaphore也是区分公平模式和非公平模式的。</p>
<ul>
<li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO。</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
<p>Semaphore 对应的两个构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">     sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<p>Semaphore实现原理这里就不分析了，可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903866329202701">死磕 java同步系列之Semaphore源码解析</a>这篇文章。</p>
<p>需要明白的是，<strong>Semaphore也是共享锁的一种实现</strong>。它默认构造AQS的state为permits。当执行任务的线程数量超出permits，那么多余的线程将会被放入阻塞队列Park，并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行，此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
<p>Semaphore常用于做<strong>流量控制</strong>，特别是公用资源有限的应用场景。</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>acquire()&#x2F;acquire(int permits)</td>
<td>获取许可证。获取许可失败，会进入AQS的队列中排队。</td>
</tr>
<tr>
<td>tryAcquire()&#x2F;tryAcquire(int permits)</td>
<td>获取许可证。获取许可失败，直接返回false。</td>
</tr>
<tr>
<td>tryAcquire(long timeout, TimeUnit unit)&#x2F; tryAcquire(int permits, long timeout, TimeUnit unit)</td>
<td>超时等待获取许可证。</td>
</tr>
<tr>
<td>release()</td>
<td>归还许可证。</td>
</tr>
<tr>
<td>intavailablePermits()</td>
<td>返回此信号量中当前可用的许可证数。</td>
</tr>
<tr>
<td>intgetQueueLength()</td>
<td>返回正在等待获取许可证的线程数。</td>
</tr>
<tr>
<td>booleanhasQueuedThreads()</td>
<td>是否有线程正在等待获取许可证。</td>
</tr>
<tr>
<td>void reducePermits（int reduction）</td>
<td>减少reduction个许可证，是个protected方法。</td>
</tr>
<tr>
<td>Collection getQueuedThreads()</td>
<td>返回所有等待获取许可证的线程集合，是个protected方法。</td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">        <span class="comment">// 一次只能允许执行的线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">// 获取1个许可，所以可运行线程数量为10/1=10</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release();<span class="comment">// 释放1个许可，所以可运行线程数量为10/1=10</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadNum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;threadNum:&quot;</span> + threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，虽然有50个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。</p>
<p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p>
<h5 id="4-CountDownLatch-倒计时器"><a href="#4-CountDownLatch-倒计时器" class="headerlink" title="4 CountDownLatch (倒计时器)"></a>4 CountDownLatch (倒计时器)</h5><h6 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h6><p>在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。jdk 1.5之前一般都使用线程的join()方法来实现这一点，但是join方法不够灵活，难以满足不同场景的需要，所以jdk 1.5之后concurrent包提供了CountDownLatch这个类。</p>
<p><strong>CountDownLatch</strong>是一种同步辅助工具，它<strong>允许一个或多个线程等待其他线程完成操作</strong>。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739171" alt="img"></p>
<p>CountDownLatch的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>调用该方法的线程等到构造方法传入的 N 减到 0 的时候，才能继续往下执行。</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit)</td>
<td>调用该方法的线程等到指定的 timeout 时间后，不管 N 是否减至为 0，都会继续往下执行。</td>
</tr>
<tr>
<td>countDown()</td>
<td>使 CountDownLatch 初始值 N 减 1。</td>
</tr>
<tr>
<td>getCount()</td>
<td>获取当前 CountDownLatch 维护的值，也就是AQS的state的值。</td>
</tr>
</tbody></table>
<p>CountDownLatch的实现原理，可以查看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/leesf456/p/5406191.html">【JUC】JDK1.8源码分析之CountDownLatch（五）</a>一文。</p>
<p>根据源码分析可知，<strong>CountDownLatch是AQS中共享锁的一种实现</strong>。AbstractQueuedSynchronizer中维护了一个volatile类型的整数state，volatile可以保证多线程环境下该变量的修改对每个线程都可见，并且由于该属性为整型，因而对该变量的修改也是原子的。</p>
<p>CountDownLatch默认构造 AQS 的 state 值为 count。创建一个CountDownLatch对象时，所传入的整数N就会赋值给state属性。</p>
<p>当调用countDown()方法时，其实是调用了<code>tryReleaseShared</code>方法以CAS的操作来对state减1；而调用await()方法时，当前线程就会判断state属性是否为0。如果为0，阻塞线程被唤醒继续往下执行；如果不为0，则使当前线程放入阻塞队列Park，直至最后一个线程调用了countDown()方法使得state &#x3D;&#x3D; 0，再唤醒在await()方法中等待的线程。</p>
<p><strong>特别注意的是</strong>：</p>
<p><strong>CountDownLatch 是一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。如果<strong>需要能重置计数，可以使用CyclicBarrier</strong>。</p>
<h6 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h6><p>CountDownLatch主要应用场景：</p>
<ol>
<li><strong>实现最大的并行性</strong>：同时启动多个线程，实现最大程度的并行性。例如110跨栏比赛中，所有运动员准备好起跑姿势，进入到预备状态，等待裁判一声枪响。裁判开了枪，所有运动员才可以开跑。</li>
<li><strong>开始执行前等待N个线程完成各自任务</strong>：例如一群学生在教室考试，学生们都完成了作答，老师才可以进行收卷操作。</li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREAD_COUNT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程:&quot;</span> + threadNum);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程启动...&quot;</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程执行完毕...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了请求的数量为30，当这 30 个请求被处理完成之后，才会打印<code>子线程执行完毕</code>。</p>
<p>主线程在启动其他线程后调用 <code>CountDownLatch.await()</code> 方法进入阻塞状态，直到其他线程完成各自的任务才被唤醒。</p>
<p>开启的30个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当30个线程都调用了这个方法后，count 的值才等于0，然后主线程就能通过 <code>await()</code>方法，继续执行自己的任务。</p>
<h5 id="5-CyclicBarrier-循环栅栏"><a href="#5-CyclicBarrier-循环栅栏" class="headerlink" title="5 CyclicBarrier(循环栅栏)"></a>5 CyclicBarrier(循环栅栏)</h5><h6 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h6><p><strong>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）</strong>。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier 的功能和应用场景与CountDownLatch都非常类似。</p>
<p><img src="https://segmentfault.com/img/remote/1460000037739170" alt="img"></p>
<p>CyclicBarrier常用方法：</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>await()</td>
<td>在所有线程都已经在此 barrier上并调用 await 方法之前，将一直等待。</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit)</td>
<td>所有线程都已经在此屏障上调用 await 方法之前将一直等待，或者超出了指定的等待时间。</td>
</tr>
<tr>
<td>getNumberWaiting()</td>
<td>返回当前在屏障处等待的线程数目。</td>
</tr>
<tr>
<td>getParties()</td>
<td>返回要求启动此 barrier 的线程数目。</td>
</tr>
<tr>
<td>isBroken()</td>
<td>查询此屏障是否处于损坏状态。</td>
</tr>
<tr>
<td>reset()</td>
<td>将屏障重置为其初始状态。</td>
</tr>
</tbody></table>
<h6 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h6><p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作。</span></span><br><span class="line"><span class="comment">// 该操作由最后一个进入 barrier 的线程执行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>parties 就表示屏障拦截的线程数量</strong>。</p>
<p>CyclicBarrier 的最重要的方法就是 await 方法，<code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，<strong>当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。查看<code>dowait(boolean timed, long nanos)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取”独占锁“</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存“当前的generation”</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="comment">// 如果当前代损坏，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">        <span class="comment">// 如果线程中断，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将损坏状态设置为 true，并唤醒所有阻塞在此栅栏上的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将“count计数器”-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 当 count== 0，说明最后一个线程已经到达栅栏</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="comment">// 执行栅栏任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程，并更新generation。</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="comment">// 结束，等价于return index</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者条件之一发生</span></span><br><span class="line">        <span class="comment">// 当前线程才继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有时间限制，则直接等待，直到被唤醒。</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 如果有时间限制，则等待指定时间再唤醒(超时等待)。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 当前代没有损坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 让栅栏失效</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上面条件不满足,说明这个线程不是这代的。</span></span><br><span class="line">                    <span class="comment">// 就不会影响当前这代栅栏执行逻辑。中断。</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果“当前generation已经损坏”，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();  </span><br><span class="line">            <span class="comment">// 如果“generation已经换代”，则返回index。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index; </span><br><span class="line">            <span class="comment">// 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier</span></span><br><span class="line">            <span class="comment">// 唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“独占锁(lock)”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generation是CyclicBarrier的一个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Generation一代的意思。</span></span><br><span class="line"><span class="comment">  * CyclicBarrier是可以循环使用的，用它来标志本代和下一代。</span></span><br><span class="line"><span class="comment">  * broken：当前代是否损坏的标志。标志有线程发生了中断，或者异常，就是任务没有完成。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现独占锁</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">// 实现多个线程之间相互等待通知，就是满足某些条件之后，线程才能执行，否则就等待</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"> <span class="comment">// 初始化时屏障数量 </span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"> <span class="comment">// 当条件满足(即屏障数量为0)之后，会回调这个Runnable</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"> <span class="comment">//当前代</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 剩余的屏障数量count</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在CyclicBarrier中，<strong>同一批的线程属于同一代</strong>，即同一个generation；CyclicBarrier中通过generation对象，记录属于哪一代。<br>当有parties个线程到达barrier，generation就会被更新换代。</p>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h6><ol>
<li><code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏，那么就将计数器减1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就会将代更新并重置计数器，并唤醒所有之前等待在栅栏上的线程。</li>
<li>如果在等待的过程中，线程中断都也会抛出BrokenBarrierException异常，并且这个异常会传播到其他所有的线程，CyclicBarrier会被损坏。</li>
<li>如果超出指定的等待时间，当前线程会抛出 TimeoutException 异常，其他线程会抛出BrokenBarrierException异常，CyclicBarrier会被损坏。</li>
</ol>
<h6 id="5-3-应用场景"><a href="#5-3-应用场景" class="headerlink" title="5.3 应用场景"></a>5.3 应用场景</h6><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is ready&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待60秒，保证子线程完全执行结束</span></span><br><span class="line">                    cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">childThread:<span class="number">0</span> is ready</span><br><span class="line">childThread:<span class="number">1</span> is ready</span><br><span class="line">childThread:<span class="number">2</span> is ready</span><br><span class="line">childThread:<span class="number">3</span> is ready</span><br><span class="line">childThread:<span class="number">4</span> is ready</span><br><span class="line">childThread:<span class="number">4</span> is finish</span><br><span class="line">childThread:<span class="number">0</span> is finish</span><br><span class="line">childThread:<span class="number">1</span> is finish</span><br><span class="line">childThread:<span class="number">3</span> is finish</span><br><span class="line">childThread:<span class="number">2</span> is finish</span><br><span class="line">childThread:<span class="number">5</span> is ready</span><br><span class="line">childThread:<span class="number">6</span> is ready</span><br><span class="line">childThread:<span class="number">7</span> is ready</span><br><span class="line">childThread:<span class="number">8</span> is ready</span><br><span class="line">childThread:<span class="number">9</span> is ready</span><br><span class="line">childThread:<span class="number">9</span> is finish</span><br><span class="line">childThread:<span class="number">8</span> is finish</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>可以看到当线程数量也就是请求数量达定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p>
<p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------优先执行------&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is ready&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待60秒，保证子线程完全执行结束</span></span><br><span class="line">                    cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;childThread:&quot;</span> + threadNum + <span class="string">&quot; is finish&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">childThread:<span class="number">0</span> is ready</span><br><span class="line">childThread:<span class="number">1</span> is ready</span><br><span class="line">childThread:<span class="number">2</span> is ready</span><br><span class="line">childThread:<span class="number">3</span> is ready</span><br><span class="line">childThread:<span class="number">4</span> is ready</span><br><span class="line">------优先执行------</span><br><span class="line">childThread:<span class="number">4</span> is finish</span><br><span class="line">childThread:<span class="number">0</span> is finish</span><br><span class="line">childThread:<span class="number">1</span> is finish</span><br><span class="line">childThread:<span class="number">3</span> is finish</span><br><span class="line">childThread:<span class="number">2</span> is finish</span><br><span class="line">childThread:<span class="number">5</span> is ready</span><br><span class="line">childThread:<span class="number">6</span> is ready</span><br><span class="line">childThread:<span class="number">7</span> is ready</span><br><span class="line">childThread:<span class="number">8</span> is ready</span><br><span class="line">childThread:<span class="number">9</span> is ready</span><br><span class="line">------优先执行------</span><br><span class="line">childThread:<span class="number">9</span> is finish</span><br><span class="line">childThread:<span class="number">6</span> is finish</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<h6 id="5-4-CyclicBarrier和CountDownLatch的区别"><a href="#5-4-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5.4 CyclicBarrier和CountDownLatch的区别"></a>5.4 CyclicBarrier和CountDownLatch的区别</h6><ol>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()方法重置，可多次使用。</li>
<li>侧重点不同。CountDownLatch多用于某一个线程等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于多个线程互相等待至一个同步点，然后这些线程再继续一起执行。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量；isBroken()方法用来了解阻塞的线程是否被中断。</li>
</ol>
<h4 id="十三、ReentrantLock-、-ReentrantReadWriteLock-、StampedLock（JDK8）"><a href="#十三、ReentrantLock-、-ReentrantReadWriteLock-、StampedLock（JDK8）" class="headerlink" title="十三、ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）"></a>十三、ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）</h4><h5 id="JDK8的一种新的读写锁StampedLock"><a href="#JDK8的一种新的读写锁StampedLock" class="headerlink" title="JDK8的一种新的读写锁StampedLock"></a>JDK8的一种新的读写锁StampedLock</h5><p>JDK8新增一种新的读写锁StampedLock。一个最重要的功能改进就是读写锁中<strong>解决写线程饥饿的问题</strong>。</p>
<h5 id="StampedLock与ReentrantReadWriteLock"><a href="#StampedLock与ReentrantReadWriteLock" class="headerlink" title="StampedLock与ReentrantReadWriteLock"></a>StampedLock与ReentrantReadWriteLock</h5><p>以StampedLock与ReentrantReadWriteLock两者比较为线索介绍StampedLock锁。关于ReentrantReadWriteLock锁参考文档<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e44202261319">ReentrantReadWriteLock源码解析</a>。</p>
<h5 id="StampedLock不基于AQS实现"><a href="#StampedLock不基于AQS实现" class="headerlink" title="StampedLock不基于AQS实现"></a>StampedLock不基于AQS实现</h5><p>之前包括ReentrantReadWriteLock，ReentrantLock和信号量等同步工具，都是基于AQS同步框架实现的。而在StampedLock中摒弃了AQS框架，为StampedLock实现提供了更多的灵活性。</p>
<h5 id="StampedLock增加乐观读锁机制"><a href="#StampedLock增加乐观读锁机制" class="headerlink" title="StampedLock增加乐观读锁机制"></a>StampedLock增加乐观读锁机制</h5><p>先获取记录下当前锁的版本号stamp，执行读取操作后，要验证这个版本号是否改变，如果没有改变继续执行接下来的逻辑。乐观读锁机制基于在系统中大多数时间线程并发竞争不严重，绝大多数读操作都可以在没有竞争的情况下完成的论断。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乐观读锁</span></span><br><span class="line">stamp = <span class="keyword">lock</span>.tryOptimisticRead();</span><br><span class="line"><span class="comment">//do some reading</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">lock</span>.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">//do somethinng</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际中，乐观读的实现是通过判断state的高25位是否有变化来实现的，获取乐观读锁也仅仅是返回当前锁的版本号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock锁的状态和版本号"><a href="#StampedLock锁的状态和版本号" class="headerlink" title="StampedLock锁的状态和版本号"></a>StampedLock锁的状态和版本号</h5><p>基于AQS实现实现的ReentrantReadWriteLock，高16位存储读锁被获取的次数，低16位存储写锁被获取的次数。<br> 而摒弃了AQS的StampedLock，自身维护了一个状态变量state。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</span><br></pre></td></tr></table></figure>

<p>StampedLock的状态变量state被分成3段：</p>
<ol>
<li>高24位存储版本号，只有写锁增加其版本号，而读锁不会增加其版本号；</li>
<li>低7位存储读锁被获取的次数；</li>
<li>第8位存储写锁被获取的次数，<strong>因为只有一位用于表示写锁，所以StampedLock不是可重入锁</strong>。</li>
</ol>
<p>关于状态变量state操作的变量设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">//读线程的个数占有低7位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for lock state and stamp operations</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RUNIT</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">//读线程个数每次增加的单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">//写线程个数所在的位置 1000 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">//读线程个数的掩码 111 1111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RFULL</span> <span class="operator">=</span> RBITS - <span class="number">1L</span>;<span class="comment">//最大读线程个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ABITS</span> <span class="operator">=</span> RBITS | WBIT;<span class="comment">//读线程个数和写线程个数的掩码 1111 1111</span></span><br><span class="line"><span class="comment">// Initial value for lock state; avoid failure value zero</span></span><br><span class="line"><span class="comment">//state的初始值。 1 0000 0000，也就是高24位最后一位为1，版本号初始值为1 0000 0000。锁获取失败返回版本号0。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock自旋"><a href="#StampedLock自旋" class="headerlink" title="StampedLock自旋"></a>StampedLock自旋</h5><p>如下代码片段，可以看到StampedLock锁获取时存在大量自旋逻辑(for循环)。自旋是一种锁优化技术，在并发程序中大多数的锁持有时间很短暂，通过自旋可以避免线程被阻塞和唤醒产生的开销。<br> 自旋技术对于系统中持有锁时间短暂的任务比较高效，但是对于持有锁时间长的任务是对CPU的浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireWrite</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123; <span class="comment">// spin while enqueuing</span></span><br><span class="line">          ....省略代码逻辑....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;</span><br><span class="line">        ....省略代码逻辑....</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">           ....省略代码逻辑....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireRead</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;</span><br><span class="line">        ....省略代码逻辑....</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> m, s, ns;;) &#123;</span><br><span class="line">            ....省略代码逻辑....</span><br><span class="line">        &#125;</span><br><span class="line">        ....省略代码逻辑....</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ....省略代码逻辑....</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">    ....省略代码逻辑....    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StampedLock的CLH队列"><a href="#StampedLock的CLH队列" class="headerlink" title="StampedLock的CLH队列"></a>StampedLock的CLH队列</h5><p>StampedLock的CLH队列是一个经过改良的队列，在ReentrantReadWriteLock的等待队列中每个线程节点是依次排队，然后责任链设计模式依次唤醒，这样就可能导致读线程全部唤醒，而写线程处于饥饿状态。StampedLock的等待队列，连续的读线程只有首个节点存储在队列中，其它的节点存储在首个节点的cowait队列中。</p>
<p>StampedLock唤醒读锁是一次性唤醒连续的读锁节点。</p>
<p>类WNode是StampedLock等待队列的节点，cowait存放连续的读线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">    <span class="keyword">volatile</span> WNode next;</span><br><span class="line">    <span class="comment">//cowait存放连续的读线程</span></span><br><span class="line">    <span class="keyword">volatile</span> WNode cowait; <span class="comment">// list of linked readers</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">//non-null while possibly parked</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">    WNode(<span class="type">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个读节点之间有一个写节点，那么这两个读节点就不是连续的，会分别排队。正是因为这样的机制，会按照到来顺序让先到的写线程先于它后面的读线程执行。</p>
<p>StampedLock只有非公平模式，线程到来就会尝试获取锁。</p>
<h4 id="十四、CAS-了解么？原理？"><a href="#十四、CAS-了解么？原理？" class="headerlink" title="十四、CAS 了解么？原理？"></a>十四、CAS 了解么？原理？</h4><h5 id="1、什么是CAS？"><a href="#1、什么是CAS？" class="headerlink" title="1、什么是CAS？"></a><strong>1、什么是CAS？</strong></h5><p>CAS：Compare and Swap，即比较再交换。</p>
<p>jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。</p>
<h5 id="2、CAS算法理解"><a href="#2、CAS算法理解" class="headerlink" title="2、CAS算法理解"></a><strong>2、CAS算法理解</strong></h5><p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>CAS比较与交换的伪代码可以表示为：</p>
<p>do{</p>
<p>备份旧数据；</p>
<p>基于旧数据构造新数据；</p>
<p>}while(!CAS( 内存地址，备份的旧数据，新数据 ))</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/zK9ke8_20210607145034.png" alt="img"></p>
<p>注：t1，t2线程是同时更新同一变量56的值</p>
<p>因为t1和t2线程都同时去访问同一变量56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。</p>
<p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p>
<p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>
<p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>
<h5 id="3、CAS开销"><a href="#3、CAS开销" class="headerlink" title="3、CAS开销"></a><strong>3、CAS开销</strong></h5><p>前面说过了，CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。但CAS就没有开销了吗？不！有cache miss的情况。这个问题比较复杂，首先需要了解CPU的硬件体系结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5ckVXA_20210607145057.png" alt="img"></p>
<p>上图可以看到一个8核CPU计算机系统，每个CPU有cache（CPU内部的高速缓存，寄存器），管芯内还带有一个互联模块，使管芯内的两个核可以互相通信。在图中央的系统互联模块可以让四个管芯相互通信，并且将管芯与主存连接起来。数据以“缓存线”为单位在系统中传输，“缓存线”对应于内存中一个 2 的幂大小的字节块，大小通常为 32 到 256 字节之间。当 CPU 从内存中读取一个变量到它的寄存器中时，必须首先将包含了该变量的缓存线读取到 CPU 高速缓存。同样地，CPU 将寄存器中的一个值存储到内存时，不仅必须将包含了该值的缓存线读到 CPU 高速缓存，还必须确保没有其他 CPU 拥有该缓存线的拷贝。</p>
<p>比如，如果 CPU0 在对一个变量执行“比较并交换”（CAS）操作，而该变量所在的缓存线在 CPU7 的高速缓存中，就会发生以下经过简化的事件序列：</p>
<p>CPU0 检查本地高速缓存，没有找到缓存线。</p>
<p>请求被转发到 CPU0 和 CPU1 的互联模块，检查 CPU1 的本地高速缓存，没有找到缓存线。</p>
<p>请求被转发到系统互联模块，检查其他三个管芯，得知缓存线被 CPU6和 CPU7 所在的管芯持有。</p>
<p>请求被转发到 CPU6 和 CPU7 的互联模块，检查这两个 CPU 的高速缓存，在 CPU7 的高速缓存中找到缓存线。</p>
<p>CPU7 将缓存线发送给所属的互联模块，并且刷新自己高速缓存中的缓存线。</p>
<p>CPU6 和 CPU7 的互联模块将缓存线发送给系统互联模块。</p>
<p>系统互联模块将缓存线发送给 CPU0 和 CPU1 的互联模块。</p>
<p>CPU0 和 CPU1 的互联模块将缓存线发送给 CPU0 的高速缓存。</p>
<p>CPU0 现在可以对高速缓存中的变量执行 CAS 操作了</p>
<p>以上是刷新不同CPU缓存的开销。最好情况下的 CAS 操作消耗大概 40 纳秒，超过 60 个时钟周期。这里的“最好情况”是指对某一个变量执行 CAS 操作的 CPU 正好是最后一个操作该变量的CPU，所以对应的缓存线已经在 CPU 的高速缓存中了，类似地，最好情况下的锁操作（一个“round trip 对”包括获取锁和随后的释放锁）消耗超过 60 纳秒，超过 100 个时钟周期。这里的“最好情况”意味着用于表示锁的数据结构已经在获取和释放锁的 CPU 所属的高速缓存中了。锁操作比 CAS 操作更加耗时，是因深入理解并行编程</p>
<p>为锁操作的数据结构中需要两个原子操作。缓存未命中消耗大概 140 纳秒，超过 200 个时钟周期。需要在存储新值时查询变量的旧值的 CAS 操作，消耗大概 300 纳秒，超过 500 个时钟周期。想想这个，在执行一次 CAS 操作的时间里，CPU 可以执行 500 条普通指令。这表明了细粒度锁的局限性。</p>
<p>以下是cache miss cas 和lock的性能对比：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/J5FBy2_20210607145123.png" alt="img"></p>
<h5 id="4、CAS算法在JDK中的应用"><a href="#4、CAS算法在JDK中的应用" class="headerlink" title="4、CAS算法在JDK中的应用"></a><strong>4、CAS算法在JDK中的应用</strong></h5><p>在原子类变量中，如java.util.concurrent.atomic中的AtomicXXX，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在java.util.concurrent中的大多数类在实现时都直接或间接的使用了这些原子变量类。</p>
<p>Java 1.7中AtomicInteger.incrementAndGet()的实现源码为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/E76D9I_20210607145148.png" alt="img"></p>
<p>由此可见，AtomicInteger.incrementAndGet的实现用了乐观锁技术，调用了类sun.misc.Unsafe库里面的 CAS算法，用CPU指令来实现无锁自增。所以，AtomicInteger.incrementAndGet的自增比用synchronized的锁效率倍增。</p>
<h4 id="十五、Atomic-原子类"><a href="#十五、Atomic-原子类" class="headerlink" title="十五、Atomic 原子类"></a>十五、Atomic 原子类</h4><h5 id="Atomic概览"><a href="#Atomic概览" class="headerlink" title="Atomic概览"></a>Atomic概览</h5><p>整个atomic包包含了17个类，如下图所示：根据其功能及其实现原理，可将其分为五个部分。本文主要针对图中序号1都部分进行源码阅读和分析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/n8IQyt_20210607145409.png" alt="img"></p>
<h5 id="核心对象——Unsafe"><a href="#核心对象——Unsafe" class="headerlink" title="核心对象——Unsafe"></a>核心对象——Unsafe</h5><p>整个atomic都是基于<code>Unsafe</code>实现的，Unsafe通过通过单例模式来提供实例对象，这里我们主要关注它提供的几个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单1 sun.misc.Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final native boolean <span class="title">compareAndSwapInt</span>(<span class="params">Object var1, <span class="built_in">long</span> var2, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> var4, <span class="built_in">int</span> var5</span>)</span>;      <span class="comment">// 核心方法CAS</span></span><br><span class="line"><span class="comment">// 参数释义：var1为类对象，参数var2为Field的偏移量，var4为旧值，var5为更新后的值</span></span><br><span class="line"><span class="comment">//（对象和偏移量构成唯一的内存地址，如果对源码JVM有兴趣，可下载源码参考，非本文范畴，不赘述）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> native <span class="built_in">long</span> <span class="title">staticFieldOffset</span>(<span class="params">Field var1</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> native <span class="built_in">long</span> <span class="title">objectFieldOffset</span>(<span class="params">Field var1</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Unsafe提供的大多是native方法，<code>compareAndSwapInt()</code>通过原子的方式将期望值和内存中的值进行对比，如果两者相等，则执行更新操作。<br> <code>staticFieldOffset()</code>和<code>objectFieldOffset()</code>两方法分别提供两静态、非静态域的偏移量计算方法。</p>
<p>注意：之所以命名为Unsafe，因为该对于大部分Java开发者来说是不安全的，它像C一样，拥有操作指针、分配和回收内存的能力，由该对象申请的内存是无法被JVM回收的，因此轻易别用。当然，如果对并发有非常浓厚的兴趣，就要好好研究下它，许多高性能的框架都使用它作为底层实现，如Netty、Kafka。</p>
<h5 id="AtomicInteger的基本实现"><a href="#AtomicInteger的基本实现" class="headerlink" title="AtomicInteger的基本实现"></a>AtomicInteger的基本实现</h5><p>接着再来看<code>AtomicInteger</code>的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 清单<span class="number">2</span> AtomicInteger</span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.<span class="built_in">getUnsafe</span>();    <span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;    <span class="comment">// 偏移量</span></span><br><span class="line"><span class="type">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        valueOffset = unsafe.<span class="built_in">objectFieldOffset</span></span><br><span class="line">                (AtomicInteger.<span class="keyword">class</span>.<span class="built_in">getDeclaredField</span>(<span class="string">&quot;value&quot;</span>))    <span class="comment">// 计算偏移量</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(Exception ex)&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ex);&#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;    <span class="comment">// 使用volatile修饰，保证可见性</span></span><br></pre></td></tr></table></figure>

<p>私有的静态域Unsafe对象和偏移量都是final修饰的，在静态代码块中，通过Unsafe实例计算出域value的偏移地址。<br> value使用volatile来修饰，保证了其可见性。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单3 getAndSetInt的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final <span class="built_in">int</span> <span class="title">getAndSetInt</span>(<span class="params">Object var1, <span class="built_in">long</span> var2, <span class="built_in">int</span> var4</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);        <span class="comment">// 原子获取变量的值</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line">                                                       <span class="comment">// CAS操作，失败重试</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过方法名可知清单3中的方法<code>getAndSetInt()</code>为获取旧值并赋予新值的操作，通过CAS失败重试的机制来实现原子操作，这就是乐观锁的思想，也是整个并发包的核心思想。</p>
<h4 id="扩展-灵活的函数式编程"><a href="#扩展-灵活的函数式编程" class="headerlink" title="扩展-灵活的函数式编程"></a>扩展-灵活的函数式编程</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/42TeKb_20210607145444.png" alt="img"></p>
<p>AtomicInteger方法</p>
<p>AtomicInteger的方法中，除了简单的加、减、更新和获取的原子操作外，在JDK1.8中增加了4个方法，即图上标红的方法。通过函数式编程，可以灵活的实现更加复杂的原子操作。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单5 IntUnaryOperator接口</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">applyAsInt</span>(<span class="params"><span class="built_in">int</span> operand</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="literal">default</span> IntUnaryOperator <span class="title">compose</span>(<span class="params">IntUnaryOperator before</span>)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span> v) -&gt; applyAsInt(before.applyAsInt(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="literal">default</span> IntUnaryOperator <span class="title">andThen</span>(<span class="params">IntUnaryOperator after</span>)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span> t) -&gt; after.applyAsInt(applyAsInt(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口定义了一个待实现方法和两个默认方法，通过compose和andThen即可实现多个IntUnaryOperator的组合调用。在AtomicInteger中做如下调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单6 AtomicInteger代码片段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> final <span class="built_in">int</span> <span class="title">getAndUpdate</span>(<span class="params">IntUnaryOperator updateFunction</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">get</span>();   <span class="comment">// 获取当前值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);  <span class="comment">// 函数调用计算</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));   <span class="comment">// CAS更新操作</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同代码清单7，通过函数式编程，可以轻易地完成复杂计算的原子操作。除了IntUnaryOperator接口，还有一个IntBinaryOperator接口，该接口支持额外增加的参数参与计算，两者有相似之处</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 清单7 IntUnaryOperatorTest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    IntOperatorAdd <span class="keyword">add</span> = <span class="keyword">new</span> IntOperatorAdd();</span><br><span class="line">    IntOperatorMul mul = <span class="keyword">new</span> IntOperatorMul();</span><br><span class="line">    <span class="built_in">int</span> result = <span class="keyword">new</span> AtomicInteger(<span class="number">3</span>).updateAndGet(<span class="keyword">add</span>);   <span class="comment">// 结果为6 -&gt; 3+3</span></span><br><span class="line">    <span class="built_in">int</span> result2 = <span class="keyword">new</span> AtomicInteger(<span class="number">3</span>).updateAndGet(mul);  <span class="comment">// 结果为9 -&gt; 3*3</span></span><br><span class="line">    <span class="built_in">int</span> result3 = <span class="keyword">new</span> AtomicInteger(<span class="number">3</span>).updateAndGet(<span class="keyword">add</span>.andThen(mul));</span><br><span class="line">                                         <span class="comment">// 结果为36 -&gt; 3+3=6, 6*6=36</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">IntOperatorAdd</span> <span class="title">implements</span> <span class="title">IntUnaryOperator</span> &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">applyAsInt</span>(<span class="params"><span class="built_in">int</span> operand</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> operand + operand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">IntOperatorMul</span> <span class="title">implements</span> <span class="title">IntUnaryOperator</span> &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">applyAsInt</span>(<span class="params"><span class="built_in">int</span> operand</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> operand * operand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他原子操作类"><a href="#其他原子操作类" class="headerlink" title="其他原子操作类"></a>其他原子操作类</h5><p>除了AtomicInteger外，还有AtomicLong、AtomicReference以及AtomicBoolean三个原子包装类。其实现原理都是一致的，均可举一反三。</p>
<h4 id="十六、并发容器：ConcurrentHashMap-、-CopyOnWriteArrayList-、-ConcurrentLinkedQueue-BlockingQueue-、ConcurrentSkipListMap"><a href="#十六、并发容器：ConcurrentHashMap-、-CopyOnWriteArrayList-、-ConcurrentLinkedQueue-BlockingQueue-、ConcurrentSkipListMap" class="headerlink" title="十六、并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap"></a>十六、并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>不考虑多线程并发的情况下，容器类一般使用ArrayList、HashMap等线程不安全的类，效率更高。在并发场景下，常会用到ConcurrentHashMap、ArrayBlockingQueue等线程安全的容器类，虽然牺牲了一些效率，但却得到了安全。</p>
<p>上面提到的线程安全容器都在java.util.concurrent包下，这个包下并发容器不少，今天全部翻出来鼓捣一下。</p>
<p>仅做简单介绍，后续再分别深入探索。</p>
<h5 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a>并发容器介绍</h5><ol>
<li>ConcurrentHashMap：并发版HashMap</li>
<li>CopyOnWriteArrayList：并发版ArrayList</li>
<li>CopyOnWriteArraySet：并发Set</li>
<li>ConcurrentLinkedQueue：并发队列(基于链表)</li>
<li>ConcurrentLinkedDeque：并发队列(基于双向链表)</li>
<li>ConcurrentSkipListMap：基于跳表的并发Map</li>
<li>ConcurrentSkipListSet：基于跳表的并发Set</li>
<li>ArrayBlockingQueue：阻塞队列(基于数组)</li>
<li>LinkedBlockingQueue：阻塞队列(基于链表)</li>
<li>LinkedBlockingDeque：阻塞队列(基于双向链表)</li>
<li>PriorityBlockingQueue：线程安全的优先队列</li>
<li>SynchronousQueue：读写成对的队列</li>
<li>LinkedTransferQueue：基于链表的数据交换队列</li>
<li>DelayQueue：延时队列</li>
</ol>
<h6 id="1-ConcurrentHashMap-并发版HashMap"><a href="#1-ConcurrentHashMap-并发版HashMap" class="headerlink" title="1.ConcurrentHashMap 并发版HashMap"></a><strong>1.ConcurrentHashMap 并发版HashMap</strong></h6><p>最常见的并发容器之一，可以用作并发场景下的缓存。底层依然是哈希表，但在JAVA 8中有了不小的改变，而JAVA 7和JAVA 8都是用的比较多的版本，因此经常会将这两个版本的实现方式做一些比较（比如面试中）。</p>
<p>一个比较大的差异就是，JAVA 7中采用分段锁来减少锁的竞争，JAVA 8中放弃了分段锁，采用CAS（一种乐观锁），同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）。</p>
<h6 id="2-CopyOnWriteArrayList-并发版ArrayList"><a href="#2-CopyOnWriteArrayList-并发版ArrayList" class="headerlink" title="2.CopyOnWriteArrayList 并发版ArrayList"></a><strong>2.CopyOnWriteArrayList 并发版ArrayList</strong></h6><p>并发版ArrayList，底层结构也是数组，和ArrayList不同之处在于：当新增和删除元素时会创建一个新的数组，在新的数组中增加或者排除指定对象，最后用新增数组替换原来的数组。</p>
<p>适用场景：由于读操作不加锁，写（增、删、改）操作加锁，因此适用于读多写少的场景。</p>
<p>局限：由于读的时候不会加锁（读的效率高，就和普通ArrayList一样），读取的当前副本，因此可能读取到脏数据。如果介意，建议不用。</p>
<p>看看源码感受下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Zi01aI_20210607145655.png" alt="img"></p>
<h6 id="3-CopyOnWriteArraySet-并发Set"><a href="#3-CopyOnWriteArraySet-并发Set" class="headerlink" title="3.CopyOnWriteArraySet 并发Set"></a><strong>3.CopyOnWriteArraySet 并发Set</strong></h6><p>基于CopyOnWriteArrayList实现（内含一个CopyOnWriteArrayList成员变量），也就是说底层是一个数组，意味着每次add都要遍历整个集合才能知道是否存在，不存在时需要插入（加锁）。</p>
<p>适用场景：在CopyOnWriteArrayList适用场景下加一个，集合别太大（全部遍历伤不起）。</p>
<h6 id="4-ConcurrentLinkedQueue-并发队列-基于链表"><a href="#4-ConcurrentLinkedQueue-并发队列-基于链表" class="headerlink" title="4.ConcurrentLinkedQueue 并发队列(基于链表)"></a><strong>4.ConcurrentLinkedQueue 并发队列(基于链表)</strong></h6><p>基于链表实现的并发队列，使用乐观锁(CAS)保证线程安全。因为数据结构是链表，所以理论上是没有队列大小限制的，也就是说添加数据一定能成功。</p>
<h6 id="5-ConcurrentLinkedDeque-并发队列-基于双向链表"><a href="#5-ConcurrentLinkedDeque-并发队列-基于双向链表" class="headerlink" title="5.ConcurrentLinkedDeque 并发队列(基于双向链表)"></a><strong>5.ConcurrentLinkedDeque 并发队列(基于双向链表)</strong></h6><p>基于双向链表实现的并发队列，可以分别对头尾进行操作，因此除了先进先出(FIFO)，也可以先进后出（FILO），当然先进后出的话应该叫它栈了。</p>
<h6 id="6-ConcurrentSkipListMap-基于跳表的并发Map"><a href="#6-ConcurrentSkipListMap-基于跳表的并发Map" class="headerlink" title="6.ConcurrentSkipListMap 基于跳表的并发Map"></a><strong>6.ConcurrentSkipListMap 基于跳表的并发Map</strong></h6><p>SkipList即跳表，跳表是一种空间换时间的数据结构，通过冗余数据，将链表一层一层索引，达到类似二分查找的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ECYW6E_20210607145723.png" alt="img"></p>
<h6 id="7-ConcurrentSkipListSet-基于跳表的并发Set"><a href="#7-ConcurrentSkipListSet-基于跳表的并发Set" class="headerlink" title="7.ConcurrentSkipListSet 基于跳表的并发Set"></a><strong>7.ConcurrentSkipListSet 基于跳表的并发Set</strong></h6><p>类似HashSet和HashMap的关系，ConcurrentSkipListSet里面就是一个ConcurrentSkipListMap，就不细说了。</p>
<h6 id="8-ArrayBlockingQueue-阻塞队列-基于数组"><a href="#8-ArrayBlockingQueue-阻塞队列-基于数组" class="headerlink" title="8.ArrayBlockingQueue 阻塞队列(基于数组)"></a><strong>8.ArrayBlockingQueue 阻塞队列(基于数组)</strong></h6><p>基于数组实现的可阻塞队列，构造时必须制定数组大小，往里面放东西时如果数组满了便会阻塞直到有位置（也支持直接返回和超时等待），通过一个锁ReentrantLock保证线程安全。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/P65yAF_20210607145757.png" alt="img"></p>
<p>乍一看会有点疑惑，读和写都是同一个锁，那要是空的时候正好一个读线程来了不会一直阻塞吗？</p>
<p>答案就在notEmpty、notFull里，这两个出自lock的小东西让锁有了类似synchronized + wait + notify的功能。传送门 → 终于搞懂了sleep&#x2F;wait&#x2F;notify&#x2F;notifyAll</p>
<h6 id="9-LinkedBlockingQueue-阻塞队列-基于链表"><a href="#9-LinkedBlockingQueue-阻塞队列-基于链表" class="headerlink" title="9.LinkedBlockingQueue 阻塞队列(基于链表)"></a><strong>9.LinkedBlockingQueue 阻塞队列(基于链表)</strong></h6><p> 基于链表实现的阻塞队列，想比与不阻塞的ConcurrentLinkedQueue，它多了一个容量限制，如果不设置默认为int最大值。</p>
<h6 id="10-LinkedBlockingDeque-阻塞队列-基于双向链表"><a href="#10-LinkedBlockingDeque-阻塞队列-基于双向链表" class="headerlink" title="10.LinkedBlockingDeque 阻塞队列(基于双向链表)"></a><strong>10.LinkedBlockingDeque 阻塞队列(基于双向链表)</strong></h6><p>类似LinkedBlockingQueue，但提供了双向链表特有的操作。</p>
<h6 id="11-PriorityBlockingQueue-线程安全的优先队列"><a href="#11-PriorityBlockingQueue-线程安全的优先队列" class="headerlink" title="11.PriorityBlockingQueue 线程安全的优先队列"></a><strong>11.PriorityBlockingQueue 线程安全的优先队列</strong></h6><p>构造时可以传入一个比较器，可以看做放进去的元素会被排序，然后读取的时候按顺序消费。某些低优先级的元素可能长期无法被消费，因为不断有更高优先级的元素进来。</p>
<h6 id="12-SynchronousQueue-数据同步交换的队列"><a href="#12-SynchronousQueue-数据同步交换的队列" class="headerlink" title="12.SynchronousQueue 数据同步交换的队列"></a><strong>12.SynchronousQueue 数据同步交换的队列</strong></h6><p>一个虚假的队列，因为它实际上没有真正用于存储元素的空间，每个插入操作都必须有对应的取出操作，没取出时无法继续放入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/yzfXal_20210607145843.png" alt="img"></p>
<p>可以看到，写入的线程没有任何sleep，可以说是全力往队列放东西，而读取的线程又很不积极，读一个又sleep一会。输出的结果却是读写操作成对出现。</p>
<p>JAVA中一个使用场景就是Executors.newCachedThreadPool()，创建一个缓存线程池。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607145908632_20210607145909.png" alt="img"></p>
<h6 id="13-LinkedTransferQueue-基于链表的数据交换队列"><a href="#13-LinkedTransferQueue-基于链表的数据交换队列" class="headerlink" title="13.LinkedTransferQueue 基于链表的数据交换队列"></a><strong>13.LinkedTransferQueue 基于链表的数据交换队列</strong></h6><p>实现了接口TransferQueue，通过transfer方法放入元素时，如果发现有线程在阻塞在取元素，会直接把这个元素给等待线程。如果没有人等着消费，那么会把这个元素放到队列尾部，并且此方法阻塞直到有人读取这个元素。和SynchronousQueue有点像，但比它更强大。</p>
<h6 id="14-DelayQueue-延时队列"><a href="#14-DelayQueue-延时队列" class="headerlink" title="14.DelayQueue 延时队列"></a><strong>14.DelayQueue 延时队列</strong></h6><p>可以使放入队列的元素在指定的延时后才被消费者取出，元素需要实现Delayed接口。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>上面简单介绍了JAVA并发包下的一些容器类，知道有这些东西，遇到合适的场景时就能想起有个现成的东西可以用了。想要知其所以然，后续还得再深入探索一番。</p>
<h4 id="十七、Future-和-CompletableFuture"><a href="#十七、Future-和-CompletableFuture" class="headerlink" title="十七、Future 和 CompletableFuture"></a>十七、Future 和 CompletableFuture</h4><p>CompletableFuture是java 8引入的，用于Java异步编程。异步编程是一种通过在与主应用程序线程不同的线程上运行任务并通知主线程其进度，完成或失败的方法来编写非阻塞代码的方法。<br> 这样，您的主线程就不会阻塞&#x2F;等待任务完成，并且可以并行执行其他任务。具有这种并行性可以大大提高程序的性能。</p>
<h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>Future被用作异步计算结果的参考。它提供了一个isDone（）方法来检查计算是否完成，以及一个get（）方法来检索计算完成后的结果。</p>
<h5 id="Future-VS-CompletableFuture："><a href="#Future-VS-CompletableFuture：" class="headerlink" title="Future VS CompletableFuture："></a>Future VS CompletableFuture：</h5><h6 id="1-手动完成"><a href="#1-手动完成" class="headerlink" title="1.手动完成"></a>1.手动完成</h6><p>Future提供了一个isDone（）方法来检查计算是否完成，以及get（）方法来检索计算结果。但是，Future不提供手动完成的方法。CompletableFuture的complete（）方法可帮助我们手动完成Future</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Manual Completion 手动完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">manualCompletion</span>() throws ExecutionException, InterruptedException</span> &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1111&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手动结束核心</span></span><br><span class="line">        future.complete(<span class="string">&quot;手动完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.<span class="keyword">out</span>.println(future.<span class="keyword">get</span>());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Future的get()方法在完成计算的之前是阻塞的，我们可以使用complete()方法来手动完成计算。</p>
<h6 id="2-多个Future组成调用链"><a href="#2-多个Future组成调用链" class="headerlink" title="2.多个Future组成调用链"></a>2.多个Future组成调用链</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callbackChain</span>() throws ExecutionException, InterruptedException</span> &#123;</span><br><span class="line">    CompletableFuture completableFuture</span><br><span class="line">            = CompletableFuture</span><br><span class="line">            .supplyAsync(() -&gt; <span class="string">&quot;Knolders!&quot;</span>)</span><br><span class="line">            .thenRun(() -&gt; System.<span class="keyword">out</span>.println(<span class="string">&quot;Example with thenRun().&quot;</span>));</span><br><span class="line">    System.<span class="keyword">out</span>.println(completableFuture.<span class="keyword">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-组合多个CompletableFuture结果"><a href="#3-组合多个CompletableFuture结果" class="headerlink" title="3.组合多个CompletableFuture结果"></a>3.组合多个CompletableFuture结果</h6><p>如果是Future，则无法创建异步工作流程，即长时间运行的计算。但是CompletableFuture为我们提供了方法来实现此功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private <span class="keyword">static</span> void <span class="title function_ invoke__">thenCompose</span>() &#123;</span><br><span class="line">    CompletableFuture&lt;<span class="type">String</span>&gt; completableFuture =</span><br><span class="line">            CompletableFuture.<span class="title function_ invoke__">supplyAsync</span>(() <span class="punctuation">-&gt;</span> <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                    .<span class="title function_ invoke__">thenCompose</span>(value <span class="punctuation">-&gt;</span></span><br><span class="line">                            CompletableFuture.<span class="title function_ invoke__">supplyAsync</span>(</span><br><span class="line">                                    () <span class="punctuation">-&gt;</span> value + <span class="string">&quot; Knolders! Its thenCompose&quot;</span>));</span><br><span class="line">    completableFuture.<span class="title function_ invoke__">thenAccept</span>(System.out::println); <span class="comment">// Hello Knolders! Its thenCompose</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你希望合并要并行运行的100种不同的Future，然后在所有这些Future完成后再运行某些功能。可是使用如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合所有的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> void allOf() <span class="keyword">throws</span> <span class="type">ExecutionException</span>, <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">String</span>&gt; completableFuture1</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">String</span>&gt; completableFuture2</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.supplyAsync(() -&gt; <span class="string">&quot;lv!&quot;</span>);</span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">String</span>&gt; completableFuture3</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.supplyAsync(() -&gt; <span class="string">&quot;Its allOf&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个方法并不直接返回结果只是返回一个CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">Void</span>&gt; combinedFuture</span><br><span class="line">                <span class="operator">=</span> <span class="type">CompletableFuture</span>.allOf(completableFuture1, completableFuture2, completableFuture3);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(combinedFuture.get()); <span class="comment">//输出null</span></span><br><span class="line"></span><br><span class="line">        assert (completableFuture1.isDone());</span><br><span class="line">        assert (completableFuture2.isDone());</span><br><span class="line">        assert (completableFuture3.isDone());</span><br><span class="line">        <span class="comment">//使用以下两种方法获取最终结果</span></span><br><span class="line">        <span class="type">CompletableFuture</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt; listCompletableFuture <span class="operator">=</span> combinedFuture.thenApply(v -&gt;</span><br><span class="line">                <span class="type">Stream</span>.of(completableFuture1, completableFuture2, completableFuture3).</span><br><span class="line">                        map(CompletableFuture::join).</span><br><span class="line">                        collect(<span class="type">Collectors</span>.toList()));</span><br><span class="line">        <span class="type">System</span>.out.println(listCompletableFuture.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> combined <span class="operator">=</span> <span class="type">Stream</span>.of(completableFuture1, completableFuture2, completableFuture3)</span><br><span class="line">                .map(CompletableFuture::join)</span><br><span class="line">                .collect(<span class="type">Collectors</span>.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        <span class="type">System</span>.out.println(combined);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h6><p>如果发生异常，调用链将会停止调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static void exception() &#123;</span><br><span class="line">    Integer age = -<span class="number">1</span>;</span><br><span class="line">    CompletableFuture&lt;String&gt; exceptionFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    exceptionFuture.thenAccept(System.<span class="keyword">out</span>::println); <span class="comment">//Unknown!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static void exceptionUsingHandle() &#123;</span><br><span class="line">    Integer age = -<span class="number">1</span>;</span><br><span class="line">    CompletableFuture&lt;String&gt; exceptionFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    exceptionFuture.thenAccept(System.<span class="keyword">out</span>::println); <span class="comment">// Unknown!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十八、……"><a href="#十八、……" class="headerlink" title="十八、……"></a>十八、……</h4><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h2><p>对于 Java 程序员来说，JVM 帮助我们做了很多事情比如内存管理、垃圾回收等等。在 JVM 的帮助下，我们的程序出现内存泄漏这些问题的概率相对来说是比较低的。但是，这并不代表我们在日常开发工作中不会遇到。万一你在工作中遇到了 OOM 问题，你至少要知道如何去排查和解决问题吧！<br>并且，就单纯从面试角度来说，JVM 是 Java 后端面试（大厂）中非常重要的一环。不论是应届还是社招，面试国内的一些大厂，你都会被问到很多 JVM 相关的问题（应届的话侧重理论，社招实践）。</p>
<p>只有搞懂了 JVM 才有可能真正把 Java 语言“吃透”。学习 JVM 这部分的内容，一定要注意要实战和理论结合。</p>
<p>书籍的话，**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a>** 这本书是首先要推荐的。</p>
<p>下面是我总结的一些关于 JVM 的小问题，你可以拿来自测：</p>
<h3 id="一、什么是虚拟机？"><a href="#一、什么是虚拟机？" class="headerlink" title="一、什么是虚拟机？"></a>一、什么是虚拟机？</h3><h4 id="1、-什么是JVM？"><a href="#1、-什么是JVM？" class="headerlink" title="1、 什么是JVM？"></a>1、 什么是JVM？</h4><p>　　JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<p>　　Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>
<h4 id="2、JRE-x2F-JDK-x2F-JVM是什么关系？"><a href="#2、JRE-x2F-JDK-x2F-JVM是什么关系？" class="headerlink" title="2、JRE&#x2F;JDK&#x2F;JVM是什么关系？"></a>2、JRE&#x2F;JDK&#x2F;JVM是什么关系？</h4><p>JRE(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。 </p>
<p>JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。 </p>
<p>JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p>
<h4 id="3、JVM原理"><a href="#3、JVM原理" class="headerlink" title="3、JVM原理"></a>3、JVM原理</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/vsFMvy_20210607151034.png" alt="img"></p>
<p>　　Java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。</p>
<p>我刚整理了一套2018最新的0基础入门和进阶教程，无私分享，加Java学习裙 ：678-241-563 即可获取，内附：开发工具和安装包，以及系统学习路线图</p>
<h4 id="4、JVM的体系结构"><a href="#4、JVM的体系结构" class="headerlink" title="4、JVM的体系结构"></a>4、JVM的体系结构</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/h5akfA_20210607151049.png" alt="img"></p>
<p>（1）java栈内存，它等价于C语言中的栈， 栈的内存地址是不连续的， 每个线程都拥有自己的栈。 栈里面存储着的是StackFrame，在《JVM Specification》中文版中被译作java虚拟机框架，也叫做栈帧。StackFrame包含三类信息：局部变量，执行环境，操作数栈。局部变量用来存储一个类的方法中所用到的局部变量。执行环境用于保存解析器对于java字节码进行解释过程中需要的信息，包括：上次调用的方法、局部变量指针和 操作数栈的栈顶和栈底指针。操作数栈用于存储运算所需要的操作数和结果。StackFrame在方法被调用时创建，在某个线程中，某个时间点上，只有一个 框架是活跃的，该框架被称为Current Frame，而框架中的方法被称为Current Method，其中定义的类为Current Class。局部变量和操作数栈上的操作总是引用当前框架。当Stack Frame中方法被执行完之后，或者调用别的StackFrame中的方法时，则当前栈变为另外一个StackFrame。Stack的大小是由两种类 型，固定和动态的，动态类型的栈可以按照线程的需要分配。 下面两张图是关于栈之间关系以及栈和非堆内存的关系基本描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FK51y8_20210607151103.png" alt="img"></p>
<p>（2） Java堆是用来存放对象信息的，和Stack不同，Stack代表着一种运行时的状态。换句话说，栈是运行时单位，解决程序该如何执行的问题，而堆是存储的单位， 解决数据存储的问题。Heap是伴随着JVM的启动而创建，负责存储所有对象实例和数组的。堆的存储空间和栈一样是不需要连续的。</p>
<p>（3）程序计数寄存器，程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>　　由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p>
<p>（4）方法区域（Method Area），在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p>
<p>（5）运行时常量池（Runtime Constant Pool），存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。</p>
<p>（6）本地方法堆栈（Native Method Stacks），JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。</p>
<h3 id="二、Java-内存区域是怎么划分的？大对象放在哪个内存区域？"><a href="#二、Java-内存区域是怎么划分的？大对象放在哪个内存区域？" class="headerlink" title="二、Java 内存区域是怎么划分的？大对象放在哪个内存区域？"></a>二、Java 内存区域是怎么划分的？大对象放在哪个内存区域？</h3><h4 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/isI7wn_20210607151456.png" alt="img"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>记录正在执行的虚拟机字节码指令地址（如果正在执行的是本地的方法则为空）。</p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/i4F7mi_20210607151531.png" alt="img"></p>
<p>可以通过-Xss这个虚拟机参数来指定一个Java虚拟机栈内存大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss = 512M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：<br>  1、当线程请求的栈深度超过最大值，会抛出StackOverflowError异常；<br>  2、栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法不是用Java实现，对待这些方法需要特别处理。<br> 与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7A6VYF_20210607151605.png" alt="img"></p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>所有对象实例都在这里分配内存。</p>
<p>是垃圾收集器的主要区域（”GC堆”），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把Java堆分成以下三块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://www.cnblogs.com/orientsun/archive/2012/07/25/2608548.html">Tenured Generation</a>）</li>
<li>永久代（Permanent Generation）</li>
</ul>
<p>当一个对象被创建时，首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效率地进行垃圾回收，把新生代分成以下三个空间：</p>
<ul>
<li>Eden</li>
<li>From Survivor</li>
<li>To Survivor</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/I1PicV_20210607151634.png" alt="img"></p>
<p>Java堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OutOfMenmoryError异常。<br> 可以通过-Xms和-Xmx两个虚拟机参数来指定一个程序的Java堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms = 1M -Xmx = 2M HackTheJava</span><br></pre></td></tr></table></figure>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br> 和Java堆不一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。<br> 对这块区域进行垃圾回收的主要目标是对常量池的回收和类的卸载，但是一般比较难实现，HotSpot把它当成永久代来进行垃圾回收。</p>
<h5 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h5><p>运行常量池是方法区的一部分。<br> Class文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。<br> 除了在编译期生成的常量，还允许动态生成，例如String类的intern()。这部分常量也会被放入运行时常量池。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h4 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h4><h4 id="重拾Markdown，一些用法的使用记录"><a href="#重拾Markdown，一些用法的使用记录" class="headerlink" title="重拾Markdown，一些用法的使用记录"></a>重拾Markdown，一些用法的使用记录</h4><h5 id="1、空行"><a href="#1、空行" class="headerlink" title="1、空行"></a>1、空行</h5><p>  起作用的：正文内容。<br>  不起作用的：各级标题、分隔线、代码框编辑前后。<strong>使用前后都添加空行</strong></p>
<h5 id="2、缩进控制"><a href="#2、缩进控制" class="headerlink" title="2、缩进控制"></a>2、缩进控制</h5><p>  <code> </code>&amp;ensp;缩进一个空格。<br>  <code> </code>&amp;emsp;缩进两个空格。<br> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9d94660a96f1">https://www.jianshu.com/p/9d94660a96f1</a></p>
<h5 id="3、代码展示"><a href="#3、代码展示" class="headerlink" title="3、代码展示"></a>3、代码展示</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/m7N6bX_20210607151405.png" alt="img"></p>
<p>&#96;&#96;&#96;和&#96;两者包含的代码框有什么不同？ </p>
<p>&#96;&#96;&#96;代码框。</p>
<p>&#96;代码片。</p>
<p> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9b582bb6760">https://www.jianshu.com/p/b9b582bb6760</a></p>
<h5 id="4、Markdown是否有转义字符的使用？"><a href="#4、Markdown是否有转义字符的使用？" class="headerlink" title="4、Markdown是否有转义字符的使用？"></a>4、Markdown是否有转义字符的使用？</h5><p>  比如代码框符号&#96;&#96;&#96;，引用符号&gt;等。这个转义字符就是反斜杠 \。<br> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9b582bb6760">https://www.jianshu.com/p/b9b582bb6760</a></p>
<h5 id="5、简数编辑区域的Markdown怎么设置图片的位置？"><a href="#5、简数编辑区域的Markdown怎么设置图片的位置？" class="headerlink" title="5、简数编辑区域的Markdown怎么设置图片的位置？"></a>5、简数编辑区域的Markdown怎么设置图片的位置？</h5><p>  <em>暂时没有解决。</em></p>
<h5 id="6、一些说明："><a href="#6、一些说明：" class="headerlink" title="6、一些说明："></a>6、一些说明：</h5><p>  <strong>图片连接地址前后都设置一个空行。</strong>简书的markdown文章中的图片不用做其他设置都是默认居中，而在个人博客中却默认左对齐，具体效果如下图。对于有轻微强迫症的笔者决定将所有图片修改为居中对齐，搜索了一下，只需在markdown文件中的图片引用前后加上 HTML <div> 标签即可实现居中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----空行----</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">![]()</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">-----空行----</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.php-master.com/post/68996.html">http://www.php-master.com/post/68996.html</a></p>
<h5 id="7、强制换行"><a href="#7、强制换行" class="headerlink" title="7、强制换行"></a>7、强制换行</h5><p>  markdown编辑器下直接回车，预览时换行是显示不了的。这时就需要强制换行了。<br>  强制换行语法：<code>&lt;br&gt;</code>。可以直接使用，在简书编辑区域同样有效。</p>
<h5 id="8、杂"><a href="#8、杂" class="headerlink" title="8、杂"></a>8、杂</h5><p>  <code>&lt;br&gt;</code>与<code>&lt;br/&gt;</code>？<br>  不同的标准下的产物，使用上没什么差异，相互兼容。</p>
<p>  分隔符还是统一使用***；使用—如果它的上面没有空行，文字将会被误解析成标题。</p>
<p>  Markdown编辑的文本在不同的解析器下面，换行的长度会不同。</p>
<h3 id="三、垃圾回收有哪些算法？GC-的流程"><a href="#三、垃圾回收有哪些算法？GC-的流程" class="headerlink" title="三、垃圾回收有哪些算法？GC 的流程"></a>三、垃圾回收有哪些算法？GC 的流程</h3><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>1、一个对象一生经历了什么？<br>2、如何判断对象是否可用？<br>3、引用计数法和可达性分析算法各自优缺点?<br>4、哪些对象可以作为GC ROOT?<br>5、垃圾回收的时候如何快速寻找根节点？<br>6、垃圾回收算法有哪些？各自优缺点？<br>7、有哪些垃圾回收器？各自优缺点？适用什么场景？</p>
<h4 id="1、对象回收处理过程"><a href="#1、对象回收处理过程" class="headerlink" title="1、对象回收处理过程"></a>1、对象回收处理过程</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607152935713_20210607152936.png" alt="img"></p>
<h4 id="2、判断用户是否可用计算"><a href="#2、判断用户是否可用计算" class="headerlink" title="2、判断用户是否可用计算"></a>2、判断用户是否可用计算</h4><h5 id="2-1、引用计数算法"><a href="#2-1、引用计数算法" class="headerlink" title="2.1、引用计数算法"></a>2.1、引用计数算法</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/zQbhzP_20210607153405.png" alt="img"></p>
<p>如上图，给对象一个引用技术refCount。每有一个对象引用它，计时器加1，当它为0时，表示对象补课在用。</p>
<p>缺点。  </p>
<p>很难解决循环引用的问题。</p>
<p>objA.instance &#x3D; objB</p>
<p>objB.instance &#x3D; objA</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/O85ZFh_20210607153439.png" alt="img"></p>
<p>如上，即使objA和objB 都不在被访问后，但是它们还在 相互引用，所以计数器不会为0</p>
<h5 id="2-2、可达性分析算法"><a href="#2-2、可达性分析算法" class="headerlink" title="2.2、可达性分析算法"></a>2.2、可达性分析算法</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lsM8Kz_20210607153506.png" alt="img"></p>
<p>如上图，从GC Roots开始向下搜索，连接的路径为引用链；</p>
<p>GC Roots不可达的对象被判为不可用；<br><strong>可作为GC Root的对象</strong></p>
<p><strong>如上图，虚拟机栈帧中本地变量表引用的对象，本地方法栈中，JNI引用的对象，方法区中的类静态属性引入的对象和常量引用对象都可以作为GC Root。</strong></p>
<p><strong>引用类型</strong></p>
<ul>
<li>强引用：<br>类似 object a &#x3D; new object();</li>
<li>软引用：<br>SoftReference<String> ref &#x3D; new SoftReference<String>(“Hello World”);OOM前，JVM会把这些对象列入回收范围进行二次回收，如果回收后内存还是不做，则OOM。</li>
<li>弱引用：<br>WeakReference<Car> weakCar &#x3D; new WeakReference<Car>(car);每次垃圾收集，弱引用的对象就会被清理</li>
<li>虚引用：<br>幽灵引用，不能用来获取一个对象的实例，唯一用途：当一个虚引用引用的对象被回收，系统会收到这个对象被回收的通知。</li>
</ul>
<h4 id="3、HotSpot中如何实现判断是否存在与GC-Roots相连接的引用链"><a href="#3、HotSpot中如何实现判断是否存在与GC-Roots相连接的引用链" class="headerlink" title="3、HotSpot中如何实现判断是否存在与GC Roots相连接的引用链"></a>3、HotSpot中如何实现判断是否存在与GC Roots相连接的引用链</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607153915850_20210607153916.png" alt="img"></p>
<p>第一小节流程图里的是否存在与GC Roots相连接的引用链 这个判断子流程是怎么实现的呢，这节我们来仔细探讨下。</p>
<p>一般的，我们都是选取可达性分析算法，这里主要阐述怎么寻找GC Root以及如何检查引用链。</p>
<h5 id="3-1、枚举根节点"><a href="#3-1、枚举根节点" class="headerlink" title="3.1、枚举根节点"></a>3.1、枚举根节点</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607153933179_20210607153933.png" alt="img"></p>
<p>如上图，在一个调用关系为：</p>
<p>ClassA.invokeA() –&gt; ClassB.invokeB() –&gt;doinvokeB() –&gt;ClassC.execute()</p>
<p>的情况下，每个调用对应一个栈帧，栈帧里面的本地变量表存储了GC Roots的引用。</p>
<p>如果直接遍历所有的栈去查找GC Roots，效率太低了。为此我们引入了OopMap和安全点的概念。</p>
<p><strong>安全点和OopMap</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/eNYInZ_20210607154007.png" alt="img"></p>
<p>如上图，在源代码编译的时候，会在特定位置下记录安全点，一般为：</p>
<p>1、循环的末尾</p>
<p>2、方法返回前 或者调用方法的call指令后</p>
<p>3、可能抛出异常的位置</p>
<p>通过安全点把代码分成几段，每段代码一个OopMap。</p>
<p>OopMap记录栈上本地变量到堆上对象的引用关系，每当触发GC的时候，程序都先跑的最近的安全点，然后自动挂起，然后在触发更新OopMap，然后进行枚举类GC ROOT，进行垃圾回收：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/4Wn0gn_20210607154023.png" alt="img"></p>
<p>安全区域：在一段代码片段之中，引用关系不会发生变化，因此在这个区域中的任意位置开始 GC 都是安全的。如处于Sleep或者Blocked状态的线程。</p>
<p>为了在枚举GC Roots的过程中，对象的引用关系不会变更，所以需要一个GC停顿。</p>
<p>还有一种抢先式中断的方式，几乎没有虚拟机采用：先中断所有线程，发现线程没中断在安全点，恢复它，继续执行到安全点。</p>
<p>找到了该回收的对象，下一步就是清掉这些对象了，HotSpot将去交给CG收集器。</p>
<h4 id="4、垃圾回收算法"><a href="#4、垃圾回收算法" class="headerlink" title="4、垃圾回收算法"></a>4、垃圾回收算法</h4><p>概览图</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TtxwIM_20210607154038.png" alt="img"></p>
<h5 id="4-1、标记-清除算法"><a href="#4-1、标记-清除算法" class="headerlink" title="4.1、标记-清除算法"></a>4.1、标记-清除算法</h5><h6 id="4-1-1、算法描述"><a href="#4-1-1、算法描述" class="headerlink" title="4.1.1、算法描述"></a>4.1.1、算法描述</h6><p>标记阶段：标记处所有需要回收的对象；</p>
<p>清除阶段：标记成功后，统一回收所有被标记的对象；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/502JCL_20210607154055.png" alt="img"></p>
<h6 id="4-1-2、不足"><a href="#4-1-2、不足" class="headerlink" title="4.1.2、不足"></a>4.1.2、不足</h6><p>效率不高：标记和清除两个过程效率都不高；</p>
<p>空间问题：产生大量不连续的内存碎片，进而无法容纳大对象提早触发另一次GC.。</p>
<h5 id="4-2、复制算法"><a href="#4-2、复制算法" class="headerlink" title="4.2、复制算法"></a>4.2、复制算法</h5><h6 id="4-2-1、算法描述"><a href="#4-2-1、算法描述" class="headerlink" title="4.2.1、算法描述"></a>4.2.1、算法描述</h6><p>将可用内存分为容量大小相等的两块，每次只使用其中一块；</p>
<p>当一块用完，就将存活着的对象复制到另一块，然后将这块全部内存清理掉；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/0duyuk_20210607154116.png" alt="img"></p>
<h6 id="4-2-2、优点"><a href="#4-2-2、优点" class="headerlink" title="4.2.2、优点"></a>4.2.2、优点</h6><p>不会产生不连续的内存碎片</p>
<p>提高效率： </p>
<p>​    回收：每次都是对整个半区进行回收；</p>
<p>​    分配：分配时也不用考虑内存碎片的问题，只要移动指针，按顺序分配内存即可。</p>
<h6 id="4-2-3、缺点"><a href="#4-2-3、缺点" class="headerlink" title="4.2.3、缺点"></a>4.2.3、缺点</h6><p>可用内存缩小为原来的一半了，适合GC过后只有少量存活的新生代，可以根据实际情况，将内存块大小比例适当调整；</p>
<p>如果存活对象数量比较大，复制性能会变得很差。</p>
<h5 id="4-2-4、JVM中新生代的垃圾回收"><a href="#4-2-4、JVM中新生代的垃圾回收" class="headerlink" title="4.2.4、JVM中新生代的垃圾回收"></a>4.2.4、JVM中新生代的垃圾回收</h5><p>如下图，分为新生代和老年代。其中新生代又分为一个Eden区和两个Survivor去(from区和to区)，默认Eden : from : to 比例为8:1:1。</p>
<p>可通过JVM参数：-XX:SurvivorRatio配置比例，-XX:SurvivorRatio&#x3D;8 表示 Eden区大小 &#x2F; 1块Survivor区大小 &#x3D; 8。</p>
<p><strong>第一次Young GC</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HDxRFt_20210607154131.png" alt="img"></p>
<p>再次触发Young GC，扫描Eden区和from区，把存活的对象复制到To区，清空Eden区和from区。如果此时Survivor区的空间不够了，就会提前把对象放入老年代。</p>
<p>默认的，这样来回交换15次后，如果对象最终还是存活，就放入老年代。</p>
<p>交换次数可以通过JVM参数MaxTenuringThreshold进行设置。</p>
<h5 id="4-2-5、JVM内存模型"><a href="#4-2-5、JVM内存模型" class="headerlink" title="4.2.5、JVM内存模型"></a>4.2.5、JVM内存模型</h5><p>JDK8之前</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/gjNNif_20210607154155.png" alt="img"></p>
<p>JDK8</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KUvMoR_20210607154209.png" alt="img"></p>
<p>如上图，JDK8的方法区实现变成了元空间，元空间在本地内存中。</p>
<h5 id="4-3、标记-整理算法"><a href="#4-3、标记-整理算法" class="headerlink" title="4.3、标记-整理算法"></a>4.3、标记-整理算法</h5><h6 id="4-3-1、算法描述"><a href="#4-3-1、算法描述" class="headerlink" title="4.3.1、算法描述"></a>4.3.1、算法描述</h6><p>标记过程与标记-清楚算法一样；</p>
<p>标记完成后，将存活对象向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/66TPGn_20210607154247.png" alt="img"></p>
<h6 id="4-3-2、优点"><a href="#4-3-2、优点" class="headerlink" title="4.3.2、优点"></a>4.3.2、优点</h6><p>不会产生内存碎片；</p>
<p>不需要浪费额外的空间进行分配担保；</p>
<h6 id="4-3-3、不足"><a href="#4-3-3、不足" class="headerlink" title="4.3.3、不足"></a>4.3.3、不足</h6><p>整理阶段存在效率问题，适合老年代这种垃圾回收频率不是很高的场景；</p>
<h5 id="4-4、分代收集算法"><a href="#4-4、分代收集算法" class="headerlink" title="4.4、分代收集算法"></a>4.4、分代收集算法</h5><p>当前商业虚拟机都采用该算法。</p>
<p>新生代：复制算法(CG后只有少量的对象存活)</p>
<p>老年代：标记-整理算法 或者 标记-清理算法(GC后对象存活率高)</p>
<h4 id="5、垃圾回收器"><a href="#5、垃圾回收器" class="headerlink" title="5、垃圾回收器"></a>5、垃圾回收器</h4><p>这一步就是我们真正进行垃圾回收的过程了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NYLE3J_20210607154302.png" alt="img"></p>
<p>本节概念约定：并发：用户线程与垃圾收集线程同时执行，但不一定是并行，可能交替执行；并行：多条垃圾收集线程并行工作，单用户线程仍处于等待状态。</p>
<p>以下是垃圾收集器概览图</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/D6zV3r_20210607154323.png" alt="img"></p>
<h5 id="5-1、Serial收集器"><a href="#5-1、Serial收集器" class="headerlink" title="5.1、Serial收集器"></a>5.1、Serial收集器</h5><h6 id="5-1-1、特点"><a href="#5-1-1、特点" class="headerlink" title="5.1.1、特点"></a>5.1.1、特点</h6><p>串行化：在垃圾回收时，必须赞同其他所有工作线程，知道收集结束，Stop The World；</p>
<p>在单CPU模式下无线程交互开销，专心做垃圾收集，简单高效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Eb3q5X_20210607154332.png" alt="img"></p>
<h6 id="5-1-2、适用场景"><a href="#5-1-2、适用场景" class="headerlink" title="5.1.2、适用场景"></a>5.1.2、适用场景</h6><p>特别适合限定单CPU的环境；</p>
<p>Client模式下的默认新生代收集器，用户桌面应用场景分配给虚拟机的内存一般不会很大，所以停顿时间也是在一百多毫秒以内，影响不大。</p>
<h5 id="5-2、ParNew收集器"><a href="#5-2、ParNew收集器" class="headerlink" title="5.2、ParNew收集器"></a>5.2、ParNew收集器</h5><p>Parallel New?</p>
<h6 id="5-2-1、特点"><a href="#5-2-1、特点" class="headerlink" title="5.2.1、特点"></a>5.2.1、特点</h6><p>Serial收集器的多线程版本；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/iZVXHy_20210607154350.png" alt="img"></p>
<h6 id="5-2-2、适用场景"><a href="#5-2-2、适用场景" class="headerlink" title="5.2.2、适用场景"></a>5.2.2、适用场景</h6><p>许多运行在Server模式下的虚拟机中的首选新生代收集器；</p>
<p>除了Serial收集器外，只有它能和CMS收集器搭配使用。</p>
<p>-XX:+UseConcMarkSweepGC选型默认使用ParNew收集器。也可以使用-XX:+UseParNewGC选项强制指定它。</p>
<p>ParNew收集器在单CPU环境比Serial收集器效果差(存在线程交互开销)。</p>
<p>CPU数量越多，ParNew效果越好，默认开启收集线程数&#x3D;CPU数量。可以使用-XX:ParallelGCThreads参数限制垃圾收集器的线程数。</p>
<h5 id="5-3、Parallel-Scavenge收集器"><a href="#5-3、Parallel-Scavenge收集器" class="headerlink" title="5.3、Parallel Scavenge收集器"></a>5.3、Parallel Scavenge收集器</h5><h6 id="5-3-1、特点"><a href="#5-3-1、特点" class="headerlink" title="5.3.1、特点"></a>5.3.1、特点</h6><p>新生代收集器，使用复制算法，并行多线程；</p>
<p>吞吐量优先收集器：CMS等收集器会关注如何缩短停顿时间，而这个收集器是为了吞吐量而设计的。</p>
<p>吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )</p>
<p>也就是说整体垃圾收集时间越短，吞吐量越高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/EDV0Fw_20210607154405.png" alt="img"></p>
<h6 id="5-3-2、适用场景"><a href="#5-3-2、适用场景" class="headerlink" title="5.3.2、适用场景"></a>5.3.2、适用场景</h6><p>可以高效利用CPU时间，尽快完成程序的运算任务，适合后台运算不需要太多交互的任务；</p>
<h6 id="5-3-3、相关参数"><a href="#5-3-3、相关参数" class="headerlink" title="5.3.3、相关参数"></a>5.3.3、相关参数</h6><p>-XXMaxGCPauseMillis：设置最大垃圾收集停顿时间，大于0的毫秒数；</p>
<p>缩短GC停顿时间会牺牲吞吐量和新生代空间。新生代空间小，GC回收就快，但是同时会导致GC更加频繁，整体垃圾回收时间更长。</p>
<p>-XX:GCTimeRatio：设置吞吞量大小。0~100的整数，垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</p>
<p>19: 1&#x2F;(1+19)&#x3D; 5%，即最大GC时间占比5%；</p>
<p>99: 1&#x2F;(1+99)&#x3D;1%，即最大GC时间占比1%；</p>
<p>-XX:+UseAdaptiveSizePolicy：GC自适应调节策略开关，打开开关，无需手工指定-Xmn(新生代大小)、-XX:SurvivorRatio(Eden与Survivor区比例)、-XX:PretenureSizeThreshold(晋升老年代对象年龄)等参数，虚拟机会收集性能监控信息，动态调整这些参数，确保提供最合适的 停顿时间或者最大吞吐量。</p>
<h5 id="5-4、Serial-Old收集器"><a href="#5-4、Serial-Old收集器" class="headerlink" title="5.4、Serial Old收集器"></a>5.4、Serial Old收集器</h5><h6 id="5-4-1、特点"><a href="#5-4-1、特点" class="headerlink" title="5.4.1、特点"></a>5.4.1、特点</h6><p>Serial收集器的老年代版本。使用单线程，标记-整理算法。</p>
<h6 id="5-4-2、适用场景"><a href="#5-4-2、适用场景" class="headerlink" title="5.4.2、适用场景"></a>5.4.2、适用场景</h6><p>主要给Client模式下的虚拟机使用；</p>
<p>Server模式下，量大用途：</p>
<p>JDK1.5版本之前的版本与Parallel Scavenge收集器搭配使用；</p>
<p>作为CMS收集器的后备预案，发生Concurrent Mode Failure时使用。</p>
<h5 id="5-5、Parallel-Olde收集器"><a href="#5-5、Parallel-Olde收集器" class="headerlink" title="5.5、Parallel Olde收集器"></a>5.5、Parallel Olde收集器</h5><h6 id="5-5-1、特点"><a href="#5-5-1、特点" class="headerlink" title="5.5.1、特点"></a>5.5.1、特点</h6><p>Parallel Scavenge收集器的老年代版本，使用多线程，标记整理算法。</p>
<h6 id="5-5-2、使用场景"><a href="#5-5-2、使用场景" class="headerlink" title="5.5.2、使用场景"></a>5.5.2、使用场景</h6><p>主要配合Parallel Scavenge使用，提高吞吐量。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑这个组合。</p>
<p>JDK1.6之后提供，之前Parallel Scavenge只能与Serial Old配合使用，老年代Serial Old无法充分利用服务器多CPU处理器能力，拖累了实际的吞吐量，效果不如ParNew+CMS组合；</p>
<h5 id="5-6、CMS收集器"><a href="#5-6、CMS收集器" class="headerlink" title="5.6、CMS收集器"></a>5.6、CMS收集器</h5><p>Concurrent Mark Sweep</p>
<h6 id="5-6-1、特点"><a href="#5-6-1、特点" class="headerlink" title="5.6.1、特点"></a>5.6.1、特点</h6><p>设计目标：获得最短回收停顿时间；</p>
<p>注重服务响应速度；</p>
<p>标记-清除算法；</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/nC3LQY_20210607154423.png" alt="img"></p>
<h6 id="5-6-2、缺点"><a href="#5-6-2、缺点" class="headerlink" title="5.6.2、缺点"></a>5.6.2、缺点</h6><p>对CPU资源敏感，虽然不会导致用户线程停顿，但是会占用一部分线程(CPU资源)而导致应用程序变慢，吞吐量降低；</p>
<p>CMS收集器无法处理浮动垃圾。在CMS并发清理阶段，用户线程会产生垃圾。如果出现Concurrent Mode Failure失败，会启动后备预案：临时启动Serial Old收集器重新进行老年代垃圾收集，停顿时间更长了。-XX:CM SInitiatingOccupancyFraction设置的太高容易导致这个问题；</p>
<p>基于标记-清除算法，会产生大量空间碎片。</p>
<h6 id="5-6-3、使用场景"><a href="#5-6-3、使用场景" class="headerlink" title="5.6.3、使用场景"></a>5.6.3、使用场景</h6><p>互联网网站或者B&#x2F;S系统的服务器；</p>
<h6 id="5-6-4、相关参数"><a href="#5-6-4、相关参数" class="headerlink" title="5.6.4、相关参数"></a>5.6.4、相关参数</h6><p>-XX:+UseCMSCompactAtFullCollection：在CMS要进行Full GC时进行内存碎片整理(默认开启)。内存整理过程无法并发，会增加停顿时间；</p>
<p>-XX:CMSFullGCsBeforeCompaction：在多少次 Full GC 后进行一次空间整理(默认0，即每一次 Full GC 后都进行一次空间整理)；</p>
<p>-XX:CM SInitiatingOccupancyFraction：触发GC的内存百分比，设置的太高容易导致Concurrent Mode Failure失败(GC过程中，用户线程新增的浮动垃圾，导致触发另一个Full GC)。</p>
<p>CMS为什么要采用标记-清除算法？</p>
<p>CMS主要关注低延迟，所以采用并发方式清理垃圾，此时程序还在运行，如果采用压缩算法，则会涉及到移动应用程序的存活对象，这种场景下不做停顿是很难处理的，一般需要停顿下来移动存活对象，再让应用程序继续运行，但是这样停顿时间就边长了，延迟变长。CMS是容忍了空间碎片来换取回收的低延迟。</p>
<h5 id="5-7、G1收集器"><a href="#5-7、G1收集器" class="headerlink" title="5.7、G1收集器"></a>5.7、G1收集器</h5><p>G1：Garbage-First，即优先回收价值最大的Region(注1)。</p>
<p>注1：G1与收集器将整个Java堆换分为多个代销相等的独立区域，跟踪各个Region里面的垃圾堆积的价值大小，优先回收价值最大的Region。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/jtj1A0_20210607154438.png" alt="img"></p>
<p>如上图，G1收集器分为四个阶段：</p>
<p>初始标记：只标记GC Roots能直接关联到的对象，速度很快。并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能够在正确可用的Region中创建新对象，这阶段需要停顿线程；</p>
<p>并发标记：GC RootsTracing过程。该阶段对象变化记录在线程Remembered Set Logs中。</p>
<p>最终标记：修正并发期间因用户程序运作而导致标记产生变动的部分对象的标记记录。把Remembered Set Logs数据合并到Remembered Set中。这个阶段需要停顿，但是可并行执行；</p>
<p>筛选回收：对各个Region回收价值和成本进行排序，根据用户期望Gc停顿时间制定回收计划。与CMS不一样，这里不用和用户线程并发执行，提高收集效率，使用标记-整理算法，不产生空间碎片。</p>
<h6 id="5-7-1、特点"><a href="#5-7-1、特点" class="headerlink" title="5.7.1、特点"></a>5.7.1、特点</h6><p>并行与并发：并发标记，并行最终标记与筛选回收；</p>
<p>分代收集</p>
<p>空间整合：基于标记-整理算法，不会产生碎片。</p>
<p>可预测的停顿：G与收集器将整个Java堆换分为多个代销相等的独立区域，避免在整个Java堆中进行全区域的垃圾回收，跟踪各个Region里面垃圾堆积的价值大小，后台维护一个优先列表，每次根据运行的收集时间，优先回收价值最大的Region。</p>
<h3 id="四、什么是类加载？何时类加载？类加载流程？"><a href="#四、什么是类加载？何时类加载？类加载流程？" class="headerlink" title="四、什么是类加载？何时类加载？类加载流程？"></a>四、什么是类加载？何时类加载？类加载流程？</h3><h4 id="类的加载过程介绍"><a href="#类的加载过程介绍" class="headerlink" title="类的加载过程介绍"></a>类的加载过程介绍</h4><ol>
<li><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul>
<li><p>类的加载指的是将类的 .class 文件中的二进制数据读入到 JVM 内存中，将其放在运行时数据区的 <strong>方法区</strong> 内，然后在 <strong>堆区</strong> 创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。类的加载的最终是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且提供了访问方法区内的数据结构的接口。</p>
</li>
<li><p>类的加载过程分为 3 个步骤：<strong>加载；连接（验证、准备、解析）；初始化</strong>，一般情况下 JVM 会连续完成 3 个步骤，有时也会只完成前两步。</p>
</li>
<li><p>如图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18194036-69d59af96d828f3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1158/format/webp" alt="img"></p>
<p>类加载过程.jpg</p>
</li>
</ul>
</li>
<li><h5 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a80db3beb21a">类加载介绍</a></li>
<li>系统可能在第一次使用某一个类时，加载该类，但也可能采用 <strong>预先加载机制</strong> 来加载该类，不管怎样类的加载必须由 <strong>类加载器</strong> 来完成。通常类加载器是由 JVM 提供。</li>
<li>类的加载必须由类加载器完成，通常情况下类加载器由 JVM 提供，但也可以通过自定义。<ol>
<li>JVM 提供的类加载器被称之为 <strong>系统类加载器</strong></li>
<li>开发者还可以通过继承 <strong>ClassLoader</strong> 接口来创建 <strong>自定义类加载器</strong></li>
</ol>
</li>
<li>通过不同的类加载器，可以从不同的 “来源” 加载类的 .class 文件（二进制文件）<ol>
<li>从本地系统中直接读取 .class 文件，大部分的加载方式。</li>
<li>从 ZIP、JAR 等归档文件中加载 .class 文件，很常见。</li>
<li>从网络下载 .class 文件数据。</li>
<li>从专有数据库中读取 .class 文件</li>
<li>将 Java 的源文件数据，上传到服务器中，进行动态编译产生 .class 文件，并加以执行。</li>
</ol>
</li>
<li>但是不管 .class 文件数据来源何处，加载的结果都是相同的<ol>
<li>将字节码文件数据加载到 JVM 内存中，将其放在运行时数据区的 <strong>方法区</strong> 内，然后在 <strong>堆区</strong> 创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。类的加载的最终是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且提供了访问方法区内的数据结构的接口。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>通过一个类的全限定名来获取其定义的字节码（二进制字节流），将字节码文件加载到 JVM 内存中，此过程由类加载器完成（可控）</li>
</ul>
</li>
<li><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h5><ul>
<li>加载阶段是可控性最强的阶段，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</li>
</ul>
</li>
</ol>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ol>
<li><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><ul>
<li>校验 .class 文件是否合法，遵循 .class 文件格式 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a682f9cc5fea">参考地址</a></li>
</ul>
</li>
<li><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul>
<li>为类变量（<code>static</code> 修饰的变量）在 JVM 方法区中分配内存，并进行 <strong>默认初始化</strong><ol>
<li><code>int</code> 默认初始化为 <code>0</code></li>
<li>引用默认初始化为 <code>null</code></li>
<li>等等</li>
</ol>
</li>
<li>静态常量（<code>static final</code>） ，有所不同，直接在 JVM 方法去中 <strong>显示初始化</strong></li>
</ul>
</li>
<li><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ul>
<li>JVM 将常量池的符号引用。替换为直接（地址）引用</li>
</ul>
</li>
<li><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li><strong>此时在堆区中已经创建一个 java.lang.Class 对象，指向方法区中的数据</strong></li>
</ul>
</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ul>
<li>主要是对类静态的类变量进行 <strong>显示初始化</strong>  <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/u013309870/article/details/72975536">参考地址</a><ol>
<li>init 对非静态变量解析初始化</li>
<li>clinit 是 java.lang.class 类构造器对静态变量，静态代码块进行初始化</li>
</ol>
</li>
<li>类构造器方法（clinit）由编译器收集类中所有类变量的 <strong>显示赋值和静态代码块中的语句合并产生</strong></li>
</ul>
</li>
<li><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul>
<li>当初始化某个类时，如果其父类没有初始化，则先触发父类的初始化动作</li>
<li>JVM 保证一个类的初始化，在多线中中正确加锁和同步</li>
</ul>
</li>
</ol>
<h4 id="何时会或者不会触发类初始化动作呢？"><a href="#何时会或者不会触发类初始化动作呢？" class="headerlink" title="何时会或者不会触发类初始化动作呢？"></a>何时会或者不会触发类初始化动作呢？</h4><ol>
<li><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><ul>
<li>上面已经介绍，类的加载过程分为 3 步，大部分 3 步按顺序完成，有时也会只完成前两步</li>
</ul>
</li>
<li><h5 id="如何区分会不会触发类的初始化"><a href="#如何区分会不会触发类的初始化" class="headerlink" title="如何区分会不会触发类的初始化"></a>如何区分会不会触发类的初始化</h5><ul>
<li><p>如表</p>
<table>
<thead>
<tr>
<th>会触发类的初始化</th>
<th>不会触发类的初始化</th>
</tr>
</thead>
<tbody><tr>
<td>当虚拟机启动时，先初始化 <code>main()</code> 方法所在的类</td>
<td>引用静态常量不会触发此类的初始化</td>
</tr>
<tr>
<td>一次 <code>new</code> 一个类的对象（在 JVM 中一个类的 Class 对象只有一个）</td>
<td>当访问一个静态域时，只有真正声明该域的类才会被初始化（子类继承父类的静态变量，在子类使用该静态变量时，只有父类会初始化，子类不会初始化）</td>
</tr>
<tr>
<td>调用该类的静态变量（<code>static final</code> 除外，因为其在连接时已经显示初始化完成）和静态方法</td>
<td>通过数组定义类引用时，不会触发类初始化（<code>A[] as = new A[2]</code> A 是类，此时不会初始化 A类）</td>
</tr>
<tr>
<td>当初始化某个类时，其父类没有被初始化时，则会先初始化其父类</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h3 id="五、知道哪些类加载器。类加载器之间的关系？"><a href="#五、知道哪些类加载器。类加载器之间的关系？" class="headerlink" title="五、知道哪些类加载器。类加载器之间的关系？"></a>五、知道哪些类加载器。类加载器之间的关系？</h3><h4 id="一、三种类加载器"><a href="#一、三种类加载器" class="headerlink" title="一、三种类加载器"></a>一、三种类加载器</h4><p>当 JVM 启动的时候，Java 缺省开始使用如下三种类型的类加载器：</p>
<p><strong>启动（Bootstrap）类加载器</strong>：引导类加载器是用 本地代码实现的类加载器，它负责将 <JAVA_HOME>&#x2F;lib 下面的核心类库 或 -Xbootclasspath 选项指定的 jar 包等 虚拟机识别的类库 加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以 不允许直接通过引用进行操作。</p>
<p><strong>扩展（Extension）类加载器</strong>：扩展类加载器是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将 <JAVA_HOME>&#x2F;lib&#x2F;ext 或者由系统变量 - Djava.ext.dir 指定位置中的类库 加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
<p><strong>系统（System）类加载器</strong>：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将 用户类路径 (java -classpath 或 - Djava.class.path 变量所指的目录，即当前类所在路径及其引用的第三方类库的路径。开发者可以直接使用系统类加载器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/a3hwNw_20210607160522.png"></p>
<p>通过这两张图我们可以看出，扩展类加载器和系统类加载器均是继承自 java.lang.ClassLoader 抽象类。</p>
<h4 id="二、类加载器的关系"><a href="#二、类加载器的关系" class="headerlink" title="二、类加载器的关系"></a>二、类加载器的关系</h4><p>关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ap1Obm_20210607160540.png"></p>
<p>上面图片给人的直观印象是：系统类加载器的父类加载器是标准扩展类加载器，标准扩展类加载器的父类加载器是启动类加载器。</p>
<p>事实上，由于启动类加载器无法被 Java 程序直接引用，因此 JVM 默认直接使用 null 代表启动类加载器。</p>
<p>此外：</p>
<p>1．<strong>系统类加载器（AppClassLoader）调用 ClassLoader (ClassLoader parent) 构造函数将父类加载器设置为标准扩展类加载器 (ExtClassLoader)。</strong>（因为如果不强制设置，默认会通过调用 getSystemClassLoader () 方法获取并设置成系统类加载器。）</p>
<p>2．<strong>扩展类加载器（ExtClassLoader）调用 ClassLoader (ClassLoader parent) 构造函数将父类加载器设置为 null</strong>（null 本身就代表着引导类加载器）。（因为如果不强制设置，默认会通过调用 getSystemClassLoader () 方法获取并设置成系统类加载器，。）</p>
<h3 id="六、类加载器的双亲委派了解么？-结合-Tomcat-说一下双亲委派（Tomcat-如何打破双亲委托机制？…）。"><a href="#六、类加载器的双亲委派了解么？-结合-Tomcat-说一下双亲委派（Tomcat-如何打破双亲委托机制？…）。" class="headerlink" title="六、类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。"></a>六、类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。</h3><p>这是我们研究Tomcat的第四篇文章，前三篇文章我们搭建了源码框架，了解了tomcat的大致的设计架构， 还写了一个简单的服务器。按照我们最初订的计划，今天，我们要开始研究tomcat的几个主要组件（组件太多，无法一一解析，解析几个核心），包括核心的类加载器，连接器和容器，还有生命周期，还有pipeline 和 valve。一个一个来，今天来研究类加载器。</p>
<p>我们分为4个部分来探讨:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 什么是类加载机制？</span><br><span class="line">2. 什么是双亲委任模型？</span><br><span class="line">3. 如何破坏双亲委任模型？</span><br><span class="line">4. Tomcat 的类加载器是怎么设计的？</span><br></pre></td></tr></table></figure>

<p>我想，在研究tomcat 类加载之前，我们复习一下或者说巩固一下java 默认的类加载器。楼主以前对类加载也是懵懵懂懂，借此机会，也好好复习一下。</p>
<p>楼主翻开了神书《深入理解Java虚拟机》第二版，p227, 关于类加载器的部分。请看：</p>
<h5 id="1-什么是类加载机制？"><a href="#1-什么是类加载机制？" class="headerlink" title="1. 什么是类加载机制？"></a>1. 什么是类加载机制？</h5><blockquote>
<p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p>
</blockquote>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以呗虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
</blockquote>
<blockquote>
<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p>
</blockquote>
<h6 id="类与类加载器的关系"><a href="#类与类加载器的关系" class="headerlink" title="类与类加载器的关系"></a>类与类加载器的关系</h6><blockquote>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由<strong>加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，<code>只有在这两个类是由同一个类加载器加载的前提下才有意义</code>，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p>
</blockquote>
<h5 id="2-什么是双亲委任模型"><a href="#2-什么是双亲委任模型" class="headerlink" title="2. 什么是双亲委任模型"></a>2. 什么是双亲委任模型</h5><ol>
<li>从Java虚拟机的角度来说，只存在两种不同类加载器：一种是**启动类加载器(Bootstrap ClassLoader)**，这个类加载器使用C++语言实现（只限HotSpot），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>.</li>
<li>从Java开发人员的角度来看，类加载还可以划分的更细致一些，绝大部分Java程序员都会使用以下3种系统提供的类加载器：<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME&#x2F;lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。</li>
<li>扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME&#x2F;lib&#x2F;ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 种的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</li>
</ol>
<p>这些类加载器之间的关系一般如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ZjCurq_20210607161016.png" alt="img"></p>
<p>图中各个类加载器之间的关系成为 <strong>类加载器的双亲委派模型（Parents Dlegation Mode）</strong>。双亲委派模型要求除了顶层的启动类加载器之外，<strong>其余的类加载器都应当由自己的父类加载器加载</strong>，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2 期间被引入并被广泛应用于之后的所有Java程序中，但他并不是个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h6 id="为什么要这么做呢？"><a href="#为什么要这么做呢？" class="headerlink" title="为什么要这么做呢？"></a><strong>为什么要这么做呢？</strong></h6><blockquote>
<p>如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，<strong>那系统将会出现多个不同的Object类</strong>， Java类型体系中最基础的行为就无法保证。应用程序也将会变得一片混乱。</p>
</blockquote>
<h6 id="双亲委任模型时如何实现的？"><a href="#双亲委任模型时如何实现的？" class="headerlink" title="双亲委任模型时如何实现的？"></a><strong>双亲委任模型时如何实现的？</strong></h6><blockquote>
<p>非常简单：所有的代码都在java.lang.ClassLoader中的loadClass方法之中，代码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/rL2L6J_20210607161108.png" alt="img"></p>
</blockquote>
<p>逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法， 如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass方法进行加载。</p>
<h5 id="3-如何破坏双亲委任模型？"><a href="#3-如何破坏双亲委任模型？" class="headerlink" title="3. 如何破坏双亲委任模型？"></a>3. 如何破坏双亲委任模型？</h5><p>刚刚我们说过，双亲委任模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型，但也有例外，到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。<br> <strong>第一次</strong>：在双亲委派模型出现之前—–即JDK1.2发布之前。<br> <strong>第二次</strong>：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，<strong>如果基础类调用会用户的代码</strong>怎么办呢？</p>
<p>这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。</p>
<p>嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，<strong>JDBC</strong>，JCE，JAXB，JBI等。</p>
<p><strong>第三次</strong>：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</p>
<p>书中还说到：</p>
<blockquote>
<p>Java 程序中基本有一个共识：OSGI对类加载器的使用时值得学习的，弄懂了OSGI的实现，就可以算是掌握了类加载器的精髓。</p>
</blockquote>
<p>牛逼啊！！！</p>
<p>现在，我们已经基本明白了Java默认的类加载的作用了原理，也知道双亲委派模型。说了这么多，差点把我们的tomcat给忘了，我们的题目是Tomcat 加载器为何违背双亲委派模型？下面就好好说说我们的tomcat的类加载器。</p>
<h5 id="4-Tomcat-的类加载器是怎么设计的？"><a href="#4-Tomcat-的类加载器是怎么设计的？" class="headerlink" title="4. Tomcat 的类加载器是怎么设计的？"></a>4. Tomcat 的类加载器是怎么设计的？</h5><p>首先，我们来问个问题：</p>
<h6 id="Tomcat-如果使用默认的类加载机制行不行？"><a href="#Tomcat-如果使用默认的类加载机制行不行？" class="headerlink" title="Tomcat 如果使用默认的类加载机制行不行？"></a>Tomcat 如果使用默认的类加载机制行不行？</h6><p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖<strong>同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。</li>
</ol>
<p>再看看我们的问题：Tomcat 如果使用默认的类加载机制行不行？<br> 答案是不行的。为什么？我们看，第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。第三个问题和第一个问题一样。我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改（楼主起的名字），jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<h5 id="Tomcat-如何实现自己独特的类加载机制？"><a href="#Tomcat-如何实现自己独特的类加载机制？" class="headerlink" title="Tomcat 如何实现自己独特的类加载机制？"></a>Tomcat 如何实现自己独特的类加载机制？</h5><p>所以，Tomcat 是怎么实现的呢？牛逼的Tomcat团队已经设计好了。我们看看他们的设计图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9Fh6Id_20210607161152.png" alt="img"></p>
<p>我们看到，前面3个类加载和默认的一致，CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，<strong>每一个Web应用程序</strong>对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<blockquote>
<p>CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。</p>
</blockquote>
<blockquote>
<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>
</blockquote>
<blockquote>
<p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</p>
</blockquote>
<p>好了，至此，我们已经知道了tomcat为什么要这么设计，以及是如何设计的，那么，tomcat 违背了java 推荐的双亲委派模型了吗？答案是：违背了。 我们前面说过：</p>
<blockquote>
<p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。</p>
</blockquote>
<p>很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p>
<h5 id="我们扩展出一个问题：如果tomcat-的-Common-ClassLoader-想加载-WebApp-ClassLoader-中的类，该怎么办？"><a href="#我们扩展出一个问题：如果tomcat-的-Common-ClassLoader-想加载-WebApp-ClassLoader-中的类，该怎么办？" class="headerlink" title="我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？"></a>我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？</h5><p>看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。牛逼吧。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>好了，终于，我们明白了Tomcat 为何违背双亲委派模型，也知道了tomcat的类加载器是如何设计的。顺便复习了一下 Java 默认的类加载器机制，也知道了如何破坏Java的类加载机制。这一次收获不小哦！！！ 嘿嘿。</p>
<h3 id="七、常见调优参数有哪些？"><a href="#七、常见调优参数有哪些？" class="headerlink" title="七、常见调优参数有哪些？"></a>七、常见调优参数有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：堆最大内存为 2g；</span><br><span class="line">-XX:NewRatio=<span class="number">4</span>：设置年轻的和老年代的内存比例为 <span class="number">1</span>:<span class="number">4</span>；</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>：设置新生代 Eden 和 Survivor 比例为 <span class="number">8</span>:<span class="number">2</span>；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure>

<h3 id="八、……"><a href="#八、……" class="headerlink" title="八、……"></a>八、……</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p><strong>学习了 MySQL 之后，务必确保自己掌握下面这些知识点：</strong></p>
<h3 id="一、MySQL-常用命令-："><a href="#一、MySQL-常用命令-：" class="headerlink" title="一、MySQL 常用命令 ："></a>一、MySQL 常用命令 ：</h3><h4 id="1、MySQL常用命令"><a href="#1、MySQL常用命令" class="headerlink" title="1、MySQL常用命令"></a>1、MySQL常用命令</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create database name; 创建数据库</span><br><span class="line">use databasename; 选择数据库</span><br><span class="line">drop database name 直接删除数据库，不提醒</span><br><span class="line">show tables; 显示表</span><br><span class="line">describe tablename; 表的详细描述</span><br><span class="line">select 中加上distinct去除重复字段</span><br><span class="line">mysqladmin drop databasename 删除数据库前，有提示。</span><br><span class="line">显示当前mysql版本和当前日期</span><br><span class="line">select <span class="title function_">version</span><span class="params">()</span>,current_date;</span><br></pre></td></tr></table></figure>

<h4 id="2、修改mysql中root的密码："><a href="#2、修改mysql中root的密码：" class="headerlink" title="2、修改mysql中root的密码："></a>2、修改mysql中root的密码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell&gt;mysql -u root -p</span><br><span class="line"> mysql&gt; update user set password=password(”xueok654123″) where user=’root’;</span><br><span class="line"> mysql&gt; flush privileges <span class="comment">//刷新数据库</span></span><br><span class="line"> mysql&gt;use dbname； 打开数据库：</span><br><span class="line"> mysql&gt;show databases; 显示所有数据库</span><br><span class="line"> mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后</span><br><span class="line"> mysql&gt;describe user; 显示表mysql数据库中user表的列信息）；</span><br></pre></td></tr></table></figure>

<h4 id="3、grant"><a href="#3、grant" class="headerlink" title="3、grant"></a>3、grant</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个</span><br><span class="line"> mysql&gt; grant all privileges on *.* to user<span class="meta">@localhost</span> identified by ’something’ with</span><br><span class="line"> 增加新用户</span><br><span class="line"> 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”</span><br><span class="line"> GRANT ALL PRIVILEGES ON *.* TO monty<span class="meta">@localhost</span> IDENTIFIED BY ’something’ WITH GRANT OPTION;</span><br><span class="line"> GRANT ALL PRIVILEGES ON *.* TO monty@”%” IDENTIFIED BY ’something’ WITH GRANT OPTION;</span><br><span class="line"> 删除授权：</span><br><span class="line"> mysql&gt; revoke all privileges on *.* from root@”%”;</span><br><span class="line"> mysql&gt; delete from user where user=”root” and host=”%”;</span><br><span class="line"> mysql&gt; flush privileges;</span><br><span class="line"> 创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb</span><br><span class="line"> mysql &gt;grant select, insert, update, delete, create,drop on fangchandb.* to custom@ [it363.com](https:<span class="comment">//link.jianshu.com?t=http://it363.com) identified by ‘ passwd’</span></span><br><span class="line"> 重命名表:</span><br><span class="line"> mysql &gt; alter table t1 rename t2;</span><br></pre></td></tr></table></figure>

<h4 id="4、mysqldump"><a href="#4、mysqldump" class="headerlink" title="4、mysqldump"></a>4、mysqldump</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">备份数据库</span><br><span class="line"> shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql</span><br><span class="line"> 恢复数据库</span><br><span class="line"> shell&gt; mysqladmin -h myhost -u root -p create dbname</span><br><span class="line"> shell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql</span><br><span class="line"> 如果只想卸出建表指令，则命令如下：</span><br><span class="line"> shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql</span><br><span class="line"> 如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：</span><br><span class="line"> shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql</span><br><span class="line"> 那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？</span><br><span class="line"> 　 mysqldump -T./ phptest driver</span><br><span class="line"> 其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver 表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。</span><br></pre></td></tr></table></figure>

<h4 id="5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。"><a href="#5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。" class="headerlink" title="5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。"></a>5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，如果在文件my_file.sql 中存放有查</span><br><span class="line"> 询，可如下执行这些查询：</span><br><span class="line"> 例如，如果您想将建表语句提前写在sql.txt中:</span><br><span class="line"> mysql &gt; mysql -h myhost -u root -p database &lt; sql.txt</span><br></pre></td></tr></table></figure>

<h3 id="二、MySQL-中常用的数据类型、字符集编码"><a href="#二、MySQL-中常用的数据类型、字符集编码" class="headerlink" title="二、MySQL 中常用的数据类型、字符集编码"></a>二、MySQL 中常用的数据类型、字符集编码</h3><p>MySQL 支持多种数据类型，主要有数值类型、日期&#x2F;时间类型和字符串类型。</p>
<ul>
<li>数值类型：包括整数类型 <code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>、浮点小数数据类型 <code>FLOAT</code>和 <code>DOUBLE</code>、定点小数类型 <code>DECIMAL</code>。</li>
<li>日期&#x2F;时间类型：<code>YEAR</code> 、<code>TIME</code>、 <code>DATE</code>、 <code>DATETIME</code> 和 <code>TIMESTAMP</code>。</li>
<li>字符串类型： <code>CHAR</code> 、<code>VARCHAR</code>、 <code>BINARY</code>、 <code>VARBINARY</code>、 <code>BLOB</code>、 <code>TEXT</code>、 <code>ENUM</code>、 <code>SET</code> 。</li>
</ul>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中的整数型数据类型：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th align="center">存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td align="center">2个字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td align="center">3个字节</td>
</tr>
<tr>
<td>INT(INTEGER)</td>
<td align="center">4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td align="center">8个字节</td>
</tr>
</tbody></table>
<h4 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h4><table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901~2155</td>
<td>1个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59~838:59:59</td>
<td>3个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01~9999-12-3</td>
<td>3个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00~9999-12-31 23:59:59</td>
<td>8个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:01 UTC ~2038-01-19 03:14:07 UTC</td>
<td>4个字节</td>
</tr>
</tbody></table>
<p>在这里提一下** CURRENT_DATE 和 NOW() 的区别**：CURRENT_DATE 返回当前日期值，不包括时间部分，NOW() 函数返回日期和时间值。</p>
<p>提示：TIMESTAMP 和 DATATIME 除了存储字节和支持的范围不同外，还有一个最大的区别就是：DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；而 TIMESTAMP 值的存储是以 UTC （世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M字节，1&lt;&#x3D;M&lt;&#x3D; 255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，L&lt;&#x3D;M和1&lt;&#x3D;M&lt;&#x3D;255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此L&lt;2^32</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能存一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目（最大值65535）</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或多个 SET 成员</td>
<td>1、2、3、4或8个字节，取决于集合成员的数量（最多64个成员）</td>
</tr>
</tbody></table>
<h3 id="三、MySQL-简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……"><a href="#三、MySQL-简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……" class="headerlink" title="三、MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……"></a>三、MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……</h3><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607163257520_20210607163257.png" alt="image-20210607163257520"></p>
<h3 id="四、MySQL-中使用索引、视图、存储过程、游标、触发器"><a href="#四、MySQL-中使用索引、视图、存储过程、游标、触发器" class="headerlink" title="四、MySQL 中使用索引、视图、存储过程、游标、触发器"></a>四、MySQL 中使用索引、视图、存储过程、游标、触发器</h3><blockquote>
<p>1 索引<br> 2 触发器<br> 3 存储过程和函数<br> 4 视图<br> 5 基本的数据库建表语句练习</p>
</blockquote>
<h4 id="1-索引"><a href="#1-索引" class="headerlink" title="1 索引"></a>1 索引</h4><h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/buhuikanjian/article/details/52966039">https://blog.csdn.net/buhuikanjian/article/details/52966039</a></p>
<h5 id="（2）建立索引的原则"><a href="#（2）建立索引的原则" class="headerlink" title="（2）建立索引的原则"></a>（2）建立索引的原则</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspwebchh/p/6652855.html">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></p>
<h5 id="（3）具体操作语句"><a href="#（3）具体操作语句" class="headerlink" title="（3）具体操作语句"></a>（3）具体操作语句</h5><p>步骤1  创建表test_table1,添加三个索引</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test_table1(</span><br><span class="line"><span class="keyword">id</span> INT NOT <span class="literal">NULL</span>  PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">address CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">description CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">UNIQUE INDEX UniqIdx(<span class="keyword">id</span>),</span><br><span class="line">INDEX MultiColIdx(NAME(<span class="number">20</span>), address(<span class="number">30</span>)),</span><br><span class="line">INDEX ComIdx(description(<span class="number">30</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>步骤2  创建表test_table1,添加三个索引创建表test_table2，存储引擎为MyISAM</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">test_table2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">id         INT NOT <span class="literal">NULL</span>  PRIMARY KEY AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="params"><span class="function">firstname   CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">middlename CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">lastname   CHAR(<span class="number">100</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">birth      DATE NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">title       CHAR(<span class="number">100</span>) <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> ENGINE</span>=MYISAM;</span><br></pre></td></tr></table></figure>

<p>步骤3  创建表test_table1,添加三个索引使用ALTER TABLE语句在表test_table2的birth字段上，建立名称为ComDateIdx的普通索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALTER TABLE test_table2 ADD INDEX <span class="title">ComDateIdx</span><span class="params">(birth)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤4 创建表test_table1,添加三个索引使用ALTER TABLE语句在表test_table2的id字段上，添加名称为UniqIdx2的唯一索引，并以降序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALTER TABLE test_table2 ADD UNIQUE INDEX <span class="title">UniqIdx2</span> <span class="params">(id DESC)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤5  创建表test_table1,添加三个索引使用CREATE INDEX在firstname、middlename和lastname3个字段上建立名称为MultiColIdx2的组合索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE INDEX MultiColIdx2 ON <span class="title">test_table2</span><span class="params">(firstname, middlename, lastname)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤6 创建表test_table1,添加三个索引使用CREATE INDEX在title字段上建立名称为FTIdx的全文索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE FULLTEXT INDEX FTIdx ON <span class="title">test_table2</span><span class="params">(title)</span></span>;</span><br></pre></td></tr></table></figure>

<p>步骤7 创建表test_table1,添加三个索引使用ALTER TABLE语句删除表test_table1中名称为UniqIdx的唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test_table1 DROP INDEX UniqIdx;</span><br></pre></td></tr></table></figure>

<p>步骤8 创建表test_table1,添加三个索引使用DROP INDEX语句删除表test_table2中名称为MultiColIdx2的组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX MultiColIdx2 ON test_table2;</span><br></pre></td></tr></table></figure>

<h4 id="2-触发器"><a href="#2-触发器" class="headerlink" title="2 触发器"></a>2 触发器</h4><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Bfkva0_20210607165356.png" alt="img"></p>
<h5 id="（2）触发器使用"><a href="#（2）触发器使用" class="headerlink" title="（2）触发器使用"></a>（2）触发器使用</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yank/p/4193820.html">https://www.cnblogs.com/yank/p/4193820.html</a></p>
<h4 id="3-存储过程和函数"><a href="#3-存储过程和函数" class="headerlink" title="3 存储过程和函数"></a>3 存储过程和函数</h4><h5 id="（1）存储过程优缺点"><a href="#（1）存储过程优缺点" class="headerlink" title="（1）存储过程优缺点"></a>（1）存储过程优缺点</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jackmacro/article/details/5688687">https://blog.csdn.net/jackmacro/article/details/5688687</a></p>
<h5 id="（2）存储过程、函数、游标"><a href="#（2）存储过程、函数、游标" class="headerlink" title="（2）存储过程、函数、游标"></a>（2）存储过程、函数、游标</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/doudouxiaoye/p/5811836.html">https://www.cnblogs.com/doudouxiaoye/p/5811836.html</a><br> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jacketlin/p/7874009.html">https://www.cnblogs.com/jacketlin/p/7874009.html</a></p>
<h5 id="（3）代码详解"><a href="#（3）代码详解" class="headerlink" title="（3）代码详解"></a>（3）代码详解</h5><p>1 创建查看fruits表的存储过程，创建了一个查看fruits表的存储过程，每次调用这个存储过程的时候都会执行SELECT语句查看表的内容。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE Proc()</span><br><span class="line">     <span class="keyword">BEGIN</span></span><br><span class="line">        SELECT * FROM fruits;</span><br><span class="line">     <span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>

<p>2 创建名称为CountProc的存储过程，获取fruits表记录条数。COUNT(*) 计算后把结果放入参数param1中。<br> 当使用DELIMITER命令时，应该避免使用反斜杠（’\’）字符，因为反斜线是MySQL的转义字符。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE CountProc (OUT param1 INT)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">SELECT COUNT(*) INTO param1 FROM fruits;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>3 创建存储函数NameByZip，该函数返回SELECT语句的查询结果，数值类型为字符串型。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION <span class="title function_ invoke__">NameByZip</span> ()</span><br><span class="line">  RETURNS <span class="title function_ invoke__">CHAR</span>(<span class="number">50</span>)</span><br><span class="line">  <span class="title function_ invoke__">RETURN</span>  (SELECT s_name FROM suppliers WHERE s_call= <span class="string">&#x27;48075&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>4 定义名称为myparam的变量，类型为INT类型，默认值为100。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  myparam  INT  DEFAULT <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>5 声明3个变量，分别为var1、var2和var3，数据类型为INT，使用SET为变量赋值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE var1, var2, var3 INT;</span><br><span class="line">SET var1 = <span class="number">10</span>, var2 = <span class="number">20</span>;</span><br><span class="line">SET var3 = var1 + var2;</span><br></pre></td></tr></table></figure>

<p>MySQL中还可以通过SELECT … INTO为一个或多个变量赋值，语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_name<span class="selector-attr">[,...]</span> INTO var_name<span class="selector-attr">[,...]</span> table_expr;</span><br></pre></td></tr></table></figure>

<p>这个SELECT语法把选定的列直接存储到对应位置的变量。col_name表示字段名称；var_name表示定义的变量名称；table_expr表示查询条件表达式，包括表名称和WHERE子句。</p>
<p>6 声明变量fruitname和fruitprice，通过SELECT，INTO语句查询指定记录并为变量赋值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DECLARE fruitname <span class="title">CHAR</span>(<span class="params"><span class="number">50</span></span>)</span>;</span><br><span class="line"><span class="function">DECLARE fruitprice <span class="title">DECIMAL</span>(<span class="params"><span class="number">8</span>,<span class="number">2</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">SELECT f_name,f_price INTO fruitname, fruitprice</span><br><span class="line">FROM fruits WHERE f_id =<span class="string">&#x27;a1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>7 声明名称为cursor_fruit的光标</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_fruit CURSOR FOR SELECT f_name, f_price FROM fruits ;</span><br></pre></td></tr></table></figure>

<p>8 使用名称为cursor_fruit的光标。将查询出来的数据存入fruit_name和fruit_price这两个变量中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH  cursor_fruit INTO fruit_name, fruit_price ;</span><br></pre></td></tr></table></figure>

<p>9 IF语句的示例</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF val IS <span class="literal">NULL</span></span><br><span class="line">  THEN SELECT <span class="string">&#x27;val is NULL&#x27;</span>;</span><br><span class="line">  ELSE SELECT <span class="string">&#x27;val is not NULL&#x27;</span>;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<p>10 使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE val</span><br><span class="line">  WHEN <span class="number">1</span> THEN SELECT <span class="string">&#x27;val is 1&#x27;</span>;</span><br><span class="line">  WHEN <span class="number">2</span> THEN SELECT <span class="string">&#x27;val is 2&#x27;</span>;</span><br><span class="line">  ELSE SELECT <span class="string">&#x27;val is not 1 or 2&#x27;</span>;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<p>11 使用LOOP语句进行循环操作，id值小于等于10之前，将重复执行循环过程。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE <span class="keyword">id</span> INT DEFAULT <span class="number">0</span>;</span><br><span class="line">add_loop: LOOP  </span><br><span class="line">SET <span class="keyword">id</span> = <span class="keyword">id</span> + <span class="number">1</span>;</span><br><span class="line">  IF <span class="keyword">id</span> &gt;= <span class="number">10</span> THEN  LEAVE add_loop;</span><br><span class="line">  END IF;</span><br><span class="line">END LOOP add_ loop; </span><br></pre></td></tr></table></figure>

<p>12 使用LEAVE语句退出循环。循环执行count加1的操作。当count的值等于50时，使用LEAVE语句跳出循环。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_num: LOOP  </span><br><span class="line">SET @count=@count+<span class="number">1</span>;</span><br><span class="line">IF <span class="keyword">@count</span>=50 THEN LEAVE add_num ;</span><br><span class="line">END LOOP add_num ; </span><br></pre></td></tr></table></figure>

<p>13 ITERATE语句示例。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE doiterate()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DECLARE p1 INT DEFAULT <span class="number">0</span>;</span><br><span class="line"><span class="symbol">my_loop:</span> LOOP</span><br><span class="line">  SET p1= p1 + <span class="number">1</span>;</span><br><span class="line">  IF p1 &lt; <span class="number">10</span> THEN ITERATE my_loop;</span><br><span class="line">  ELSEIF p1 &gt; <span class="number">20</span> THEN LEAVE my_loop;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line">  SELECT <span class="string">&#x27;p1 is between 10 and 20&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> LOOP my_loop;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>14 REPEAT语句示例，id值小于等于10之前，将重复执行循环过程。<br> 该示例循环执行id加1的操作。当id值小于10时，循环重复执行；当id值大于或者等于10时，使用LEAVE语句退出循环。REPEAT循环都以END REPEAT结束。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE <span class="keyword">id</span> INT DEFAULT <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line">SET <span class="keyword">id</span> = <span class="keyword">id</span> + <span class="number">1</span>;</span><br><span class="line">UNTIL  <span class="keyword">id</span> &gt;= <span class="number">10</span></span><br><span class="line">END REPEAT; </span><br></pre></td></tr></table></figure>

<p>15 WHILE语句示例，id值小于等于10之前，将重复执行循环过程。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE i INT DEFAULT <span class="number">0</span>;</span><br><span class="line">WHILE i &lt; <span class="number">10</span> DO</span><br><span class="line">SET i = i + <span class="number">1</span>;</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>

<p>16 定义名为CountProc1的存储过程，然后调用这个存储过程。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE CountProc1 (IN sid INT, OUT <span class="built_in">num</span> INT)</span><br><span class="line">     BEGIN</span><br><span class="line">       SELECT COUNT(*) INTO <span class="built_in">num</span> FROM fruits WHERE s_id = sid;</span><br><span class="line">     END <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="4-视图"><a href="#4-视图" class="headerlink" title="4 视图"></a>4 视图</h4><h5 id="（1）视图的含义和作用"><a href="#（1）视图的含义和作用" class="headerlink" title="（1）视图的含义和作用"></a>（1）视图的含义和作用</h5><p>视图是数据库中的一个虚拟表。同真实的表一样，视图包含一系列的行和列数据。行和列数据来源于自由定义视图查询所引用的表，并且在引用视图是动态生成。</p>
<h5 id="（2）视图和表的联系、区别"><a href="#（2）视图和表的联系、区别" class="headerlink" title="（2）视图和表的联系、区别"></a>（2）视图和表的联系、区别</h5><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607165527302_20210607165528.png" alt="img"></p>
<h5 id="（3）视图基本操作"><a href="#（3）视图基本操作" class="headerlink" title="（3）视图基本操作"></a>（3）视图基本操作</h5><p>步骤1：创建学生表stu，插入3条记录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">stu</span> </span></span><br><span class="line"><span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">s_id INT PRIMARY KEY,</span></span></span><br><span class="line"><span class="params"><span class="function">s_name VARCHAR(<span class="number">20</span></span>),</span></span><br><span class="line"><span class="function">addr <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>),</span></span><br><span class="line"><span class="function">tel <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>)</span></span><br><span class="line"><span class="function">)</span>; </span><br><span class="line"><span class="function">INSERT INTO stu </span></span><br><span class="line"><span class="function"><span class="title">VALUES</span>(<span class="params"><span class="number">1</span>,<span class="string">&#x27;XiaoWang&#x27;</span>,<span class="string">&#x27;Henan&#x27;</span>,<span class="string">&#x27;0371-12345678&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">2</span>,<span class="string">&#x27;XiaoLi&#x27;</span>,<span class="string">&#x27;Hebei&#x27;</span>,<span class="string">&#x27;13889072345&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">3</span>,<span class="string">&#x27;XiaoTian&#x27;</span>,<span class="string">&#x27;Henan&#x27;</span>,<span class="string">&#x27;0371-12345670&#x27;</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤2：创建报名表sign，插入3条记录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">sign</span> </span></span><br><span class="line"><span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">s_id INT PRIMARY KEY,</span></span></span><br><span class="line"><span class="params"><span class="function">s_name VARCHAR(<span class="number">20</span></span>),</span></span><br><span class="line"><span class="function">s_sch <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>),</span></span><br><span class="line"><span class="function">s_sign_sch <span class="title">VARCHAR</span>(<span class="params"><span class="number">50</span></span>)</span></span><br><span class="line"><span class="function">)</span>; </span><br><span class="line"><span class="function">INSERT INTO sign </span></span><br><span class="line"><span class="function"><span class="title">VALUES</span>(<span class="params"><span class="number">1</span>,<span class="string">&#x27;XiaoWang&#x27;</span>,<span class="string">&#x27;Middle School1&#x27;</span>,<span class="string">&#x27;Peking University&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">2</span>,<span class="string">&#x27;XiaoLi&#x27;</span>,<span class="string">&#x27;Middle School2&#x27;</span>,<span class="string">&#x27;Tsinghua University&#x27;</span></span>),</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">3</span>,<span class="string">&#x27;XiaoTian&#x27;</span>,<span class="string">&#x27;Middle School3&#x27;</span>,<span class="string">&#x27;Tsinghua University&#x27;</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建成绩表stu_mark，插入3条记录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">stu_mark</span> (<span class="params">s_id INT PRIMARY KEY ,s_name VARCHAR(<span class="number">20</span></span>) ,mark <span class="built_in">int</span> )</span>; </span><br><span class="line"><span class="function">INSERT INTO stu_mark <span class="title">VALUES</span>(<span class="params"><span class="number">1</span>,<span class="string">&#x27;XiaoWang&#x27;</span>,<span class="number">80</span></span>),(<span class="params"><span class="number">2</span>,<span class="string">&#x27;XiaoLi&#x27;</span>,<span class="number">71</span></span>),(<span class="params"><span class="number">3</span>,<span class="string">&#x27;XiaoTian&#x27;</span>,<span class="number">70</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤4：创建考上Peking University的学生的视图</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE VIEW <span class="title">beida</span> (<span class="params">id,name,mark,sch</span>)</span></span><br><span class="line"><span class="function">AS SELECT stu_mark.s_id,stu_mark.s_name,stu_mark.mark, sign.s_sign_sch</span></span><br><span class="line"><span class="function">FROM stu_mark ,sign</span></span><br><span class="line"><span class="function">WHERE stu_mark.s_id</span>=sign.s_id AND stu_mark.mark&gt;=<span class="number">41</span></span><br><span class="line">AND sign.s_sign_sch=<span class="string">&#x27;Peking University&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤5：创建考上qinghua University的学生的视图</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE VIEW <span class="title">qinghua</span> (<span class="params">id,name,mark,sch</span>) </span></span><br><span class="line"><span class="function">AS SELECT stu_mark.s_id, stu_mark.s_name, stu_mark.mark, sign.s_sign_sch </span></span><br><span class="line"><span class="function">FROM stu_mark ,sign</span></span><br><span class="line"><span class="function">WHERE stu_mark.s_id</span>=sign.s_id  AND stu_mark.mark&gt;=<span class="number">40</span> </span><br><span class="line">AND sign.s_sign_sch=<span class="string">&#x27;Tsinghua University&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤6：XiaoTian的成绩在录入的时候录入错误多录了50分，对其录入成绩进行更正。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu_mark SET mark = mark-50 WHERE stu_mark.s_name =<span class="string">&#x27;XiaoTian&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>步骤7：查看更新过后视图和表的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu_mark;</span><br><span class="line">SELECT * FROM qinghua;</span><br><span class="line">SELECT * FROM beida;</span><br></pre></td></tr></table></figure>

<p>步骤8：查看视图的创建信息。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="selector-tag">FROM</span> information_schema<span class="selector-class">.views</span></span><br></pre></td></tr></table></figure>

<p>步骤9：删除创建的视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW beida;</span><br><span class="line">DROP VIEW qinghua;</span><br></pre></td></tr></table></figure>

<h4 id="5-基本的数据库建表语句练习（这个好像我真的是不会……）"><a href="#5-基本的数据库建表语句练习（这个好像我真的是不会……）" class="headerlink" title="5 基本的数据库建表语句练习（这个好像我真的是不会……）"></a>5 基本的数据库建表语句练习（这个好像我真的是不会……）</h4><blockquote>
<p>建立一个数据库，逻辑名称为Student，包含1个数据文件和1个日志文件。数据文件初始大小为10M</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">exists</span>(<span class="params"><span class="keyword">select</span> * <span class="keyword">from</span> sys.sysdatabases <span class="keyword">where</span> name=<span class="string">&#x27;Student&#x27;</span></span>)</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">use master</span></span><br><span class="line"><span class="function">drop database Student</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">go</span></span><br><span class="line"><span class="function">create database Student</span></span><br><span class="line"><span class="function"><span class="keyword">on</span></span></span><br><span class="line"><span class="function">--路径根据实际情况自行修改</span></span><br><span class="line"><span class="function">(<span class="params">name=N<span class="string">&#x27;Student&#x27;</span>,filename=N<span class="string">&#x27;E:\Student.mdf&#x27;</span>,size=<span class="number">10</span>mb,maxsize=unlimited,filegrowth=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">log <span class="title">on</span></span></span><br><span class="line"><span class="function">(<span class="params">name=N<span class="string">&#x27;Student&#x27;</span>,filename=N<span class="string">&#x27;E:\Student_log.ldf&#x27;</span>,size=<span class="number">10</span>mb,maxsize=unlimited,filegrowth=<span class="number">1</span></span>)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/accumulater/p/6158294.html">https://www.cnblogs.com/accumulater/p/6158294.html</a></p>
<blockquote>
<p>创建表，增加约束。包括：主键约束、非空约束、性别范围约束、出生日期约束、年龄约束、外键约束、唯一性约束、评论约束、默认关键词约束</p>
</blockquote>
<p>下面的语句可能不通顺，但是这些约束都有。check也可以使用enum代替。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="title function_ invoke__">tblstudent</span>(</span><br><span class="line">    stuID BIGINT PRIMARY KEY NOT <span class="literal">NULL</span>,</span><br><span class="line">    stuName <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">10</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">    stuSex <span class="title function_ invoke__">NCHAR</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;男&#x27;</span> <span class="title function_ invoke__">CHECK</span> (stuSex <span class="title function_ invoke__">IN</span> (<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">    stuBirth DATETIME <span class="title function_ invoke__">CHECK</span> (stuBirth &lt; <span class="title function_ invoke__">getdate</span>()) COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">    stuNum <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">18</span>) UNIQUE</span><br><span class="line">    Math INT <span class="title function_ invoke__">CHECK</span>(Sage &gt; <span class="number">18</span> AND Sage &lt; <span class="number">30</span>) COMMENT <span class="string">&#x27;数学&#x27;</span></span><br><span class="line">    stuID BIGINT REFERENCES <span class="title function_ invoke__">tblstudent</span>(stuID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghost-xyx/p/3795679.html">https://www.cnblogs.com/ghost-xyx/p/3795679.html</a></p>
<blockquote>
<p>drop，alter，insert，update，delete</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leftwukaixing/article/details/44415875">https://blog.csdn.net/leftwukaixing/article/details/44415875</a></p>
<hr>
<p>这个东西属于基础知识，可能不需要深入了解，但是不知道一定会有问题。</p>
<p><strong>如果你想让自己更加了解 MySQL ，同时也是为了准备面试的话，下面这些知识点要格外注意：</strong></p>
<h3 id="一、索引：索引优缺点、B-树和-B-树、聚集索引与非聚集索引、覆盖索引"><a href="#一、索引：索引优缺点、B-树和-B-树、聚集索引与非聚集索引、覆盖索引" class="headerlink" title="一、索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引"></a>一、索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h4><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>为什么要用索引?索引的优缺点分析</p>
<h4 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h4><p><strong>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。</strong>  另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>索引的缺点</p>
<p><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</p>
<p><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</p>
<h4 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="B树和B+树区别"></a>B树和B+树区别</h4><p>B树的所有节点既存放 键(key) 也存放 数据(data);而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。</p>
<p>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
<p>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7xaotb_20210607165833.png" alt="img"></p>
<h4 id="Hash索引和-B-树索引优劣分析"><a href="#Hash索引和-B-树索引优劣分析" class="headerlink" title="Hash索引和 B+树索引优劣分析"></a>Hash索引和 B+树索引优劣分析</h4><p><strong>Hash索引定位快</strong></p>
<p>Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。</p>
<p><strong>Hash冲突问题</strong></p>
<p>知道HashMap或HashTable的同学，相信都知道它们最大的缺点就是Hash冲突了。不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询是它最大的缺点。</strong></p>
<p>试想一种情况:</p>
<p>SELECT * FROM tb1 WHERE id &lt; 500;</p>
<p>B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。而Hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗?这就是Hash最大的缺点了。</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li><h5 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h5></li>
</ul>
<p><strong>数据表的主键列使用的就是主键索引。</strong></p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</strong></p>
<p><strong>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</strong></p>
<ul>
<li><h5 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h5></li>
</ul>
<p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p><strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>
<p><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p>
<p><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></p>
<p><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</p>
<p><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</p>
<p>二级索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lOhKAX_20210607170015.png" alt="img"></p>
<h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><ul>
<li><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5></li>
</ul>
<p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p>聚集索引的优点</p>
<p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p>聚集索引的缺点</p>
<p><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</p>
<p><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</p>
<ul>
<li><h5 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h5></li>
</ul>
<p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<p>MYISAM引擎的表的.MYI文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
<p>非聚集索引的优点</p>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p>非聚集索引的缺点</p>
<p>跟聚集索引一样，非聚集索引也依赖于有序的数据</p>
<p><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p>
<p>这是Mysql的表的文件截图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/JhKeja_20210607170103.png" alt="img"></p>
<p>聚集索引和非聚集索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/SZAydC_20210607170114.png" alt="img"></p>
<p>非聚集索引一定回表查询吗(覆盖索引)?</p>
<p><strong>非聚集索引不一定回表查询。</strong></p>
<p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p>
<p> SELECT name FROM table WHERE username&#x3D;’guang19’;</p>
<p>那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。</p>
<p><strong>即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</strong></p>
<p>SELECT id FROM table WHERE id&#x3D;1;</p>
<p>主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p>
<p>覆盖索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FQSLlU_20210607170146.png" alt="img"></p>
<h5 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h5><ul>
<li>单列索引</li>
</ul>
<p>单列索引即由一列属性组成的索引。</p>
<p>联合索引(多列索引)</p>
<p>联合索引即由多列属性组成索引。</p>
<ul>
<li>最左前缀原则</li>
</ul>
<p>假设创建的联合索引由三个字段组成:</p>
<p>ALTER TABLE table ADD INDEX index_name (num,name,age)</p>
<p>那么当查询的条件有为:num &#x2F; (num AND name) &#x2F; (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<p>但可能由于版本原因(我的mysql版本为8.0.x),我创建的联合索引，相当于在联合索引的每个字段上都创建了相同的索引:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607170240035_20210607170240.png" alt="img"></p>
<p>无论是否符合最左前缀原则，每个字段的索引都生效:</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607170253830_20210607170254.png" alt="img"></p>
<h4 id="索引创建注意点"><a href="#索引创建注意点" class="headerlink" title="索引创建注意点"></a>索引创建注意点</h4><ul>
<li><h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5></li>
</ul>
<p>虽然我目前的Mysql版本较高，好像不遵守最左前缀原则，索引也会生效。但是我们仍应遵守最左前缀原则，以免版本更迭带来的麻烦。</p>
<ul>
<li><h5 id="选择合适的字段"><a href="#选择合适的字段" class="headerlink" title="选择合适的字段"></a>选择合适的字段</h5></li>
</ul>
<p>1.不为NULL的字段</p>
<p>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p>
<p>2.被频繁查询的字段</p>
<p>我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p>3.被作为条件查询的字段</p>
<p>被作为WHERE条件查询的字段，应该被考虑建立索引。</p>
<p>4.被经常频繁用于连接的字段</p>
<p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<ul>
<li><h5 id="不合适创建索引的字段"><a href="#不合适创建索引的字段" class="headerlink" title="不合适创建索引的字段"></a>不合适创建索引的字段</h5></li>
</ul>
<p>1.被频繁更新的字段应该慎重建立索引</p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p>2.不被经常查询的字段没有必要建立索引</p>
<p>3.尽可能的考虑建立联合索引而不是单列索引</p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p>4.注意避免冗余索引</p>
<p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<p>使用索引一定能提高查询性能吗?</p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h3 id="二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别"><a href="#二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别" class="headerlink" title="二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别"></a>二、事务：事务、数据库事务、ACID、并发事务、事务隔离级别</h3><p>事务具有四大特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称为事务的ACID特性。</p>
<h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。</p>
<ul>
<li>全部成功执行</li>
<li>全部不执行</li>
</ul>
<p>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤消并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>
<h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。因此当事务全部成功提交时，就能说数据库处于一致性状态，如果数据库运行过程中出现故障，导致有些事务尚未完成就被迫中断，这些未完成的事务中的部分操作已经写入的物理数据库，这时数据库就处于一种不一致的状态。</p>
<h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p>隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其它事务干扰。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>在标准的SQL规范中，定义了四个事务隔离级别，不同的隔离级别对事务的处理不同</p>
<ul>
<li><strong>未授权读取</strong><br> 也称读未提交（Read Uncommitted），该隔离级别允许脏读，隔离级别最低。</li>
</ul>
<p>什么是脏读？</p>
<p>如果一个事务正在处理某一数据，对其进行了更新，但尚未提交事务，与此同时，另一个事务能够访问该事务更新后的数据。也就是说，事务的中间状态对其它事务是可见的。</p>
<p>举例说明：<br> 用户A原工资为1000元<br> 第一步：事务1执行修改操作，为用户A增加工资1000元，事务1尚未提交事务<br> 第二步：事务2执行读取操作，查询到用户A的工资为2000元。</p>
<p>事务2读取到了事务1中尚未提交的修改结果，但是事务1尚未提交，有可能会因为后续操作失败而产生回滚。</p>
<ul>
<li><strong>授权读取</strong><br> 也称读已提交（Read Committed），该隔离级别禁止脏读，允许不可重复读。</li>
</ul>
<p>什么是不可重复读？</p>
<p>一个事务过程中，对同一数据进行多次查询，查询的数据可能不一样，原因可能是两次查询过程中，另一个事务对该数据进行了修改并成功提交事务。也就是说，事务的结束状态对其它事务是可见的。</p>
<p>举例说明：<br> 用户A原工资为1000元<br> 第一步：事务1执行查询操作，查询到用户A的工资为1000元，事务1尚未提交事务。<br> 第二步：事务2执行修改操作，为用户A的增加工资1000元。<br> 第三步：事务1执行查询操作，查询到用户A的工资为2000元。</p>
<p>对于事务1来说，同一个事务里的多次查询，结果并不稳定。</p>
<ul>
<li><strong>可重复读取</strong><br> 可重复读取（Repeatable Read），该隔离级别禁止不可重复读和脏读，允许幻读。保证在事务处理过程中，多次读取同一数据，其值都和事务开始时刻是一致的。</li>
</ul>
<p>什么是幻读？</p>
<p>不可重复读针对的是数据的修改，而幻读针对的是数据的新增。</p>
<p>举例说明：<br> 用户表，用户名为唯一键<br> 第一步：事务1执行查询操作，查询是否存在用户名为<code>aaa</code>的数据，事务1尚未提交</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> user <span class="keyword">where</span> username = <span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第二步：事务2执行插入操作，插入用户名为<code>aaa</code>的数据<br> 第三步：事务1执行插入操作，插入用户为为<code>aaa</code>的数据，提示唯一键错误，插入失败。</p>
<p>对于事务一来说，查询用户<code>aaa</code>不存在，保存却报唯一键错误，如梦如幻，故名幻读。</p>
<ul>
<li><strong>串行化</strong><br> 串行化（Serializable）是最严格的事务隔离级别，它要求所有事务都被串行执行，即事务只能一个一个地进行处理，不能并发执行。</li>
</ul>
<blockquote>
<p>mysql 默认使用 Repeatable Read 级别，其它数据库大部分默认使用 Read Committed 级别</p>
</blockquote>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未授权读取</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>授权读取</td>
<td>不存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>可重复读取</td>
<td>不存在</td>
<td>不存在</td>
<td>存在</td>
</tr>
<tr>
<td>串行化</td>
<td>不存在</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody></table>
<h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p>持久性是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。也就是说，它对数据库所做的更新就必须被永久保存一下，即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p>
<h3 id="三、存储引擎（MyISAM-和-InnoDB）"><a href="#三、存储引擎（MyISAM-和-InnoDB）" class="headerlink" title="三、存储引擎（MyISAM 和 InnoDB）"></a>三、存储引擎（MyISAM 和 InnoDB）</h3><h4 id="1、MySQL默认存储引擎的变迁"><a href="#1、MySQL默认存储引擎的变迁" class="headerlink" title="1、MySQL默认存储引擎的变迁"></a><strong>1、MySQL默认存储引擎的变迁</strong></h4><p>在MySQL 5.1之前的版本中，默认的搜索引擎是MyISAM，从MySQL 5.5之后的版本中，默认的搜索引擎变更为InnoDB。</p>
<h4 id="2、MyISAM与InnoDB存储引擎的主要特点"><a href="#2、MyISAM与InnoDB存储引擎的主要特点" class="headerlink" title="2、MyISAM与InnoDB存储引擎的主要特点"></a><strong>2、MyISAM与InnoDB存储引擎的主要特点</strong></h4><p>MyISAM存储引擎的特点是：表级锁、不支持事务和全文索引，适合一些CMS内容管理系统作为后台数据库使用，但是使用大并发、重负荷生产系统上，表锁结构的特性就显得力不从心；</p>
<p>以下是MySQL 5.7 MyISAM存储引擎的版本特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/1rNi5X_20210607170801.png" alt="img"></p>
<p>InnoDB存储引擎的特点是：行级锁、事务安全（ACID兼容）、支持外键、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。InnoDB是为处理巨大量时拥有最大性能而设计的。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。</p>
<p>以下是MySQL 5.7 InnoDB存储引擎的版本特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/AigyQF_20210607170822.png" alt="img"></p>
<p>注意：</p>
<p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如<code>update table set num=1 where name like “a%”</code>。</p>
<p>两种类型最主要的差别就是InnoDB支持事务处理与外键和行级锁。而MyISAM不支持。所以MyISAM往往就容易被人认为只适合在小项目中使用。</p>
<h4 id="3、MyISAM与InnoDB性能测试"><a href="#3、MyISAM与InnoDB性能测试" class="headerlink" title="3、MyISAM与InnoDB性能测试"></a><strong>3、MyISAM与InnoDB性能测试</strong></h4><p>下边两张图是官方提供的MyISAM与InnoDB的压力测试结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9Adido_20210607170839.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/al7WB3_20210607170855.png" alt="img"></p>
<p>可以看出，随着CPU核数的增加，InnoDB的吞吐量反而越好，而MyISAM，其吞吐量几乎没有什么变化，显然，MyISAM的表锁定机制降低了读和写的吞吐量。</p>
<h4 id="4、事务支持与否"><a href="#4、事务支持与否" class="headerlink" title="4、事务支持与否"></a><strong>4、事务支持与否</strong></h4><p>MyISAM是一种非事务性的引擎，使得MyISAM引擎的MySQL可以提供高速存储和检索，以及全文搜索能力，适合数据仓库等查询频繁的应用；</p>
<p>InnoDB是事务安全的；</p>
<p>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p>
<h4 id="5、MyISAM与InnoDB构成上的区别"><a href="#5、MyISAM与InnoDB构成上的区别" class="headerlink" title="5、MyISAM与InnoDB构成上的区别"></a><strong>5、MyISAM与InnoDB构成上的区别</strong></h4><p>（1）每个MyISAM在磁盘上存储成三个文件：</p>
<blockquote>
<p>第一个文件的名字以表的名字开始，扩展名指出文件类型，.frm文件存储表定义。<br> 第二个文件是数据文件，其扩展名为.MYD (MYData)。<br> 第三个文件是索引文件，其扩展名是.MYI (MYIndex)。</p>
</blockquote>
<p>（2）基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的 大小只受限于操作系统文件的大小，一般为 2GB。</p>
<h4 id="6、MyISAM与InnoDB表锁和行锁的解释"><a href="#6、MyISAM与InnoDB表锁和行锁的解释" class="headerlink" title="6、MyISAM与InnoDB表锁和行锁的解释"></a><strong>6、MyISAM与InnoDB表锁和行锁的解释</strong></h4><p>MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。什么意思呢，就是说对MyISAM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；而对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。</p>
<p>InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁！行级锁在每次获取锁和释放锁的操作需要消耗比表锁更多的资源。在InnoDB两个事务发生死锁的时候，会计算出每个事务影响的行数，然后回滚行数少的那个事务。当锁定的场景中不涉及Innodb的时候，InnoDB是检测不到的。只能依靠锁定超时来解决。</p>
<h4 id="7、是否保存数据库表中表的具体行数"><a href="#7、是否保存数据库表中表的具体行数" class="headerlink" title="7、是否保存数据库表中表的具体行数"></a><strong>7、是否保存数据库表中表的具体行数</strong></h4><p>InnoDB 中不保存表的具体行数，也就是说，执行<code>select count(*) from table</code>时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。</p>
<p>注意的是，当<code>count(*)</code>语句包含<code>where</code>条件时，两种表的操作是一样的。也就是 上述“6”中介绍到的InnoDB使用表锁的一种情况。</p>
<h4 id="8、如何选择"><a href="#8、如何选择" class="headerlink" title="8、如何选择"></a><strong>8、如何选择</strong></h4><p>MyISAM适合：</p>
<ul>
<li>（1）做很多count 的计算；</li>
<li>（2）插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择；</li>
<li>（3）没有事务。</li>
</ul>
<p>InnoDB适合：</p>
<ul>
<li>（1）可靠性要求比较高，或者要求事务；</li>
<li>（2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建；</li>
<li>（3）如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表；</li>
<li>（4）DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除；</li>
<li>（5）LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。</li>
</ul>
<p>要注意，创建每个表格的代码是相同的，除了最后的 TYPE参数，这一参数用来指定数据引擎。</p>
<h4 id="其他区别："><a href="#其他区别：" class="headerlink" title="其他区别："></a><strong>其他区别：</strong></h4><p>1、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>2、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>3、LOAD TABLE FROMMASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>4、 InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</p>
<p>5、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p>
<p>6、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。</p>
<h3 id="四、锁机制与-InnoDB-锁算法"><a href="#四、锁机制与-InnoDB-锁算法" class="headerlink" title="四、锁机制与 InnoDB 锁算法"></a>四、锁机制与 InnoDB 锁算法</h3><h4 id="1、-锁分类（按粒度分）"><a href="#1、-锁分类（按粒度分）" class="headerlink" title="1、 锁分类（按粒度分）"></a>1、 锁分类（按粒度分）</h4><p><strong>解决并发、数据安全的问题，用锁。</strong></p>
<h5 id="1-表级锁"><a href="#1-表级锁" class="headerlink" title="(1)表级锁"></a><strong>(1)表级锁</strong></h5><p><strong>粒度最大</strong>，对整表加锁，实现简单 <strong>，资源消耗也比较少，加锁快，不会出现死锁</strong> 。其锁定<strong>粒度最大</strong>，触发锁冲突的概率最高，<strong>并发度最低</strong>，MyISAM和 InnoDB引擎都支持表级锁。</p>
<h5 id="2-行级锁"><a href="#2-行级锁" class="headerlink" title="(2)行级锁"></a><strong>(2)行级锁</strong></h5><p><strong>粒度最小</strong>。 <strong>减少数据库冲突。加锁粒度最小，并发度高，加锁开销最大，加锁慢，会出现死锁。</strong> InnoDB支持的行级锁：</p>
<p><strong>1)行锁 Record Lock:</strong> 对<strong>索引</strong>项<strong>加锁</strong>，锁定符合条件的行。其他事务不能修改和删除加锁项；</p>
<p><strong>2)间隙锁 Gap Lock:</strong> 对<strong>索引项之间</strong>的“<strong>间隙</strong>”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p>
<p><strong>3)行锁和间隙锁组合 Next-key Lock：</strong> 锁定<strong>索引项本身</strong>和<strong>索引范围</strong>。解决幻读问题。</p>
<p><strong>虽行级索粒度小、并发度高等特点，但表级锁有时候非常必要</strong>：</p>
<p>事务<strong>更新大表</strong>中的<strong>大部分数据</strong>直接使用表级锁<strong>效率更高</strong>；用行级索很可能引起<strong>死锁</strong>导致回滚。</p>
<h4 id="2、另外两个表级锁：IS和IX"><a href="#2、另外两个表级锁：IS和IX" class="headerlink" title="2、另外两个表级锁：IS和IX"></a><strong>2、另外两个表级锁：IS和IX</strong></h4><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而<strong>意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</strong></p>
<p><strong>InnoDB另外的两个表级锁：</strong></p>
<p><strong>意向共享锁（IS）：</strong> 事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p><strong>意向排他锁（IX）：</strong> 事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p><strong>注意：</strong></p>
<p><strong>这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干预。</strong></p>
<p><strong>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</strong></p>
<p><strong>InnoDB的锁机制兼容情况如下：</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/STIhyH_20210607171136.png" alt="img"></p>
<h4 id="3、死锁和避免死锁"><a href="#3、死锁和避免死锁" class="headerlink" title="3、死锁和避免死锁"></a>3、死锁和避免死锁</h4><p><strong>InnoDB的行级锁是基于索引实现的，</strong>如果查询语句为<strong>命中任何索引，用表级锁.</strong> 对索引加的锁，不针对数据记录，访问不同行记录，如用<strong>相同索引</strong>键仍锁<strong>冲突</strong>，</p>
<p>SELECT…LOCKINSHARE MODE 或 SELECT…FORUPDATE;</p>
<p><strong>用锁</strong>时，如<strong>没有</strong>定义<strong>索引</strong>，<strong>InnoDB****创建</strong>隐藏聚簇索引<strong>加记录锁</strong>。</p>
<p><strong>InnoDB锁逐步获得，两个事务都要获得对方持有的锁，都等待，产生死锁。</strong> 可<strong>检测到</strong>，并使一个事务<strong>释放锁回退</strong>，另一个<strong>获取锁完成事务</strong>，避免死锁：</p>
<p><strong>(1)表级锁来减少死锁</strong></p>
<p><strong>(2)多个程序尽量相同顺序访问表</strong>（解决并发理论中哲学家就餐问题一种思路）</p>
<p><strong>(3)同一个事务尽可能一次锁定所有资源。</strong></p>
<h4 id="4、总结与补充"><a href="#4、总结与补充" class="headerlink" title="4、总结与补充"></a>4、总结与补充</h4><p><strong>页级锁：</strong> 介于行级锁和表级锁中间。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级折衷，一次<strong>锁定相邻一组</strong>记录。BDB支持页级锁。<strong>开销和加锁时间</strong>界于表锁和行锁之间，会出现<strong>死锁</strong>。并发度一般。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><p>下面是我总结的一些关于并发的小问题，你可以拿来自测：</p>
<h3 id="一、Redis-和-Memcached-的区别和共同点"><a href="#一、Redis-和-Memcached-的区别和共同点" class="headerlink" title="一、Redis 和 Memcached 的区别和共同点"></a>一、Redis 和 Memcached 的区别和共同点</h3><h4 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h4><p>在大多数Web应用都将数据保存到关系型数据库中，WWW服务器从中读取数据并在浏览器中显示。但随着数据量的增大、访问的集中，就会出现关系型数据的负担加重、数据库响应缓慢、网站打开延迟等问题。</p>
<p>通过在内存中缓存数据库的查询结果，减少数据访问次数，以提高动态Web应用的速度，提高网站架构的并发能力和可扩展性</p>
<p>传统开发中用的数据库最多的就是MySQL了，随着数据量上千万或上亿级后，它的关系型数据库的读取速度可能并不能满足我们对数据的需求，所以内存式的缓存系统就出现了</p>
<h4 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h4><p>Memcache 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。</p>
<p>Memcache基于一个存储键&#x2F;值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcache协议与守护进程通信。</p>
<p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
<p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应用数据量不能大于硬件内存。</p>
<p>在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</p>
<p>同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
<h4 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h4><p>Redis与memcached有什么不同</p>
<p>什么是原子性,什么是原子性操作？</p>
<h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h4><p>Memcached</p>
<p>内部的数据存储，使用基于Slab的内存管理方式，有利于减少内存碎片和频繁分配销毁内存所带来的开销。各个Slab按需动态分配一个page的内存</p>
<p>（和4Kpage的概念不同，这里默认page为1M），page内部按照不同slab class的尺寸再划分为内存chunk供服务器存储KV键值对使用</p>
<p>Redis内部的数据结构最终也会落实到key-Value对应的形式，不过从暴露给用户的数据结构来看，</p>
<p>要比memcached丰富，除了标准的通常意义的键值对，Redis还支持List，Set， Hashes，Sorted Set等数据结构</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>Memcached的命令或者说通讯协议非常简单，Server所支持的命令基本就是对特定key的添加，删除，替换，原子更新，读取等，具体包括 Set, Get, Add, Replace, Append, Inc&#x2F;Dec 等等</p>
<p>Memcached的通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如telnet）和对性能要求更高的客户端的不同需求</p>
<p>Redis的命令在KV（String类型）上提供与Memcached类似的基本操作，在其它数据结构上也支持基本类似的操作（当然还有这些数据结构所特有的操作，如Set的union，List的pop等）而支持更多的数据结构，在一定程度上也就意味着更加广泛的应用场合</p>
<p>除了多种数据结构的支持，</p>
<p>Redis相比Memcached还提供了许多额外的特性，比如Subscribe&#x2F;publish命令，以支持发布&#x2F;订阅模式这样的通知机制等等，这些额外的特性同样有助于拓展它的应用场景Redis的客户端-服务器通讯协议完全采用文本格式（在将来可能的服务器间通讯会采用二进制格式）</p>
<h4 id="分布式实现："><a href="#分布式实现：" class="headerlink" title="分布式实现："></a>分布式实现：</h4><p>（1）memcached的分布式由客户端实现，通过一致性哈希算法来保证访问的缓存命中率；Redis的分布式由服务器端实现，通过服务端配置来实现分布式；</p>
<p>（2）事务性，memcached没有事务的概念，但是可以通过CAS协议来保证数据的完整性，一致性。Redis引入数据库中的事务概念来保证数据的完整性和一致性。</p>
<p>（3）简单性，memcached是纯KV缓存，协议简单，学习和使用成本比redis小很多</p>
<p>Memcached也不做数据的持久化工作，但是有许多基于memcached协议的项目实现了数据的持久化，例如memcacheDB使用BerkeleyDB进行数据存储，但本质上它已经不是一个Cache Server，而只是一个兼容Memcached的协议key-valueData Store了</p>
<p>Redis可以以master-slave的方式配置服务器，Slave节点对数据进行replica备份，Slave节点也可以充当Read only的节点分担数据读取的工作</p>
<p>Redis内建支持两种持久化方案，snapshot快照和AOF 增量Log方式。快照顾名思义就是隔一段时间将完整的数据Dump下来存储在文件中。AOF增量Log则是记录对数据的修改操作（实际上记录的就是每个对数据产生修改的命令本身）.</p>
<h3 id="二、为什么要用-Redis-x2F-为什么要用缓存？"><a href="#二、为什么要用-Redis-x2F-为什么要用缓存？" class="headerlink" title="二、为什么要用 Redis&#x2F;为什么要用缓存？"></a>二、为什么要用 Redis&#x2F;为什么要用缓存？</h3><p><strong>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</strong></p>
<p>下面我们主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QoQDu9_20210607171659.png" alt="img"></p>
<p><strong>高性能 ：</strong><br> 对照上面<br> 假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。<br> 这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。<br> 不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong><br> 一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。<br> <strong>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</strong><br> 所以，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发</p>
<h3 id="三、Redis-常见数据结构以及使用场景分析"><a href="#三、Redis-常见数据结构以及使用场景分析" class="headerlink" title="三、Redis 常见数据结构以及使用场景分析"></a>三、Redis 常见数据结构以及使用场景分析</h3><ul>
<li><em>string</em><br>1、介绍 ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。<br>2、常用命令: set,get,strlen,exists,dect,incr,setex 等等。<br>3、应用场景 ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。<br> 下面我们简单看看它的使用！</li>
</ul>
<p><strong>普通字符串的基本操作：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set key value #设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get key # 根据 key 获得对应的 value</span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists key  # 判断某个 key 是否存在</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; strlen key # 返回 key 所储存的字符串值的长度。</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del key # 删除某个 key 对应的值</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>批量设置 :</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset key1 value1 key2 value2 # 批量设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mget key1 key2 # 批量获取多个 key 对应的 value</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set number <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; incr number # 将 key 中储存的数字值增一</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; decr number # 将 key 中储存的数字值减一</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>过期：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire key  <span class="number">60</span> # 数据在 <span class="number">60s</span> 后过期</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; setex key <span class="number">60</span> value # 数据在 <span class="number">60s</span> 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) <span class="number">56</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>list</em><br> 1.介绍 ：list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br> 2.常用命令: rpush,lpop,lpush,rpop,lrange、llen 等。<br> 3.应用场景: 发布与订阅或者说消息队列、慢查询。<br> 下面我们简单看看它的使用</li>
</ul>
<p><strong>通过 rpush&#x2F;lpop 实现队列：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush myList value1 # 向 list 的头部（右边）添加元素</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush myList value2 value3 # 向list的头部（最右边）添加多个元素</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop myList # 将 list的尾部(最左边)元素取出</span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange myList <span class="number">0</span> <span class="number">1</span> # 查看对应下标的list列表， <span class="number">0</span> 为 start,<span class="number">1</span>为 end</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange myList <span class="number">0</span> -<span class="number">1</span> # 查看列表中的所有元素，-<span class="number">1</span>表示倒数第一</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>通过 rpush&#x2F;rpop 实现栈：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop myList2 # 将 list的头部(最右边)元素取出</span><br><span class="line"><span class="string">&quot;value3&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>我专门花了一个图方便小伙伴们来理解：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210607172058285_20210607172058.png" alt="img"></p>
<p><strong>通过 lrange 查看对应下标范围的列表元素：</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> rpush myList value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> lrange myList <span class="number">0</span> <span class="number">1</span> <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> lrange myList <span class="number">0</span> -<span class="number">1</span> <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value3&quot;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>通过 lrange 命令，你可以基于 list 实现分页查询，性能非常高！</strong></p>
<p><strong>通过 llen 查看链表长度：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen myList</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>hash</em></li>
</ul>
<ol>
<li>介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li>常用命令： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。</li>
<li>应用场景: 系统中对象数据的存储。<br> 下面我们简单看看它的使用！</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>Set</em><br> 1.介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。<br> 2.常用命令： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。<br> 3.应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景<br> 下面我们简单看看它的使用！</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scard mySet # 查看 set 的长度</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd mySet2 value2 value3</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers mySet3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>sorted set</em><br> 1.介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。<br> 2.常用命令： zadd,zcard,zscore,zrange,zrevrange,zrem 等。<br> 3.应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。<br> 下面我们简单看看它的使用！</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myZset <span class="number">3.0</span> value1 # 添加元素到 sorted set 中 <span class="number">3.0</span> 为权重</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myZset <span class="number">2.0</span> value2 <span class="number">1.0</span> value3 # 一次添加多个元素</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange  myZset <span class="number">0</span> -<span class="number">1</span> # 顺序输出某个范围区间的元素，<span class="number">0</span> -<span class="number">1</span> 表示输出所有元素</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange  myZset <span class="number">0</span> <span class="number">1</span> # 顺序输出某个范围区间的元素，<span class="number">0</span> 为 start  <span class="number">1</span> 为 stop</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrange  myZset <span class="number">0</span> <span class="number">1</span> # 逆序输出某个范围区间的元素，<span class="number">0</span> 为 start  <span class="number">1</span> 为 stop</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="四、Redis-没有使用多线程？为什么不使用多线程？Redis6-0-之后为何引入了多线程？"><a href="#四、Redis-没有使用多线程？为什么不使用多线程？Redis6-0-之后为何引入了多线程？" class="headerlink" title="四、Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？"></a>四、Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？</h3><p>Redis 6.0 新特性，多线程连环 13 问！</p>
<p>Redis 6.0 来了</p>
<p>—</p>
<p>在全国一片祥和IT民工欢度五一节假日的时候，Redis 6.0不声不响地于5 月 2 日正式发布了，吓得我赶紧从床上爬起来，学无止境！学无止境！</p>
<p>对于6.0版本，Redis之父Antirez在RC1版本发布时（2019-12-19）在他的博客上连续用了几个“EST”词语来评价：</p>
<p>the most “enterprise” Redis version to date &#x2F;&#x2F; 最”企业级”的</p>
<p>the largest release of Redis ever as far as I can tell &#x2F;&#x2F; 最大的</p>
<p>the one where the biggest amount of people participated &#x2F;&#x2F; 参与人数最多的</p>
<p>这个版本提供了诸多令人心动的新特性及功能改进，比如新网络协议RESP3，新的集群代理，ACL等，其中关注度最高的应该是“多线程”了，笔者也第一时间体验了一下，带着众多疑问，我们来一起开始“Redis 6.0 新特性-多线程连环13问”。</p>
<p>Redis 6.0 多线程连环13问</p>
<p>—</p>
<p><strong>1.Redis6.0之前的版本真的是单线程吗？</strong></p>
<p>Redis在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。</p>
<p>但如果严格来讲从Redis4.0之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。</p>
<p><strong>2.Redis6.0之前为什么一直不使用多线程？</strong></p>
<p>官方曾做过类似问题的回复：使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。</p>
<p>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p>
<p>Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。</p>
<p><strong>3.Redis6.0为什么要引入多线程呢？</strong></p>
<p>Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p>
<p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读&#x2F;写问题；数据偏斜，重新分配和放大&#x2F;缩小变得更加复杂等等。</p>
<p>从Redis自身角度来说，因为读写网络的read&#x2F;write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p>
<p> • 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</p>
<p> • 使用多线程充分利用多核，典型的实现比如 Memcached。</p>
<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：</p>
<p> • 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</p>
<p> • 多线程任务可以分摊 Redis 同步 IO 读写负荷</p>
<p><strong>4.Redis6.0默认是否开启了多线程？</strong></p>
<p>Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：io-threads-do-reads yes</p>
<p><strong>5.Redis6.0多线程开启时，线程数如何设置？</strong></p>
<p>开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件</p>
<p>关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。</p>
<p><strong>6.Redis6.0采用多线程后，性能的提升效果如何？</strong></p>
<p>Redis 作者 antirez 在 RedisConf 2019分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。国内也有大牛曾使用unstable版本在阿里云esc进行过测试，GET&#x2F;SET 命令在4线程 IO时性能相比单线程是几乎是翻倍了。</p>
<p><strong>测试环境：</strong></p>
<p>Redis Server: 阿里云 Ubuntu 18.04，8 CPU 2.5 GHZ, 8G 内存，主机型号 ecs.ic5.2xlarge</p>
<p>Redis Benchmark Client: 阿里云 Ubuntu 18.04，8 2.5 GHZ CPU, 8G 内存，主机型号 ecs.ic5.2xlarge</p>
<p><strong>测试结果：</strong></p>
<p><strong>说明1</strong>：这些性能验证的测试并没有针对严谨的延时控制和不同并发的场景进行压测。数据仅供验证参考而不能作为线上指标。</p>
<p><strong>说明2</strong>：如果开启多线程，至少要4核的机器，且Redis实例已经占用相当大的CPU耗时的时候才建议采用，否则使用多线程没有意义。所以估计80%的公司开发人员看看就好。</p>
<hr>
<p><strong>7.Redis6.0多线程的实现机制？</strong></p>
<hr>
<p><strong>流程简述如下：</strong></p>
<p>1、主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列</p>
<p>2、主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程</p>
<p>3、主线程阻塞等待 IO 线程读取 socket 完毕</p>
<p>4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行</p>
<p>5、主线程阻塞等待 IO 线程将数据回写 socket 完毕</p>
<p>6、解除绑定，清空等待队列</p>
<p><strong>该设计有如下特点：</strong></p>
<p>1、IO 线程要么同时在读 socket，要么同时在写，不会同时读或写</p>
<p>2、IO 线程只负责读写 socket 解析命令，不负责命令处理</p>
<p><strong>8.开启多线程后，是否会存在线程并发安全问题？</strong></p>
<p>从上面的实现机制可以看出，Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p>
<p><strong>9.Linux环境上如何安装Redis6.0.1（6.0的正式版是6.0.1）？</strong></p>
<p>这个和安装其他版本的redis没有任何区别，整个流程跑下来也没有任何的坑，所以这里就不做描述了。唯一要注意的就是配置多线程数一定要小于cpu的核心数，查看核心数量命令：</p>
<p>[<a href="mailto:&#114;&#111;&#x6f;&#116;&#64;&#x63;&#101;&#x6e;&#116;&#x6f;&#115;&#55;&#46;&#53;">&#114;&#111;&#x6f;&#116;&#64;&#x63;&#101;&#x6e;&#116;&#x6f;&#115;&#55;&#46;&#53;</a> ~]# lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 4On-line CPU(s) list: 0-3</p>
<p><strong>10.Redis6.0的多线程和Memcached多线程模型进行对比</strong></p>
<p>前些年memcached 是各大互联网公司常用的缓存方案，因此redis 和 memcached 的区别基本成了面试官缓存方面必问的面试题，最近几年memcached用的少了，基本都是 redis。</p>
<p>不过随着Redis6.0加入了多线程特性，类似的问题可能还会出现，接下来我们只针对多线程模型来简单比较一下。</p>
<p>如上图所示：Memcached 服务器采用 master-woker 模式进行工作，服务端采用 socket 与客户端通讯。主线程、工作线程 采用 pipe管道进行通讯。主线程采用 libevent 监听 listen、accept 的读事件，事件响应后将连接信息的数据结构封装起来，根据算法选择合适的工作线程，将连接任务携带连接信息分发出去，相应的线程利用连接描述符建立与客户端的socket连接 并进行后续的存取数据操作。</p>
<p>Redis6.0与Memcached多线程模型对比：</p>
<p>相同点：都采用了 master线程-worker 线程的模型</p>
<p>不同点：Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</p>
<p><strong>11.Redis作者是如何点评 “多线程”这个新特性的？</strong></p>
<p>关于多线程这个特性，在6.0 RC1时，Antirez曾做过说明：</p>
<p>Redis支持多线程有2种可行的方式：第一种就是像“memcached”那样，一个Redis实例开启多个线程，从而提升GET&#x2F;SET等简单命令中每秒可以执行的操作。这涉及到I&#x2F;O、命令解析等多线程处理，因此，我们将其称之为“I&#x2F;O threading”。另一种就是允许在不同的线程中执行较耗时较慢的命令，以确保其它客户端不被阻塞，我们将这种线程模型称为“Slow commands threading”。</p>
<p>经过深思熟虑，Redis不会采用“I&#x2F;O threading”，redis在运行时主要受制于网络和内存，所以提升redis性能主要是通过在多个redis实例，特别是redis集群。接下来我们主要会考虑改进两个方面：</p>
<p>\1. Redis集群的多个实例通过编排能够合理地使用本地实例的磁盘，避免同时重写AOF。</p>
<p>2.提供一个Redis集群代理，便于用户在没有较好的集群协议客户端时抽象出一个集群。</p>
<p>补充说明一下，Redis和memcached一样是一个内存系统，但不同于Memcached。多线程是复杂的，必须考虑使用简单的数据模型，执行LPUSH的线程需要服务其他执行LPOP的线程。</p>
<p>我真正期望的实际是“slow operations threading”，在redis6或redis7中，将提供“key-level locking”，使得线程可以完全获得对键的控制以处理缓慢的操作。</p>
<p><strong>12.Redis线程中经常提到IO多路复用，如何理解？</strong></p>
<p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p>
<p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h3 id="五、Redis-给缓存数据设置过期时间有啥用？"><a href="#五、Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="五、Redis 给缓存数据设置过期时间有啥用？"></a>五、Redis 给缓存数据设置过期时间有啥用？</h3><h3 id="六、Redis-是如何判断数据是否过期的呢？"><a href="#六、Redis-是如何判断数据是否过期的呢？" class="headerlink" title="六、Redis 是如何判断数据是否过期的呢？"></a>六、Redis 是如何判断数据是否过期的呢？</h3><h3 id="七、过期的数据的删除策略了解么？"><a href="#七、过期的数据的删除策略了解么？" class="headerlink" title="七、过期的数据的删除策略了解么？"></a>七、过期的数据的删除策略了解么？</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a><strong>定时删除</strong></h4><p>定时删除是指在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快的被删除，并释放过期键所占用的内存。</p>
<p>定时删除策略的缺点是，他对CPU时间是最不友好的：再过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件。而当前时间事件的实现方式—-无序链表，查找一个事件的时间复杂度为O(N)—-并不能高效地处理大量时间事件。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h4><p>惰性删除是指放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回该键。</p>
<p>惰性删除策略对CPU时间来说是最友好的，但对内存是最不友好的。如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么他们也许永远也不会被删除。</p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h4><p>定期删除是指每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。</p>
<p>定期删除策略是前两种策略的一种整合和折中:</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键带来的内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率：</p>
<ul>
<li>如果删除操作执行的太频繁或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多的消耗在删除过期键上面。</li>
<li>如果删除操作执行的太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li>
</ul>
<h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a><strong>Redis的过期键删除策略</strong></h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好的在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a><strong>定期删除策略的实现</strong></h4><p>过期键的定期删除策略由函数redis.c&#x2F;activeExpireCycle实现，每当Redis服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h3 id="八、Redis-内存淘汰机制了解么？"><a href="#八、Redis-内存淘汰机制了解么？" class="headerlink" title="八、Redis 内存淘汰机制了解么？"></a>八、Redis 内存淘汰机制了解么？</h3><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><p>内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？</p>
<p>Redis 提供了下面几种淘汰策略供用户选择，其中默认的策略为 <code>noeviction</code> 策略：</p>
<ul>
<li>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错</li>
<li>allkeys-lru：在主键空间中，优先移除最近未使用的key</li>
<li>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的 key</li>
<li>allkeys-random：在主键空间中，随机移除某个 key</li>
<li>volatile-random：在设置了过期时间的键空间中，随机移除某个 key</li>
<li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除</li>
</ul>
<p>这里补充一下主键空间和设置了过期时间的键空间，举个例子，假设我们有一批键存储在Redis中，则有那么一个哈希表用于存储这批键及其值，如果这批键中有一部分设置了过期时间，那么这批键还会被存储到另外一个哈希表中，这个哈希表中的值对应的是键被设置的过期时间。设置了过期时间的键空间为主键空间的子集。</p>
<h4 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h4><p>我们了解了 Redis 大概提供了这么几种淘汰策略，那么如何选择呢？淘汰策略的选择可以通过下面的配置指定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure>

<p>但是这个值填什么呢？为解决这个问题，我们需要了解我们的应用请求对于 Redis 中存储的数据集的访问方式以及我们的诉求是什么。同时 Redis 也支持 Runtime 修改淘汰策略，这使得我们不需要重启 Redis 实例而实时的调整内存淘汰策略。</p>
<p>下面看看几种策略的适用场景：</p>
<ul>
<li>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略</li>
<li>allkeys-random：如果我们的应用对于缓存 key 的访问概率相等，则可以使用这个策略</li>
<li>volatile-ttl：这种策略使得我们可以向 Redis 提示哪些 key 更适合被 eviction</li>
</ul>
<p>另外，<code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</p>
<h4 id="非精准的-LRU"><a href="#非精准的-LRU" class="headerlink" title="非精准的 LRU"></a>非精准的 LRU</h4><p>上面提到的 LRU（Least Recently Used）策略，实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的，这里涉及到一个权衡的问题，如果需要在全部键空间内搜索最优解，则必然会增加系统的开销，Redis 是单线程的，也就是同一个实例在每一个时刻只能服务于一个客户端，所以耗时的操作一定要谨慎。为了在一定成本内实现相对的 LRU，早期的 Redis 版本是基于采样的 LRU，也就是放弃全部键空间内搜索解改为采样空间搜索最优解。自从 Redis3.0 版本之后，Redis 作者对于基于采样的 LRU 进行了一些优化，目的是在一定的成本内让结果更靠近真实的 LRU。</p>
<h3 id="九、Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#九、Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="九、Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>九、Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h3><p>Redis是常用的基于内存的缓存服务，能为我们缓存数据减少数据库访问从而提升性能，也能作为NoSQL数据库存储数据或借助有序队列做排队系统等。当仅作为数据缓存用时，Redis服务的可用性要求没那么高， 毕竟挂了还能从数据库获取， 但如果作为数据库或队列使用时，Redis挂了可能会影响到业务。本文整理了Redis的持久化方案，使用它们来对Redis的内存数据进行持久化，保障数据的安全性。</p>
<p>Redis支持RDB与AOF两种持久化机制，持久化可以避免因进程异常退出或down机导致的数据丢失问题，在下次重启时能利用之前的持久化文件实现数据恢复。</p>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a><strong>RDB持久化</strong></h4><p>RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。RDB持久化的触发包括手动触发与自动触发两种方式。</p>
<h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a><strong>手动触发</strong></h5><ol>
<li>save， 在命令行执行save命令，将以同步的方式创建rdb文件保存快照，会阻塞服务器的主进程，生产环境中不要用</li>
<li>bgsave, 在命令行执行bgsave命令，将通过fork一个子进程以异步的方式创建rdb文件保存快照，除了fork时有阻塞，子进程在创建rdb文件时，主进程可继续处理请求</li>
</ol>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a><strong>自动触发</strong></h5><ol>
<li>在redis.conf中配置 <code>save m n</code> 定时触发，如 <code>save 900 1</code>表示在900s内至少存在一次更新就触发</li>
<li>主从复制时，如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li>
<li>执行debug reload命令重新加载Redis时</li>
<li>执行shutdown且没有开启AOF持久化</li>
</ol>
<p>redis.conf中RDB持久化配置</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 只要满足下列条件之一，则会执行bgsave命令</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="meta"># 在900s内存在至少一次写操作</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># 禁用RBD持久化，可在最后加 save &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当备份进程出错时主进程是否停止写入操作</span></span><br><span class="line">stop-writes-<span class="keyword">on</span>-bgsave-error yes</span><br><span class="line"><span class="meta"># 是否压缩rdb文件 推荐no 相对于硬盘成本cpu资源更贵</span></span><br><span class="line">rdbcompression no</span><br></pre></td></tr></table></figure>

<h5 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a><strong>AOF持久化</strong></h5><p>AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，就可以通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。</p>
<p>redis.conf中AOF持久化配置如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认关闭AOF，若要开启将no改为yes</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># append文件的名字</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔一秒将缓存区内容写入文件 默认开启的写入方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当AOF文件大小大于该配置项时自动开启重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>AOF持久化的实现包括3个步骤:</p>
<ol>
<li>命令追加：将命令追加到AOF缓冲区</li>
<li>文件写入：缓冲区内容写到AOF文件</li>
<li>文件保存：AOF文件保存到磁盘</li>
</ol>
<p>其中后两步的频率通过appendfsync来配置，appendfsync的选项包括</p>
<ul>
<li>always， 每执行一个命令就保存一次，安全性最高，最多只丢失一个命令的数据，但是性能也最低（频繁的磁盘IO）</li>
<li>everysec，每一秒保存一次，推荐使用，在安全性与性能之间折中，最多丢失一秒的数据</li>
<li>no， 依赖操作系统来执行（一般大概30s一次的样子），安全性最低，性能最高，丢失操作系统最后一次对AOF文件触发SAVE操作之后的数据</li>
</ul>
<p>AOF通过保存命令来持久化，随着时间的推移，AOF文件会越来越大，Redis通过AOF文件重写来解决AOF文件不断增大的问题（可以减少文件的磁盘占有量，加快数据恢复的速度），原理如下：</p>
<ol>
<li>调用fork，创建一个子进程</li>
<li>子进程读取当前数据库的状态来“重写”一个新的AOF文件（这里虽然叫“重写”，但实际并没有对旧文件进行任何读取，而是根据数据库的当前状态来形成指令）</li>
<li>主进程持续将新的变动同时写到AOF重写缓冲区与原来的AOF缓冲区中</li>
<li>主进程获取到子进程重写AOF完成的信号，调用信号处理函数将AOF重写缓冲区内容写入新的AOF文件中，并对新文件进行重命名，原子地覆盖原有AOF文件，完成新旧文件的替换</li>
</ol>
<p>AOF的重写也分为手动触发与自动触发</p>
<ul>
<li>手动触发：直接调用bgrewriteaof命令</li>
<li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。其中auto-aof-rewrite-min-size表示运行AOF重写时文件最小体积，默认为64MB。auto-aof-rewrite-percentage表示当前AOF文件大小（aof_current_size）和上一次重写后AOF文件大小（aof_base_size）的比值。自动触发时机为 aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp;（aof_current_size - aof_base_size）&#x2F;aof_base_size&gt; &#x3D; auto-aof-rewrite-percentage</li>
</ul>
<h5 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a><strong>RDB vs AOF</strong></h5><p>RDB与AOF两种方式各有优缺点。</p>
<p>RDB的优点：与AOF相比，RDB文件相对较小，恢复数据比较快（原因见数据恢复部分）<br> RDB的缺点：服务器宕机，RBD方式会丢失掉上一次RDB持久化后的数据；使用bgsave fork子进程时会耗费内存。</p>
<p>AOF的优点：AOF只是追加文件，对服务器性能影响较小，速度比RDB快，消耗内存也少，同时可读性高。<br> AOF的缺点：生成的文件相对较大，即使通过AOF重写，仍然会比较大；恢复数据的速度比RDB慢。</p>
<h5 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a><strong>数据库的恢复</strong></h5><p>服务器启动时，如果没有开启AOF持久化功能，则会自动载入RDB文件，期间会阻塞主进程。如果开启了AOF持久化功能，服务器则会优先使用AOF文件来还原数据库状态，因为AOF文件的更新频率通常比RDB文件的更新频率高，保存的数据更完整。</p>
<p>redis数据库恢复的处理流程如下，</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/qJZdWt_20210607200126.png" alt="img"></p>
<p>在数据恢复方面，RDB的启动时间会更短，原因有两个：</p>
<ol>
<li>RDB 文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了，文件相对较小。</li>
<li>RDB 文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。</li>
</ol>
<p>但是在进行RDB持久化时，fork出来进行dump操作的子进程会占用与父进程一样的内存，采用的copy-on-write机制，对性能的影响和内存的消耗都是比较大的。比如16G内存，Redis已经使用了10G，这时save的话会再生成10G，变成20G，大于系统的16G。这时候会发生交换，要是虚拟内存不够则会崩溃，导致数据丢失。所以在用redis的时候一定对系统内存做好容量规划。</p>
<h4 id="RDB、AOF混合持久化"><a href="#RDB、AOF混合持久化" class="headerlink" title="RDB、AOF混合持久化"></a><strong>RDB、AOF混合持久化</strong></h4><p>Redis从4.0版开始支持RDB与AOF的混合持久化方案。首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。</p>
<p>开启混合持久化</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-<span class="keyword">use</span>-<span class="title">rdb</span>-<span class="title">preamble</span> <span class="title">yes</span></span><br></pre></td></tr></table></figure>

<p>数据恢复加载过程就是先按照RDB进行加载，然后把AOF命令追加写入。</p>
<h4 id="持久化方案的建议"><a href="#持久化方案的建议" class="headerlink" title="持久化方案的建议"></a><strong>持久化方案的建议</strong></h4><ol>
<li>如果Redis只是用来做缓存服务器，比如数据库查询数据后缓存，那可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。</li>
<li>如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。如果你可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。</li>
<li>通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。</li>
</ol>
<h3 id="十、Redis-缓存穿透、缓存雪崩？"><a href="#十、Redis-缓存穿透、缓存雪崩？" class="headerlink" title="十、Redis 缓存穿透、缓存雪崩？"></a>十、Redis 缓存穿透、缓存雪崩？</h3><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h4><p>通过某个key比如A进行查询时，每次都不能从缓存中获取到数据，因此每次都是访问数据库进行查询（数据库中也没有）。</p>
<p><strong>解决方案</strong><br> 当key值A从数据库未查询到数据时，在缓存中将A的值设为空并设置过期时间。</p>
<h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h4><p>某个热点key A在高并发的请求的情况下，缓存失效的瞬间，大量请求击穿缓存访问数据库。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>1.业务允许的情况下，热点数据不过期；</li>
<li>2.构建互斥锁，在第一个请求创建完成缓存后再释放锁，从而其他请求可以通过key访问缓存；</li>
</ul>
<h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h4><p>雪崩是指缓存中大量数据过期导致系统涌入大量查询请求时，因大部分数据在Redis层已经失效，请求渗透到数据库层，大批量请求引起数据库压力造成查询堵塞甚至宕机。</p>
<p><strong>代码层面，设置数据过期时间：</strong></p>
<ul>
<li>1.数据失效时间分散，不要在同一个时间大量缓存数据失效；</li>
<li>2.业务允许的情况下，数据不失效；</li>
</ul>
<p><strong>架构层面：</strong></p>
<ul>
<li>1.redis高可用，Redis Cluster，主从同步，避免redis全盘奔溃；</li>
<li>2.缓存分级，ehcache + redis + mysql模式，本地内存中无数据再从redis中查找；再者，MySQL实现限流和降级，避免宕机。</li>
<li>3.redis必须要持久化，重启后从磁盘加载数据，快速恢复缓存数据；</li>
</ul>
<h3 id="十一、如何保证缓存和数据库数据的一致性？"><a href="#十一、如何保证缓存和数据库数据的一致性？" class="headerlink" title="十一、如何保证缓存和数据库数据的一致性？"></a>十一、如何保证缓存和数据库数据的一致性？</h3><p>看到好些人在写更新缓存数据代码时，<strong>先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中</strong>。然而，这个是逻辑是错误的。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
<p>这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。</p>
<p>这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。</p>
<p>更新缓存的的Design Pattern有四种：</p>
<ul>
<li>Cache aside （旁路缓存 ）</li>
<li>Read through</li>
<li>Write through</li>
<li>Write behind caching</li>
</ul>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li><strong>失效：</strong>应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中：</strong>应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新：</strong>先把数据存到数据库中，成功后，<strong>再让缓存失效</strong>。</li>
</ul>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。</p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<p>这是标准的design pattern，包括Facebook的论文《<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">Scaling Memcache at Facebook</a>》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p><strong>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</strong></p>
<h4 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h4><p>我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read&#x2F;Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。<strong>可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</strong></p>
<h5 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h5><p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<h5 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h5><p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）<br> 下图自来Wikipedia的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Cache_(computing)">Cache词条</a>。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5yRk3U_20210607200416.png" alt="img"></p>
<h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>Write Behind 又叫 Write Back。<strong>一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。</strong>所以，基础很重要，我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I&#x2F;O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix&#x2F;Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/gV226v_20210607200455.png" alt="img"></p>
<h4 id="再多唠叨一些"><a href="#再多唠叨一些" class="headerlink" title="再多唠叨一些"></a>再多唠叨一些</h4><p>1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache&#x2F;redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。<strong>基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略</strong>，所以这也就是，工程学上所谓的Best Practice，遵从就好了。</p>
<p>2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I&#x2F;O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以，<strong>请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。</strong></p>
<p>3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，<strong>看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子</strong>。千万不要似是而非地，想当然的做软件设计。</p>
<p>4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit&#x2F;rollback，比如Java 7 的XAResource，还有MySQL 5.7的 XA Transaction，有些cache也支持XA，比如EhCache。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://coolshell.cn/articles/10910.html">分布式系统的事务处理</a>》一文。</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><p>非常重要！非常重要！特别是 Git 和 Docker。</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h3><p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p>
<p>Docker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：</p>
<ol>
<li>一致的运行环境，能够更轻松地迁移</li>
<li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源</li>
<li>可以通过镜像复制多个一致的容器</li>
</ol>
<p>Docker 常见概念解读，可以看这篇 Github 上开源的这篇<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker">《Docker 基本概念解读》</a> ，从零到上手实战可以看<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98">《Docker 从入门到上手干事》</a>这篇文章，内容非常详细！</p>
<p>另外，再给大家推荐一本质量非常高的开源书籍<a href="https://link.zhihu.com/?target=https://yeasy.gitbook.io/docker_practice/introduction/why">《Docker 从入门到实践》</a> ，这本书的内容非常新，毕竟书籍的内容是开源的，可以随时改进。</p>
<p><img src="https://pic1.zhimg.com/50/v2-f5d0bf0587f742c9a65f985e7fc12f93_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-f5d0bf0587f742c9a65f985e7fc12f93_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a><strong>常用框架</strong></h2><p><a href="https://link.zhihu.com/?target=https://t.1yb.co/mBsy">2021 最新Java实战项目源码打包下载t.1yb.co<img src="https://pic2.zhimg.com/v2-5c70f2d4123edf16afab8b4bed070b4d_180x120.jpg" alt="图标"></a></p>
<h2 id="Spring-x2F-SpringBoot"><a href="#Spring-x2F-SpringBoot" class="headerlink" title="Spring&#x2F;SpringBoot"></a><strong>Spring&#x2F;SpringBoot</strong></h2><p><strong>Spring 和 SpringBoot 真的很重要！</strong></p>
<p>一定要搞懂 AOP 和 IOC 这两个概念。Spring 中 bean 的作用域与生命周期、SpringMVC 工作原理详解等等知识点都是非常重要的，一定要搞懂。</p>
<p>企业中做 Java 后端，你一定离不开 SpringBoot ，这个是必备的技能了！一定一定一定要学好！</p>
<p>像 SpringBoot 和一些常见技术的整合你也要知识怎么做，比如 SpringBoot 整合 MyBatis、 ElasticSearch、SpringSecurity、Redis 等等。</p>
<p>学习 Spring 的话，可以多看看 **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-framework%23learn">《Spring 的官方文档》</a>**，写的很详细。你可以在这里找到 Spring 全家桶的学习资源。</p>
<p><img src="https://pic4.zhimg.com/50/v2-617c73716c914ce3ee4c9a32be97daa3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-617c73716c914ce3ee4c9a32be97daa3_720w.jpg?source=1940ef5c" alt="img"></p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34949443/">《Spring 实战》</a></strong> 这本书作为学习 Spring 的参考资料。 这本书还是比较新的，目前已经出到了第 5 版，基于 Spring 5 来讲。</p>
<p><img src="https://pic2.zhimg.com/50/v2-27116d84a7876e40fe9e008d0bd1927e_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-27116d84a7876e40fe9e008d0bd1927e_720w.jpg?source=1940ef5c" alt="img"></p>
<p>了解了 Spring 中的一些常见概念和基本用法之后，你就可以开始学习 Spring Boot 了。</p>
<p>当然了，Spring 其实并不是学习 Spring Boot 的前置基础，相比于 Spring 来说，Spring Boot 要更容易上手一些！如果你只是想使用 Spring Boot 来做项目的话，直接学 Spring Boot 就可以了。</p>
<p>不过，我建议你在学习 Spring Boot 之前，可以看看 <strong><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">《Spring 常见问题总结》</a></strong> 。这些问题都是 Spring 比较重要的知识点，也是面试中经常会被问到的。</p>
<p>学习 Spring Boot 的话，还是建议可以多看看  **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-boot%23learn">《Spring Boot 的官方文档》</a>**，写的很详细。</p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26857423/">《Spring Boot 实战》</a></strong> 这本书作为学习 Spring Boot 的参考资料。</p>
<p><img src="https://pic2.zhimg.com/50/v2-ccd869cdada64fb595d5e2c524180eba_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-ccd869cdada64fb595d5e2c524180eba_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书的整体质量实际一般，你当做参考书来看就好了!</p>
<p>相比于 《Spring Boot 实战》这本书，我更推荐国人写的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34894533/">《Spring Boot 实战派》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-347c02b27d1c8074dd6423c11c867b95_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-347c02b27d1c8074dd6423c11c867b95_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书使用的 Spring Boot 2.0+的版本，还算比较新。整本书采用“知识点+实例”的形式编写，书籍的最后两章还有 2 个综合性的企业实战项目：</p>
<ul>
<li>开发企业级通用的后台系统</li>
<li>实现一个类似“京东”的电子商务商城</li>
</ul>
<p>作者在注意实战的过程中还不忘记对于一些重要的基础知识的讲解。</p>
<p>如果你想专研 Spring Boot 底层原理的话，可以看看 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/33390560/">《Spring Boot 编程思想（核心篇）》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书稍微有点啰嗦，不过，原理介绍的比较清楚（不适合初学者）。</p>
<p>如果你比较喜欢看视频的话，推荐尚硅谷雷神的**<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV19K4y1L7MT">《2021 版 Spring Boot2 零基础入门》</a>** 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-8edcdf9da09d431d5a827737df1326f8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-8edcdf9da09d431d5a827737df1326f8_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这可能是全网质量最高并且免费的 Spring Boot 教程了，好评爆炸！</p>
<p>另外，Spring Boot 这块还有很多优质的开源教程，我已经整理好放到 <a href="https://link.zhihu.com/?target=https://github.com/CodingDocs/awesome-java%23springboot">awesome-java@SpringBoot</a> 中了。</p>
<p><img src="https://pic4.zhimg.com/50/v2-bd98e686b9da09ebbe25bfc843364147_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-bd98e686b9da09ebbe25bfc843364147_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a><strong>Netty</strong></h2><p>但凡涉及到网络通信就必然必然离不开网络编程。 Netty 目前作为 Java 网络编程最热门的框架，毫不夸张地说是每个 Java 程序员必备的技能之一。</p>
<p><strong>为什么说学好 Netty 很有必要呢？</strong></p>
<ol>
<li>Netty 基于 NIO （NIO 是一种同步非阻塞的 I&#x2F;O 模型，在 Java 1.4 中引入了 NIO ）。使用 Netty 可以极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面都非常优秀。</li>
<li>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC、Spark、Elasticsearch 等等热门开源项目都用到了 Netty。</li>
<li>大部分微服务框架底层涉及到网络通信的部分都是基于 Netty 来做的，比如说 Spring Cloud 生态系统中的网关 Spring Cloud Gateway 。</li>
</ol>
<p>下面是一些比较推荐的书籍&#x2F;专栏。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/27038538/">《Netty 实战》</a></strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-8a4c942af44520f5d2c99c3d6f37b4dc_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-8a4c942af44520f5d2c99c3d6f37b4dc_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书可以用来入门 Netty ，内容从 BIO 聊到了 NIO、之后才详细介绍为什么有 Netty 、Netty 为什么好用以及 Netty 重要的知识点讲解。</p>
<p>这本书基本把 Netty 一些重要的知识点都介绍到了，而且基本都是通过实战的形式讲解。</p>
<p><strong>《Netty 进阶之路：跟着案例学 Netty》</strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-214ed872bb89b37b2b3c06b4c8c022e5_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-214ed872bb89b37b2b3c06b4c8c022e5_720w.jpg?source=1940ef5c" alt="img"></p>
<p>内容都是关于使用 Netty 的实践案例比如内存泄露这些东西。如果你觉得你的 Netty 已经完全入门了，并且你想要对 Netty 掌握的更深的话，推荐你看一下这本书。</p>
<p><strong>《Netty 入门与实战：仿写微信 IM 即时通讯系统》</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-31d3de0843d01caea292fc461ca00d55_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-31d3de0843d01caea292fc461ca00d55_720w.jpg?source=1940ef5c" alt="img"></p>
<p>通过一个基于 Netty 框架实现 IM 核心系统为引子，带你学习 Netty。整个小册的质量还是很高的，即使你没有 Netty 使用经验也能看懂。</p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h2><p>搜索引擎用于提高搜索效率，功能和浏览器搜索引擎类似。比较常见的搜索引擎是 Elasticsearch（推荐） 和 Solr。</p>
<p>如果你要学习 Elasticsearch 的话，<a href="https://link.zhihu.com/?target=http://www.elasticsearch.cn/">Elastic 中文社区</a> 以及 <a href="https://link.zhihu.com/?target=https://www.elastic.co/cn/blog/">Elastic 官方博客</a> 都是非常不错的资源，上面会分享很多具体的实践案例。</p>
<p>除此之外，极客时间的<a href="https://link.zhihu.com/?target=http://gk.link/a/10bcT">《Elasticsearch 核心技术与实战》</a>这门课程非常赞！这门课基于 Elasticsearch 7.1 版本讲解，比较新。并且，作者是 eBay 资深技术专家，有 20 年的行业经验，课程质量有保障！</p>
<p><img src="https://pic1.zhimg.com/50/v2-057c22f1e83338a78f2e6b22e5da777d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-057c22f1e83338a78f2e6b22e5da777d_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想看书的话，可以考虑一下 《Elasticsearch 实战》 这本书。不过，需要说明的是，这本书中的 Elasticsearch 版本比较老，你可以将其作为一个参考书籍来看，有一些原理性的东西可以在上面找找答案。</p>
<p><img src="https://pic2.zhimg.com/50/v2-d2048059f45eac3a26001579c7826d8f_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d2048059f45eac3a26001579c7826d8f_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想进一步深入研究 Elasticsearch 原理的话，可以看看张超老师的《Elasticsearch 源码解析与优化实战》这本书。这是市面上唯一一本写 Elasticsearch 源码的书。</p>
<p><img src="https://pic4.zhimg.com/50/v2-85d4049c868a55ecbc76ae6c329eaebf_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-85d4049c868a55ecbc76ae6c329eaebf_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>下面我们开始学习分布式以及高并发、高可用了。</p>
<p>这块内容的话，对于每一个知识点没有特定的书籍。我就推荐 2 本我觉得还不错的书籍吧！这两把书籍基本把下面涉及到的知识点给涵盖了。</p>
<p>第一本是李运华老师的**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30335935/">《从零开始学架构》</a>** 。</p>
<p><img src="https://pic2.zhimg.com/50/v2-145c577cd6856daca487eec730ffc394_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-145c577cd6856daca487eec730ffc394_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书对应的有一个极客时间的专栏—<a href="https://link.zhihu.com/?target=http://gk.link/a/10pKZ">《从零开始学架构》</a>，里面的很多内容都是这个专栏里面的，两者买其一就可以了。</p>
<p>第二本是余老师的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30443578/">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-fe7286730c9ea0f94196b5e9f1dd3e07_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-fe7286730c9ea0f94196b5e9f1dd3e07_720w.jpg?source=1940ef5c" alt="img"></p>
<p>事务与锁、分布式（CAP、分布式事务……）、高并发、高可用这本书都有介绍到。值得推荐！良心好书！</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a><strong>理论</strong></h3><h4 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a><strong>CAP 理论</strong></h4><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">《CAP 理论解读》</a>。</p>
<h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a><strong>BASE 理论</strong></h4><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/BASE%E7%90%86%E8%AE%BA">《BASE 理论解读》</a>。</p>
<h4 id="Paxos-算法和-Raft-算法"><a href="#Paxos-算法和-Raft-算法" class="headerlink" title="Paxos 算法和 Raft 算法"></a><strong>Paxos 算法和 Raft 算法</strong></h4><p><strong>Paxos 算法</strong>诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—<strong>Raft 算法</strong>。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><strong>RPC</strong></h3><p>RPC 让调用远程服务调用像调用本地方法那样简单。</p>
<p>Dubbo 是一款国产的 RPC 框架，由阿里开源。相关阅读：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/Dubbo">Dubbo 常见问题总结</a></li>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC">服务之间的调用为啥不直接用 HTTP 而用 RPC？</a></li>
</ul>
<h4 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a><strong>服务注册与发现</strong></h4><p>Eureka、Zookeeper、Consul、Nacos 都可以提供服务注册与发现的功能。</p>
<p><img src="https://pic1.zhimg.com/50/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_720w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a><strong>API 网关</strong></h3><p>网关主要用于请求转发、安全认证、协议转换、容灾。</p>
<p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，为了取代 Netflix Zuul。</p>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a><strong>配置中心</strong></h4><p>微服务下，业务的发展一般会导致服务数量的增加，进而导致程序配置（服务地址、数据库参数等等）增多。</p>
<p>传统的配置文件的方式已经无法满足当前需求，主要有两点原因：一是安全性得不到保障（配置放在代码库中容易泄露）；二是时效性不行 （修改配置需要重启服务才能生效）。</p>
<p>Spring Cloud Config、Nacos 、Apollo、K8s ConfigMap 都可以用来做配置中心。</p>
<p>Apollo 和 Nacos 我个人更喜欢。Nacos 使用起来更加顺手，Apollo 在配置管理方面做的更加全面。</p>
<h3 id="分布式-id"><a href="#分布式-id" class="headerlink" title="分布式 id"></a><strong>分布式 id</strong></h3><p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>
<p><img src="https://pic1.zhimg.com/50/v2-21c5fb2a333d04d70ccf2554e4a66995_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-21c5fb2a333d04d70ccf2554e4a66995_720w.jpg?source=1940ef5c" alt="img"></p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>
<p>我简单举一个分库分表的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。</p>
<p>单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>
<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-1f699f3733924441f3707926da884744_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-1f699f3733924441f3707926da884744_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<p>分布式 ID 的解决方案有很多比如 ：</p>
<ul>
<li>算法 ：UUID、Snowflake</li>
<li>开源框架 ： UidGenerator、Leaf 、Tinyid</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><strong>分布式事务</strong></h3><p>微服务架构下，一个系统被拆分为多个小的微服务。</p>
<p>每个微服务都可能存在不同的机器上，并且每个微服务可能都有一个单独的数据库供自己使用。这种情况下，一组操作可能会涉及到多个微服务以及多个数据库。</p>
<p>举个例子：电商系统中，你创建一个订单往往会涉及到订单服务（订单数加一）、库存服务（库存减一）等等服务，这些服务会有供自己单独使用的数据库。</p>
<p><img src="https://pic2.zhimg.com/50/v2-feaa7d9765154fa367bc008444d208c3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-feaa7d9765154fa367bc008444d208c3_720w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>那么如何保证这一组操作要么都执行成功，要么都执行失败呢？</strong></p>
<p>这个时候单单依靠数据库事务就不行了！我们就需要引入 <strong>分布式事务</strong> 这个概念了！</p>
<p>常用分布式事务解决方案有 Seata 和 Hmily。</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://seata.io/zh-cn/index.html">Seata</a></strong> :Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://gitee.com/shuaiqiyu/hmily">Hmily</a></strong> : 金融级分布式事务解决方案</li>
</ol>
<h3 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a><strong>分布式链路追踪</strong></h3><p>不同于单体架构，在分布式架构下，请求需要在多个服务之间调用，排查问题会非常麻烦。我们需要分布式链路追踪系统来解决这个痛点。</p>
<p>目前分布式链路追踪系统基本都是根据谷歌的《Dapper 大规模分布式系统的跟踪系统》这篇论文发展而来，主流的有 Pinpoint，Skywalking ，CAT（当然也有其他的例如 Zipkin，Jaeger 等产品，不过总体来说不如前面选取的 3 个完成度高）等。</p>
<p>Zipkin 是 Twitter 公司开源的一个分布式链路追踪工具，Spring Cloud Sleuth 实际是基于 Zipkin 的。</p>
<p>SkyWalking 是国人吴晟（华为）开源的一款分布式追踪，分析，告警的工具，现在是 Apache 旗下开源项目</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><p>微服务的很多东西实际在分布式这一节已经提到了。</p>
<p>我这里就再补充一些微服务架构中，经常使用到的一些组件。</p>
<ul>
<li><strong>声明式服务调用</strong> : Feign</li>
<li><strong>负载均衡</strong> : Ribbon</li>
<li>……</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a><strong>高并发</strong></h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h4><p><img src="https://pic2.zhimg.com/50/v2-4903cf7307350d41a16d0277112d5424_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4903cf7307350d41a16d0277112d5424_720w.jpg?source=1940ef5c" alt="img"></p>
<p>消息队列在分布式系统中主要是为了解耦和削峰。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/message-queue/message-queue">消息队列常见问题总结</a>。</p>
<p>常用的消息队列如下：</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/rocketmq">RocketMQ</a></strong> ：阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/kafka">Kafaka</a></strong>: Kafka 是一种分布式的，基于发布 &#x2F; 订阅的消息系统。关于它的入门可以查看：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md">Kafka 入门看这一篇就够了</a></li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/rabbitmq">RabbitMQ</a></strong> :由 erlang 开发的基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。</li>
</ol>
<h3 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a><strong>读写分离&amp;分库分表</strong></h3><p>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。主服务器负责写，从服务器负责读。另外，一主一从或者一主多从都可以。</p>
<p>读写分离可以大幅提高读性能，小幅提高写的性能。因此，读写分离更适合单机并发读请求比较多的场景。</p>
<p><img src="https://pic3.zhimg.com/50/v2-36f2ed6de6018bb4cebab32623373864_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-36f2ed6de6018bb4cebab32623373864_720w.jpg?source=1940ef5c" alt="img"></p>
<p>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</p>
<p>常见的分库分表工具有：sharding-jdbc（当当）、TSharding（蘑菇街）、MyCAT（基于 Cobar）、Cobar（阿里巴巴）…。 推荐使用 sharding-jdbc。 因为，sharding-jdbc 是一款轻量级 Java 框架，以 jar 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。</p>
<p><img src="https://pic2.zhimg.com/50/v2-635a97b84f0e3b718b1cfdc61a0bbe08_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-635a97b84f0e3b718b1cfdc61a0bbe08_720w.jpg?source=1940ef5c" alt="img"></p>
<p>相关阅读： <a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">读写分离&amp;分库分表常见问题总结</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。</p>
<p>常见的负载均衡系统包括 3 种：</p>
<ol>
<li><strong>DNS 负载均衡</strong> ：一般用来实现地理级别的均衡。</li>
<li><strong>硬件负载均衡</strong> ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li>
<li><strong>软件负载均衡</strong> ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li>
</ol>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h2><p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的 。</p>
<p>相关阅读： <strong>《<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9">如何设计一个高可用系统？要考虑哪些地方？</a>》</strong> 。</p>
<h3 id="限流-amp-降级-amp-熔断"><a href="#限流-amp-降级-amp-熔断" class="headerlink" title="限流&amp;降级&amp;熔断"></a><strong>限流&amp;降级&amp;熔断</strong></h3><p>限流是从用户访问压力的角度来考虑如何应对系统故障。限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。比如某一接口的请求限制为 100 个每秒, 对超过限制的请求放弃处理或者放到队列中等待处理。限流可以有效应对突发请求过多。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/limit-request">限流算法有哪些？</a></p>
<p>降级是从系统功能优先级的角度考虑如何应对系统故障。服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<p>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。</p>
<p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Netflix/Hystrix">Hystrix</a> 和 <a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel">Sentinel</a> 都能实现限流、降级、熔断。</p>
<p>Hystrix 是 Netflix 开源的熔断降级组件，Sentinel 是阿里中间件团队开源的一款不光具有熔断降级功能，同时还支持系统负载保护的组件。</p>
<p>两者都是主要做熔断降级 ，那么两者到底有啥异同呢？该如何选择呢？</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94">Sentinel 的 wiki 中已经详细描述了其与 Hystrix 的区别</a>，你可以看看。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a><strong>排队</strong></h3><p>另类的一种限流，类比于现实世界的排队。玩过英雄联盟的小伙伴应该有体会，每次一有活动，就要经历一波排队才能进入游戏。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><p>相同的服务部署多份，避免单点故障。</p>
<h3 id="超时和重试机制"><a href="#超时和重试机制" class="headerlink" title="超时和重试机制"></a><strong>超时和重试机制</strong></h3><p><strong>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</strong> 如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。</p>
<h4 id="另外，重试的次数一般设为-3-次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。"><a href="#另外，重试的次数一般设为-3-次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。" class="headerlink" title="另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。"></a>另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</h4>
      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/ac3dc3bf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ac3dc3bf/" class="post-title-link" itemprop="url">9、【对线面试官】线程池</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 09:48:07" itemprop="dateModified" datetime="2022-03-10T09:48:07+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/ac3dc3bf/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/ac3dc3bf/" data-xid="/posts/ac3dc3bf/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="9、【对线面试官】线程池"><a href="#9、【对线面试官】线程池" class="headerlink" title="9、【对线面试官】线程池"></a>9、【对线面试官】线程池</h1><h2 id="今天来聊聊线程池呗，你对Java线程池了解多少？"><a href="#今天来聊聊线程池呗，你对Java线程池了解多少？" class="headerlink" title="今天来聊聊线程池呗，你对Java线程池了解多少？"></a>今天来聊聊线程池呗，你对Java线程池了解多少？</h2><h2 id="或者换个问法：为什么需要线程池？"><a href="#或者换个问法：为什么需要线程池？" class="headerlink" title="或者换个问法：为什么需要线程池？"></a>或者换个问法：为什么需要线程池？</h2><ol>
<li>JVM在HotSpot的线程模型下，Java线程会一对一映射为内核线程</li>
<li>这意味着，在Java中每次创建以及回收线程都会去内核创建以及回收</li>
<li>这就有可能导致：创建和销毁线程所花费的时间和资源可能比处理的任务花费的时间和资源要更多</li>
<li>线程池的出现是为了提高线程的复用性以及固定线程的数量！！！</li>
</ol>
<h2 id="你在项目中用到了线程池吗？"><a href="#你在项目中用到了线程池吗？" class="headerlink" title="你在项目中用到了线程池吗？"></a>你在项目中用到了线程池吗？</h2><ol>
<li>嗯，用到的。我先说下背景吧</li>
<li>我所负责的项目是消息管理平台，提供其中一个功能就是：运营会圈定人群，然后群发消息</li>
<li>主要流程大致就是：创建模板-》定时-》群发消息-》用户收到消息</li>
<li>运营圈定的人群实际上在模板上只是一个ID，我这边要通过ID去获取到HDFS文件</li>
<li>对HDFS文件进行遍历，然后继续往下发</li>
<li>「接收到定时任务，再对HDFS进行遍历」这里的处理，我用的就是线程池处理</li>
</ol>
<h2 id="为什么选择用线程池呢？"><a href="#为什么选择用线程池呢？" class="headerlink" title="为什么选择用线程池呢？"></a>为什么选择用线程池呢？</h2><ol>
<li>HDFS遍历其实就是IO的操作，我把这个过程给异步化，为了提高系统的吞吐量，于是我这里用的线程池。</li>
<li>即便遍历HDFS出现问题，我这边都有完备的监控和告警可以及时发现。</li>
</ol>
<h2 id="那你是怎么用线程池的呢？用Executors去创建的吗？"><a href="#那你是怎么用线程池的呢？用Executors去创建的吗？" class="headerlink" title="那你是怎么用线程池的呢？用Executors去创建的吗？"></a>那你是怎么用线程池的呢？用Executors去创建的吗？</h2><ol>
<li>不是的，我这边用的ThreadPoolExecutor去创建线程池</li>
<li>其实看阿里巴巴开发手册就有提到，不要使用Executors去创建线程。</li>
<li>最主要的目的就是：使用ThreadPoolExecutor创建的线程你是更能了解线程池运行的规则，避免资源耗尽的风险</li>
<li>ThreadPoolExecutor在构造的时候有几个重要的参数，分别是：<br>corePoolSize （核心线程数量） 、maxim umPoolSize（最大线程数量）、keepAli veTime（线程空余时间） 、workQueue（阻塞队列）、handler（任务拒绝策略）</li>
<li>这几个参数应该很好理解哈，我就说下任务提交的流程，分别对应着几个参数的作用吧。<ul>
<li>首先会判断运行线程数是否小于corePoolSize，如果小于，则直接创建新的线程执行任务</li>
<li>如果大于corePoolSize，判断workQueue阻塞队列是否已满，如果还没满，则将任务放到阻塞队列中</li>
<li>如果workQueue阻塞队列已经满了，则判断当前线程数是否大于maximumPoolSize，如果没大于则创建新的线程执行任务</li>
<li>如果大于maximumPoolSize，则执行任务拒绝策略（具体就是你自己实现的handler)</li>
</ul>
</li>
<li>这里有个点需要注意下，就是workQueu e阻塞队列满了，但当前线程数小于maximumPoolSize，这时候会创建新的线程执行任务</li>
<li>源码就是这样实现的</li>
<li>不过一般我们都是将corePoolSize和maximumPoolSize设置相同数量</li>
<li>keepAliveTime指的就是，当前运行的线程数大于核心线程数了，只要空闲时间达到了，就会对线程进行回收</li>
</ol>
<h2 id="那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。"><a href="#那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。" class="headerlink" title="那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。"></a>那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。</h2><ol>
<li>线程池指定线程数这块，首先要考量自己的业务是什么样的</li>
<li>是cpu密集型的还是io密集型的，假设运行应用的机器CPU核心数是N</li>
<li>那cpu密集型的可以先给到N+1，io密集型的可以给到2N去试试</li>
<li>上面这个只是一个常见的经验做法，具体究竟开多少线程，需要压测才能比较准确地定下来</li>
<li>线程不是说越大越好，在之前的面试我也提到过，多线程是为了充分利用CPU的资源</li>
<li>如果设置的线程过多，线程大量有上下文切换，这一部分也会带来系统的开销，这就得不偿失了</li>
</ol>
<h2 id="ThreadPoolExecutor你看过源码吗？"><a href="#ThreadPoolExecutor你看过源码吗？" class="headerlink" title="ThreadPoolExecutor你看过源码吗？"></a>ThreadPoolExecutor你看过源码吗？</h2><ol>
<li>看过的，其实上面说的ThreadPoolExecutor几个参数，在源码的顶部注释都有</li>
<li>在执行的时候，重点就在于它维护了一个ctl参数，这个ctl参数的用高3位表示线程池的状态，低29位来表示线程的数量</li>
<li>里边用到了大量的位运算符操作，具体细节我就忘了，但是流程还是上面所讲的</li>
</ol>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/eb551b6f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/eb551b6f/" class="post-title-link" itemprop="url">面试官“谈谈Spring中都用到了那些设计模式”。</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 09:48:07" itemprop="dateModified" datetime="2022-03-10T09:48:07+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/eb551b6f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/eb551b6f/" data-xid="/posts/eb551b6f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面试官-“谈谈Spring中都用到了那些设计模式-”。"><a href="#面试官-“谈谈Spring中都用到了那些设计模式-”。" class="headerlink" title="面试官:“谈谈Spring中都用到了那些设计模式?”。"></a>面试官:“谈谈Spring中都用到了那些设计模式?”。</h1><p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。</p>
<p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>
<h2 id="控制反转-IoC-和依赖注入-DI"><a href="#控制反转-IoC-和依赖注入-DI" class="headerlink" title="控制反转(IoC)和依赖注入(DI)"></a>控制反转(IoC)和依赖注入(DI)</h2><p><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwBuibJ4N5OTyAvJibFj8b7zhiaTcnFwmnfLqQQWwlWv2uNMZyiabexkUSuW24WAWAuL6cvzguu8JyYzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<center>ioc-patterns</center>

<p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>
<p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a> ，非常不错。</p>
<p><strong>控制翻转怎么理解呢?</strong> 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</p>
<p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>
<h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(</span><br><span class="line">                <span class="string">&quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloApplicationContext</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloApplicationContext) context.getBean(<span class="string">&quot;helloApplicationContext&quot;</span>);</span><br><span class="line">        obj.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml:<bean id="userService" class="top.snailclimb.UserService" scope="singleton"/>&#96;&#96;</li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ul>
<p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h2><h3 id="代理模式在-AOP-中的应用"><a href="#代理模式在-AOP-中的应用" class="headerlink" title="代理模式在 AOP 中的应用"></a>代理模式在 AOP 中的应用</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/16qDep_20210809142649.png" alt="图片"></p>
<center>SpringAOPProcess</center>

<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7MhBrj_20210809142855.png" alt="图片"></p>
<center>模板方法UML图</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="comment">//这是我们的模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">TemplateMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        PrimitiveOperation1();  </span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        PrimitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span>  <span class="title function_">PrimitiveOperation1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被子类实现的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation3</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateImpl</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3 id="Spring-事件驱动模型中的三种角色"><a href="#Spring-事件驱动模型中的三种角色" class="headerlink" title="Spring 事件驱动模型中的三种角色"></a>Spring 事件驱动模型中的三种角色</h3><h4 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h4><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/tKwbDY_20210809143054.png" alt="图片"></p>
<center>ApplicationEvent-Subclass</center>

<h4 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h4><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h4><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p>
<h3 id="Spring-的事件流程总结"><a href="#Spring-的事件流程总结" class="headerlink" title="Spring 的事件流程总结"></a>Spring 的事件流程总结</h3><ol>
<li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li>
<li>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoEvent</span><span class="params">(Object source,String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;DemoEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(DemoEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息是：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">DemoEvent</span>(<span class="built_in">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h3 id="spring-AOP中的适配器模式"><a href="#spring-AOP中的适配器模式" class="headerlink" title="spring AOP中的适配器模式"></a>spring AOP中的适配器模式</h3><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<h3 id="spring-MVC中的适配器模式"><a href="#spring-MVC中的适配器模式" class="headerlink" title="spring MVC中的适配器模式"></a>spring MVC中的适配器模式</h3><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p>
<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TRTmlJ_20210809143212.png" alt="图片"></p>
<center>
  装饰者模式示意图
</center>

<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 框架中用到了哪些设计模式：</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring技术内幕》</li>
<li><a target="_blank" rel="noopener" href="https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/">https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.yeamin.top/2018/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Spring%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialsteacher.com/ioc/inversion-of-control">https://www.tutorialsteacher.com/ioc/inversion-of-control</a></li>
<li><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a8eb261f265da4e9e307230">https://juejin.im/post/5a8eb261f265da4e9e307230</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ba28986f265da0abc2b6084">https://juejin.im/post/5ba28986f265da0abc2b6084</a></li>
</ul>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/995671e7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/995671e7/" class="post-title-link" itemprop="url">动态规划答疑篇</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-11 10:11:17" itemprop="dateModified" datetime="2022-03-11T10:11:17+08:00">2022-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/995671e7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/995671e7/" data-xid="/posts/995671e7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态规划答疑篇"><a href="#动态规划答疑篇" class="headerlink" title="动态规划答疑篇"></a>动态规划答疑篇</h1><h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>这篇文章就给你讲明白两个读者问得最多的问题：</p>
<p>1、到底什么才叫「最优子结构」，和动态规划什么关系。</p>
<p>2、为什么动态规划遍历<code>dp</code>数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历，有的无论咋遍历都是对的。</p>
<h2 id="一、最优子结构详解"><a href="#一、最优子结构详解" class="headerlink" title="一、最优子结构详解"></a>一、最优子结构详解</h2><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。</p>
<p>我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p>
<p>我给你提出的这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p>
<p>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p>
<p>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p>
<p>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划详解</a> 说过，想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p>
<p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a : school) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Student b : school) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a is b) <span class="keyword">continue</span>;</span><br><span class="line">        result = max(result, |a.score - b.score|);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p>
<p>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。</p>
<p>前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484469&idx=1&sn=e8d321c8ad62483874a997e9dd72da8f&chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 和 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484690&idx=1&sn=eea075701a5d96dd5c6e3dc6a993cac5&chksm=9bd7fb1aaca0720c58c9d9e02a8b9211a289bcea359633a95886d7808d2846898d489ce98078&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋（进阶篇）</a> 就展示了如何改造问题，不同的最优子结构，可能导致不同的解法和效率。</p>
<p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxVal(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxVal(root.right);</span><br><span class="line">    <span class="keyword">return</span> max(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看这个问题也符合最优子结构，以<code>root</code>为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p>
<p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p>
<p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p>
<p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。</p>
<p>这里就不举那些正宗动态规划的例子了，读者可以翻翻历史文章，看看状态转移是如何遵循最优子结构的，这个话题就聊到这，下面再来看另外个动态规划迷惑行为。</p>
<h3 id="二、dp-数组的遍历方向"><a href="#二、dp-数组的遍历方向" class="headerlink" title="二、dp 数组的遍历方向"></a>二、dp 数组的遍历方向</h3><p>我相信读者做动态规划问题时，肯定会对<code>dp</code>数组的遍历顺序有些头疼。我们拿二维<code>dp</code>数组来举例，有时候我们是正向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p>有时候我们反向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p>有时候可能会斜向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斜着遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a> 中有的地方就正反皆可。</p>
<p>那么，如果仔细观察的话可以发现其中的原因的。你只要把住两点就行了：</p>
<p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p>
<p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p>
<p>下面来具体解释上面两个原则是什么意思。</p>
<p>比如编辑距离这个经典的问题，详解见前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect">经典动态规划：编辑距离</a>，我们通过对<code>dp</code>数组的定义，确定了 base case 是<code>dp[..][0]</code>和<code>dp[0][..]</code>，最终答案是<code>dp[m][n]</code>；而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i-1][j-1]</code>转移而来，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/H23fMQ_20210507174659.png" alt="图片"></p>
<p>那么，参考刚才说的两条原则，你该怎么遍历<code>dp</code>数组？肯定是正向遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="comment">// 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span></span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案<code>dp[m][n]</code>。</strong></p>
<p>再举一例，回文子序列问题，详见前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484666&idx=1&sn=e3305be9513eaa16f7f1568c0892a468&chksm=9bd7faf2aca073e4f08332a706b7c10af877fee3993aac4dae86d05783d3d0df31844287104e&scene=21#wechat_redirect">子序列解题模板：最长回文子序列</a>，我们通过过对<code>dp</code>数组的定义，确定了 base case 处在中间的对角线，<code>dp[i][j]</code>需要从<code>dp[i+1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i+1][j-1]</code>转移而来，想要求的最终答案是<code>dp[0][n-1]</code>，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/L4hOYZ_20210507174734.png" alt="图片"></p>
<p>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/UGCkQ2_20210507174820.png" alt="图片"></p>
<p><strong>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>的左边、下边、左下边已经计算完毕，最终得到正确结果。</strong></p>
<p>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/117b65dd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/117b65dd/" class="post-title-link" itemprop="url">动态规划设计之最长递增子序列</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/117b65dd/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/117b65dd/" data-xid="/posts/117b65dd/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态规划设计之最长递增子序列"><a href="#动态规划设计之最长递增子序列" class="headerlink" title="动态规划设计之最长递增子序列"></a>动态规划设计之最长递增子序列</h1><h2 id="预计阅读时间：-9-分钟"><a href="#预计阅读时间：-9-分钟" class="headerlink" title="预计阅读时间： 9 分钟"></a>预计阅读时间： 9 分钟</h2><p>很多读者反应，就算看了前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247483818&idx=1&sn=6035f861d1b2bfd0178e842f26ac4836&chksm=fb3361e8cc44e8fe331154bfd32bd7b3b4f159bfad5d38d4a6b0b9f0d7e3485b93b828ee72cc&scene=21#wechat_redirect">动态规划详解</a>，了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。</p>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。</p>
<p>比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p>
<p>先看一下题目，很容易理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/MEAMGr_20210715222744.png" alt="图片"></p>
<p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p>
<h2 id="一、动态规划解法"><a href="#一、动态规划解法" class="headerlink" title="一、动态规划解法"></a>一、动态规划解法</h2><p><strong>动态规划的核心设计思想是数学归纳法。</strong></p>
<p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k&lt;n 时成立，然后想办法证明 k&#x3D;<em>n</em> 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <em>dp</em>[0…<em>i</em>−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出<em>dp[i] ?</em></p>
<p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？</p>
<p><strong>我们的定义是这样的：****dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。</strong></p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/S9DvIE_20210715222829.png" alt="图片"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/vrYoH4_20210715222841.png" alt="图片"></p>
<p>算法演进的过程是这样的：<img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640_20210715222950.gif" alt="图片"></p>
<p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？</p>
<p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p>
<p>我们已经知道了 <em>d**p</em>[0…4] 的所有结果，我们如何通过这些已知结果推出 <em>d**p</em>[5] 呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/xpC5LY_20210715223016.png" alt="图片"></p>
<p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p>
<p>nums[5] &#x3D; 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p>
<p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p>
<p>![图片](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640">https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640</a> (1)_20210715223303.gif)</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QksgN5_20210715223039.png" alt="图片"></p>
<p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？</p>
<p>类似数学归纳法，你已经可以通过 dp[0…4] 算出 dp[5] 了，那么任意 dp[i] 你肯定都可以算出来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9CYook_20210715223056.png" alt="图片"></p>
<p>还有一个细节问题，就是 base case。dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210715223113307_20210715223113.png" alt="图片"></p>
<p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：</p>
<p>首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p>然后根据 dp 数组的定义，运用数学归纳法的思想，假设 <em>d**p</em>[0…<em>i</em>−1] 都已知，想办法求出 <em>d**p</em>[<em>i</em>]，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p>
<h2 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h2><p>这个解法的时间复杂度会将为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以如果大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p>
<p>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。</p>
<p>为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下思路。</p>
<p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/DFBLV6_20210715223123.png" alt="图片"></p>
<p>处理这些扑克牌要遵循以下规则：</p>
<p>只能把点数小的牌压到点数比它大的牌上。如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去。如果当前牌有多个堆可供选择，则选择最左边的堆放置。</p>
<p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 A 的值是最大的，而不是 1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210715223138612_20210715223138.png" alt="图片"></p>
<p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Cnd9HF_20210715223145.png" alt="图片"></p>
<p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是我们想求的最长递增子序列的长度，证明略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/8SHDGY_20210715223158.png" alt="图片"></p>
<p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。</p>
<p>PS：旧文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484090&idx=1&sn=5635cf1c4fd8a8570b63c7ae9b4304c2&chksm=fb3362f8cc44ebee0a19a4cfba7f2e13923e05f47e15f2e99a1f42b01aeee83b946aceac3d4c&scene=21#wechat_redirect">二分查找算法详解</a> 详细介绍了二分查找的细节及变体，这里就完美应用上了。如果没读过强烈建议阅读。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/f6Golz_20210715223219.png" alt="图片"></p>
<p>至此，二分查找的解法也讲解完毕。</p>
<p>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。</p>
<p>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/e775a8f2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e775a8f2/" class="post-title-link" itemprop="url">回溯算法和动态规划，到底谁是谁爹</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/e775a8f2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/e775a8f2/" data-xid="/posts/e775a8f2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="回溯算法和动态规划，到底谁是谁爹？"><a href="#回溯算法和动态规划，到底谁是谁爹？" class="headerlink" title="回溯算法和动态规划，到底谁是谁爹？"></a>回溯算法和动态规划，到底谁是谁爹？</h1><p>我们前文经常说回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。</p>
<p>那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/RGwzua_20210422224714.png" alt="图片"></p>
<p>那么，它俩具体有啥区别呢？回溯算法和动态规划之间，是否可能互相转化呢？</p>
<p>今天就用力扣第 494 题「目标和」来详细对比一下回溯算法和动态规划，真可谓群魔乱舞：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/fMFTnw_20210422224839.png" alt="图片"></p>
<p>注意，给出的例子 <code>nums</code> 全是 1，但实际上可以是任意正整数哦。</p>
<h2 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="一、回溯思路"></a>一、回溯思路</h2><p>其实我第一眼看到这个题目，花了两分钟就写出了一个回溯解法。</p>
<p>任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法，前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法解题框架</a> 就写了回溯算法框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>关键就是搞清楚什么是「选择」，而对于这道题，「选择」不是明摆着的吗？</p>
<p>**对于每个数字 <code>nums[i]</code>，我们可以选择给一个正号 <code>+</code> 或者一个负号 <code>-</code>**，然后利用回溯模板穷举出来所有可能的结果，数一数到底有几种组合能够凑出 <code>target</code> 不就行了嘛？</p>
<p>伪码思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">backtrack</span><span class="params">(nums, i)</span>:</span><br><span class="line">    <span class="type">if</span> <span class="variable">i</span> <span class="operator">=</span>= len(nums):</span><br><span class="line">        <span class="keyword">if</span> 达到 target:</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> op in &#123; +<span class="number">1</span>, -<span class="number">1</span> &#125;:</span><br><span class="line">        选择 op * nums[i]</span><br><span class="line">        # 穷举 nums[i + <span class="number">1</span>] 的选择</span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>如果看过我们之前的几篇回溯算法文章，这个代码可以说是比较简单的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法模板 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明恰好凑出 target</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 - 号</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest -= nums[i]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 + 号</span></span><br><span class="line">    rest -= nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的读者可能问，选择 <code>-</code> 的时候，为什么是 <code>rest += nums[i]</code>，选择 <code>+</code> 的时候，为什么是 <code>rest -= nums[i]</code> 呢，是不是写反了？</p>
<p>不是的，「如何凑出 <code>target</code>」和「如何把 <code>target</code> 减到 0」其实是一样的。我们这里选择后者，因为前者必须给 <code>backtrack</code> 函数多加一个参数，我觉得不美观：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们给 <code>nums[i]</code> 选择 <code>+</code> 号，就要让 <code>rest - nums[i]</code>，反之亦然。</p>
<p>以上回溯算法可以解决这个问题，时间复杂度为 <code>O(2^N)</code>，<code>N</code> 为 <code>nums</code> 的大小。这个复杂度怎么算的？回忆前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&chksm=9bd7fbbcaca072aa75e2a241064a403fde1e579d57ab846cd8537a54253ceb2c8b93cc3bf38e&scene=21#wechat_redirect">学习数据结构和算法的框架思维</a>，发现这个回溯算法就是个二叉树的遍历问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest - nums[i]);</span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest + nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的高度就是 <code>nums</code> 的长度嘛，所以说时间复杂度就是这棵二叉树的节点数，为 <code>O(2^N)</code>，其实是非常低效的。</p>
<p>那么，这个问题如何用动态规划思想进行优化呢？</p>
<h2 id="二、消除重叠子问题"><a href="#二、消除重叠子问题" class="headerlink" title="二、消除重叠子问题"></a>二、消除重叠子问题</h2><p>动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。</p>
<p>如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 <code>backtrack</code> 函数来说，会变的参数为 <code>i</code> 和 <code>rest</code>。</p>
<p>前文 动态规划之编辑距离 说了一种一眼看出重叠子问题的方法，先抽象出递归框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest - nums[i]);</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest + nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个简单的例子，如果 <code>nums[i] = 0</code>，会发生什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest);</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看，这样就出现了两个「状态」完全相同的递归函数，无疑这样的递归计算就是重复的。<strong>这就是重叠子问题，而且只要我们能够找到一个重叠子问题，那一定还存在很多的重叠子问题</strong>。</p>
<p>因此，状态 <code>(i, rest)</code> 是可以用备忘录技巧进行优化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp(nums, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line">HashMap&lt;String, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把它俩转成字符串才能作为哈希表的键</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i + <span class="string">&quot;,&quot;</span> + rest;</span><br><span class="line">    <span class="comment">// 避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (memo.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还是穷举</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp(nums, i + <span class="number">1</span>, rest - nums[i]) + dp(nums, i + <span class="number">1</span>, rest + nums[i]);</span><br><span class="line">    <span class="comment">// 记入备忘录</span></span><br><span class="line">    memo.put(key, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前我们都是用 Python 的元组配合哈希表 <code>dict</code> 来做备忘录的，其他语言没有元组，可以用把「状态」转化为字符串作为哈希表的键，这是一个常用的小技巧。</p>
<p>这个解法通过备忘录消除了很多重叠子问题，效率有一定的提升，但是这就结束了吗？</p>
<h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><p>事情没有这么简单，先来算一算，消除重叠子问题之后，算法的时间复杂度是多少？其实最坏情况下依然是 <code>O(2^N)</code>。</p>
<p>为什么呢？因为我们只不过恰好发现了重叠子问题，顺手用备忘录技巧给优化了，但是底层思路没有变，依然是暴力穷举的回溯算法，依然在遍历一棵二叉树。<strong>这只能叫对回溯算法进行了「剪枝」，提升了算法在某些情况下的效率</strong>，但算不上质的飞跃。</p>
<p>其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……</p>
<p>首先，如果我们把 <code>nums</code> 划分成两个子集 <code>A</code> 和 <code>B</code>，分别代表分配 <code>+</code> 的数和分配 <code>-</code> 的数，那么他们和 <code>target</code> 存在如下关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum(A) - sum(B) = target</span><br><span class="line"><span class="title function_">sum</span><span class="params">(A)</span> = target + sum(B)</span><br><span class="line">sum(A) + sum(A) = target + sum(B) + sum(A)</span><br><span class="line"><span class="number">2</span> * sum(A) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<p>综上，可以推出 <code>sum(A) = (target + sum(nums)) / 2</code>，也就是把原问题转化成：**<code>nums</code> 中存在几个子集 <code>A</code>，使得 <code>A</code> 中元素的和为 <code>(target + sum(nums)) / 2</code>**？</p>
<p>类似的子集划分问题我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485103&idx=1&sn=8a9752e18ed528e5c18d973dcd134260&chksm=9bd7f8a7aca071b14c736a30ef7b23b80914c676414b01f8269808ef28da48eb13e90a432fff&scene=21#wechat_redirect">经典背包问题：子集划分</a> 讲过，现在实现这么一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以这样调用这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) sum += n;</span><br><span class="line">    <span class="comment">// 这两种情况，不可能存在合法的子集划分</span></span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || (sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets(nums, (sum + target) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，变成背包问题的标准形式：</p>
<p><strong>有一个背包，容量为 <code>sum</code>，现在给你 <code>N</code> 个物品，第 <code>i</code> 个物品的重量为 <code>nums[i - 1]</code>（注意 <code>1 &lt;= i &lt;= N</code>），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包</strong>？</p>
<p>现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：</p>
<p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p>
<p>对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
<p><strong>第二步要明确 <code>dp</code> 数组的定义</strong>。</p>
<p>按照背包问题的套路，可以给出如下定义：</p>
<p><code>dp[i][j] = x</code> 表示，若只在前 <code>i</code> 个物品中选择，若当前背包的容量为 <code>j</code>，则最多有 <code>x</code> 种方法可以恰好装满背包。</p>
<p>翻译成我们探讨的子集问题就是，若只在 <code>nums</code> 的前 <code>i</code> 个元素中选择，若目标和为 <code>j</code>，则最多有 <code>x</code> 种方法划分子集。</p>
<p>根据这个定义，显然 <code>dp[0][..] = 0</code>，因为没有物品的话，根本没办法装背包；<code>dp[..][0] = 1</code>，因为如果背包的最大载重为 0，「什么都不装」就是唯一的一种装法。</p>
<p>我们所求的答案就是 <code>dp[N][sum]</code>，即使用所有 <code>N</code> 个物品，有几种方法可以装满容量为 <code>sum</code> 的背包。</p>
<p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>回想刚才的 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p>
<p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么恰好装满背包的方法数就取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p>
<p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么只要看前 <code>i - 1</code> 个物品有几种方法可以装满 <code>j - nums[i-1]</code> 的重量就行了，所以取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p>
<p>PS：注意我们说的 <code>i</code> 是从 1 开始算的，而数组 <code>nums</code> 的索引时从 0 开始算的，所以 <code>nums[i-1]</code> 代表的是第 <code>i</code> 个物品的重量，<code>j - nums[i-1]</code> 就是背包装入物品 <code>i</code> 之后还剩下的容量。</p>
<p><strong>由于 <code>dp[i][j]</code> 为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br></pre></td></tr></table></figure>

<p>然后，根据状态转移方程写出动态规划算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 两种选择的结果之和</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 背包的空间不足，只能选择不装物品 i</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，发现这个 <code>dp[i][j]</code> 只和前一行 <code>dp[i-1][..]</code> 有关，那么肯定可以优化成一维 <code>dp</code>：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="built_in">int</span> subsets(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> <span class="keyword">sum</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.length;</span><br><span class="line">    <span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="keyword">sum</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// j 要从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="keyword">sum</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="keyword">sum</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对照二维 <code>dp</code>，只要把 <code>dp</code> 数组的第一个维度全都去掉就行了，唯一的区别就是这里的 <code>j</code> 要从后往前遍历，原因如下</strong>：</p>
<p>因为二维压缩到一维的根本原理是，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还没被新结果覆盖的时候，相当于二维 <code>dp</code> 中的 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-nums[i-1]]</code>。</p>
<p>那么，我们就要做到：<strong>在计算新的 <code>dp[j]</code> 的时候，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还是上一轮外层 for 循环的结果</strong>。</p>
<p>如果你从前往后遍历一维 <code>dp</code> 数组，<code>dp[j]</code> 显然是没问题的，但是 <code>dp[j-nums[i-1]]</code> 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。</p>
<p>现在，这道题算是彻底解决了。</p>
<p>总结一下，回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出状态压缩，还得反向遍历。</p>
<p>现在搞得我都忘了自己是来干嘛的了。嗯，这也许就是动态规划的魅力吧。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/6e5dcbe0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6e5dcbe0/" class="post-title-link" itemprop="url">回溯算法团灭排列组合子集问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-10 11:51:52" itemprop="dateModified" datetime="2022-03-10T11:51:52+08:00">2022-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/6e5dcbe0/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/6e5dcbe0/" data-xid="/posts/6e5dcbe0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="回溯算法团灭排列-x2F-组合-x2F-子集问题"><a href="#回溯算法团灭排列-x2F-组合-x2F-子集问题" class="headerlink" title="回溯算法团灭排列&#x2F;组合&#x2F;子集问题"></a>回溯算法团灭排列&#x2F;组合&#x2F;子集问题</h1><h2 id="回溯算法团灭排列-x2F-组合-x2F-子集问题-1"><a href="#回溯算法团灭排列-x2F-组合-x2F-子集问题-1" class="headerlink" title="回溯算法团灭排列&#x2F;组合&#x2F;子集问题"></a>回溯算法团灭排列&#x2F;组合&#x2F;子集问题</h2><h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。这几个问题都可以用回溯算法解决。</p>
<h3 id="一、子集"><a href="#一、子集" class="headerlink" title="一、子集"></a>一、子集</h3><p>问题很简单，输入一个<strong>不包含重复数字</strong>的数组，要求算法输出这些数字的所有子集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 <code>nums = [1,2,3]</code>，你的算法应输出 8 个子集，包含空集和本身，顺序可以不同：</p>
<p>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]</p>
<p><strong>第一个解法是利用数学归纳的思想</strong>：假设我现在知道了规模更小的子问题的结果，如何推导出当前问题的结果呢？</p>
<p>具体来说就是，现在让你求 <code>[1,2,3]</code> 的子集，如果你知道了 <code>[1,2]</code> 的子集，是否可以推导出 <code>[1,2,3]</code> 的子集呢？先把  <code>[1,2]</code> 的子集写出来瞅瞅：</p>
<p>[ [],[1],[2],[1,2] ]</p>
<p>你会发现这样一个规律：</p>
<p>subset(<code>[1,2,3]</code>) - subset(<code>[1,2]</code>)</p>
<p>&#x3D; [3],[1,3],[2,3],[1,2,3]</p>
<p>而这个结果，就是把 sebset(<code>[1,2]</code>) 的结果中每个集合再添加上 3。</p>
<p>换句话说，如果 <code>A = subset([1,2])</code> ，那么：</p>
<p>subset(<code>[1,2,3]</code>)</p>
<p>&#x3D; A + [A[i].add(3) for i &#x3D; 1..len(A)]</p>
<p>这就是一个典型的递归结构嘛，<code>[1,2,3]</code> 的子集可以由 <code>[1,2]</code> 追加得出，<code>[1,2]</code> 的子集可以由 <code>[1]</code> 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。</p>
<p>翻译成代码就很容易理解了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// base case，返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.back();</span><br><span class="line">    nums.pop_back();</span><br><span class="line">    <span class="comment">// 先递归算出前面元素的所有子集</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = subsets(nums);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.push_back(res[i]);</span><br><span class="line">        res.back().push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个问题的时间复杂度计算比较容易坑人</strong>。我们之前说的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是 N，但我们发现每次递归 for 循环的迭代次数取决于 <code>res</code> 的长度，并不是固定的。</p>
<p>根据刚才的思路，<code>res</code> 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。或者不用这么麻烦，你想想一个大小为 N 的集合的子集总共有几个？2^N 个对吧，所以说至少要对 <code>res</code> 添加 2^N 次元素。</p>
<p>那么算法的时间复杂度就是 O(2^N) 吗？还是不对，2^N 个子集是 <code>push_back</code> 添加进 <code>res</code> 的，所以要考虑 <code>push_back</code> 这个操作的效率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    res.push_back(res[i]); <span class="comment">// O(N)</span></span><br><span class="line">    res.back().push_back(n); <span class="comment">// O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>res[i]</code> 也是一个数组呀，<code>push_back</code> 是把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。</p>
<p>综上，总的时间复杂度就是 O(N*2^N)，还是比较耗时的。</p>
<p>空间复杂度的话，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p>
<p><strong>第二种通用方法就是回溯算法</strong>。旧文「回溯算法详解」写过回溯算法的模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>只要改造回溯算法的模板就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> &#123;</span><br><span class="line">    res.push_back(track);</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，对 <code>res</code> 的更新是一个<strong>前序遍历</strong>，也就是说，<code>res</code> 就是树上的所有节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/sULT7a_20210507182400.png" alt="图片"></p>
<h3 id="二、组合"><a href="#二、组合" class="headerlink" title="二、组合"></a>二、组合</h3><p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 <code>n = 4, k = 2</code>，输出如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，<code>[1,2]</code> 和 <code>[2,1]</code> 也算重复）：</p>
<p>[<br> [1,2],<br> [1,3],<br> [1,4],<br> [2,3],<br> [2,4],<br> [3,4]<br>]</p>
<p>这就是典型的回溯算法，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度，直接套我们以前讲过的回溯算法模板框架就行了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/y3DT6L_20210507182421.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    backtrack(n, k, <span class="number">1</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达树的底部</span></span><br><span class="line">    <span class="keyword">if</span> (k == track.size()) &#123;</span><br><span class="line">        res.push_back(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(i);</span><br><span class="line">        backtrack(n, k, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>backtrack</code> 函数和计算子集的差不多，<strong>区别在于，更新 <code>res</code> 的地方是树的底端</strong>。</p>
<h3 id="三、排列"><a href="#三、排列" class="headerlink" title="三、排列"></a>三、排列</h3><p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：</p>
<p>[<br> [1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1]<br>]</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法详解</a> 中就是拿这个问题来解释回溯模板的。这里又列出这个问题，是将「排列」和「组合」这两个回溯算法的代码拿出来对比。</p>
<p>首先画出回溯树来看一看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/uRIb5X_20210507182434.png" alt="图片"></p>
<p>我们当时使用 Java 代码写的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯模板依然没有变，但是根据排列问题和组合问题画出的树来看，排列问题的树比较对称，而组合问题的树越靠右节点越少。</p>
<p>在代码中的体现就是，排列问题每次通过 <code>contains</code> 方法来排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。</p>
<p><strong>以上，就是排列组合和子集三个问题的解法，总结一下</strong>：</p>
<p>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 <code>start</code> 参数排除已选择的数字。</p>
<p>组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 <code>start</code> 排除已经选择过的数字。</p>
<p>排列问题是回溯思想，也可以表示成树结构套用算法模板，不同之处在于使用 <code>contains</code> 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。</p>
<p>对于这三个问题，关键区别在于回溯树的结构，不妨多观察递归树的结构，很自然就可以理解代码的含义了。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swimminghao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">990k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:01</span>
  </span>
</div>

<span id="sitetime"></span>
<script language=javascript>
    function siteTime(){
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2022,02,28,00,00,00); //你的建站时间
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById("sitetime").innerHTML=" 本站已安全运行 "+diffYears+" Year "+diffDays+" Days "+diffHours+" Hours "+diffMinutes+" m "+diffSeconds+" s";
    }
    siteTime();
</script>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        访问人数：<span id="busuanzi_value_site_uv"></span>
      </span>人
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
       访问总量：<span id="busuanzi_value_site_pv"></span>
      </span>次
    </span>


<!--
  本文总阅读量：<span id="busuanzi_value_page_pv"></span>次
-->

</div>


<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

--><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-nu.vercel.app","placeholder":"请文明评论呀","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/page/12/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "middleCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
</body>
</html>
