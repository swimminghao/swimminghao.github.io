<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-loading-bar.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="swimminghao的学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swimminghao&#39;s blog">
<meta property="og:url" content="http://example.com/page/28/index.html">
<meta property="og:site_name" content="swimminghao&#39;s blog">
<meta property="og:description" content="swimminghao的学习博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swimminghao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/28/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/28/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>swimminghao's blog</title>
  




<link rel="dns-prefetch" href="waline-server-nu.vercel.app"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">swimminghao's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">56</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">280</span></a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="swimminghao"
      src="/images/lion.png">
  <p class="site-author-name" itemprop="name">swimminghao</p>
  <div class="site-description" itemprop="description">swimminghao的学习博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">280</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/swimminghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swimminghao0@gmail.com" title="E-Mail → mailto:swimminghao0@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/swimminghao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;swimminghao" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- recent posts -->
    <div class="links-of-blogroll motion-element links-of-blogroll-block">
        <div class="links-of-blogroll-title recent-posts-title">
	    <i class="fa fa-history " aria-hidden="true"></i>
            近期文章
	</div>
	<ul class="links-of-blogroll-list recent-posts-list">
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/7ac8a987/" title="HIFI日记：HQPlayer embedded （HQPlayer OS）嵌入版使用教程" target="">
		    HIFI日记：HQPlayer embedded （HQPlayer OS）嵌入版使用教程
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/eb18152/" title="OpenCore添加ubuntu引导，引导双系统" target="">
		    OpenCore添加ubuntu引导，引导双系统
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/f3a01220/" title="hqplayer和roon二合一" target="">
		    hqplayer和roon二合一
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/a0ae5a65/" title="CentOS7 源码安装redis4" target="">
		    CentOS7 源码安装redis4
		    </a>
		</li>
	        <li class="my-links-of-blogroll-item">
		    <a href="/posts/701fa192/" title="mac10.15 下 git2.33 安装 git-gui" target="">
		    mac10.15 下 git2.33 安装 git-gui
		    </a>
		</li>
	</ul>
    </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/7f30ba70/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7f30ba70/" class="post-title-link" itemprop="url">子序列解题模板：最长回文子序列</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/7f30ba70/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/7f30ba70/" data-xid="/posts/7f30ba70/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="子序列解题模板：最长回文子序列"><a href="#子序列解题模板：最长回文子序列" class="headerlink" title="子序列解题模板：最长回文子序列"></a>子序列解题模板：最长回文子序列</h1><h2 id="预计阅读时间：6-分钟"><a href="#预计阅读时间：6-分钟" class="headerlink" title="预计阅读时间：6 分钟"></a>预计阅读时间：6 分钟</h2><p>子序列问题是常见的算法问题，而且并不好解决。</p>
<p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p>
<p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484486&idx=1&sn=0bdcb94c6390307ea32427757ec0072c&chksm=9bd7fa4eaca073583623cdb93b05dc9e1d0757b25697bb40b29b3e450124e929ff1a8eaac50f&scene=21#wechat_redirect">最长公共子序列</a>，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p>
<p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。</p>
<p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p>
<p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p>
<h2 id="一、两种思路"><a href="#一、两种思路" class="headerlink" title="一、两种思路"></a>一、两种思路</h2><p><strong>1、****第一种思路模板是一个一维的 dp 数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个我们写过的例子 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484498&idx=1&sn=df58ef249c457dd50ea632f7c2e6e761&chksm=9bd7fa5aaca0734c29bcf7979146359f63f521e3060c2acbf57a4992c887aeebe2a9e4bd8a89&scene=21#wechat_redirect">最长递增子序列</a>，在这个思路中 dp 数组的定义是：</p>
<p>*<em>在子数组<code>array[0..i]</code>中，以*</em><code>array[i]</code>**结尾的目标子序列（最长递增子序列）的长度是<code>dp[i]</code>**。</p>
<p>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。</p>
<p><strong>2、****第二种思路模板是一个二维的 dp 数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">dp</span>[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种思路运用相对更多一些，尤其是涉及两个字符串&#x2F;数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。</p>
<p><strong>2.1</strong> <strong>涉及两个字符串&#x2F;数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p>
<p>**在子数组<code>arr1[0..i]</code>和子数组<code>arr2[0..j]</code>中，我们要求的子序列（最长公共子序列）长度为<code>dp[i][j]</code>**。</p>
<p><strong>2.2</strong> <strong>只涉及一个字符串&#x2F;数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：</p>
<p>**在子数组<code>array[i..j]</code>中，我们要求的子序列（最长回文子序列）的长度为<code>dp[i][j]</code>**。</p>
<p>第一种情况可以参考这两篇旧文：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect">详解编辑距离</a> 和 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484486&idx=1&sn=0bdcb94c6390307ea32427757ec0072c&chksm=9bd7fa4eaca073583623cdb93b05dc9e1d0757b25697bb40b29b3e450124e929ff1a8eaac50f&scene=21#wechat_redirect">最长公共子序列</a>。</p>
<p>下面就借最长回文子序列这个问题，详解一下第二种情况下如何使用动态规划。</p>
<h3 id="二、最长回文子序列"><a href="#二、最长回文子序列" class="headerlink" title="二、最长回文子序列"></a>二、最长回文子序列</h3><p>之前解决了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484471&idx=1&sn=7c26d04a1f035770920d31377a1ebd42&chksm=9bd7fa3faca07329189e9e8b51e1a665166946b66b8e8978299ba96d5f2c0d3eafa7db08b681&scene=21#wechat_redirect">最长回文子串</a> 的问题，这次提升难度，求最长回文子序列的长度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/LAjRcC_20210507181302.png" alt="图片"></p>
<p>我们说这个问题对 dp 数组的定义是：**在子串<code>s[i..j]</code>中，最长回文子序列的长度为<code>dp[i][j]</code>**。一定要记住这个定义才能理解算法。</p>
<p>为啥这个问题要这样定义二维的 dp 数组呢？我们前文多次提到，<strong>找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分</strong>，这样定义容易归纳，容易发现状态转移关系。</p>
<p>具体来说，如果我们想求<code>dp[i][j]</code>，假设你知道了子问题<code>dp[i+1][j-1]</code>的结果（<code>s[i+1..j-1]</code>中最长回文子序列的长度），你是否能想办法算出<code>dp[i][j]</code>的值（<code>s[i..j]</code>中，最长回文子序列的长度）呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2kxUZI_20210507181356.png" alt="图片"></p>
<p>可以！<strong>这取决于<code>s[i]</code>和<code>s[j]</code>的字符</strong>：</p>
<p><strong>如果它俩相等</strong>，那么它俩加上<code>s[i+1..j-1]</code>中的最长回文子序列就是<code>s[i..j]</code>的最长回文子序列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/aUzko6_20210507181418.png" alt="图片"></p>
<p><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在<code>s[i..j]</code>的最长回文子序列中，那么把它俩<strong>分别</strong>加入<code>s[i+1..j-1]</code>中，看看哪个子串产生的回文子序列更长即可：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/syOQNF_20210507181435.png" alt="图片"></p>
<p>以上两种情况写成代码就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">    <span class="comment">// 它俩一定在最长回文子序列中</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span></span><br><span class="line">    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>至此，状态转移方程就写出来了，根据 dp 数组的定义，我们要求的就是<code>dp[0][n - 1]</code>，也就是整个<code>s</code>的最长回文子序列的长度。</p>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是<code>dp[i][j] = 1,(i == j)</code>。</p>
<p>因为<code>i</code>肯定小于等于<code>j</code>，所以对于那些<code>i &gt; j</code>的位置，根本不存在什么子序列，应该初始化为 0。</p>
<p>另外，看看刚才写的状态转移方程，想求<code>dp[i][j]</code>需要知道<code>dp[i+1][j-1]</code>，<code>dp[i+1][j]</code>，<code>dp[i][j-1]</code>这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/K0G91r_20210507181558.png" alt="图片"></p>
<p><strong>为了保证每次计算<code>dp[i][j]</code>，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ckwq8R_20210507181610.png" alt="图片"></p>
<p>我选择反着遍历，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(string s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.size();</span><br><span class="line">    <span class="comment">// dp 数组全部初始化为 0</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">dp</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)</span>);</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，最长回文子序列的问题就解决了。</p>
<p>主要还是正确定义 dp 数组的含义，遇到子序列问题，首先想到两种动态规划思路，然后根据实际问题看看哪种思路容易找到状态转移关系。</p>
<p>另外，找到状态转移和 base case 之后，<strong>一定要观察 DP table</strong>，看看怎么遍历才能保证通过已计算出来的结果解决新的问题</p>
<p>有了以上思路方向，子序列问题也不过如此嘛。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/dbdb8baa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/dbdb8baa/" class="post-title-link" itemprop="url">完全二叉树的节点数，你真的会算吗？</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/dbdb8baa/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/dbdb8baa/" data-xid="/posts/dbdb8baa/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="完全二叉树的节点数，你真的会算吗？"><a href="#完全二叉树的节点数，你真的会算吗？" class="headerlink" title="完全二叉树的节点数，你真的会算吗？"></a>完全二叉树的节点数，你真的会算吗？</h1><p>如果让你数一下一棵普通二叉树有多少个节点，这很简单，只要在二叉树的遍历框架上加一点代码就行了。</p>
<p>但是，如果给你一棵<strong>完全二叉树</strong>，让你计算它的节点个数，你会不会？算法的时间复杂度是多少？</p>
<p>这个算法的时间复杂度应该是 O(logN*logN)，如果你心中的算法没有达到这么高效，那么本文就是给你写的。</p>
<p>首先要明确一下两个关于二叉树的名词「完全二叉树」和「满二叉树」。</p>
<p>我们说的<strong>完全二叉树</strong>如下图，每一层都是<strong>紧凑靠左</strong>排列的：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdEP9mVB4tqBYfNT69s5yTbm0UlN0d2fmKXn6RCv25WiapjvnsxLZ7mkobu5v1NPQY3cVkt8iawyMYvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们说的<strong>满二叉树</strong>如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/UuUXKT_20210810164344.png" alt="图片"></p>
<p>说句题外话，关于这两个定义，中文语境和英文语境似乎有点区别，我们说的完全二叉树对应英文 Complete Binary Tree，没有问题。但是我们说的满二叉树对应英文 Perfect Binary Tree，而英文中的 Full Binary Tree 是指一棵二叉树的所有节点要么没有孩子节点，要么有两个孩子节点。如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/GzzIX6_20210810164402.png" alt="图片"></p>
<p>以上定义出自 wikipedia，这里就是顺便一提，其实名词叫什么都无所谓，重要的是算法操作。</p>
<p><strong>本文就按我们中文的语境，记住「满二叉树」和「完全二叉树」的区别，等会会用到</strong>。</p>
<h3 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="一、思路分析"></a>一、思路分析</h3><p>现在回归正题，如何求一棵完全二叉树的节点个数呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵完全二叉树，返回节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span>;</span><br></pre></td></tr></table></figure>

<p>如果是一个<strong>普通</strong>二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果是一棵<strong>满</strong>二叉树，节点总数就和树的高度呈指数关系，时间复杂度 O(logN)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点总数就是 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完全</strong>二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root, r = root;</span><br><span class="line">    <span class="comment">// 记录左、右子树的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合刚才针对满二叉树和普通二叉树的算法，上面这段代码应该不难理解，就是一个结合版，但是<strong>其中降低时间复杂度的技巧是非常微妙的</strong>。</p>
<h3 id="二、复杂度分析"><a href="#二、复杂度分析" class="headerlink" title="二、复杂度分析"></a>二、复杂度分析</h3><p>开头说了，这个算法的时间复杂度是 O(logN*logN)，这是怎么算出来的呢？</p>
<p>直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return <span class="number">1</span> + count<span class="constructor">Nodes(<span class="params">root</span>.<span class="params">left</span>)</span> + count<span class="constructor">Nodes(<span class="params">root</span>.<span class="params">right</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发<code>hl == hr</code>而立即返回，不会递归下去</strong>。</p>
<p>为什么呢？原因如下：</p>
<p><strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Z2YcMA_20210810164429.png" alt="图片"></p>
<p>看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发<code>hl == hr</code>，只消耗 O(logN) 的复杂度而不会继续递归。</p>
<p>综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。</p>
<p>所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/196710be/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/196710be/" class="post-title-link" itemprop="url">快慢指针的一些证明</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/196710be/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/196710be/" data-xid="/posts/196710be/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="快慢指针在链表中的一些证明"><a href="#快慢指针在链表中的一些证明" class="headerlink" title="快慢指针在链表中的一些证明"></a>快慢指针在链表中的一些证明</h1><p>目录</p>
<h3 id="一、一定会相遇的证明"><a href="#一、一定会相遇的证明" class="headerlink" title="一、一定会相遇的证明"></a>一、一定会相遇的证明</h3><h3 id="二、环长度"><a href="#二、环长度" class="headerlink" title="二、环长度"></a>二、环长度</h3><h3 id="三、连接点"><a href="#三、连接点" class="headerlink" title="三、连接点"></a>三、连接点</h3><h3 id="四、带环链表总长度"><a href="#四、带环链表总长度" class="headerlink" title="四、带环链表总长度"></a>四、带环链表总长度</h3><h3 id="五、例题"><a href="#五、例题" class="headerlink" title="五、例题"></a>五、例题</h3><h2 id="一、一定会相遇的证明-1"><a href="#一、一定会相遇的证明-1" class="headerlink" title="一、一定会相遇的证明"></a>一、一定会相遇的证明</h2><h4 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h4><p>1、如果链表没有环，那么快指针比慢指针先到达尾部（null)。</p>
<p>2、如果链表有环的话，因为快指针走的比慢指针快，所以在环中相遇的过程可以看作是快指针从环后边追赶慢指针的过程。</p>
<p>用递归法证明，快慢指针一定会相遇：</p>
<p>（1)快指针与慢指针之间差一步。此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇。<br>（2)快指针与慢指针之间差两步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，转化为第一种情况。<br>（3)快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)即N-1步。重复这个过程，直到快指针和慢指针相遇。</p>
<p>因此，此题得证。所以快指针必然与慢指针相遇。</p>
<h4 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h4><p>如果链表存在环，快慢指针就一定能相遇。设快指针每次移动q步，慢指针每次移动s步，环的长度为n，环之前的链表长度为m，如下图所示</p>
<p><img src="https://pic2.zhimg.com/50/da087f6034204e3713f69f94542c99e1_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/da087f6034204e3713f69f94542c99e1_720w.jpg?source=1940ef5c" alt="img"></p>
<p>假设慢指针第一次到达环时移动了x次，位置为a，此时快指针也移动了x次，位置为b，</p>
<p>则此时快慢指针相遇的等式为<img src="https://www.zhihu.com/equation?tex=(b+q*y)mod(n)+=+(a+s*y)mod(n)" alt="[公式]">，</p>
<p>也即<img src="https://www.zhihu.com/equation?tex=((b-a)++(q-s)*y)mod(n)+=+0+" alt="[公式]">（1）成立，</p>
<p>又：</p>
<p><img src="https://www.zhihu.com/equation?tex=b=(q*x+-+m)mod(n)" alt="[公式]">（2），</p>
<p><img src="https://www.zhihu.com/equation?tex=a=(s*x-m)mod(n)" alt="[公式]">（3），</p>
<p>由（1）（2）（3）可得出<img src="https://www.zhihu.com/equation?tex=(q-s)(x+y)mod(n)=0" alt="[公式]">成立，显而易见（q(x+y)-s(x+y) &#x3D;&#x3D; n *k(k&#x3D;1,2,3,…)），x+y是n的整数倍的时候，该式一定成立。</p>
<p>————————————————找环的起点分割线——————————————<br>假设快指针每次移动2步，慢指针每次移动1步，则根据上述证明可知，<img src="https://www.zhihu.com/equation?tex=x=m" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=a=0" alt="[公式]">，相遇的位置在y处；求环的起点，就是求m的大小，此时令一指针p1从头结点出发，每次移动1步，令一指针q1从相遇处出发，每次移动1步，则p1与q1再次相遇的地方就是环的起点处，因为此时两个指针均移动m步，由<img src="https://www.zhihu.com/equation?tex=(y+m)mod(n)=0" alt="[公式]">可知，相遇</p>
<p><strong>推导：慢指针进入环后，快指针最多多绕一个圈。</strong></p>
<p><strong>快指针F先进环，慢指针S后进。</strong></p>
<p><strong>假设慢指针进环那一刻快指针差m步能追上（0&lt;&#x3D; m &lt; Length环），根据上边结论，两个指针走m次就会相遇了。</strong></p>
<p><strong>因为m &lt; Length环，所以快指针在慢指针进环那一刻最多比慢指针多绕一个圈</strong>。</p>
<h2 id="二、环长度-1"><a href="#二、环长度-1" class="headerlink" title="二、环长度"></a>二、环长度</h2><p>快指针和慢指针第一次相遇时的节点pq（碰撞点），快指针和慢指针从该点开始继续往前走，再次碰撞时所用的操作数就是环的长度Length环。</p>
<p>证明:由上边的推导可得，这里的m为Lengh环。</p>
<h2 id="三、连接点-1"><a href="#三、连接点-1" class="headerlink" title="三、连接点"></a>三、连接点</h2><p><img src="https://images2015.cnblogs.com/blog/833392/201704/833392-20170409211030332-1528137014.png" alt="img"></p>
<p>假设慢指针进入环中时，即连接点p，快指针（q）需要m步才能追上慢指针。</p>
<p>p和q第一次相遇时，碰撞点在pq处。此时，p走到pq时用了m步。</p>
<p> 假设head到p的距离为a，环长度为Length环，慢指针走了s步，则快指针走了2s步。</p>
<p>从上图可知:</p>
<p>s &#x3D; a + m</p>
<p>2s &#x3D; a + m + n * Length环（n为快指针绕环的圈数）</p>
<p>可得</p>
<p>a &#x3D; n * Length环 - m</p>
<p>也就是：若在头结点和相遇结点分别设一指针，同步(单步)前进，则最后一定相遇在环入口结点p。</p>
<p>可根据这个结论来找到入口节点。</p>
<h2 id="四、带环链表总长度-1"><a href="#四、带环链表总长度-1" class="headerlink" title="四、带环链表总长度"></a>四、带环链表总长度</h2><p>找到连接点p后，求head到p的长度，再加上环的长度，即为链表的总长。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/50cab45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/50cab45/" class="post-title-link" itemprop="url">滑动窗口</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/50cab45/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/50cab45/" data-xid="/posts/50cab45/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><h2 id="滑动窗口算法-1"><a href="#滑动窗口算法-1" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p><strong>滑动窗口框架套路详解</strong></p>
<p>在滑动窗口算法框架中，我编写一首小诗来歌颂滑动窗口算法的伟大：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdEsLiaY9d9CcVdNcPTAdO5MRwZhsxtTc6BaDMpHQtibCX5kY406sxFeaClrlft3j6XiaJ48jq0Gnj2dQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>关于双指针的快慢指针和左右指针的用法，可以参见前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484505&idx=1&sn=0e9517f7c4021df0e6146c6b2b0c4aba&chksm=9bd7fa51aca07347009c591c403b3228f41617806429e738165bd58d60220bf8f15f92ff8a2e&scene=21#wechat_redirect">双指针技巧汇总</a>，<strong>本文就解决一类最难掌握的双指针技巧：滑动窗口技巧，并总结出一套框架，可以保你闭着眼直接套出答案。</strong></p>
<p>说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法技巧的时间复杂度是 O(N)，比一般的字符串暴力算法要高效得多。</p>
<p><strong><em>其实困扰大家的</em>，不是算法的思路，而是各种细节问题</strong>。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<p><strong>所以今天我就写一套滑动窗口算法的代码框架，我连在哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出边界问题</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span>(<span class="params">string s, string t</span>) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; need, <span class="variable language_">window</span>;</span><br><span class="line">    <span class="keyword">for</span> (char c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    int left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    int valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="title function_">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        char c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">window</span> needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            char d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中两处<code>...</code>表示的更新窗口数据的地方，到时候你直接往里面填就行了</strong>。</p>
<p>而且，这两个<code>...</code>处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。</p>
<p><strong>说句题外话，其实有很多人喜欢执着于表象，不喜欢探求问题的本质。</strong>比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。</p>
<p>我也是服了，算法看的是时间复杂度，你能确保自己的时间复杂度最优就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……</p>
<p>重点在于算法思想，你把框架思维了然于心套出解法，然后随你再魔改代码好吧，你高兴就好。</p>
<p>言归正传，<strong>下面就直接上*<em>四道*</em> LeetCode 原题来套这个框架</strong>，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。</p>
<p>本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：</p>
<p><code>unordered_map</code>就是哈希表（字典），它的一个方法<code>count(key)</code>相当于 Java 的<code>containsKey(key)</code>可以判断键 key 是否存在。</p>
<p>可以使用方括号访问键对应的值<code>map[key]</code>。需要注意的是，如果该<code>key</code>不存在，C++ 会自动创建这个 key，并把<code>map[key]</code>赋值为 0。</p>
<p>所以代码中多次出现的<code>map[key]++</code>相当于 Java 的<code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p>
<h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p>LeetCode 76 题，Minimum Window Substring，难度 <strong>Hard</strong>，我带大家看看它到底有多 <strong>Hard</strong>：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowk6hiaxmGN6ibHiaTqxHMqYvCRA4lWuRCQicPSfZY78De1GmwkXviar4psjw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>就是说要在<code>S</code>(source) 中找到包含<code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.size(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p><em><strong>1、</strong></em>我们在字符串<code>S</code>中使用双指针中的左右指针技巧，初始化<code>left = right = 0</code>，<strong>把索引左闭右开区间<code>[left, right)</code>称为一个「窗口」</strong>。</p>
<p><em><strong>2、</strong></em>我们先不断地增加<code>right</code>指针扩大窗口<code>[left, right)</code>，直到窗口中的字符串符合要求（包含了<code>T</code>中的所有字符）。</p>
<p><em><strong>3、</strong></em>此时，我们停止增加<code>right</code>，转而不断增加<code>left</code>指针缩小窗口<code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含<code>T</code>中的所有字符了）。同时，每次增加<code>left</code>，我们都要更新一轮结果。</p>
<p><em><strong>4、</strong></em>重复第 2 和第 3 步，直到<code>right</code>到达字符串<code>S</code>的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code>和<code>window</code>相当于计数器，分别记录<code>T</code>中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEow6FwvAvsZKyCTCtrmLcvKDxhYAJEqI36cAZxfoIWLFibEhmz9IfHf24Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>增加<code>right</code>，直到窗口<code>[left, right)</code>包含了<code>T</code>中所有字符：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowCyAS47jbjAGEfqUVRzkKDWbT6Y8JiarUicPMVR2yI72X3X6hjBGj4bGw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>现在开始增加<code>left</code>，缩小窗口<code>[left, right)</code>。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowoE6BjdgVFKZwEb1q6VibCzIsNuoYmHuNicVdlDibQrQD6lRJbibjkBxO4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code>不再继续移动。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowZQrqU81dPoEicq1J93aicY0A70IdicorFC5kfhJKa66CibKQTJxY4A60jA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>之后重复上述过程，先移动<code>right</code>，再移动<code>left</code>…… 直到<code>right</code>指针到达字符串<code>S</code>的末端，算法结束。</p>
<p>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。<strong>现在我们来看看这个滑动窗口代码框架怎么用</strong>：</p>
<p>首先，初始化<code>window</code>和<code>need</code>两个哈希表，记录窗口中的字符和需要凑齐的字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br></pre></td></tr></table></figure>

<p>然后，使用<code>left</code>和<code>right</code>变量初始化窗口的两端，不要忘了，区间<code>[left, right)</code>是左闭右开的，所以初始情况下窗口没有包含任何元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中<code>valid</code>变量表示窗口中满足<code>need</code>条件的字符个数</strong>，如果<code>valid</code>和<code>need.size</code>的大小相同，则说明窗口已满足条件，已经完全覆盖了串<code>T</code>。</p>
<p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p>
<p><strong>1、</strong>当移动<code>right</code>扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p><strong>2、</strong>什么条件下，窗口应该暂停扩大，开始移动<code>left</code>缩小窗口？</p>
<p><strong>3、</strong>当移动<code>left</code>缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p><strong>4、</strong>我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加<code>window</code>计数器；如果一个字符将移出窗口的时候，应该减少<code>window</code>计数器；当<code>valid</code>满足<code>need</code>时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<p>下面是完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">string <span class="title function_">minWindow</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">len</span> <span class="operator">=</span>= INT_MAX ?</span><br><span class="line">        <span class="string">&quot;&quot;</span> : s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当我们发现某个字符在<code>window</code>的数量满足了<code>need</code>的需要，就要更新<code>valid</code>，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p>
<p>当<code>valid == need.size()</code>时，说明<code>T</code>中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。</p>
<p>移动<code>left</code>收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p>
<p>至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。<strong>以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿</strong>。</p>
<p>下面就直接利用这套框架秒杀几道题吧，你基本上一眼就能看出思路了。</p>
<h3 id="二、字符串排列"><a href="#二、字符串排列" class="headerlink" title="二、字符串排列"></a>二、字符串排列</h3><p>LeetCode 567 题，Permutation in String，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowmo3G9oN6XDmHeHjGic6tUauwoZia40pxjbicJXtN1RcjMMRDkfcGaVNVg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注意哦，输入的<code>s1</code>是可以包含重复字符的，所以这个题难度不小。</p>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个<code>S</code>和一个<code>T</code>，请问你<code>S</code>中是否存在一个子串，包含<code>T</code>中所有字符且不包含其他字符</strong>？</p>
<p>首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line">bool <span class="title function_">checkInclusion</span><span class="params">(string t, string s)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p><strong>1、</strong>本题移动<code>left</code>缩小窗口的时机是窗口大小大于<code>t.size()</code>时，因为排列嘛，显然长度应该是一样的。</p>
<p><strong>2、</strong>当发现<code>valid == need.size()</code>时，就说明窗口中就是一个合法的排列，所以立即返回<code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="三、找所有字母异位词"><a href="#三、找所有字母异位词" class="headerlink" title="三、找所有字母异位词"></a>三、找所有字母异位词</h3><p>这是 LeetCode 第 438 题，Find All Anagrams in a String，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowe98rknTABmhPaxgzV5Vv9gHdEpNUDia6CO0gxuPpNR5My6ogK8wuibTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？<strong>相当于，输入一个串<code>S</code>，一个串<code>T</code>，找到<code>S</code>中所有<code>T</code>的排列，返回它们的起始索引</strong>。</p>
<p>直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="title function_">findAnagrams</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入<code>res</code>即可。</p>
<h3 id="四、最长无重复子串"><a href="#四、最长无重复子串" class="headerlink" title="四、最长无重复子串"></a>四、最长无重复子串</h3><p>这是 LeetCode 第 3 题，Longest Substring Without Repeating Characters，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowdOEyLaTVTiabiabMHr2Z7SzZZ08fxMDZt4uzzRcfvoI7sJzfdORvH0tA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(string s)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是变简单了，连<code>need</code>和<code>valid</code>都不需要，而且更新窗口内数据也只需要简单的更新计数器<code>window</code>即可。</p>
<p>当<code>window[c]</code>值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动<code>left</code>缩小窗口了嘛。</p>
<p>唯一需要注意的是，在哪里更新结果<code>res</code>呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p>
<p>这里和之前不一样，**要在收缩窗口完成后更新<code>res</code>**，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p>
<h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p><strong>建议背诵并默写这套框架，顺便背诵一下文章开头的那首诗。以后就再也不怕子串、子数组问题了。</strong></p>
<p>我觉得吧，能够看到这的都是高手，要么就是在成为高手的路上。有了框架，任他窗口怎么滑，东哥这波车开得依然稳如老狗。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/20eb9dff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/20eb9dff/" class="post-title-link" itemprop="url">益智游戏克星：BFS暴力搜索算法</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/20eb9dff/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/20eb9dff/" data-xid="/posts/20eb9dff/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="益智游戏克星：BFS暴力搜索算法"><a href="#益智游戏克星：BFS暴力搜索算法" class="headerlink" title="益智游戏克星：BFS暴力搜索算法"></a>益智游戏克星：BFS暴力搜索算法</h1><h2 id="益智游戏克星：BFS暴力搜索算法-1"><a href="#益智游戏克星：BFS暴力搜索算法-1" class="headerlink" title="益智游戏克星：BFS暴力搜索算法"></a>益智游戏克星：BFS暴力搜索算法</h2><p>滑动拼图游戏大家应该都玩过，下图是一个 4x4 的滑动拼图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5zWwfF_20210507183108.png" alt="图片"></p>
<p>拼图中有一个格子是空的，可以利用这个空着的格子移动其他数字。你需要通过移动这些数字，得到某个特定排列顺序，这样就算赢了。</p>
<p>我小时候还玩过一款叫做「华容道」的益智游戏，也和滑动拼图比较类似：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ueMqO0_20210507183151.png" alt="图片"></p>
<p>那么这种游戏怎么玩呢？我记得是有一些套路的，类似于魔方还原公式。但是我们今天不来研究让人头秃的技巧，<strong>这些益智游戏通通可以用暴力搜索算法解决，所以今天我们就学以致用，用 BFS 算法框架来秒杀这些游戏</strong>。</p>
<h3 id="一、题目解析"><a href="#一、题目解析" class="headerlink" title="一、题目解析"></a>一、题目解析</h3><p>LeetCode 第 773 题就是滑动拼图问题，题目的意思如下：</p>
<p>给你一个 2x3 的滑动拼图，用一个 2x3 的数组<code>board</code>表示。拼图中有数字 0~5 六个数，其中数字 0 就表示那个空着的格子，你可以移动其中的数字，当<code>board</code>变为<code>[[1,2,3],[4,5,0]]</code>时，赢得游戏。</p>
<p>请你写一个算法，计算赢得游戏需要的最少移动次数，如果不能赢得游戏，返回 -1。</p>
<p>比如说输入的二维数组<code>board = [[4,1,2],[5,0,3]]</code>，算法应该返回 5：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/DnxfJo_20210507183245.png" alt="图片"></p>
<p>如果输入的是<code>board = [[1,2,3],[4,0,5]]</code>，则算法返回 -1，因为这种局面下无论如何都不能赢得游戏。</p>
<h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><p>对于这种计算最小步数的问题，我们就要敏感地想到 BFS 算法。</p>
<p>这个题目转化成 BFS 问题是有一些技巧的，我们面临如下问题：</p>
<p>1、一般的 BFS 算法，是从一个起点<code>start</code>开始，向终点<code>target</code>进行寻路，但是拼图问题不是在寻路，而是在不断交换数字，这应该怎么转化成 BFS 算法问题呢？</p>
<p>2、即便这个问题能够转化成 BFS 问题，如何处理起点<code>start</code>和终点<code>target</code>？它们都是数组哎，把数组放进队列，套 BFS 框架，想想就比较麻烦且低效。</p>
<p>首先回答第一个问题，<strong>BFS 算法并不只是一个寻路算法，而是一种暴力搜索算法</strong>，只要涉及暴力穷举的问题，BFS 就可以用，而且可以最快地找到答案。</p>
<p>你想想计算机怎么解决问题的？哪有那么多奇技淫巧，本质上就是把所有可行解暴力穷举出来，然后从中找到一个最优解罢了。</p>
<p>明白了这个道理，我们的问题就转化成了：<strong>如何穷举出<code>board</code>当前局面下可能衍生出的所有局面</strong>？这就简单了，看数字 0 的位置呗，和上下左右的数字进行交换就行了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KoSRd4_20210507183301.png" alt="图片"></p>
<p>这样其实就是一个 BFS 问题，每次先找到数字 0，然后和周围的数字进行交换，形成新的局面加入队列…… 当第一次到达<code>target</code>时，就得到了赢得游戏的最少步数。</p>
<p>对于第二个问题，我们这里的<code>board</code>仅仅是 2x3 的二维数组，所以可以压缩成一个一维字符串。<strong>其中比较有技巧性的点在于，二维数组有「上下左右」的概念，压缩成一维后，如何得到某一个索引上下左右的索引</strong>？</p>
<p>很简单，我们只要手动写出来这个映射就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**这个含义就是，在一维字符串中，索引<code>i</code>在二维数组中的的相邻索引为<code>neighbor[i]</code>**，：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CkiHlV_20210507183314.png" alt="图片"></p>
<p>至此，我们就把这个问题完全转化成标准的 BFS 问题了，借助前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485134&idx=1&sn=fd345f8a93dc4444bcc65c57bb46fc35&chksm=9bd7f8c6aca071d04c4d383f96f2b567ad44dc3e67d1c3926ec92d6a3bcc3273de138b36a0d9&scene=21#wechat_redirect">BFS 算法框架套路详解</a> 的代码框架，直接就可以套出解法代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">slidingPuzzle</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>, n = <span class="number">3</span>;</span><br><span class="line">    <span class="type">string</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">string</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;123450&quot;</span>;</span><br><span class="line">    <span class="comment">// 将 2x3 的数组转化成字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            start.push_back(board[i][j] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录一维字符串的相邻索引</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* BFS 算法框架开始 *******/</span></span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_set&lt;string&gt; visited;</span><br><span class="line">    q.push(start);</span><br><span class="line">    visited.insert(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">cur</span> <span class="operator">=</span> q.front(); q.pop();</span><br><span class="line">            <span class="comment">// 判断是否达到目标局面</span></span><br><span class="line">            <span class="keyword">if</span> (target == cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到数字 0 的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; cur[idx] != <span class="string">&#x27;0&#x27;</span>; idx++);</span><br><span class="line">            <span class="comment">// 将数字 0 和相邻的数字交换位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> adj : neighbor[idx]) &#123;</span><br><span class="line">                <span class="type">string</span> <span class="variable">new_board</span> <span class="operator">=</span> cur;</span><br><span class="line">                swap(new_board[adj], new_board[idx]);</span><br><span class="line">                <span class="comment">// 防止走回头路</span></span><br><span class="line">                <span class="keyword">if</span> (!visited.count(new_board)) &#123;</span><br><span class="line">                    q.push(new_board);</span><br><span class="line">                    visited.insert(new_board);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/******* BFS 算法框架结束 *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就解决了，其实框架完全没有变，套路都是一样的，我们只是花了比较多的时间将滑动拼图游戏转化成 BFS 算法。</p>
<p><strong>很多益智游戏都是这样，虽然看起来特别巧妙，但都架不住暴力穷举</strong>，常用的算法就是回溯算法或者 BFS 算法，感兴趣的话我们以后再聊。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/87975f1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/87975f1/" class="post-title-link" itemprop="url">经典动态规划：0-1 背包问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/87975f1/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/87975f1/" data-xid="/posts/87975f1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：0-1-背包问题"><a href="#经典动态规划：0-1-背包问题" class="headerlink" title="经典动态规划：0-1 背包问题"></a>经典动态规划：0-1 背包问题</h1><p>后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。</p>
<p>今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题，简单描述一下吧：</p>
<p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>举个简单的例子，输入如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span></span><br><span class="line">wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>算法返回 6，选择前两件物品装进背包，总重量 3 小于<code>W</code>，可以获得最大价值 6。</p>
<p>题目就是这么简单，一个典型的动态规划问题。<strong>这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。</strong>这也许就是 0-1 背包这个名词的来历。</p>
<p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划套路详解</a> 中的套路，直接走流程就行了。</p>
<h2 id="动规标准套路"><a href="#动规标准套路" class="headerlink" title="动规标准套路"></a>动规标准套路</h2><p>看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的，今天再来手把手演示一下：</p>
<p><strong>第一步****要明确两点，「状态」和「选择」</strong>。</p>
<p>先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p>
<p>再说选择，也很容易想到啊，对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p>
<p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>PS：此框架出自历史文章 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a>。</p>
<p><strong>第二步**<strong>要明确</strong></strong><code>dp</code>数组的定义**。</p>
<p><code>dp</code>数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用<code>dp</code>数组把状态表示出来。</p>
<p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维<code>dp</code>数组，一维表示可选择的物品，一维表示背包的容量。</p>
<p><strong><code>dp[i][w]</code>的定义如下：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</strong></p>
<p>比如说，如果 <code>dp[3][5]</code> &#x3D; 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p>
<p>PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种动规套路都被扒得清清楚楚了。</p>
<p><strong>根据这个定义，我们想求的最终答案就是</strong>**<code>dp[N][W]</code>。base case 就是<code>dp[0][..] = dp[..][0] = 0</code>**，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p>
<p>细化上面的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = max(</span><br><span class="line">            把物品 i 装进背包,</span><br><span class="line">            不把物品 i 装进背包</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<p><strong>第三步****，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>简单说就是，上面伪码中「把物品<code>i</code>装进背包」和「不把物品<code>i</code>装进背包」怎么用代码体现出来呢？</p>
<p><strong>这一步要结合对</strong><strong><code>dp</code>数组的定义和我们的算法逻辑来分析：</strong></p>
<p>先重申一下刚才我们的<code>dp</code>数组的定义：</p>
<p><code>dp[i][w]</code>表示：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>时，这种情况下可以装下的最大价值是<code>dp[i][w]</code>。</p>
<p><strong>如果你没有把这第</strong><strong><code>i</code>个物品装入背包</strong>，那么很显然，最大价值<code>dp[i][w]</code>应该等于<code>dp[i-1][w]</code>。你不装嘛，那就继承之前的结果。</p>
<p><strong>如果你把这第</strong><strong><code>i</code>个物品装入了背包</strong>，那么<code>dp[i][w]</code>应该等于<code>dp[i-1][w-wt[i-1]] + val[i-1]</code>。</p>
<p>首先，由于<code>i</code>是从 1 开始的，所以对<code>val</code>和<code>wt</code>的取值是<code>i-1</code>。</p>
<p>而<code>dp[i-1][w-wt[i-1]]</code>也很好理解：你如果想装第<code>i</code>个物品，你怎么计算这时候的最大价值？<strong>换句话说，在装第</strong><strong><code>i</code>个物品的前提下，背包能装的最大价值是多少？</strong></p>
<p>显然，你应该寻求剩余重量<code>w-wt[i-1]</code>限制下能装的最大价值，加上第<code>i</code>个物品的价值<code>val[i-1]</code>，这就是装第<code>i</code>个物品的前提下，背包可以装的最大价值。</p>
<p>综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = max(</span><br><span class="line">            dp[i-<span class="number">1</span>][w],</span><br><span class="line">            dp[i-<span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>]</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<p><strong>最后一步****，把伪码翻译成代码，处理一些边界情况</strong>。</p>
<p>我用 C++ 写的代码，把上面的思路完全翻译了一遍，并且处理了<code>w - wt[i-1]</code>可能小于 0 导致数组索引越界的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> &#123;</span><br><span class="line">    <span class="comment">// vector 全填入 0，base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">dp</span><span class="params">(N + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>)</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i-<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你看这个解法代码，是不是感觉非常简单，就是把我们刚才分析的思路原封不动翻译了一下而已。</p>
<p>所以说，明确了动态规划的套路，思路就显得行云流水，非常自然就出答案了。</p>
<p>至此，背包问题就解决了。相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导逻辑比较容易想到，基本上你明确了<code>dp</code>数组的定义，就可以理所当然地确定状态转移了。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/93bfdc7a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/93bfdc7a/" class="post-title-link" itemprop="url">经典动态规划：戳气球问题</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/93bfdc7a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/93bfdc7a/" data-xid="/posts/93bfdc7a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：戳气球问题"><a href="#经典动态规划：戳气球问题" class="headerlink" title="经典动态规划：戳气球问题"></a>经典动态规划：戳气球问题</h1><p>今天我们要聊的这道题「Burst Balloon」和之前我们写过的那篇 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋问题</a> 分析过的高楼扔鸡蛋问题类似，知名度很高，但难度确实也很大。因此 labuladong 公众号就给这道题赐个座，来看一看这道题目到底有多难。</p>
<p>它是 LeetCode 第 312 题，题目如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NNiTSq_20210507180038.png" alt="图片"></p>
<p>首先必须要说明，这个题目的状态转移方程真的比较巧妙，所以说如果你看了题目之后完全没有思路恰恰是正常的。虽然最优答案不容易想出来，但基本的思路分析是我们应该力求做到的。所以本文会先分析一下常规思路，然后再引入动态规划解法。</p>
<h2 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="一、回溯思路"></a>一、回溯思路</h2><p>先来顺一下解决这种问题的套路：</p>
<p><strong>我们前文多次强调过，很显然只要涉及求最值，没有任何奇技淫巧，一定是穷举所有可能的结果，然后对比得出最值</strong>。</p>
<p>所以说，只要遇到求最值的算法问题，首先要思考的就是：如何穷举出所有可能的结果？</p>
<p>穷举主要有两种算法，就是回溯算法和动态规划，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」。</p>
<p>如何将我们的扎气球问题转化成回溯算法呢？这个应该不难想到的，<strong>我们其实就是想穷举戳气球的顺序</strong>，不同的戳气球顺序可能得到不同的分数，我们需要把所有可能的分数中最高的那个找出来，对吧。</p>
<p>那么，这不就是一个「全排列」问题嘛，我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法框架套路详解</a> 中有全排列算法的详解和代码，其实只要稍微改一下逻辑即可，伪码思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/* 输入一组气球，返回戳破它们获得的最大分数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回溯算法的伪码解法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> socre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums 为空) &#123;</span><br><span class="line">        res = max(res, score);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> nums[i-<span class="number">1</span>] * nums[i] * nums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        在 nums 中删除元素 nums[i]</span><br><span class="line">        <span class="comment">// 递归回溯</span></span><br><span class="line">        backtrack(nums, score + point);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        将 temp 还原到 nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法就是这么简单粗暴，但是相应的，算法的效率非常低。这个解法等同于全排列，所以时间复杂度是阶乘级别，非常高，题目说了<code>nums</code>的大小<code>n</code>最多为 500，所以回溯算法肯定是不能通过所有测试用例的。</p>
<h2 id="二、动态规划思路"><a href="#二、动态规划思路" class="headerlink" title="二、动态规划思路"></a>二、动态规划思路</h2><p>这个动态规划问题和我们之前的动态规划系列文章相比有什么特别之处？为什么它比较难呢？</p>
<p><strong>原因在于，这个问题中我们每戳破一个气球<code>nums[i]</code>，得到的分数和该气球相邻的气球<code>nums[i-1]</code>和<code>nums[i+1]</code>是有相关性的</strong>。</p>
<p>我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划套路框架详解</a> 说过运用动态规划算法的一个重要条件：<strong>子问题必须独立</strong>。所以对于这个戳气球问题，如果想用动态规划，必须巧妙地定义<code>dp</code>数组的含义，避免子问题产生相关性，才能推出合理的状态转移方程。</p>
<p>如何定义<code>dp</code>数组呢，这里需要对问题进行一个简单地转化。题目说可以认为<code>nums[-1] = nums[n] = 1</code>，那么我们先直接把这两个边界加进去，形成一个新的数组<code>points</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 两端加入两个虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在气球的索引变成了从<code>1</code>到<code>n</code>，<code>points[0]</code>和<code>points[n+1]</code>可以认为是两个「虚拟气球」。</p>
<p>那么我们可以改变问题：<strong>在一排气球<code>points</code>中，请你戳破气球<code>0</code>和气球<code>n+1</code>之间的所有气球（不包括<code>0</code>和<code>n+1</code>），使得最终只剩下气球<code>0</code>和气球<code>n+1</code>两个气球，最多能够得到多少分</strong>？</p>
<p>现在可以定义<code>dp</code>数组的含义：</p>
<p>**<code>dp[i][j] = x</code>表示，戳破气球<code>i</code>和气球<code>j</code>之间（开区间，不包括<code>i</code>和<code>j</code>）的所有气球，可以获得的最高分数为<code>x</code>**。</p>
<p>那么根据这个定义，题目要求的结果就是<code>dp[0][n+1]</code>的值，而 base case 就是<code>dp[i][j] = 0</code>，其中<code>0 &lt;= i &lt;= n+1, j &lt;= i+1</code>，因为这种情况下，开区间<code>(i, j)</code>中间根本没有气球可以戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>现在我们要根据这个<code>dp</code>数组来推导状态转移方程了，根据我们前文的套路，所谓的推导「状态转移方程」，实际上就是在思考怎么「做选择」，也就是这道题目最有技巧的部分：</p>
<p>不就是想求戳破气球<code>i</code>和气球<code>j</code>之间的最高分数吗，如果「正向思考」，就只能写出前文的回溯算法；<strong>我们需要「反向思考」，想一想气球<code>i</code>和气球<code>j</code>之间最后一个被戳破的气球可能是哪一个</strong>？</p>
<p>其实气球<code>i</code>和气球<code>j</code>之间的所有气球都可能是最后被戳破的那一个，不防假设为<code>k</code>。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：<code>i</code>和<code>j</code>就是两个「状态」，最后戳破的那个气球<code>k</code>就是「选择」。</p>
<p><strong>根据刚才对<code>dp</code>数组的定义，如果最后一个戳破气球<code>k</code>，<code>dp[i][j]</code>的值应该为</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][k] + dp[k][j] </span><br><span class="line">         + points[i]*points[k]*points[j]</span><br></pre></td></tr></table></figure>

<p>你不是要最后戳破气球<code>k</code>吗？那得先把开区间<code>(i, k)</code>的气球都戳破，再把开区间<code>(k, j)</code>的气球都戳破；最后剩下的气球<code>k</code>，相邻的就是气球<code>i</code>和气球<code>j</code>，这时候戳破<code>k</code>的话得到的分数就是<code>points[i]*points[k]*points[j]</code>。</p>
<p>那么戳破开区间<code>(i, k)</code>和开区间<code>(k, j)</code>的气球最多能得到的分数是多少呢？嘿嘿，就是<code>dp[i][k]</code>和<code>dp[k][j]</code>，这恰好就是我们对<code>dp</code>数组的定义嘛！</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BgWf3s_20210507180154.png" alt="图片"></p>
<p>结合这个图，就能体会出<code>dp</code>数组定义的巧妙了。由于是开区间，<code>dp[i][k]</code>和<code>dp[k][j]</code>不会影响气球<code>k</code>；而戳破气球<code>k</code>时，旁边相邻的就是气球<code>i</code>和气球<code>j</code>了，最后还会剩下气球<code>i</code>和气球<code>j</code>，这也恰好满足了<code>dp</code>数组开区间的定义。</p>
<p>那么，对于一组给定的<code>i</code>和<code>j</code>，我们只要穷举<code>i &lt; k &lt; j</code>的所有气球<code>k</code>，选择得分最高的作为<code>dp[i][j]</code>的值即可，这也就是状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">    <span class="comment">// 择优做选择，使得 dp[i][j] 最大</span></span><br><span class="line">    dp[i][j] = Math.max(</span><br><span class="line">        dp[i][j], </span><br><span class="line">        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写出状态转移方程就完成这道题的一大半了，但是还有问题：对于<code>k</code>的穷举仅仅是在做「选择」，但是应该如何穷举「状态」<code>i</code>和<code>j</code>呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(</span><br><span class="line">                dp[i][j], </span><br><span class="line">                dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">            );</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="三、写出代码"><a href="#三、写出代码" class="headerlink" title="三、写出代码"></a>三、写出代码</h2><p><strong>关于「状态」的穷举，最重要的一点就是：状态转移所依赖的状态必须被提前计算出来</strong>。</p>
<p>拿这道题举例，<code>dp[i][j]</code>所依赖的状态是<code>dp[i][k]</code>和<code>dp[k][j]</code>，那么我们必须保证：在计算<code>dp[i][j]</code>时，<code>dp[i][k]</code>和<code>dp[k][j]</code>已经被计算出来了（其中<code>i &lt; k &lt; j</code>）。</p>
<p>那么应该如何安排<code>i</code>和<code>j</code>的遍历顺序，来提供上述的保证呢？我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484832&idx=1&sn=44ad2505ac5c276bf36eea1c503b78c3&chksm=9bd7fba8aca072be32f66e6c39d76ef4e91bdbf4ef993014d4fee82896687ad61da4f4fc4eda&scene=21#wechat_redirect">动态规划答疑篇</a> 写过处理这种问题的一个鸡贼技巧：<strong>根据 base case 和最终状态进行推导</strong>。</p>
<p>PS：最终状态就是指题目要求的结果，对于这道题目也就是<code>dp[0][n+1]</code>。</p>
<p>我们先把 base case 和最终的状态在 DP table 上画出来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/u3gd6W_20210507180507.png" alt="图片"></p>
<p>对于任一<code>dp[i][j]</code>，我们希望所有<code>dp[i][k]</code>和<code>dp[k][j]</code>已经被计算，画在图上就是这种情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Nhk1gt_20210507180419.png" alt="图片"></p>
<p>那么，为了达到这个要求，可以有两种遍历方法，要么斜着遍历，要么从下到上从左到右遍历：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/F2pPqp_20210507180541.png" alt="图片"></p>
<p>斜着遍历有一点难写，所以一般我们就从下往上遍历，下面看完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i][j], </span><br><span class="line">                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就完全解决了，十分巧妙，但也不是那么难，对吧？</p>
<p>关键在于<code>dp</code>数组的定义，需要避免子问题互相影响，所以我们反向思考，将<code>dp[i][j]</code>的定义设为开区间，考虑最后戳破的气球是哪一个，以此构建了状态转移方程。</p>
<p>对于如何穷举「状态」，我们使用了小技巧，通过 base case 和最终状态推导出<code>i,j</code>的遍历方向，保证正确的状态转移。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/e7520fcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e7520fcc/" class="post-title-link" itemprop="url">经典动态规划：高楼扔鸡蛋</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/e7520fcc/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/e7520fcc/" data-xid="/posts/e7520fcc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：高楼扔鸡蛋"><a href="#经典动态规划：高楼扔鸡蛋" class="headerlink" title="经典动态规划：高楼扔鸡蛋"></a>经典动态规划：高楼扔鸡蛋</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484675&from_itemidx=1&count=3&nolastread=1#wechat_redirect">手把手刷动态规划 25个</a></p>
<h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p>
<p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了不太划算。</p>
<p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p>
<h2 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h2><p>题目是这样：你面前有一栋从 1 到<code>N</code>共<code>N</code>层的楼，然后给你<code>K</code>个鸡蛋（<code>K</code>至少为 1）。现在确定这栋楼存在楼层<code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于<code>F</code>的楼层都会碎，低于<code>F</code>的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层<code>F</code>呢？</p>
<p>PS：F 可以为 0，比如说鸡蛋在 1 层都能摔碎，那么 F &#x3D; 0。</p>
<p>也就是让你找摔不碎鸡蛋的最高楼层<code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p>
<p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p>
<p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p>
<p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p>
<p>现在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p>
<p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p>
<p>最好的策略是使用二分查找思路，我先去第<code>(1 + 7) / 2 = 4</code>层扔一下：</p>
<p>如果碎了说明<code>F</code>小于 4，我就去第<code>(1 + 3) / 2 = 2</code>层试……</p>
<p>如果没碎说明<code>F</code>大于等于 4，我就去第<code>(5 + 7) / 2 = 6</code>层试……</p>
<p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试<code>log7</code>向上取整等于 3 次，比刚才的 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p>
<p>PS：这有点像 Big O 表示法计算算法的复杂度。</p>
<p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制<code>K</code>，直接使用二分思路就不行了</strong>。</p>
<p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层<code>F</code>了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。</p>
<p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p>
<p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p>
<p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。</p>
<p>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p>
<p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p>
<h2 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h2><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p>
<p>**「状态」很明显，就是当前拥有的鸡蛋数<code>K</code>和需要测试的楼层数<code>N</code>**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p>
<p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p>
<p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的<code>dp</code>数组或者带有两个状态参数的<code>dp</code>函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 当前状态为 (K 个鸡蛋，N 层楼)</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="type">int</span> res</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        res = min(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p>
<p>我们在第<code>i</code>层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p>
<p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数<code>K</code>应该减一，搜索的楼层区间应该从<code>[1..N]</code>变为<code>[1..i-1]</code>共<code>i-1</code>层楼；</p>
<p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数<code>K</code>不变，搜索的楼层区间应该从 <code>[1..N]</code>变为<code>[i+1..N]</code>共<code>N-i</code>层楼。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CvIp2u_20210429194724.png" alt="图片"></p>
<p>PS：细心的读者可能会问，在第<code>i</code>层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第<code>i</code>层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第<code>i</code>层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p>
<p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第<code>i</code>层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>递归的 base case 很容易理解：当楼层数<code>N</code>等于 0 时，显然不需要扔鸡蛋；当鸡蛋数<code>K</code>为 1 时，显然只能线性扫描所有楼层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">    <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">superEggDrop</span><span class="params">(K: <span class="type">int</span>, N: <span class="type">int</span>)</span>:</span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="title function_">dp</span><span class="params">(K, N)</span> -&gt; <span class="type">int</span>:</span><br><span class="line">        # base <span class="keyword">case</span></span><br><span class="line">        <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        # 避免重复计算</span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        res = <span class="type">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        # 穷举所有可能的选择</span><br><span class="line">        <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">1</span>, N + <span class="number">1</span>)</span>:</span><br><span class="line">            res = min(res, </span><br><span class="line">                      max(</span><br><span class="line">                            dp(K, N - i), </span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                         ) + <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)。</p>
<h2 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h2><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录&#x2F;DP table 优化，真的没啥新意。</p>
<p>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层<code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p>
<p>比方说你有 2 个鸡蛋，面对 10 层楼，你得拿一个鸡蛋去某一层楼扔对吧？那选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于鸡蛋碎没碎，下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。</p>
<p>其实，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K<em>N</em>logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p>
<p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最小值。</p>
<p>这里就不展开以上解法了，有兴趣的读者可以点击「阅读原文」查看。</p>
<p>我觉得吧，我们这种解法就够了：<strong>找状态，做选择</strong>，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，二分查找的优化应该可以看懂，之后的优化也就随缘吧。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/d0fbc9db/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/d0fbc9db/" class="post-title-link" itemprop="url">经典动态规划：高楼扔鸡蛋（进阶篇）</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/d0fbc9db/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/d0fbc9db/" data-xid="/posts/d0fbc9db/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典动态规划：高楼扔鸡蛋（进阶篇）"><a href="#经典动态规划：高楼扔鸡蛋（进阶篇）" class="headerlink" title="经典动态规划：高楼扔鸡蛋（进阶篇）"></a>经典动态规划：高楼扔鸡蛋（进阶篇）</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484675&from_itemidx=1&count=3&nolastread=1#wechat_redirect">手把手刷动态规划 25个</a></p>
<h2 id="预计阅读时间：9-分钟"><a href="#预计阅读时间：9-分钟" class="headerlink" title="预计阅读时间：9 分钟"></a>预计阅读时间：9 分钟</h2><p>我们在 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">上篇文章</a> 聊了高楼扔鸡蛋问题，讲了一种效率不是很高，但是较为容易理解的动态规划解法。后台很多读者问如何更高效地解决这个问题，今天就谈两种思路，来优化一下这个问题，分别是二分查找优化和重新定义状态转移。</p>
<p>如果还不知道高楼扔鸡蛋问题的读者可以看下 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋</a>，<strong>那篇文章详解了题目的含义和基本的动态规划解题思路，请确保理解前文，<strong><strong>因为</strong></strong>今天的优化都是基于这个基本解法的</strong>。</p>
<p>二分搜索的优化思路也许是我们可以尽力尝试写出的，而修改状态转移的解法可能是不容易想到的，可以借此见识一下动态规划算法设计的玄妙，当做思维拓展。</p>
<h2 id="一、二分搜索优化"><a href="#一、二分搜索优化" class="headerlink" title="一、二分搜索优化"></a>一、二分搜索优化</h2><p>之前提到过这个解法，核心是因为状态转移方程的单调性，这里可以具体展开看看。</p>
<p>题目要求最坏情况下至少需要扔几次鸡蛋才能测出鸡蛋恰好摔不碎的楼层<code>F</code>。首先简述一下原始动态规划的思路：</p>
<p><strong>1</strong>、暴力穷举尝试在所有楼层<code>1 &lt;= i &lt;= N</code>扔鸡蛋，每次选择尝试次数<strong>最少</strong>的那一层；</p>
<p><strong>2</strong>、每次扔鸡蛋有两种可能，要么碎，要么没碎；</p>
<p><strong>3</strong>、如果鸡蛋碎了，<code>F</code>应该在第<code>i</code>层下面，否则，<code>F</code>应该在第<code>i</code>层上面；</p>
<p><strong>4</strong>、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数<strong>更多</strong>，因为我们想求的是最坏情况下的结果。</p>
<p>核心的状态转移代码是这段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当前状态为 K 个鸡蛋，面对 N 层楼</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CyPTgO_20210429195258.png" alt="图片"></p>
<p>如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。</p>
<p>首先我们根据<code>dp(K, N)</code>数组的定义（有<code>K</code>个鸡蛋面对<code>N</code>层楼，最少需要扔 dp(K, N) 次），<strong>很容易知道<code>K</code>固定时，这个函数随着<code>N</code>的增加一定是单调递增的</strong>，无论你策略多聪明，楼层增加的话，测试次数一定要增加。</p>
<p>那么注意<code>dp(K - 1, i - 1)</code>和<code>dp(K, N - i)</code>这两个函数，其中<code>i</code>是从 1 到<code>N</code>单增的，如果我们固定<code>K</code>和<code>N</code>，<strong>把这两个函数看做关于<code>i</code>的函数，前者随着<code>i</code>的增加应该也是单调递增的，而后者随着<code>i</code>的增加应该是单调递减的</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/6NYUjf_20210429195215.png" alt="图片"></p>
<p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。</p>
<p>我们前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484598&idx=1&sn=69edaf4a7f6bfd0b1185cae5d0689c1d&chksm=9bd7fabeaca073a8820bc93cb67a8e26fa9eaa1ab9717b7e3ac41b4aac12235067c8af3520d5&scene=21#wechat_redirect">二分搜索只能用来查找元素吗？</a>讲过，二分查找的运用很广泛，形如下面这种形式的 for 循环代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOK(i))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个<code>dp</code>函数的曲线，我们要找的最低点其实就是这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp(K - <span class="number">1</span>, i - <span class="number">1</span>) == dp(K, N - i))</span><br><span class="line">        <span class="keyword">return</span> dp(K, N - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">superEggDrop</span><span class="params">(self, K: <span class="type">int</span>, N: <span class="type">int</span>)</span> -&gt; <span class="type">int</span>:</span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">        <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        # <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        #     res = min(res, </span><br><span class="line">        #             max( </span><br><span class="line">        #                 dp(K - <span class="number">1</span>, i - <span class="number">1</span>), </span><br><span class="line">        #                 dp(K, N - i)      </span><br><span class="line">        #                 ) + <span class="number">1</span> </span><br><span class="line">        #             )</span><br><span class="line"></span><br><span class="line">        res = <span class="type">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        # 用二分搜索代替线性搜索</span><br><span class="line">        lo, hi = <span class="number">1</span>, N</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) <span class="comment">// 2</span></span><br><span class="line">            broken = dp(K - <span class="number">1</span>, mid - <span class="number">1</span>) # 碎</span><br><span class="line">            not_broken = dp(K, N - mid) # 没碎</span><br><span class="line">            # res = min(max(碎，没碎) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> broken &gt; not_broken:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">                res = min(res, broken + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">                res = min(res, not_broken + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K<em>N</em>logN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效不少。</p>
<h2 id="二、重写状态转移"><a href="#二、重写状态转移" class="headerlink" title="二、重写状态转移"></a>二、重写状态转移</h2><p>前文 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484469&idx=1&sn=e8d321c8ad62483874a997e9dd72da8f&chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 就提过，找动态规划的状态转移本就是见仁见智，比较玄学的事情。不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异。这里就是一个很好的例子。</p>
<p>再回顾一下我们之前定义的<code>dp</code>数组含义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(k, n)</span> -&gt; <span class="type">int</span></span><br><span class="line"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="line"># 返回这个状态下最少的扔鸡蛋次数</span><br></pre></td></tr></table></figure>

<p>用 dp 数组表示的话也是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[k][n] = m</span><br><span class="line"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="line"># 这个状态下最少的扔鸡蛋次数为 m</span><br></pre></td></tr></table></figure>

<p>按照这个定义，就是<strong>确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数</strong>。最终我们想要的答案就是<code>dp(K, N)</code>的结果。</p>
<p>这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，只不过是更聪明的穷举。</p>
<p>现在，我们稍微修改<code>dp</code>数组的定义，<strong>确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定<code>F</code>的最高楼层数</strong>。</p>
<p>有点绕口，具体来说是这个意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[k][m] = n</span><br><span class="line"># 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋</span><br><span class="line"># 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼</span><br><span class="line"></span><br><span class="line"># 比如说 dp[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">7</span> 表示：</span><br><span class="line"># 现在有 <span class="number">1</span> 个鸡蛋，允许你扔 <span class="number">7</span> 次;</span><br><span class="line"># 这个状态下最多给你 <span class="number">7</span> 层楼，</span><br><span class="line"># 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎</span><br><span class="line"># （一层一层线性探查嘛）</span><br></pre></td></tr></table></figure>

<p>这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？</p>
<p>我们最终要求的其实是扔鸡蛋次数<code>m</code>，但是这时候<code>m</code>在状态之中而不是<code>dp</code>数组的结果，可以这样处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="comment">// 状态转移...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目不是<strong>给你<code>K</code>鸡蛋，<code>N</code>层楼，让你求最坏情况下最少的测试次数<code>m</code></strong> 吗？<code>while</code>循环结束的条件是<code>dp[K][m] == N</code>，也就是<strong>给你<code>K</code>个鸡蛋，允许测试<code>m</code>次，最坏情况下最多能测试<code>N</code>层楼</strong>。</p>
<p>注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210429195434229_20210429195434.png" alt="图片"></p>
<p>这个图描述的仅仅是某一个楼层<code>i</code>，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种<code>dp</code>定义根本不需要这些了，基于下面两个事实：</p>
<p><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上</strong>。</p>
<p><strong>2、无论你上楼还是下楼，总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</strong>。</p>
<p>根据这个特点，可以写出下面的状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k][m] = dp[k][m-<span class="number">1</span>] + dp[k-<span class="number">1</span>][m-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong><code>dp[k][m - 1]</code>就是楼上的楼层数</strong>，因为鸡蛋个数<code>k</code>不变，也就是鸡蛋没碎，扔鸡蛋次数<code>m</code>减一；</p>
<p><strong><code>dp[k - 1][m - 1]</code>就是楼下的楼层数</strong>，因为鸡蛋个数<code>k</code>减一，也就是鸡蛋碎了，同时扔鸡蛋次数<code>m</code>减一。</p>
<p>PS：这个<code>m</code>为什么要减一而不是加一？之前定义得很清楚，这个<code>m</code>是一个允许的次数上界，而不是扔了几次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/72KWkN_20210429195454.png" alt="图片"></p>
<p>至此，整个思路就完成了，只要把状态转移方程填进框架即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case:</span></span><br><span class="line">    <span class="comment">// dp[0][..] = 0</span></span><br><span class="line">    <span class="comment">// dp[..][0] = 0</span></span><br><span class="line">    <span class="comment">// Java 默认初始化数组都为 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">            dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你还觉得这段代码有点难以理解，其实它就等同于这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; dp[K][m] &lt; N; m++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>看到这种代码形式就熟悉多了吧，因为我们要求的不是<code>dp</code>数组里的值，而是某个符合条件的索引<code>m</code>，所以用<code>while</code>循环来找到这个<code>m</code>而已。</p>
<p>这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。</p>
<p>另外注意到<code>dp[m][k]</code>转移只和左边和左上的两个状态有关，所以很容易优化成一维<code>dp</code>数组，这里就不写了。</p>
<h2 id="三、进一步思考"><a href="#三、进一步思考" class="headerlink" title="三、进一步思考"></a>三、进一步思考</h2><p>再往下就要用一些数学方法了，不具体展开，就简单提一下思路吧。</p>
<p>在刚才的思路之上，<strong>注意函数<code>dp(m, k)</code>是随着<code>m</code>单增的，因为鸡蛋个数<code>k</code>不变时，允许的测试次数越多，可测试的楼层就越高。</strong></p>
<p>这里又可以借助二分搜索算法快速逼近<code>dp[K][m] == N</code>这个终止条件，时间复杂度进一步下降为 O(KlogN)，我们可以设<code>g(k,m)</code>等于……</p>
<p>算了算了，打住吧。我觉得我们能够写出 O(K<em>N</em>logN) 的二分优化算法就行了，后面的这些解法呢，听个响鼓个掌就行了，把欲望限制在能力的范围之内才能拥有快乐！</p>
<p>不过可以肯定的是，根据二分搜索代替线性扫描 m 的取值，代码的大致框架肯定是修改穷举 m 的 for 循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把线性搜索改成二分搜索</span></span><br><span class="line"><span class="comment">// for (int m = 1; dp[K][m] &lt; N; m++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = N;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (... &lt; N) &#123;</span><br><span class="line">        lo = ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结一下吧，<strong>第一个二分优化是利用了<code>dp</code>函数的单调性</strong>，用二分查找技巧快速搜索答案；<strong>第二种优化是巧妙地修改了状态转移方程</strong>，简化了求解了流程，但相应的，解题逻辑比较难以想到；后续还可以用一些数学方法和二分搜索进一步优化第二种解法，不过看了看镜子中的发量，算了。</p>
<p>本文终，希望对你有一点启发。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/afbd7c28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lion.png">
      <meta itemprop="name" content="swimminghao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swimminghao's blog">
      <meta itemprop="description" content="swimminghao的学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | swimminghao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/afbd7c28/" class="post-title-link" itemprop="url">经典面试题：如何寻找最⻓回文子串</a>
        </h2>

        <div class="post-meta-container">

          

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-28 19:57:47" itemprop="dateCreated datePublished" datetime="2022-02-28T19:57:47+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 16:20:39" itemprop="dateModified" datetime="2025-02-13T16:20:39+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/posts/afbd7c28/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/afbd7c28/" data-xid="/posts/afbd7c28/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="经典面试题：如何寻找最⻓回文子串"><a href="#经典面试题：如何寻找最⻓回文子串" class="headerlink" title="经典面试题：如何寻找最⻓回文子串"></a>经典面试题：如何寻找最⻓回文子串</h1><h2 id="预计阅读时间：5-分钟"><a href="#预计阅读时间：5-分钟" class="headerlink" title="预计阅读时间：5 分钟"></a>预计阅读时间：5 分钟</h2><p>回文串是面试常常遇到的问题（虽然问题本身没啥意义），本文就告诉你回文串问题的核心思想是什么。</p>
<p>首先，明确一下什：<strong>回文串就是正着读和反着读都一样的字符串</strong>。</p>
<p>比如说字符串<code>aba</code>和<code>abba</code>都是回文串，因为它们对称，反过来还是和本身一样。反之，字符串<code>abac</code>就不是回文串。</p>
<p>可以看到回文串的的长度可能是奇数，也可能是偶数，这就添加了回文串问题的难度，解决该类问题的核心是<strong>双指针</strong>。下面就通过一道最长回文子串的问题来具体理解一下回文串问题：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4lLwdm05DtOeOPia4eSQF3HJWKPuI6XXSumtytXXkvgQPwO1szjiaWicF84yMiaIwmFyRic4RmocZz3qvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h3><p>对于这个问题，我们首先应该思考的是，给一个字符串<code>s</code>，如何在<code>s</code>中找到一个回文子串？</p>
<p>有一个很有趣的思路：既然回文串是一个正着反着读都一样的字符串，那么如果我们把<code>s</code>反转，称为<code>s&#39;</code>，然后在<code>s</code>和<code>s&#39;</code>中寻找<strong>最长公共子串</strong>，这样应该就能找到最长回文子串。</p>
<p>比如说字符串<code>abacd</code>，反过来是<code>dcaba</code>，它俩的最长公共子串是<code>aba</code>，也就是最长回文子串。</p>
<p>但是这个思路是错误的，比如说字符串<code>aacxycaa</code>，反转之后是<code>aacyxcaa</code>，最长公共子串是<code>aac</code>，但是最长回文子串应该是<code>aa</code>。</p>
<p>虽然这个思路不正确，但是<strong>这种把问题转化为其他形式的思考方式是非常值得提倡的</strong>。</p>
<p>下面，就来说一下正确的思路，如何使用双指针。</p>
<p><strong>寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串</strong>。对于最长回文子串，就是这个意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>但是呢，我们刚才也说了，回文串的长度可能是奇数也可能是偶数，如果是<code>abba</code>这种情况，没有一个中心字符，上面的算法就没辙了。所以我们可以修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>PS：读者可能发现这里的索引会越界，等会会处理。</p>
<h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p>按照上面的思路，先要实现一个函数来寻找最长回文串，这个函数是有点技巧的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HpyEbX_20210507183744.png" alt="图片"></p>
<p>为什么要传入两个指针<code>l</code>和<code>r</code>呢？<strong>因为这样实现可以同时处理回文串长度为奇数和偶数的情况</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    # 找到以 s[i] 为中心的回文串</span><br><span class="line">    palindrome(s, i, i)</span><br><span class="line">    # 找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>下面看下<code>longestPalindrome</code>的完整代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/VFGLHs_20210507183807.png" alt="图片"></p>
<p>至此，这道最长回文子串的问题就解决了，时间复杂度 O(N^2)，空间复杂度 O(1)。</p>
<p>值得一提的是，这个问题可以用动态规划方法解决，时间复杂度一样，但是空间复杂度至少要 O(N^2) 来存储 DP table。这道题是少有的动态规划非最优解法的问题。</p>
<p>另外，这个问题还有一个巧妙的解法，时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为没必要掌握。该算法的名字叫 Manacher’s Algorithm（马拉车算法），有兴趣的读者可以自行搜索一下。</p>

      
    </div>

    
    
    


    <div>
      
    </div>

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>l




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swimminghao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:22</span>
  </span>
</div>

<span id="sitetime"></span>
<script language=javascript>
    function siteTime(){
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2022,02,28,00,00,00); //你的建站时间
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById("sitetime").innerHTML=" 本站已安全运行 "+diffYears+" Year "+diffDays+" Days "+diffHours+" Hours "+diffMinutes+" m "+diffSeconds+" s";
    }
    siteTime();
</script>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        访问人数：<span id="busuanzi_value_site_uv"></span>
      </span>人
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
       访问总量：<span id="busuanzi_value_site_pv"></span>
      </span>次
    </span>


<!--
  本文总阅读量：<span id="busuanzi_value_page_pv"></span>次
-->

</div>


<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

--><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-nu.vercel.app","placeholder":"请文明评论呀","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/page/28/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "middleCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
</body>
</html>
