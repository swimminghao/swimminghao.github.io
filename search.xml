<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<p>摘要内容……</p>
<span id="more"></span>
<p>以下为隐藏内容</p>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>一个函数秒杀 2Sum 3Sum 4Sum 问题</title>
    <url>/posts/2df4ba17/</url>
    <content><![CDATA[<h1 id="一个函数秒杀-2Sum-3Sum-4Sum-问题"><a href="#一个函数秒杀-2Sum-3Sum-4Sum-问题" class="headerlink" title="一个函数秒杀 2Sum 3Sum 4Sum 问题"></a>一个函数秒杀 2Sum 3Sum 4Sum 问题</h1><p>经常刷 LeetCode 的读者肯定知道鼎鼎有名的 <code>twoSum</code> 问题，我们的旧文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484474&idx=1&sn=dfbadbe6e17d695a1907e2adcd9f0d3c&chksm=9bd7fa32aca0732406829a6d1de34b7e3144af239cc25e014f5349d73cea952d5f2b0473345a&scene=21#wechat_redirect">Two Sum 问题的核心思想</a> 对 <code>twoSum</code> 的几个变种做了解析。</p>
<p>但是除了 <code>twoSum</code> 问题，LeetCode 上面还有 <code>3Sum</code>，<code>4Sum</code> 问题，我估计以后出个 <code>5Sum</code>，<code>6Sum</code> 也不是不可能。</p>
<p>那么，对于这种问题有没有什么好办法用套路解决呢？本文就由浅入深，层层推进，用一个函数来解决所有 <code>nSum</code> 类型的问题。</p>
<h2 id="一、twoSum-问题"><a href="#一、twoSum-问题" class="headerlink" title="一、twoSum 问题"></a>一、twoSum 问题</h2><p>[leetcode1](<a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和 - 力扣（LeetCode） (leetcode-cn.com)</a>)</p>
<p>力扣上的 twoSum 问题，题目要求返回的是索引，这里我来编一道 twoSum 题目，不要返回索引，返回元素的值：</p>
<p>如果假设输入一个数组 <code>nums</code> 和一个目标和 <code>target</code>，<strong>请你返回 <code>nums</code> 中能够凑出 <code>target</code> 的两个元素的值</strong>，比如输入 <code>nums = [5,3,1,6], target = 9</code>，那么算法返回两个元素 <code>[3,6]</code>。可以假设只有且仅有一对儿元素可以凑出 <code>target</code>。</p>
<p>我们可以先对 <code>nums</code> 排序，然后利用前文「<a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484505&idx=1&sn=0e9517f7c4021df0e6146c6b2b0c4aba&chksm=9bd7fa51aca07347009c591c403b3228f41617806429e738165bd58d60220bf8f15f92ff8a2e&scene=21#wechat_redirect">双指针技巧汇总</a>」写过的左右双指针技巧，从两端相向而行就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="title function_">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 先对数组排序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">        <span class="comment">// 根据 sum 和 target 的比较，移动左右指针</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;nums[lo], nums[hi]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以解决这个问题，不过我们要继续魔改题目，把这个题目变得更泛化，更困难一点：</p>
<p><strong><code>nums</code> 中可能有多对儿元素之和都等于 <code>target</code>，请你的算法返回所有和为 <code>target</code> 的元素对儿，其中不能出现重复</strong>。</p>
<p>函数签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span>;</span><br></pre></td></tr></table></figure>

<p>比如说输入为 <code>nums = [1,3,1,2,2,3], target = 4</code>，那么算法返回的结果就是：<code>[[1,3],[2,2]]</code>。</p>
<p>对于修改后的问题，关键难点是现在可能有多个和为 <code>target</code> 的数对儿，还不能重复，比如上述例子中 <code>[1,3]</code> 和 <code>[3,1]</code> 就算重复，只能算一次。</p>
<p>首先，基本思路肯定还是排序加双指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target &#123;</span></span><br><span class="line"><span class="params">    // 先对数组排序</span></span><br><span class="line"><span class="params">    sort(nums.begin()</span>, nums.end());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">        <span class="comment">// 根据 sum 和 target 的比较，移动左右指针</span></span><br><span class="line">        <span class="keyword">if</span>      (sum &lt; target) lo++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) hi--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(&#123;lo, hi&#125;);</span><br><span class="line">            lo++; hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这样实现会造成重复的结果，比如说 <code>nums = [1,1,1,2,2,3,3], target = 4</code>，得到的结果中 <code>[1,3]</code> 肯定会重复。</p>
<p>出问题的地方在于 <code>sum == target</code> 条件的 if 分支，当给 <code>res</code> 加入一次结果后，<code>lo</code> 和 <code>hi</code> 不应该改变 1 的同时，还应该跳过所有重复的元素：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/EQzz7o_20210427105202.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">    <span class="comment">// 记录索引 lo 和 hi 最初对应的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[lo], right = nums[hi];</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target)      lo++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) hi--;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res.push_back(&#123;left, right&#125;);</span><br><span class="line">        <span class="comment">// 跳过所有重复的元素</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个通用化的 <code>twoSum</code> 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 <code>3Sum</code> 和 <code>4Sum</code> 的时候会复用这个函数。</p>
<p>这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 <code>O(N)</code>，而排序的时间复杂度是 <code>O(NlogN)</code>，所以这个函数的时间复杂度是 <code>O(NlogN)</code>。</p>
<h3 id="二、3Sum-问题"><a href="#二、3Sum-问题" class="headerlink" title="二、3Sum 问题"></a>二、3Sum 问题</h3><p><a href="https://leetcode-cn.com/problems/3sum/">Leetcode15</a></p>
<p>这是力扣第 15 题「三数之和」：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/MUV5CJ_20210427105255.png" alt="图片"></p>
<p>题目就是让我们找 <code>nums</code> 中和为 0 的三个元素，返回所有可能的三元组（triple），函数签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 <code>target</code> 的三元组吧，同上面的 <code>twoSum</code> 一样，也不允许重复的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 求和为 0 的三元组</span></span><br><span class="line">    <span class="keyword">return</span> threeSumTarget(nums, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSumTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 输入数组 nums，返回所有和为 target 的三元组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题怎么解决呢？<strong>很简单，穷举呗</strong>。现在我们想找和为 <code>target</code> 的三个数字，那么对于第一个数字，可能是什么？<code>nums</code> 中的每一个元素 <code>nums[i]</code> 都有可能！</p>
<p>那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 <code>target - nums[i]</code> 的两个数字呗，那不就是 <code>twoSum</code> 函数解决的问题么🤔</p>
<p>可以直接写代码了，需要把 <code>twoSum</code> 函数稍作修改即可复用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从 nums[start] 开始，计算有序数组</span></span><br><span class="line"><span class="comment"> * nums 中所有和为 target 的二元组 */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(</span></span><br><span class="line"><span class="params">    vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 左指针改为从 start 开始，其他不变</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> start, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算数组 nums 中所有和为 target 的三元组 */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSumTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组得排个序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 穷举 threeSum 的第一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 对 target - nums[i] 计算 twoSum</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; </span><br><span class="line">            tuples = twoSumTarget(nums, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">        <span class="comment">// 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; tuple : tuples) &#123;</span><br><span class="line">            tuple.push_back(nums[i]);</span><br><span class="line">            res.push_back(tuple);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过第一个数字重复的情况，否则会出现重复结果</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，类似 <code>twoSum</code>，<code>3Sum</code> 的结果也可能重复，比如输入是 <code>nums = [1,1,1,2,3], target = 6</code>，结果就会重复。</p>
<p><strong>关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 <code>twoSum</code> 函数会保证它们不重复</strong>。所以代码中必须用一个 while 循环来保证 <code>3Sum</code> 中第一个元素不重复。</p>
<p>至此，<code>3Sum</code> 问题就解决了，时间复杂度不难算，排序的复杂度为 <code>O(NlogN)</code>，<code>twoSumTarget</code> 函数中的双指针操作为 <code>O(N)</code>，<code>threeSumTarget</code> 函数在 for 循环中调用 <code>twoSumTarget</code> 所以总的时间复杂度就是 <code>O(NlogN + N^2) = O(N^2)</code>。</p>
<h3 id="三、4Sum-问题"><a href="#三、4Sum-问题" class="headerlink" title="三、4Sum 问题"></a>三、4Sum 问题</h3><p><a href="https://leetcode-cn.com/problems/4sum/">Leetcode18</a></p>
<p>这是力扣第 18 题「四数之和」：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/GjaUGB_20210427105438.png" alt="图片"></p>
<p>函数签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">fourSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span>;</span><br></pre></td></tr></table></figure>

<p>都到这份上了，<code>4Sum</code> 完全就可以用相同的思路：穷举第一个数字，然后调用 <code>3Sum</code> 函数计算剩下三个数，最后组合出和为 <code>target</code> 的四元组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">fourSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组需要排序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 穷举 fourSum 的第一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 对 target - nums[i] 计算 threeSum</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; </span><br><span class="line">            triples = threeSumTarget(nums, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">        <span class="comment">// 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; triple : triples) &#123;</span><br><span class="line">            triple.push_back(nums[i]);</span><br><span class="line">            res.push_back(triple);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fourSum 的第一个数不能重复</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 nums[start] 开始，计算有序数组</span></span><br><span class="line"><span class="comment"> * nums 中所有和为 target 的三元组 */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; </span><br><span class="line">    <span class="title function_">threeSumTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">// i 从 start 开始穷举，其他都不变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; n; i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>这样，按照相同的套路，<code>4Sum</code> 问题就解决了，时间复杂度的分析和之前类似，for 循环中调用了 <code>threeSumTarget</code> 函数，所以总的时间复杂度就是 <code>O(N^3)</code>。</p>
<h3 id="四、100Sum-问题？"><a href="#四、100Sum-问题？" class="headerlink" title="四、100Sum 问题？"></a>四、100Sum 问题？</h3><p>在 LeetCode 上，<code>4Sum</code> 就到头了，<strong>但是回想刚才写 <code>3Sum</code> 和 <code>4Sum</code> 的过程，实际上是遵循相同的模式的</strong>。我相信你只要稍微修改一下 <code>4Sum</code> 的函数就可以复用并解决 <code>5Sum</code> 问题，然后解决 <code>6Sum</code> 问题……</p>
<p>那么，如果我让你求 <code>100Sum</code> 问题，怎么办呢？其实我们可以观察上面这些解法，统一出一个 <code>nSum</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注意：调用这个函数之前一定要先给 nums 排序 */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">nSumTarget</span><span class="params">(</span></span><br><span class="line"><span class="params">    vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 至少是 2Sum，且数组大小不应该小于 n</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span> || sz &lt; n) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 2Sum 是 base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 双指针那一套操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> start, hi = sz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[lo], right = nums[hi];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(&#123;left, right&#125;);</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &gt; 2 时，递归计算 (n-1)Sum 的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; sz; i++) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; </span><br><span class="line">                sub = nSumTarget(nums, n - <span class="number">1</span>, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; arr : sub) &#123;</span><br><span class="line">                <span class="comment">// (n-1)Sum 加上 nums[i] 就是 nSum</span></span><br><span class="line">                arr.push_back(nums[i]);</span><br><span class="line">                res.push_back(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; sz - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，看起来很长，实际上就是把之前的题目解法合并起来了，<code>n == 2</code> 时是 <code>twoSum</code> 的双指针解法，<code>n &gt; 2</code> 时就是穷举第一个数字，然后递归调用计算 <code>(n-1)Sum</code>，组装答案。</p>
<p><strong>需要注意的是，调用这个 <code>nSum</code> 函数之前一定要先给 <code>nums</code> 数组排序</strong>，因为 <code>nSum</code> 是一个递归函数，如果在 <code>nSum</code> 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。</p>
<p>比如说现在我们写 LeetCode 上的 <code>4Sum</code> 问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">fourSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// n 为 4，从 nums[0] 开始计算和为 target 的四元组</span></span><br><span class="line">    <span class="keyword">return</span> nSumTarget(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再比如 LeetCode 的 <code>3Sum</code> 问题，找 <code>target == 0</code> 的三元组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">threeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// n 为 3，从 nums[0] 开始计算和为 0 的三元组</span></span><br><span class="line">    <span class="keyword">return</span> nSumTarget(nums, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如果让你计算 <code>100Sum</code> 问题，直接调用这个函数就完事儿了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1、【对线面试官】今天来聊聊Java注解</title>
    <url>/posts/dc033d1f/</url>
    <content><![CDATA[<h1 id="1、【对线面试官】今天来聊聊Java注解"><a href="#1、【对线面试官】今天来聊聊Java注解" class="headerlink" title="1、【对线面试官】今天来聊聊Java注解"></a>1、【对线面试官】今天来聊聊Java注解</h1><h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><ul>
<li>注解在我的理解下，就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。</li>
</ul>
<h2 id="开发中用到的注"><a href="#开发中用到的注" class="headerlink" title="开发中用到的注"></a>开发中用到的注</h2><ol>
<li>注解其实在开发中是非常常见的，比如我们在使用各种框架时（像我们Java程序员接触最多的还是Spring框架一套） ，就会用到非常多的注解，@Controller I@Param &#x2F; @Select等等</li>
<li>一些项目也用到lombok的注解，@SIf4j&#x2F;@Data等等</li>
<li>除了框架实现的注解，Java原生也有@ Overried、 @Deprecated、 @Functional Interface等基本注解</li>
<li>不过Java原生的基本注解大多数用于「标记」和「检查」<ul>
<li>原生Java除了这些提供基本注解之外，还有一种叫做元Annotation（元注解），所谓的元Annotation就是用来修饰注解的</li>
<li>常用的元Annotation有@Retention和@Target</li>
<li>@Retention注解可以简单理解为设置注解的生命周期，而@Target表示这个注解可以修饰哪些地方（比如方法、还是成员变量、还是包等等）</li>
</ul>
</li>
</ol>
<h2 id="自己定义过的注解，在项目里边用的"><a href="#自己定义过的注解，在项目里边用的" class="headerlink" title="自己定义过的注解，在项目里边用的"></a>自己定义过的注解，在项目里边用的</h2><ol>
<li>嗯，写过的。背景是这样的：我司有个监控告警系统，对外提供了客户端供我们自己使用。监控一般的指标就是QPS、RT和错误嘛。</li>
<li>原生的客户端需要在代码里指定上报这会导致这种监控的代码会跟业务代码混合，比较恶心。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// qps 上报</span></span><br><span class="line">    qps(params);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建上下文(模拟业务代码）</span></span><br><span class="line">    <span class="type">ProcessContext</span> <span class="variable">processContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessContext</span>();</span><br><span class="line">    <span class="type">UserModel</span> <span class="variable">userModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserModel</span>();</span><br><span class="line">    userModel.setAge(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    userModel.setName(userName);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rt 上报</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    rt(endTime - startTime);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出错上报</span></span><br><span class="line">    error(params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>其实这种基础的监控信息，显然都可以通过AOP切面的方式去处理掉（可以看到都是方法级的）。而再用注解这个载体配置相关的信息，配合AOP解析就会比较优雅</p>
</li>
<li><p>要写自定义的注解，首先考虑我们是在什么时候解析这个注解。这就需要用到前面所说的@Retention注解，这个注解会修饰我们自定义注解生命周期。</p>
</li>
<li><p>@Retention注解传入的是RetentionPolic y枚举，该枚举有三个常量，分别是SOU RCE、 CLASS和RUNTIME</p>
</li>
<li><p>理解这块就得了解从.java文件到class文件再到class被jvm加载的过程了。下面的图描述着从.java文件到编译为class文件的过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lW9KUH_20211025142411.png"></p>
</li>
<li><p>从上面的图可以发现有个「注解抽象语法树」，这里其实就会去解析注解，然后做处理的逻辑。</p>
</li>
<li><p>所以重点来了，如果你想要在编译期间处理注解相关的逻辑，你需要继承AbstractProcessor并实现process方法。比如可以看到lombok就用AnnotationProcessor继承了AbstractProcessor。</p>
</li>
<li><p>一般来说，只要自定义的注解中@Retention注解设置为SOURCE和CLASS这俩个级别，那么就需要继承并实现</p>
</li>
<li><p>因为SOURCE和CLASS这俩个级别等加载到jvm的时候，注解就被抹除了</p>
</li>
<li><p>从这里又引申出：lombok的实现原理就是在这（为什么使用了个@Data这样的注解就能有set&#x2F;get等方法了，就是在这里加上去的）</p>
</li>
</ol>
<h2 id="自定义注解的级别"><a href="#自定义注解的级别" class="headerlink" title="自定义注解的级别"></a>自定义注解的级别</h2><ol>
<li>一般来说，我们自己定义的注解都是RUNTIME级别的，因为大多数情况我们是根据运行时环境去做一些处理。</li>
<li>我们现实在开发的过程中写自定义注解需要配合反射来使用</li>
<li>因为反射是Java获取运行时的信息的重要手段</li>
<li>所以，我当时就用了自定义注解，在SpringAOP的逻辑处理中，判断是否带有自定义注解，如果有则将监控的逻辑写在方法的前后</li>
<li>这样，只要在方法上加上我的注解，那就可以有对方法监控的效果（RT、QPS、ERROR)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;@annotation(com.sanwai.service.openapi.monitor.Monitor)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">antispan</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">functionName</span> <span class="operator">=</span> pjp.getSignature().getName();</span><br><span class="line">    Map&lt;String, String&gt; tags = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    logger.info(functionName);</span><br><span class="line"></span><br><span class="line">    tags.put(<span class="string">&quot;functionName&quot;</span>, functionName);</span><br><span class="line">    tags.put(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    monitor.sum(functionName, <span class="string">&quot;start&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法执行开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        o = pjp.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//方法执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        tags.put(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">        monitor.avg(<span class="string">&quot;rt&quot;</span>, tags, endTime - startTime);</span><br><span class="line"></span><br><span class="line">        monitor.sum(functionName, <span class="string">&quot;fail&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法执行结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    monitor.avg(<span class="string">&quot;rt&quot;</span>, tags, endTime - startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != o) &#123;</span><br><span class="line">        monitor.sum(functionName, <span class="string">&quot;done&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>注解是代码的特殊标记，可以在编译、类加载、运行时被读取</li>
<li>其实对应的就是RetentionPolicy枚举三种级别</li>
<li>SOURCE和CLASS级别需要继承AbstractProcessor，实现process方法去处理我们自定义的注解</li>
<li>而RUNTIME级别是我们日常开发用得最多了，配合Java反射机制可以在很多场景优化我们的代码</li>
</ol>
<h2 id="展示态度（嗯，总体来看，你对注解这块基础还是扎实的。）"><a href="#展示态度（嗯，总体来看，你对注解这块基础还是扎实的。）" class="headerlink" title="展示态度（嗯，总体来看，你对注解这块基础还是扎实的。）"></a>展示态度（嗯，总体来看，你对注解这块基础还是扎实的。）</h2><ul>
<li>主要是在工作中遇到注解的时候就多看看原理是怎么实现的，然后遇到业务机会，还是会写写，优化优化下代码</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客文章加密</title>
    <url>/posts/c30e6297/</url>
    <content><![CDATA[<h1 id="Hexo博客文章加密"><a href="#Hexo博客文章加密" class="headerlink" title="Hexo博客文章加密"></a>Hexo博客文章加密</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>平时开发过程中遇到的一些问题，我都会整理到文档中。有些感觉不错的，会二次整理成文章发布到我的博客中。但是有些文章如果存在隐私内容，或者不打算公开的话，就不能放在博客中了。</p>
<p>我的博客是使用 <code>Hexo</code> 来搭建的，并不能设置某些文章不可见。但如果不在电脑旁或者出门没有带电脑又想要查看一下之前记录的内容，就很不方便了。</p>
<p>我也尝试在 <code>github</code> 上去找一些可以设置账户的开源的博客框架，但测试过一些后发现并没有符合自己需求的，而自己开发却没有时间。</p>
<p>思来想去，就想看看有没有插件能够实现 <code>Hexo</code> 博客的加密操作。最终让我找到了一款名为 <code>Hexo-Blog-Encrypt</code> 的插件。</p>
<p>为了防止以下的修改可能出现版本差异，这里我先声明我使用的 <code>Hexo</code> 版本信息：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span>: <span class="number">4</span>.<span class="number">2</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">hexo</span>-cli: <span class="number">3</span>.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">next</span> theme version: <span class="number">7</span>.<span class="number">8</span>.<span class="number">0</span>+a7a948a</span><br><span class="line"><span class="attribute">hexo</span>-blog-encrypt: <span class="string">&quot;^3.1.6&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment">--save hexo-blog-encrypt</span></span><br></pre></td></tr></table></figure>

<h4 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h4><p>该插件的使用也很方便，这里我仅作简单介绍，详细的可以查看官方文档。 <a href="https://github.com/D0n9X1n/hexo-blog-encrypt">D0n9X1n&#x2F;hexo-blog-encrypt: Yet, just another hexo plugin for security.</a></p>
<p>要为一篇文章添加密码查看功能，只需要在文章信息头部添加 <code>password</code> 字段即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-04-13 21:18:02</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">hello</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="全局加密配置"><a href="#全局加密配置" class="headerlink" title="全局加密配置"></a>全局加密配置</h4><p>分别为每篇文章设置密码，虽然很灵活，但是配置或者修改起来非常麻烦。为此，可以通过设置统一配置来实现全局加密。</p>
<p>通过添加指定 <code>tag</code> 的方式，可以为所有需要加密的文章添加统一加密操作。只需要在需要加密的文章中，添加设置的 <code>tag值</code> 即可。</p>
<p>在Hexo主配置文件 <code>_config.yml</code> 中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">silent:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">这是一篇加密文章，需要密码才能继续阅读。</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">当前文章暂不对外可见，请输入密码后查看！</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">private</span>, <span class="attr">password:</span> <span class="string">hello</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉，您输入的密码错误，请检查后重新输入。</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">当前文章不能被校验,</span> <span class="string">不过您还是可以看看解密后的内容。</span></span><br></pre></td></tr></table></figure>

<p>之后，需要清除缓存后重新生成 <code>hexo clean &amp;&amp; hexo s -g</code>。</p>
<p>其中的 <code>tag</code> 部分：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tags:</span></span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br></pre></td></tr></table></figure>

<p>表示当在文章中指定了 <code>private</code> 这个 <code>tag</code> 后，该文章就会自动加密并使用对应的值 <code>hello</code> 作为密码，输入密码后才可查看。</p>
<p>相应的文章头部设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Password</span> <span class="string">Test</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-21 11:54:07</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h4 id="在全局加密配置下禁用某些文章的加密"><a href="#在全局加密配置下禁用某些文章的加密" class="headerlink" title="在全局加密配置下禁用某些文章的加密"></a>在全局加密配置下禁用某些文章的加密</h4><p>可能有这样的情况，属于 <code>private</code> 标签下的某篇文章在一段时间内想要开放访问。如果在描述中加上密码提示： <code>当前文章密码为xxx，请输入密码后查看</code> ，来让用户每次查看时都要先输入密码后再查看，这样的操作又会给访客带来不便。</p>
<p>这时可以单独设置允许某篇文章不设置密码。</p>
<p>只需要在使用 <code>加密tag</code> 的前提下，结合 <code>password</code> 来实现即可。在博客文章的头部添加 <code>password</code> 并设置为 <code>&quot;&quot;</code> 就能取消当前文章的 <code>Tag</code> 加密。</p>
<p>相应的设置示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="literal">No</span> <span class="string">Password</span> <span class="string">Test</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-21 11:54:07</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h4 id="在全局加密配置下设置非全局密码"><a href="#在全局加密配置下设置非全局密码" class="headerlink" title="在全局加密配置下设置非全局密码"></a>在全局加密配置下设置非全局密码</h4><p>在全局加密配置下，我们可以通过设置多个 <code>加密tag</code> 来为多篇不同类型的文章设置相同的查看密码：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tags:</span></span><br><span class="line">- &#123;name: private, password: hello&#125;</span><br><span class="line">- &#123;name: jiami, password: world&#125;</span><br><span class="line">- &#123;name: 加密, password: jiesuo&#125;</span><br></pre></td></tr></table></figure>

<p>那么可能有这样的场景：</p>
<p>属于 <code>private</code> 标签下的某篇文章想要设置成不一样的密码，防止用户恶意通过一个密码来查看同标签下的所有文章。此时，仍可以通过 <code>password</code> 参数来实现：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Password</span> <span class="string">Test</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-21 11:54:07</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;buyiyang&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>该文章通过tag值 <code>private</code> 做了加密，按说密码应该为 <code>hello</code> ，但是又在信息头中设置了 <code>password</code> ，因为配置的优先级是 <code>文章信息头 &gt; 按标签加密</code>，所以最后的密码为 <code>buyiyang</code> 。</p>
<hr>
<h4 id="解密后目录不显示"><a href="#解密后目录不显示" class="headerlink" title="解密后目录不显示"></a>解密后目录不显示</h4><p>在为某些文章设置了 <strong>加密后查看</strong> 之后，不经意间发现这些文章的目录在解密后却不显示了。</p>
<h4 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h4><p>从插件的 <code>github issues</code> 中我找到了相关的讨论：</p>
<ul>
<li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/issues/16">解密后目录不会更新 · Issue #16 · D0n9X1n&#x2F;hexo-blog-encrypt</a></li>
</ul>
<p>原因：</p>
<blockquote>
<p>加密的时候，<code>post.content</code> 会变成加密后的串，所以原来的 <code>TOC</code> 生成逻辑就会针对加密后的内容。<br>所以这边我只能把原来的内容存进 <code>post.origin</code> 字段。</p>
</blockquote>
<p>找到文件 <code>themes/next/layout/_macro/sidebar.swig</code> ，编辑如下部分：</p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418165143.png"><img src="https://gitee.com/leafney/blogimage/raw/master/blog/20210418165143.png" alt="20210418165143"></a></p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418165143.png">20210418165143</a></p>
<p>插件 <code>hexo-blog-encrypt</code> 对文章内容进行加密后，会将原始文章内容保存到字段 <code>origin</code> 中，当生成 <code>TOC</code> 时，我们可以通过 <code>page.origin</code> 来得到原始内容，生成文章目录。</p>
<p>相应的代码为：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-inner&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name">set</span> display_toc = page.toc.enable and display_toc %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> display_toc %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (page.encrypt) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="template-tag">&#123;%- <span class="name">set</span> toc = toc(page.origin, &#123; class: &quot;nav&quot;, list_number: page.toc.number, max_depth: page.toc.max_depth &#125;) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">else</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="template-tag">&#123;%- <span class="name">set</span> toc = toc(page.content, &#123; class: &quot;nav&quot;, list_number: page.toc.number, max_depth: page.toc.max_depth &#125;) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name">set</span> display_toc = toc.length &gt; 1 and display_toc %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-nav motion-element&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>修改完成后，执行 <code>hexo clean &amp;&amp; hexo s -g</code> 并重新预览。</p>
<p>效果如下：</p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418165529.png"><img src="https://gitee.com/leafney/blogimage/raw/master/blog/20210418165529.png" alt="20210418165529"></a></p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418165529.png">20210418165529</a></p>
<p>不过，这样的效果貌似不是我想要的。我理想中的效果应该是：</p>
<ul>
<li>当文章加密后，访客只能看到侧边栏中的 <code>站点概览</code> 部分，不需要看到 <code>文章目录</code> 部分。</li>
<li>当文章解密后，访客则可以看到 <code>站点概览</code> 和 <code>文章目录</code> 两部分。</li>
</ul>
<p>而现在加密后的文章未解密之前也可以看到 <code>文章目录</code> ，虽然该目录不可点击。</p>
<p>当然，如果你不是很介意，那么到这里就可以结束了。如果你和我一样有一些 <strong>追求完美的强迫症</strong> 的话，我们继续。</p>
<h5 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h5><p>查看了 <code>hexo-blog-encrypt</code> 相关的 <code>issues</code> ，我找到了一种 <strong>折中</strong> 的解决方法。</p>
<p>从 issue <a href="https://github.com/D0n9X1n/hexo-blog-encrypt/issues/67#issuecomment-463893408">Archer主题解密后TOC依旧不显示（已按手册修改）</a> 中我们可以知道：</p>
<p>我们可以在文章加密的前提下，通过将目录部分加入到一个 <code>不可见的div</code> 中来实现 <code>隐藏目录</code> 的效果。在源码中的 <a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/479ccd4cf522adc8f667cfa06290f057a219cb88/lib/hbe.js#L207">hexo-blog-encrypt&#x2F;lib&#x2F;hbe.js</a> 部分我们也可以看到，解密后通过设置 <code>id</code> 值为 <code>toc-div</code> 的元素为 <code>display:inline</code> 来控制显示隐藏。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (page.encrypt) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-div&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">else</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-div&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">xxx这里是目录部分xxx</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>对文件 <code>themes/next/layout/_macro/sidebar.swig</code> 修改后的代码如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!--noindex--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-toc-wrap sidebar-panel&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (page.encrypt) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-div&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">else</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toc-div&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> display_toc %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-toc motion-element&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; toc &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--/noindex--&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但这种方法并不是完全的加密，而是采用 <code>障眼法</code> 的方式，通过查看html源文件还是可以看到目录内容的，只是不显示罢了。</p>
<p>对于这个问题，<code>hexo-blog-encrypt</code> 插件的作者也作了说明：<a href="https://github.com/D0n9X1n/hexo-blog-encrypt/issues/162">next 主题内没有 article.ejs 文件【TOC 相关】 · Issue #162 · D0n9X1n&#x2F;hexo-blog-encrypt</a></p>
<h5 id="只好妥协"><a href="#只好妥协" class="headerlink" title="只好妥协"></a>只好妥协</h5><p>因为该插件中目前只有一个参数 <code>page.encrypt</code> 可以用来判断当前的文章是否进行了 <strong>加密处理</strong> ，而不能获知该文章当前是处于 <strong>加密后的锁定</strong> 状态，还是处于 <strong>加密后的解锁</strong> 状态。如果再有一个参数结合起来一起处理就好了。</p>
<p>所以，目前只能在解锁前隐藏目录，解锁后再显示目录。但在解锁前目录区域还是会展开，只是没有内容显示罢了。</p>
<hr>
<h4 id="让加密文章显示加密提示"><a href="#让加密文章显示加密提示" class="headerlink" title="让加密文章显示加密提示"></a>让加密文章显示加密提示</h4><p>类似于我的博客文章列表中的 <code>文章置顶</code> 的提示效果，考虑在文章列表中对加密的文章增加类似的 <code>加密</code> 提示信息。</p>
<p>上面对于文章的加密处理，一方面是在 <code>配置文件</code> 中添加的 <code>tag</code> 全局配置，另一方面是在单个 <code>md源文件</code> 中添加的 <code>password</code> 参数。所以我们需要对这两种情况分别做处理。</p>
<h5 id="对于password参数的情况"><a href="#对于password参数的情况" class="headerlink" title="对于password参数的情况"></a>对于password参数的情况</h5><p>针对于 <code>password</code> 字段，参考获取其他字段的方法，比如获取标题用 <code>post.title</code> ，获取置顶用 <code>post.top</code> ，那么获取 <code>password</code> 就是 <code>post.password</code> 了。</p>
<p>可以参考我之前添加置顶提示信息的操作，对文件 <code>themes/next/layout/_macro/post.swig</code> 的修改如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;# 加密文章添加提示信息-for password #&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> post.password %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FD7E13&#x27;</span>&gt;</span>[加密]<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="对于tag标签的情况"><a href="#对于tag标签的情况" class="headerlink" title="对于tag标签的情况"></a>对于tag标签的情况</h5><p>针对于 <code>tag</code> 标签的获取，可以从文件 <code>themes/next/layout/_macro/post.swig</code> 中找到类似的处理方法：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">&#123;%- for tag in post.tags.toArray() %&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123; <span class="name">url_for</span>(<span class="name">tag.path</span>) &#125;&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">tag_indicate</span> &#125;&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;&#123; <span class="name">tag.name</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;%- endfor %&#125;</span></span><br></pre></td></tr></table></figure>

<p>即可以用最简单的 <strong>遍历法</strong> 来处理：</p>
<p>我们获取到配置文件中设置的所有 <code>加密tag值</code> ，再找到文章中的 <code>tag标签</code> 。二者一对比，有匹配的项则说明该文章设置了 <code>tag值</code> 加密。</p>
<h5 id="swig文件"><a href="#swig文件" class="headerlink" title="swig文件"></a>swig文件</h5><p>要在 <code>.swig</code> 文件中实现相应的对比逻辑，就需要了解其使用的语法格式。而对于 <code>swig</code> 文件，使用的是 <code>Swig</code> 语法。</p>
<blockquote>
<p><code>Swig</code> 是一个非常棒的、类似 <code>Django/jinja</code> 的 <code>node.js</code> 模板引擎。</p>
</blockquote>
<p>不过看到这个代码库 <a href="https://github.com/paularmstrong/swig">paularmstrong&#x2F;swig: Take a swig of the best template engine for JavaScript.</a> 已经 <code>归档</code> 了。</p>
<p>但因为 <code>Swig</code> 是类似于 <code>jinja</code> 的模板引擎，那么我们直接去参考 <code>jinja</code> 的语法就可以了。</p>
<ul>
<li><a href="http://docs.jinkan.org/docs/jinja2/templates.html">模板设计者文档 — Jinja2 2.7 documentation</a></li>
</ul>
<h5 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h5><p>获取全局配置中 <code>encrypt.tags</code> 的值：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (config.encrypt) and (config.encrypt.tags) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">for</span></span> ctag <span class="keyword">in</span> config.encrypt.tags %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; ctag.name &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>在文章列表中获取当前文章包含的 <code>tags</code> 列表：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> post.tags %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">for</span></span> ptag <span class="keyword">in</span> post.tags.toArray() %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; ptag.name &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于其中展示的文本格式，可以参考已有的 <code>发表于</code> <code>更新于</code> 这些副标题的格式来实现。</p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;far fa-calendar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>发表于<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">time</span> <span class="attr">title</span>=<span class="string">&quot;创建时间：2021-02-28 11:18:43 / 修改时间：11:41:19&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;dateCreated datePublished&quot;</span> <span class="attr">datetime</span>=<span class="string">&quot;2021-02-28T11:18:43+08:00&quot;</span>&gt;</span>2021-02-28<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对其进行优化，我们只需要显示提示文字，不需要后面的带下划线部分，最终得到的就是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FD7E13&#x27;</span>&gt;</span>[加密]<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>整合上面的代码，对于文章中包含 <code>password</code> 的文档，通过如下方式来显示：</p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170147.png"><img src="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170147.png" alt="20210418170147"></a></p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170147.png">20210418170147</a></p>
<p>相应代码：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;# 加密文章添加提示信息-for password #&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> post.password %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FD7E13&#x27;</span>&gt;</span>[加密]<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于文章中包含指定加密 <code>tags</code> 的文档，通过如下方式来显示：</p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170209.png"><img src="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170209.png" alt="20210418170209"></a></p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170209.png">20210418170209</a></p>
<p>相应代码：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;# 加密文章添加提示信息-for config tags #&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    // 获取全局配置中的加密tag</span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (config.encrypt) and (config.encrypt.tags) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">for</span></span> ctag <span class="keyword">in</span> config.encrypt.tags %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        // 判断当前文章中是否包含tags</span></span><br><span class="line"><span class="language-xml">        </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> post.tags %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          </span><span class="template-tag">&#123;%- <span class="name"><span class="name">for</span></span> ptag <span class="keyword">in</span> post.tags.toArray() %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            // 如果有相同的tag值</span></span><br><span class="line"><span class="language-xml">            </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (ctag.name == ptag.name) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">              // 显示加密提示信息</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FD7E13&#x27;</span>&gt;</span>[加密]<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于两种都有的文档，我们只需要通过一个 <code>判断</code> 来处理就好了：优先判断文档中的 <code>password</code> 字段。当文档中包含 <code>password</code> 时，就说明是加密文章；否则就去判断配置文件看是否为加密文章。</p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170330.png"><img src="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170330.png" alt="20210418170330"></a></p>
<p><a href="https://gitee.com/leafney/blogimage/raw/master/blog/20210418170330.png">20210418170330</a></p>
<p>最后的代码为：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;# 加密文章添加提示信息-for password #&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> post.password %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FD7E13&#x27;</span>&gt;</span>[加密]<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">else</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  </span><span class="comment">&#123;# 加密文章添加提示信息-for config tags #&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (config.encrypt) and (config.encrypt.tags) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">for</span></span> ctag <span class="keyword">in</span> config.encrypt.tags %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> post.tags %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="template-tag">&#123;%- <span class="name"><span class="name">for</span></span> ptag <span class="keyword">in</span> post.tags.toArray() %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          </span><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> (ctag.name == ptag.name) %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FD7E13&#x27;</span>&gt;</span>[加密]<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>稍微不好的一点就是，上面的操作是通过 <code>两个for循环</code> 来处理的，会导致一些性能问题。不过这个操作是在编译过程 <code>hexo g</code> 的时候来处理的，不影响博客浏览，也就可以忽略了。</p>
<hr>
<h4 id="更换图标"><a href="#更换图标" class="headerlink" title="更换图标"></a>更换图标</h4><p>对于需要显示的图标，可以从网站 <a href="https://fontawesome.com/icons">Icons | Font Awesome</a> 中获取。</p>
<p>例如，我这里选择的是 <code>锁</code> 的icon图标，得到的代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-lock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
  </entry>
  <entry>
    <title>Hexo博客进阶：为 Next 主题添加 Waline 评论系统</title>
    <url>/posts/a07389a8/</url>
    <content><![CDATA[<h1 id="Hexo博客进阶：为-Next-主题添加-Waline-评论系统"><a href="#Hexo博客进阶：为-Next-主题添加-Waline-评论系统" class="headerlink" title="Hexo博客进阶：为 Next 主题添加 Waline 评论系统"></a>Hexo博客进阶：为 Next 主题添加 Waline 评论系统</h1><p> 发表于 2022-01-20 分类于 <a href="https://qianfanguojin.top/categories/Hexo%E5%8D%9A%E5%AE%A2/">Hexo博客</a> 阅读次数： 44 Waline： 本文字数： 2.2k 阅读时长 ≈ 4 分钟</p>
<p>文章发出之后，往往我们想要得到读者更多地反馈，那么拥有一个评论系统是至关重要的。</p>
<p>本篇带大家通过一些简单的配置，在 Hexo Next 主题下添加 Waline 评论系统。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的 <a href="https://qianfanguojin.top/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/?highlight=valine">Hexo博客进阶：为Next主题添加Valine评论系统 | 谢同学的博客 (qianfanguojin.top)</a> 文章中，我叙述了如何 在 Next主题下配置 Valine 评论系统。</p>
<p>但是，根据读者反馈，Valine 评论系统在 Next 主题高版本 (7.+) 以上已没有支持，且 Valine 已经很久没有更新维护了。不过，有大佬在 Valine 的基础之上开发了 <a href="https://waline.js.org/">Waline</a> 。<br>这次，我们就来描述如何快速上手安装配置更加人性化且带后端的 <a href="https://waline.js.org/">Waline</a> 评论系统。</p>
<h2 id="1-第一步，配置评论数据库"><a href="#1-第一步，配置评论数据库" class="headerlink" title="1. 第一步，配置评论数据库"></a>1. 第一步，配置评论数据库</h2><p><code>Waline</code> 和 Valine 一样，也是支持基于 <a href="https://leancloud.app/">LeanCloud</a> 作为数据存储的，但是 <code>Waline</code> 支持的部署方式更多：</p>
<table>
<thead>
<tr>
<th></th>
<th>Waline</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Client</strong></td>
<td><strong>Server</strong></td>
<td><strong>Storage</strong></td>
</tr>
<tr>
<td><a href="https://waline.js.org/">@waline&#x2F;client</a></td>
<td><a href="https://vercel.com/">Vercel</a></td>
<td><a href="https://leancloud.app/">LeanCloud</a></td>
</tr>
<tr>
<td><a href="https://minivaline.js.org/">MiniValine</a></td>
<td><a href="https://deta.sh/">Deta</a></td>
<td><a href="https://clodbase.net/">CloudBase</a></td>
</tr>
<tr>
<td><a href="https://github.com/asforest/AprilComment">AprilComment</a></td>
<td><a href="https://cloudbase.net/">CloudBase</a></td>
<td><a href="https://mongodb.com/">MongoDB</a></td>
</tr>
<tr>
<td></td>
<td><a href="https://inspirecloud.com/">InspireCloud</a></td>
<td>MySQL</td>
</tr>
<tr>
<td></td>
<td><a href="https://railway.app/">Railway</a></td>
<td>SQLite</td>
</tr>
<tr>
<td></td>
<td><a href="https://render.com/">Render</a></td>
<td>PostgreSQL</td>
</tr>
<tr>
<td></td>
<td>Docker</td>
<td><a href="https://github.com/">GitHub</a></td>
</tr>
<tr>
<td></td>
<td>Virtual Host</td>
<td><a href="https://docs.deta.sh/docs/base/about">Deta Base</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://inspirecloud.com/docs/nodejs/database/quickstart.html">InspireCloud</a></td>
</tr>
</tbody></table>
<p>为了方便，这里我只讲述最简单，零成本的数据库建立方法。</p>
<p>我们需要注册一个 <a href="https://console.leancloud.app/register">Leancloud 国际版 </a>的账号，注意，一定要是 <strong>国际版</strong>，国内版需要绑定备案的域名，比较麻烦。具体可以在注册时的左上角看到：</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201202316763.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201202316763.png" alt="img"></a></p>
<p>注册完成后，登录，然后我们找到<code>创建应用</code></p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210815161252.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210815161252.png" alt="img"></a></p>
<p>在这里填写你的应用名称,名称可以自己定义，然后，下面选择<code>开发版</code> 点击<code>创建</code>。</p>
<p>然后点击应用进入设置。</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614201.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614201.png" alt="img"></a></p>
<p>点击应用凭证，取得我们 <code>AppKey</code> 、<code>App id</code> 、以及 <code>MasterKey</code> ：</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211139993.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211139993.png" alt="img"></a></p>
<p>数据库配置完毕，接下来安装服务端。</p>
<h2 id="2-安装服务端"><a href="#2-安装服务端" class="headerlink" title="2. 安装服务端"></a>2. 安装服务端</h2><p>由上面的表格可以看到，<code>Waline</code> 支持多种服务端，为了最简便上手，我们使用第一种方式，即在 <code>Vercl</code> 上安装服务端。首先，点击下面的按钮，一键部署：</p>
<p><a href="https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example"><img src="https://vercel.com/button" alt="Vercel"></a></p>
<p>应该需要注册一个账号，支持使用 <code>Github</code> 账号直接登录：</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211306146.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211306146.png" alt="img"></a></p>
<p>登录后重新点进来，点击 <code>Create</code>：</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211309809.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211309809.png" alt="img"></a></p>
<p>然后等待下面 <code>Deploy</code> 构建完成，点击 <code>Go to Dashboard</code></p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211313406.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211313406.png" alt="img"></a></p>
<p>找到 Settings &#x3D;&gt; Environment Variables，配置环境变量：</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211314501.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211314501.png" alt="img"></a></p>
<p>我们需要配置三个环境变量，对应如下表：</p>
<table>
<thead>
<tr>
<th>Lean Cloud</th>
<th>Vercel Environment</th>
</tr>
</thead>
<tbody><tr>
<td>AppID</td>
<td>LEAN_ID</td>
</tr>
<tr>
<td>AppKey</td>
<td>LEAN_KEY</td>
</tr>
<tr>
<td>MasterKey</td>
<td>LEAN_MASTER_KEY</td>
</tr>
</tbody></table>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211330222.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211330222.png" alt="img"></a></p>
<blockquote>
<p>提示</p>
<p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p>
</blockquote>
<p>为了使环境变量生效，我们需要重新构建一次。在上方找到 Deployments ，选择第一个右边的三个点，点击 Redeploy 。</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211333672.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211333672.png" alt="img"></a></p>
<p>等待其构建结束，然后记住 <code>DOMAINS</code> 中的域名地址：</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211413737.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211413737.png" alt="img"></a></p>
<p>好了，服务端部署到此结束，下面我们开始在 <code>Hexo Next</code> 主题中配置客户端。</p>
<h2 id="3-在Hexo-Next主题中配置"><a href="#3-在Hexo-Next主题中配置" class="headerlink" title="3. 在Hexo Next主题中配置"></a>3. 在Hexo Next主题中配置</h2><p>由于 Next 主题中并不自带 <code>Waline</code> 的评论配置，我们需要安装官方提供的插件。在 <code>Hexo</code> 根目录执行：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">npm install <span class="symbol">@waline</span>/hexo-<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>找到 Next 的主题配置文件，在最后加上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline</span></span><br><span class="line"><span class="comment"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">waline-server-pearl.vercel.app</span> <span class="comment"># Waline #服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请文明评论呀</span> <span class="comment"># #评论框的默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># 自定义评论框上面的三个输入框的内容</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论数量多少时显示分页</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># 语言, 可选值: en, zh-cn</span></span><br><span class="line">  <span class="comment"># Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [] <span class="comment"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url</span></span><br></pre></td></tr></table></figure>

<p>重新部署 <code>Hexo</code> ，就可以看到结果了。</p>
<blockquote>
<p>据反馈，Hexo 似乎在 8.x 的版本使用 waline 比较稳定，如果出现 <code>hexo g</code> 出错，可尝试升级 hexo 版本。</p>
</blockquote>
<h2 id="4-登录服务端"><a href="#4-登录服务端" class="headerlink" title="4. 登录服务端"></a>4. 登录服务端</h2><p>由于 <code>Waline</code> 有服务端，支持评论管理。我们需要注册一个账号作为管理员。</p>
<p>找到评论框，点击 <code>登录</code> 按钮，会弹出一个窗口，找到用户注册，默认第一个注册的用户为管理员，所以部署好一定要记得及时注册。</p>
<p><a href="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211432511.png"><img src="https://cdn.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211432511.png" alt="img"></a></p>
<p>注册好，登录之后即可进入评论管理的后台，可以对评论进行管理。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>经典动态规划：打家劫舍系列问题</title>
    <url>/posts/5cd5216c/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="e53fc1e6e345957f0230ba06119f11eeaa4ab4c496441ffcbab6c2578d111785">d0887b061916fa4336825c648648024650420a30bcdcd73b3bacf4e441f5343e37d69d9430ea3deb9557df5a9410deb1dc7e1c7d38d3aa429ac991117ac0d3132196e471369d5ba05309a3c2a210561d84366a5599f0984b8b8451e1e85d1d07d591e1ef79e20a9147ed5682fcc12ade2bc669aa39b107e4553e8ad1b327948d6b71d706b682e36e37197592022148fb9666b92b510157969d4e69cba8ac392f84351a522351a6244f06f94290eb574c8f82c48b6541a96477ac26fdeb75748380bf81dd65fc2d4e1aac5fcaf9eb6006a723df19ee5378b02fefab623833eb4e55315ec5a9bf81519c8a4fe16f260d6e793024dccd69dc5ab03a5912904a8f463f9e1335829a55877e111c1ed9e892b013ec5c28efd95412cea2ba7eb5d24a53383018ece51ccdbd1865a8aef33f24b8f54c63d90e449225a3ec273b80da23737d0c53ee0fffc25f22a7de427be6968547d9a2589a51a3ee21de6e3366b7d3803462ac0e2555731bc0047ffa5832e29a0d00b1980d2de9ae2324773aa773ec2d7d4209e9496375c15306d2e65e90748f93c42c6f22d4a895fa0394438289c130952b48b8ee41e3ad3d7c2e2a71fc811f6a25045d910d0d6f747aabf964e0ade36567311dafdb727f7dccd48bd0f5bb78aab397a3d8dfb8ae8c16f2d9adceedc1265a766287b5106d048f98412693dff1dd1e43d2fbc53d48614a9b8d13c8d1c11eaaf6271771ce13ae10c525b2c267b86b8f636daf69e0c3e85912c45877039d7bc8d3c905cf81ad8d36d7d3b9a80dd8609d394931d153da4222f3729ab3c574c44559728d86e66538d1b10250a1d334d10a7428bfedb55fb2b6d2fc3c51676aee8ab115da95cb959ae2d80c872ab922bc5a8cec35fa4d22b224fd425daa714499022e28e5513a70f8f5988f1c2065cf8463b443761b36a7fcaae7f78254095c5d690a8808e2374417d210971214b607d566f7eeb568171114e639585f907b40e123fabaa631a5c093fe34474eb9304e75ca1ddcc0fb9189d4cb16329bb4d2032e32511d71828fc7f4caef95ae6c52832b5b369e82a52a2b796abfd2803d84eb4b7398573609d4a146badb7e0531858b6a1356ac572977f19a132fb16ed2bf7907774ad691baefed5a1d0a9d6b1cb117ea2cb8ff406ecf66bb04ffc097914dead4e5d4e2ebc679860a9d99146831b7aae4c43a7fd0cf933eccda419a665057d7d6e0efa0a3e717ce3efcd0208ba01cb3db26bd997b34465715cbe5fa7bf380e9cad42b0fde7ccc4788403d54dd094c967ce9f1efa049a15f422afd6f04dabb01fa5da27b9a40e395fafb4213e8ce8274d00779d7d3f44ace67fb106a158dc033df227551f2071286b418dffa6b58e4dbda1de45b02511793778a82a2ac294f03b21e00235d7b7fa5ea778197db332bb2968659c65ae423455eeeb87e98abeaa761513483941efa6c2bbe997e1a488385f4759b67240c50ff39a48f105d8ba102b1a3f72daedaf512d59304a73e24d691fc577c481bf36024d4c6848d7b0f9e73e1a3d0830f3d247a34d90420ba14bbe698f6e09ab92f5368b6cd26f713731dd877d037bdb4d24a69bce95a6d595b18c690e2aa7c0b044f44bacb3e1944a8834a93a1bc3354512eda730e17ea19aa94b7d193911730fa76d73998cd85b8f823e1112557dda9cf85f78e468fdee01feb4811f6d37aee5d61cabde67a9f2b00ef69f9dc01ca22e963eb4bcc273d885086340a1b511ddeec80d61e77c709f14ec93f3e2844d70375cf7b958f77fb36f7b08bd6b5c200b62b38c390c354e2813e0c4cdd7231454ac537f16f16e895b8738aef19b59c8a90c9fc1f939d9054b6d1ce32f2473fa7f34697e16846445859045a43713fe71ab36092781e331efac4864d67b956fe6df80c5ef8e7fa6d65652447bb60b74c265ebbf3e4f78826ee6ebfc8b8d1abc35205a6be6d039e065b58b2dd3dfeab184c60c02818b4b64a88e033de8469696615a7b115bae831a43c69c1386ad1655d02a0499c7d46a5556265ca8086900059ca6cb7b6194a3dd893fe045078ffbc49a708ae9a8ac203bdcf4f0a92acc1e63d9fd146e31c85450a66f51a2611504ebf48426a5585156580e0ed0a332ada2503655b4f11752f2b03ee12682d11aff902ae58d07066fd02451f455a59eba3c760a348a35f34145f15c31f481b4f63924046f8ad281a150ae1b805b6b9c1fc1ed716407be846128eeda8375d6d1e51366e5d6040711ceff37f0106c0082a77eea378d353333fb3ceccb4c6dfb93b2cce20383bf5771c503a2a23ef7c543c32176851cda3cee730277335124a87b2e252dacf2121314677e15648eae6848ccf7ab2ef5747d20473fa10fcb179b923dd32a4f747e2b4371728339d72b3c0493ec7b52ea597aa950f146cfaf40e9e6649a9c8af460abdd9e34979890678492fc68679d29228c9761e3a3e4bc49cc379e167e210998167622f2165cd29e546ae445f9e6f9506e831e64e16afe520b97cf6497e0cbd4634aa98c023b415562df70d067b2ca64b0f2f73063e73512a1f12f078f36d3613d1889e04e197a373fde1dd64db3c19129af319f1dc128b74ca99170ef7d92c71aff66b011d6e0769d64cbad5e2143c5575727b0195732bf5b611172f21e9d6a14986f3064d69f71f26fb8c509f6b8dc05e0262c2e0f93bbc6ace2a4fbc1ceaf993e52021b37e7b7958b1248ab58739b7c48210361d7da95a02757616f01ca2ece9cf656e0e93ab7a673f72550fc6e22201c5216d1c797fa86de610dda3161955f37f22eb2bc3c5a66e9e35cc81406e46fac0c7ffbf83689c13972b1b5981258a0118d20eae84ad8aa5fe1927385e2fe8cb120980661a2eb7325a4c3e6f1bc86a44e7dcb70452f27798a4269a905ed77430aad1e718c4ea68995eeecb2ee9688a3fc88cef4f57d1b23db8b984bdfcf8641abfa1e9a76b2480ab0a5c4e85abade7359bc60cd94c28cb39f332e6789b05341c2b08e4ce9835db822c0ae59ade4d5668cb80d189fd245f8b344a3ad819d00c37cea181d440b2c1b0909f9cb12682b9c6a38ccb6cbab0be24012ef851f6c7c1750a78145222dd74844a1b775a7cbda4fdc420376206847a5784eb4cf538baa08759ac118b2c7bb5f6f96adf6d34f997b6de8d61e47be2a1804654ecf178992e5ad89265233b5c77be7a0d96b529269fe96bc5591458136047ae761eb8d18daf816446635edc90eedf3e4a53ca56195ffd7af30084dd231bea5c861096f4dc78c2438c453ae1cc84e103310ffe41d55b815f7a73608dd121bfd9446a13516f0b45e8a55a49bd790b5bdac7fbb252db5a9b6880440a65fb08b35241958248694430a25bf273bba0ed16e15e49d0b338ad3f00a2f527d31bad6fa17b5d649b453f6a6aaf5a4a0d110252a5718827b90462976d2b5cd93b9a204aef24d0a025121fbcccafeae31fc67b74391b3dc99d59028ebc370abef5de8069874f49957a9808db6f3fc70d683c941316bf6fb5e42414356d64230140e6a986e789fa03cf0897acce154825b53a95b0e9544ef90f31f6de6c23386d7d5f877fcf94ff9f8fd13ea5b4b0c0013f381471a8b17eebec78321ccb45b24dad17dc7fa26f37398d473370b4816b06070d7917834ab93eb0b80dc3daa769f32c7730dbb400c003ad3a361cfa9f8df627f9eca2dcebecbfff17d3064d523d294f3fdd8a2612433dda20e95140e4a71175ea43e09c975013f3721306bee4edf238a83aa29d9af4bf395180a628432afbbf0a420fa2f8c129eb2f13aa6dc1e28ec6d64c71bcca24ebdea461ace7668bdacc8a56d875b7696cfa2c1767bbbbd2ef1b5f2768284cc218d78ed8ea748f4ce2ecc538f75c3bb7854066a3328b92f64e6d08939f80c3fbaa771bd564da1c904282e530bfbe78315c82688a39dfa1da0a37eeac9a95c8a8b2a67825f6c63e1b2e590c44e294217f7809ff754eba645d81551f21040c89383f621031a1cb2d0e06c9afe1298332005d0c92e0c1b5acd463068af062b89c7f052951dbb2cce0a43da086adf0e3c53a475bf4142187f4cb4d911d570714d837797d8aa05e2f6c6790629b3ad06c7fc6d2dd8bcee8d64faef91459982966b3c0776c89fd49b06a429f949995c6d5d81504343b38176b9b9e584d3d8afe61dc17bf2364128d4ded229d1addd89cdb52791023df19338f9caf7a4c62ae185d8332539592ed871c79d532469d64ff9d5bfd96179dbee472bcc3466912f009e540619900119a7011efabcb5cec84c11bbd15fecff7e50376e18b86373d26d76bcad6dc108660b8d278849c3bb961e1f3152c70a1cfc0c8e718cb61ef2e24770828189aa3a4614b1fa146147150251c39082db2d6efd39707b5b21604a8f6226d7be47783009aafd73ee85fc6f14eef6220d1f88cc920b404a8182ba329e2932458020151e668a19e7f1eb555d603af57d62e9e077f29525773a210482903857a86fff9dce539b11648ef93573c57919e16e8c377d2d75f7a3d3186e5835ea691ae96ef93d91ae39c818779b6a624305a889ca815147bce4783aa9f7e1fbff18336c85293bd403ed21e65f67af55ffd0d73e7bdbb37446cb09831735824c015453150ba47bb22a14899586903e807066a6d67fc4b3db6167c0a5670a587e8cb44ebf820fd7146c8a0e2c0f8f6084f825059b9a353ec50f4dbd1a1e58d4cd9caf1bd9262c41c32b709694eb0afe3d36027b0216b7adb0607860f07d7d6c5ed3e5348d063021dfcf80f373657397b7e53429990709950b3a21dc6ae07ca2463f26ca958e4d5395331c8814a89cd530ee75aa473e7331ee19d99f1780bf9d463e8bd1dca7fe909f9174c3f45d8dd7b5032e27fcd7561c79cc4a20636b9c9def89d75120fc6eab347ab112b18be0696cd2c03bab76842ba83bc1bbbef6ac270a201453833c52db6e54b273488ca4cb021babfd4093ccd0b11bb3eb399e015e10102a0d5d208c2ab59fe15231ebf9b7324b15bbda0867e6bcd72fa749c29d52370888cdba5cb7968775fa56f204652c172ffc4dff5ed4d39114ec96a0a0195a41e49269127f537149e83f7958cc0dfa510061c9d44f7c7580484fd4c574312289f17db1e802e6d179e34e2abbe8db0b98fc549101961d713e5330fa996f692f46ecdcd12bc2d45be6a9296eb4b3e48a5f1739fefeb449ec3351ed854f4b0775dd2da9c6c32fa85b4630e2b445dd811383692a1fb59ed39ee601100d998a9b519884f0a6270e64d554f62fd5aa8393f38e41bbc27e00dd270faa670aeb857e2630b7d33e7594c7caa53b16a34af90bbf69dcea783599f7031aae59c7e12b54a920e435b6c55978f66ee94f522a4f95ea7c5a69c876c452ca1cde656ab267594e415154db0718832e39f2cd4b661fcfa11357219cdd82b6a25206e0465816d2fef1a56fe41500e82cbce348595bf785f0bd20b425aefbf90ea1eec1a37cd86f8e239630b89596876135217f928d86d009567e42acbc91a39ac8352afa5afacfbc461a99a70f8687eb7388a3e5c17f7827db5983628f50044eb5295f97806e0232ece8635caddecdb37cbbb6c5a42db1d7559193f792df4f0a1291947fb5a0024a1c7ac6aceefc439c44660d2fc27609d65f81909e039712b11338fc04545244e270368333f2a74513738ec742db344b21f5b2097bc975fe3dcd05a185b7f72208b4b26fe6f7a3d17a5ea778dd204da5f3392d17e669e931bed444e793bb7069ab7671ea1f1b57f6b3edec7ebc4c4a251fc6b7c447068ba0ba3c5a8bcef2aa08261e188829680caa4efdd032feebe29470b78fb32eb5dbc9dbba1dfc81d73cd4a041fd63d1d88a6c478c1b197fd6a232f2d54682098bf22bc6c8264000f9ecf5b165ad800cb5038213076cf4e4f424e93658738fc9b7bdf19eae2366a5c625c1c744356827c112c2784f5f17d083d25b0f8c71f24e9d678f102ed1e37237c4d7c87be93a092f1d792d35153e5dd06f1abad321dfc87317566d5ef325f1abb87f38b6d1942ddc98dbfde5f469e5aba58a5cc375efa2bda1643d84dbc32f96d7060fecbf3d3bd9a925b903d1dc92c3456e048dc42e6028ada193b185346a9952c98ef75f3191ccb32748f394a917cb763f1e1cf71e5405c8575a3ef5f89ddb10047dc6eb465034c5e2480a1fe9492eb11a5f3170f5fa1b161ab219fabd4f4728580f5b890a9edc3ee812e7a812bad3353d110da030d266692ef282b5a1a04a2a61dc4045d5ecb661e294880a9e72abe5e48c20143fa6840fbd5862ea3d89e4d5b56323b42e90c688948a1c563f577d82e0295df084a26456411a21eafb9be806efd05e97fe8c0be615a2776ef9af8f87183decacb21dd6283e76c0ea4b6cb11a517d259595d7dad6584086b4acc9a647e0d54185cfb910286a8cc8d1660e4aa681c51cc762bc7e7b60247e0e2037f3de861607430b6f9d9d72aad4e13ddeabaf69b36409d586ff14882b6d3f5d82921a61f058c97ac0dfcc66c304a53cfb54ef629130dc0fcb3b64a34788988eafa78f1c3a8d9e36e22eadacca47bf725ae0f4990e2418c107fc1197dcf25745e9dbb5d920407b82d70a40557be85eabea4c2ec5234fb7dd83727f49e94af24ec7bea8bc5f39b2c84ef7b7320361c468ababd23959959fa23331a468c43c5c20cecd1643fa49bc650ce6757d6d9e7755b8829a77f49fb7f55187783848bc895d9e89a55179239f977a6241cb68f744d16b052b8229b73262fd5c39321bf212649e883226af4ec715ed2afe866aa88ecbadaea908373106d546781d6c15d2941a1d59bf4ac37b388b005cd9d065440ad285d7cc0e1cc627ac4e40b88925fc7f1f63ca54734a1efcf4783a5d49d6bf5377e4692f5837388ac1cda870e625c99546f62cc18d97dfa115a0a6e1ebd2938d0afa1e44b8b037b0f59399ac0d11bfa4ad9ba8ebdfa28a5513030fe57608cc962e7515d9f7412c0ca7d20813148d86cddfd982009abef1a1ffd3a76d3071a93233988c24356ddc496e7f769fe8e20da6ad9df7a09d6cb991fb5338ce9082f22e152a3d642bc1424d1a80489c47abbd188f149e68ac2f8daa9c2e7905638c2a727a8b117bf84a276122db877ed8bea7fbd77abfbe24d9243cf02255bc4aa2be47c8dc18c66a73011db25eea0f369e519fa2082397ff8c2fef200f246033656ac58bc45fab7f46c26f07c272ac1077b5c6812bf2e1eed40d7656cf38627dc5af037119f3640b44ca2e0bd771a5f4b99a1b26549172ab2e31b9fc7098633840e9422f71513310d94a022c09f3e43380cc074c248dba9d97ca24733797bd72bd57396b7e8955f52f657865d966c584a003446104e11346db78890c2410a0f3ab6ea1b78f1a335db4929133906e9c7fd24ee3372184ab7c1541cc2f6ef4ab8a408535a52377393f5cbad4fe718fa36ffbce252701a9b77f9b16105694fdd83aa1b0b287687929a57f66139bea554815d95828fe3863a9f56f5bedae0f826b76b590d0d36a1f9892df4847ae77c22850182c6e0a58dad05fd7a556a2227052ca185a409c8476febfe9c8117f661a988470bdb69bcd214a5993f332fca909ee0a74fda3bc60c9781c9991825e4b2ce62c2d655bd9f1d6dcaddd862bb7633cd70deafb5b0cf98d4f3c13e8009f3c5f56dd45755a7c94190ae9d19cf1aa72023fb1585c08b004f8dbca12ebe50b3d9fa4dae78c196224fc803d8fe50f4782d101e58ddbafef4bc8aaefb7156ab44cd80ca03a6fe1d50bee786e0c6973b8535e9a784421418e71ccadd507e41f78014f1b63c3320d73cf1ad830b0944ec50bde5da9acbf04caeefa09d14b007873aeba91741bbc3ddbfb133ed7e31543c3c0261930c8f5e52e27b9ef2004ce2a744b227d596681ec763ea43cf778907a0e6e7f0bac665ddad61958a2991c51df5d5243221d15742c6005b1ecb22be2a9cae8d690dcefd2a9052eeb73ce080610259d7528bec4827a7326fd99ed722443dd730a4173fa1c7bfd724e65d9c8fffb050b7dd2e3a89af31926c5e812d682168178e067b3c0aae4a0187460d957daaf965e3ce1963f0f492e686e3f4613d45fe29d217a623fd18ea594865e190cc907e63ff8ef277df9932bfd2362ab20b8c2d16661e53a5ac0ddda59b3e310f9cd2d3a641126aa07a9429b632d4806aa9663cdd0d5edd31377cd11d261103bee048731528446c66ebc963ade99c572ba24d42e1ff28fc6250d4eccdf325afc27e10483af8a850277e1c10649415f99b7a18da773e3ff87545d33b6bc03a94077254d13c2b7e9fc36c06dfe006ec21ce78ae1b22e852be0122fb713a0278a8484c8d359cd9ed7d44b991e3519f72d6eca40888aa3fb9bac380b7d3ec6baa5f0b3d66b1e63146e782b6aa3e4fccee9aaaa30ff4d2a6c95982f915734801dd30367016dae4f66d903c0e49cb6debdd2c75ec72dccdc5bb027f79a2da7019967103ff197b09b4af1d26eddba4fbadb72c1162e3821cc36bfeda857656b9f84005585505d2f2228209616929bed8c3c042fdf89bf90c0583dfb87a2ddba1dd81f93aa57d89c0f19b5b8f7d2a1a14aea38e024cbd54bf1af1e2d6898a40a5741af71ad5058ee0c6d937813843455b1f319b2ffcbdecec8d319bc385e8111484e8414d838c756955599ec2c4db0bb8f19db8f9b386ba9d3d1637c227a3a4699e1080596ecb54aa8f00833aa0f1f13c207ad1b0b3c452a9e8224ddfaa98015b87015a00094bfd77bd8098a1911d9130d69d7253b54fc92557e73a306a8f502c142287cf58a8cd41b23890bff24f918074526a623912abf7c904029116f257d823e73e3f7dd05dc11eddb1950e739e7a70ba91ddf0e4f09e8588687009bd4abb1b417b8de64a4ba0b275bd04e2bf6e1e9557da7e6a5f04dfa3743b34abe6cba7b9bc24445a6f4ae3950ff14b00f1f03345e7d32ba6a375436d183f3758ece48f16c613954fe69499445556a06887c7f4632c9e7dca9b5774ac78b03281e9f06cfcc779099faace05ca5ee7c8e035cfde2fd487fbbcb1bec53a8d39a16a9fcb22055559364553bf676290ff5c1c75a0d22b7db475b97192226931d981c105a2f1dbef94ee461558963e9a6bd39ad703fda15bc47ecdc127e35fc6f1f57be38c0d3155cfe63c4ce6694dcd7d29e09622db65661df5d14cfa0ff7740133abc32160257b27ceba4c6b9779dd6098004beeea0396300659043b1b176bc05afcfa62f9b6d4a22f6ecf370807a277722ad824954e183eac7b82d86b318275c851f959f3a3edf9c8d45cf912b6878f21f68f0cee5d4fee05711ceda9cd6f0db35d71efcf909cc97e7b6ba3e94b35648a836343fd127d991a07c803ffc8998006f03031113a6de121d66776eb468564fd0d72839f274f230d5780a48a4f82756633e3beec809ba973af6bdac238a2b6a095ae40160a38711ded9821f769b8a2f302575484cfd14e6fff0a26a84697b31c47ee55a0ed240890c736bd312f68d488c37477a65359a76f948b1036176f589720ee9a94f061e7df59cb1e919ae914994554ed6a144da279abd53c5159bcf374623cc504c966fe107fe24349f84a8cebd3033f2e6a99126e8accedab40b2763387c717aa4c8052da352034b64be1001d417831b8b74f356360eb7d211e6fcaafe3e6abd14bb89dc377cc22351f9b87a5c361b56d8575386b94d6a65d5616a53fa2828b5365372e0afc4f74410f561a85a0478fd38d95dffb68ab7775c1fc8d610296bf92680f32d02bcbca5f2dc79ecc2eee0c01167c8ea43186ea21f37ce315d9c7ed57fb7cfaa7a451addbc0dd1fb9989ec9ff6c8a6e3ee0260bac1fdc7c4a00a4f03d67b0a9771dc5e3c50e2d03f342f9e466ddf2838c1b298232f5e84abe1b5f3fba9aab4236c539455d4b0ef076f2f2c5ff097c19762b79f872c12cc6c1bbc26252b14955b33cd043bcc8d6fe59377e0f9cb576b44c0acf200a3ddf81de79cb53947591ac7923cb38711fc22c75a633acbd0342b0b8f7300ac3f14af42edeff4ec120bbfe57bfd6b274a8c0fc669c1557c977066ec645e8b8e01c654ebd585ff5b5a2e026f610662414a33b7304c572c501a63fe011dc34afb3fc10bfc72f2b3e90034de2ff8ebb3e606d22e05175bedaca9c722b12e19dce602f6b7e85071675750d09df8d97253b9abfb2379dbe965a2acefbe35d6d10bb92ebfbbd262fa8f06002328aede09b13cf5904083f2489c6584d3258b67da7dceee090c8bc15baff57545d8b8503f6c34b7c4f295e72c3988c626f8f2d0f558ae7e16df9307f8952664f09a49ce5f60248689db993f00d869b019bba3edd80519be13a0c159af6a05f82d771ee216125c0496d08272bc679b2fbd05a48ea1436256537d29c38ef00c29a748322f1a7db84ca68e2de11e5c8dcdaada5e2f960fa68a2386358884e9b7a050b9fc9863481159ffafb397cb240673ea65eba0f5e2158e2789d075ba9910e4bf00d88428f4a0cef64101ac14baa2daa933b923632c9addb9aff7d0759699c9af962280306ba91fed7c5c577c00bb9ded225f086e8637686592ae6a66276fe46569dddf01fad52c1b03f6db3341a55bb0594fd7c76d04cb98610bfc433eb83b81df238feabacfd37a89510ab4f653422dcec938aaf10d671324c611a526cdba2875199fa679f2cf20a006e056f9719b2542ff1485a3ad6836da9005eb93695eee159551da8d8554e0d8221e6688def11a00bb698c27b966bac5ab9015383b51d57aa15a3120e15ddd5d7ebb7635767372384d050929316be8b6a5e337498b6b1187449bd3de06d6fe99d4861bce91c4554f7e1421d7d400d6ff5f6bdfb56780515acf672916707b5200970ac968c831f48a18efde36f16c3c72d945e8082d415c8aa396e86ea41ad01c9d6f8829b0b678014685ad0aec29d547b2af898d0d97bcdbd7500b204dfa059384428ad2942e517dabd28babdb4255cce8b3a4b61bd80752746e0f25c6f69a14239a8e4670485d20f76517259481d5f5a4337299eb7df24a6a87cf30542cc114916f16f9d255dd5bcda1e3fc39ed4be8b1741c5a55fe0152f39d0f94a937277e8666a2a691cc1e3278de01321940e9825ccd243a648f94310f281e64b8d4a6d4429dfadce6e6b68940d5de9e70c9bd240ce54cdeb81ad5fc95e26fa93aac5ba50317d01080d4f4331ecfaaa430fea6e1837aea20f9fdb42d891df2a2b8a056f655cb247c07d8730e1a4604afc0a079d5dd86a9267740ac8b1347ede13d932f08ae04883872018bf7859440df66819a1bfcca38d03a0b697fa8396549d1ccade7cc48e59fdbc6b34c7146a43ba29f476d1f19c63d69ccf59e728a0e3f33becbcf40433b6890f6ab391c4164fb2b97c660bb9add576f8bdb808a38deb687194deff05c684f7e235bc30a7f1e0b0aed3d119e100b9e7bbca081a8b7426955ebe15d3dc5ed36976b7be1c2a5383f698565d68a80849ce3c6bf3dad4f7f2406759967add9515b3814ff81f154696118a2d06d7e5fbe85a47e36edeec099cef72f6b08904e733a46be1283fc5208f1ff0371f5b4b77939891add30397bd48d6c6fb26c0f822befb0707ddb9dd6af933b9d7eabede52f199a2718c1d522a4e39858eecbe7ae8604abb773178f3ae9bfc51e3d93c3ec5c0c976a5564d91efeb0b9c813d784f20fb0bf20ff5bc65b37795268c05ed3f0ccacf889776988647df93ff4ca5426ed6ef968e23ba44395092a098f99fd4c749fa39e6289ec6539207ac681ad9c243a97436d78c8629f2b4291f5fdffa1b64914c188d8a4e02c90a75f0c6b27ab596b74c6708c8cc14a415699e10fbc558fa426df0a131dfc48b0a867f5729889afda90e860a76256ad8df651d057712fc978231e4b2f57ee72bc8f945ed400f93477ff318ff2e1e3c240f689232c49604b81598dc3f3b956e7b847e9be89d98c46fadbe01c99a2c6ae94e3724a9d0049ba83908250c0516d235b9c52a013ceab4ef0561314b0e81b1ba12c44a528f46126b514d1bf61d9dfebc71413724c5c2754b4fa799fca9c47d4d51aae1a06a6893b81b0939bd419a41c3184e2152b19dd80621e2b767ff250057fdc435bbadc73042d7b0ea7e0c7021a0606b9d2106eef047e5c24cb0db0bb41c80ccd0c143a4e1af51b4a7da8e03d5d5156794b3e0f70b69f79b0c795de2bd256cbbf2cfcc2ec46f4d2cc6761b71cfd12230dd5511a32cfa572fdec14d021a9664f0dd409af606526b417e918408e7c88af086396d1074a62452f45c8605241cd71fd1d7624ba0c1ba8d0b9b737fa963e2bc8ea91d2d2b9758e36e9a31b4ef0989eb233ea70642e5f4d93820dfe976abbf218325e3a9fa908f1cd85c94641f4c36fb5f58318db2e7948c2bff4713d3db47b51bf58978a005fddb9634a602af41c5d628492fc8739fdbffaf72ced9909359b1758115188ea96771bfa0ff55a652bb1ab437de904a3769cb80f71d6acd69471176ebe6b61afff42f9575d525b4abbdf57667f863d576ef42863caa35e43f7b934de8be943eaefa47afd4e70af2ff72b35570c138b2ff0d3209de585a338d9d0aa307f19cfd4aac499b7a2b52213e26d0b377026ae24c8e019aa948d63e1848d39e070829190e9199e0720bc50962266867dd4530fa060a15288ad526258599e635fa53300285786eb16816eae656486cdc3b12cfcee132d218494890073a032e2f390000df1353c6107ef6009ee632ac4db06bb5ce57e7781636464fd74955e136cc64385ee33aca86b69530553d63f6035d51f2269a37d70f8e820a166f8a85ce51a8700cbb1411269655dcc3bc8d78c6687bdaebadfafd39bbce59a9cc284ad5acd08db7b6437a9a7deba9ab82eee16635688c7bdfd12b4b319b5ed48e834e0f83b33d5f4cbad67c5a28cc66c550d687e4451350dc4198d47915540d42a8223635147147e8ff3339e7f673bae0537cc7eed851a3c5b98de82b51a04d673be6ec3dde7b26f84f142f241f67ea5457bcaa485c288dddfede8e3789e0a0e4c4f30ad31e2f8a41dcf039995ff6eba2f3e05852d30dde14b3e5b14c5eabd8ac8fb28d6a95fc7a155ee7e6ed6d50b122db6322defb2c3106787823d49a30e3f50f00bcec231436ae7b604b56aa4bd524a49e5cee5bc971daa66c394d9337f9265f4bad17ab3895bca21f5b4ba46d5863e10ce6de0ff13ae86fd6317da3bc5d7adf05ac715ea341d149cca8f22e61d13b6015e18790f24b365e0451704c0030d3652777564c00c86e6954bdfb3ebacd4fe6d50184ed5dabef161fa33f12f7d7e6f4bec858a4eb2da74c7574055ed65bc80783f4e7d3f6f58c2d15fc9b07fb8c525414dfadccf4e549a8c484aeec84d96a790331bd77841a42b86eda4a503660996802595d6bafba7254c19e450c32c7800695afdfc38646b566a18e3eb73e230d8719cb3699d6f7b10be718e14468e73065583859c98bbdbe70594ca203a4239334a7f97521588ba01e6e14a30d943fc9d8684cc564e83220f95ead3586e389ae23b7f63ffec9145059e67150c94de71c24c93afea2748cbdaa719746bcd631df6815a290e66c42c1cbe9a84d3742c2f3f272b632a50ca5193ed82007d125edd5879675474241cc8ef9b685c87ab534a7504cafd66b795647922609a34ed2962244ad6215d4c3ce251e5f9d4baf6e3a655486e737594ee8a93bf55c82aebf6b3a8450979dc77aa3614f98f17fce274d132b96c168f28d02822a762425c134b1cf2c02c352bf8ba75362f64da313143165b81f7745c958de36bd70f26d18d66fe23c9bec32a3a1485d523374b6502983a9cb2583e100663b62f195e6781ef9ff0252e665dbdc4decac7b3632906c6c0483a321661820caec2ac3ba7fb0a86647b1efd83890b6230f5c424c42d5a85463b87edd990f8d2d5532d03346e675d2d12599a8307be709ce7ca2df0a821f7e0e1a13f0fd79377ab88ad9bec196ab9465f6866564c3270fbea820e407ef24194e9c47c7f035662eb4e721b7fc13d7002a118d2015a82c348eb868995ad9f5f5c2d9aff9e675bc73f9a2640d1dc8a8d2dbcd30ee55bbee5d0989a62fae675a9cb57c995e8ae7ee28f4feda3229e3d2df3d773ae4cb6bd363f15c3803789d1180479b98b4005c615001debb726ad6d5d780f1e61439b0416d47dd14b1a72cad52c4a87982ac9ba6d3f257d033a471bef2610dd107bd7d3aa3fca0469860c64771a5eac9a12536857b407c635b62907c165e4b6b9bea24b4c3fbea13028c8d674d0e663aa0701ec5b5a70b4fbe5cba25974d79e189f41368d41f619f3f021c3b22c89f15a4428b52a490777ebffe382075a3b6aff1ef18f940419c3c460ceec6f368e36f576a3a6203fb609684e6859ce7aec063ce8be3d6d649d3281931c6249af6e85ed9962d83a5b92efa4108ff6c4e5ecb813df1b294fe6e280f10a8e07a8247066d4d3c067454f21e0b0fed8a75cfec1c2692671b7cdf6880f09284b173e09d9d07a1e5757f1f9ce442fd03a5149f69ca770b068909d4d1215eb3f4eba6631363a2496440161ba1668881933dcc57678756430a6034524eea637702e1383ad3247fddd2cc1cc05e2338193fba6087b70f8102c802860a1da65f0434782418bc42cd4a370be2c1c4beb796c320e496551c6653564850b08460a1f53a384deba1cd4084598b9ca35b7a96b69ae24185b0b011e97b0a0fd5559b5887f69173250600f93a4e0c4ec2551054647ebed694b5d0c38697d5fb78d6816a346231a1c263db25ad5307279a0e4fadb75fd8e7b8a4445380b7b1f1a01d97c50cd919b461b00fdf42fa50287b86a51450aa83553d4480920a52734239756320f0728a1e86a19e6e5ed54c4fd2b50512a8c2d48cdc747c58e607bd5e9e14c33324d3cb59875c33776df1b2eb4d15b2600db15be0139d2e99787651f05fb2901c19b102b5e53c37a7fae149512c5acb1ee037df5c6fab834a45fcdb208c4428a252d0a55fe6f0c05939f2d771d55289c5c02f30da62aba1cc2cdaba38d0bd8dac438a855fc74e12ec777ac0b999859866e05842aad69da4122816e9be2f736731d0543b3526d0c0f84c73ff05c32a804e1544505814b0780a02156d5204532061ea6af680e66c33568669f17bdc13fb021e776b329f36da1c4e05f14d991e6150ed44f10edffb0586e2adca932e18a04cf31cf762d24dd9d3eb145617e2713305e6fdbc605503eb44565ca27424b85ad1e4e4c71b012a6baf9c8997da755462bb94a86724605559f3f1ef84aec0e96a36be30417e9f6f9328e899104d08b5817cb37cd563603a7f3b09015610f87a0b4f0d82f6cbd44a1d70bdb5a28d0e03e16f2252c9b19ec69ddcf1c2b8da6936de861bc52e893df5a1da307af11cbc9133d5e6b5dd9b17af83ef0a2ee47d9fcb7daf0997415f0090718c247e1c24e7162def8e0a50293bd44fd43cb0d98396baa53f5869b214c327b5b2b1a526405c12f4a8267de24b67f4f474047727a993fe69325d1e6b5e83f85b82ee8474ca094c63042ba70f707cf2245411944297967eee71259808fa55144fdb1cf968b2ab462a95e6a33194c6c3e91f887935075f867584ed860708829d19604d6a8631d923de94d67f8fb91d6d93b94a21b7266666e7446e2c9d5537ecfc6474de4145cf1e4f47b22bbc9100ab6f2f06e1e3be105fe388238f1773fc9451bcc2e0a4d63c4c45a0d99b62859226de41b173cc29777bf431df4ad58f021d91673a1c408c4c8aba78be26b985a1277d9b13b5cdf544b03b155e0a670c616ac204e72d42cfaf99e3ba5fc15d8b6364488e41b3de6eeb4633d9660032e64a2a1e6d0513cd39596d8474a91ef01f1371cb28ce5c451b202e686479b2589daf31ed45a58239ab5da5d6e77a2516eb4d6a4023f2f762ade6407528538a8dac731d3b59364e807221874b83f08bf97e7893020cc2f90765334d7b794038e5ffc84554035831547525e0fc9b6f80def8ed0502bfc274a6108ea5ff448838f085bfc7010e4c4c9d55e819e211a8283527b9067df49141c92bf897c3c3b6e24e4cfd8ea5924b0d7787be20476c6844700a86dfc84e644cbf573710706e9d3a8d150f03dffe8619c523f4c603f7300e5b447a9f56b8dcdc187cfe6acf03870f152b1819173ffb061db1044943870332183f41310389103bf2a33dd90f4ce5485f1dbb2c4aadc542f92c5372e468efa77a136d0a55349782adab4912f5988946a738fe8e8d7882637dedd74459746e4762225ef283b054cdcf88855b785e26b6ed937fdc9dd73c20504afb99f19d75d677a35fc58061a4fa310b105b3bb058d06870a1b982acaea3eee2648fcbc762b5caf2ef08a405a563c3907242c3782c3a7deb2ce3c7f57afb9c4e32b0f521c706a4a53702a5ca14e705f0192a022d98e73cc6ecccf4643dca2f11973ce817ffaa890596cbe727913503ff765eb0abbfc1b566307f7b0e98aa04bcad5f981b6713fb10db2898ee94c3851f8c3aa8120aa2d32b83d0151accc8df1dcb2d15dfe04ef485bb0a26326f8f04fc88b9070162ecda09360057f4a16728d67bbdbb779fae5c6fc9cb45f919b2160813beb95db14aa29c68ccf4d43e88fe60c33a47f11cb4a021c0f508634fa4c14746ac66b6dcde593d52c77fedd0587c790aed5ca114ac7b373a4779820d0a2cd2b03d1793b9b22687c5a728d2011038cd2781f80765e64dbf4c1d19810a81772ca4b8e8b7a9de6fef9d9569437f8ae507764cd82e5c96c31c6f575516864da671f8bd81ac4c5198a0841f56b865918153d8989f9d6cf6be72638ede52306f05e65a85a05b705bef5f2f26e5bd423b6ac3fddf3ade5918f5fb71c5f8be831192df052bc580fcea2ff2fa13f957f622d3f385b22516877253a8698d685171d28b2cf30dd2bdb861f0dbb992c925db708c4c25af6fcab6d07f267518d7d6efb5660bf259f65ecb4558e6a671e273ad0efc0fd637dae1b699322f22c6bc23e40b6877e4f9b09a186dc15593619bb14bf15929da3f4a21f887e389ed4785d6ac5b8b60895be3a43e78bc220a6d20dbdaf7cfe316f40aca1dfe2d91076d6022c0c4bd9435b5295943eb6a2e035e45b48c0664eb635e96f9b96219d08a3451877b8b038b0af5eabc1b4ebd3ef319d22c33a8799d3715d7c45e12577a2776dc33e2d8760f333d288abba1c47f561c5bfab8eda5a2b5faef26cf34e88519eb8b45f3c91f040108e3c58a341d1364fb7c1ca29ef73c40b4852225228703b5553d05efde1c24c4b8f48405d0cd7482b5f436e06c160d2b9c2f9d915536e83f74798965dd4ff7bb95822d0ea18e578a5528cafad490bd95fe0023a1dbae642f62d330886e880576bc0d60eb19754f87eda12f212046f81a5e35a03f379759d62527629428c1b543375d5438bf71ad77866edb417260937d540b53e35edee2297b6ad9ba7a7de09914a9913c01b03b317d682279cb74c74eb4ef02e96f6e35c892514d056f0ff5dac4bb4d6812cc7d459de0fb39598c672da95a12a773d9b07c80b524f3ad25e7a49fd515e05dfe98f77b7553cafe152e0e6298c9bb54aa2a0b2abdd577da4c1bb762a29b74f24ede60b979e808754d6e3ccb0b88197ac2887578ea4f125f5405a9d35ef722153e9ad5bb062d437f2b2e74cd33aa16a4efb75ecd6f3b2d7e5d14b1bb3f4be0ace4d7bec53671af3b1dbd73ce0a68b6ec53cfebafca8532c5af35001b14555fb7502b7e8408baa9454558dcef47a4f72948d2b8ca42ab964d68beabf0d05125e819ae50d1954e63700097afbcd51ef22090513b7fc4b5ae2ee0a1fef56d7d58bb4f91ce55c3fad4323b3fca15084004f491b6cc5943360fb421cab23e9e278b0a6b7637340fb9b1de8d8ef0fb97187ee94828ff73edaf57abe516de3e7438608c8ee47ff6d77be8cef5d3047f8dda051a7d906f7710b174453f4b72b8a591f93d9857b504a5b0d08f39be387f9a2ff9d48aeae386249c6b20b5abbc45ae0ffa9c76b00e7fea93b1cfff1e3e56ab007d7f8bdba31ed3ac21ca25aae69e0cea1cd2422227799fb7d0f70df2d3025df72772dd5a2d19797152b1aebf8b03bb05035a21c3473a0bc4f27c1460815759c6b39bde4a43f9f0a6d4a6de52f29cf132cdd580d4acc0bd95788b381192112b8e0a86923f117cc7fef9a4730206ce1a7710af653ab94b1d0115b7ece75bef2045f94b75d130a8fde0e3173ddc2e8f8f5fd6bbe4ad22923d76fdcfb37169598c489b81ecc08ec9aee49bd603f02b77072467fdc038c77b9094ce2e5f59a26eff6ae72264ded138cf48a0c9fb7c6c400cc17bd688ee74bc3e0d43195b5ce6f19118a81815a2a231e63fa276f2a6b75fae15982a0e86b11fd764e22791d8e879cff7a0241b745ca5df93a38711048283a5758b3402b36cbe02bb31018728bf888ec6c8bcab261f51390fccb91c4ba2bdad443d2ee33d31d1265a2ab8c9dc32aba54a104f453085ceaf1b729f6d096f4424efe7951e139a660bee0fce1e309c5ffdbe771ec328de99a113fd8253f24c787b9763fb4473e3a369f1a93a1a577ab6346bea679cd9198c1b2dbd22d753d310808b2d1c23da392cd62920c8d454ba1469429742bab496381dc175bbd2e3b53a983ed7c8e5353db8fde5bf7d94cf195b45e68b0abfb7114bd0cf891b761bfe04a3409282ca0cbbc2725caf286bd001d1613a7f9793d5e712bf48fdb3a5c58d0801b55168ca4c454db2277c10d41d22cb2be59ff784872e9f49b93820b24a0ab30e8ec2c1ca1e51e0aec310cf55ae6f39a65ee79c71d8d304737a4facf343c112cd69c64ffb623f2088c82ba81206a3a3ea4a6a0bc714e786893265fee804bc1347fb6daa09dab684d15ecbb9d3c515acc30b0d3992e32a49a290fbeed96529f1e3982e78325ae9dc24bc0b00b650aeb217355cf16f89fefadc14bc6212d7b9bc837933c63bdc7fdb755943502b5c7b3d55892e17a56217d7a69d3a4cbccbe60707414c03e664b7436b924162fab356796c9397cba6941329d7d58273a4ca03806534b1e3fb38777bad5befbb6420dc5c54fadff938abf64c96ad540135d3bd54954441ac0caf581ef6c5d164e7e701fc5e536f8bcceb665e2fe5eab0ac4331e01afe5d8b5b80463d4e6069d7cb2f7b391a7a0ee5fd63d2e40f468e65aace2defdc646efecea39e58bc78b1ccdbb5db5972c5af35591774025bb1ef906604e5987b8f11ca9229238502ae209a7ac4fe99712c9b458ee22983c4b52eae818276fd79487c7df3ee311f5bd1ca037460a086fb148a3c4a7610feaf3980fad48d33cec2280f142f6d65301cb72aea598e11280013bbd5cf6e575234dfabebc9ba139fd9f96ed932ebd05e2bc7f10b4b9f5cd2d64b35bed2a10abe362b2bc50c73bca67efe3e4d04ca30057315782a3e1d40499baca49b9a0484bc1b2c2120b55dfea1c2da1e6af8f03e7b72df31a892591dfee8f5b2e6c4d9be1f4563287a6ff419dd9f4235ab4b0b81b58409aef69b75aa0470d6c7c560bf5f41db43f05cdd23ae8a26b0036bdc591fbf099568b4cbe425f600fca80809e7a08cddee95f4c215f8337d718d4a6c76c31720ba6868eb22b8bd759e48f38cafebefe4f29e36b0081dded6f11913bf8cc871890a62dae7bf683402cc905a9ec92d82a9ca86b66da1975ba505bc8922098c9c4c0d5a3e1300291217f7975ded3bb6b87a952fcedb76b116cb90fd25180678250a291067764728d672ff01af4990c5ff073c58a881cd2955b7fc183f94b1ce1b1aa807e24d1f3cd963b58e6e2c7f7d7bfde76bc16c883e3a2a3f846eafae8e74357fcd84fb1938839f6b7a3de839f2d6cd34806d9fa862e2c489375b3decd0c3e0df462b054989ec4923f01d05a725c268372ce7a39c19a65dae35ffe48e46ded82e48282e67a8433dcb40759a014515ef84ff6e9f55456824a276e856b460c757f4beee50be5af7eae82fd53493be4d6c2be716275156ee5d30f1b2f450f009b6fef73195862fd716bc496ea31dbd85ef1267f720d6448f5887caef671453248ef3d0c9482f025b9b0d1c0ca2d4b6b4a730fbcd9407bc494af6a89245115ae75c1edde27a66e385f209aefb99add3b1387d604c107b8d1e67d4f6543528fea835f7c5cba8d7361f87268ea929e3f54f5746a95c9df39786a6d4214ab03a98f33ef8e9fc12eb2fb48185e1723cd8dcbb2566395d4d204c126a2ceb93af76c9a4f2d3d86edaa0044aad1c308fbb500a221b1b451f29d57bc11c55121b5ec3ee6aa17fe1b0bb177a6323194cdd3209cbd3d9080763e9ef9d0b2bb681ae880b82bef92a30e6e15676af80ae4e03a08622f2ab50925b1901e47a9c7ad1e2c0d8537495d6d82bea945b40500c4e08b31844a58f505ea84ac7abf4b755421e7f835111377cd35df1c275ab63174042afc7a5f9f90be6460b0caf5d4d4093b007250be07a1300e659d5c13b5388ac3238e09b140d474a8d2f6716dc12aee9ed723987f976cbda47eaa58f35fa42e5d9e4df53230ed985602ff13b53f5113813949751c1bab16b4acd322e70a5e2eb7abf2c3d54cb284aedb33e6a96c014b6df048c080bc9ef2d0d5c6cec6457bf269c06e8826b80061705e7a862fbfd32c21c5c606cfed345129e96e9713ae9a2b12a69972bf5e6bebab9798a4e3eb2c54c7e6753ea634ad25b2b604950671a2adecfb178f6973ed53638fb55a51b0e303854f7d5d6736a0f861b51cdf563e2e2c7184325844be1966e4bc2ddcd1a34d6dd1c53e45b7a82fe1e631a78634f5645e56cdb28785556bb7d7b9cc4604321a9f777f46ba96f740e8f26fafa9fc0a17fcbb0fe52b0ba59aa2a80c756430fbce742173723e1fdf70bbb2cd7d9a11013c731c6e51674705f4eb27eb8b4d5b1494ccb0c65cd894d7b24984321053dda9a0d3628311f461784441ef8f0cc6a46fe96dc722c0eedb4abd31e341937c47976f6684c562ba5a4f9700bfbc40708d0f7cf50354776c23824bd6bd50e31b08ca3c304d7f6e2690e4abc7d0fc10d6a89f58fd6f0fe14409a439b021b19a2aaef1d44286b796382d2c05e7c9181170103994a33e3badf08266aa22c7b51b2f82b003302d9a49f286555a02908d25f87b8bd4fa252ed944168edd1b6bf57e57846b7457a09afb9533668a056da342b6e24f2fefc41323fa63f8719d25cfc331210d474cf66b90bc40634b48a09aac1621ea51b1ae6b292e8a73df2c3942590e6dc727954a6a461a8358ae60b1c33af9b7e46fe14c4002a8ecc71dd2862a3d37d7f0300bb90476800c74c2a5eb60be0848d128784955c9a30d615a1833b323af2a880809174dc2236298a521ff5f1f1f3072fb94c41e7b2a2f9aa01644b0b5c88cfb311d5c5bdc5b77beb936ca2942ea80eef4f916a16b0ace90d1be49bd9cfddc69fa801d4d06d967e049ea60b0a04f914a71e343860bf687aca79ed27bf95b68ade2131f329d2c008e32b18781167f34b0fdd6f09e5dd7b19b59c9e8bcd8f3ac7aa707ec2e5eed31dcac5e3ef69f24e614a88370edec06481c40fed82ab86efcfa072d87c71f6e685d48f3e626c1f814fffc868e108a80750f47c76e9866e7ac4ca1e7dfb4297289f6cbcbcb7f082ce49ac4c039886afb50fc4ae138c0317be3718618cb9b91cbfa34d4adcda8d8fa37e3d9299a5fe161d62fdbfb89370e64bccd75bf4a15612ec9d73090ca935e9f32e1fc4eedfb25d8277ef485d0a72d33539ebfd5de19a1f380434b5c5337793f19ad0d524b7c36a66a8dc8daf1c29d59a499d2ff337ca32eb82715970f8d5fcbf2e20345f7cb1134583a776754d4c228ba8c841a88168c221ef419bdf063f79ca28d4dd4a2c34dc8295648daf0712b469ea2d4f11d5952893e08caf22177c1b10b47ae32c46d7a7cf755a20f4ca271b40ae577b9b05ef922988dc4523b52fd6bd1324e3e83ea657abcdbc3c7f7d2a895f306adb5d2337913a69d950c8d8656b3d9fa99dd07a15a53c754e9034868efdf8b97354e5e457a794e903893db1d4c28ea83bcdb883e6d46490c84481bc5de574b87a0de6db4b762e9546e1656b0bb56fa4ce129c87f8e27ecb5d5ba48aeb32f2654913a6e428baecc3324b043e746be305abb1a75d10f2bb758a8641e9fde9a1c92522443fc03772b54d53f1ae5aee7de947b5fca46230e4efb3d182ffeb27449a93136b5fe99d5e29848078e4e79ff14b6d44006815ca5a1afb9ef11ceb9608052598a12eebc2ab2a120b6e43a3767ea68c5a18bd77dc61589e2ad7338c497c449e0c64c47faa4742d8490640384c5ea2a35f8d15e3d0a228006d6608e073b1d846cc1beb6530e034144051e5da2cf721ae30ae3ee207648e49818ca471959afb902eb02514a37982e3d3495d77dd26c72136bc676111fa9c7124f63aaa936a55bfe2973f641c7a466e5e268e0f379e0b4a49b2a2a1d7abe928c88371ad615910dea71bb60e4bcc72c576dc23eec296eab8674ec9a275ad948c5a6dab496c34dd52e497d98c932172e25f153988281ab2faa998f2221aebd5e8b98be36eb88585e413ae731c5c10db5e41cc97052b5cd92bb8a18662becabd0f8a90857813b4cecb63e3beda66cd84bc5486452628e9651eaf1462b1944129e7507ed008da75547039cea73aaa72b3c6ba47330acdc6853af0e512ca4d3bddba2d6233fe996716cc16508b8399d2e7745e875e03f00fcb008e39d9bbc716033bd213df18d75a2dce012b723b6dcbda924e772be78caef91562b9739d06627e465d4c1a030715d8b21327d8c868050294451d2c67587b5b00b751b3839de1f5df74031c9beeaae3dc591b912a6029b51608867d5fdf9b0b7d166f0fabecb58c3ded616c09b999407a82dbb2ca9250accec70021241c4b236c4d41a65a9dc316a61feca3a0066030a82e6c93af2a5f7fef1492aaf80c3cca3224987ebf5ad48f8ed6ee418468b05d91d6f7f7e128f2e6b93c1bf75dab88205b58c69f686445ceffce7173c447b7936615574536b2133c98d4f5b002e175e08bcaa1e1b9eac6dbb2550d776139c4400875ec2ad9f32128c402d09f8ff62755ce89fc212f51a1a4e248d99162648854c8bab945986cfd0f64296c58b4b074e969a5bb9557708359d0c603b68d42c74ad5fb5cd3eefdb37ef2b65be0e54995672a4425ecfa5fbdbe435814e04aede8c9c064fd8c0e78cb3c63e33a7b8f6b1b5fef97de9fc82a8c195a9682c3528fc347cb5ca3325236d0a3cae43dee5c82c9c42d06fc76ba7c1dfbe78a4d70be203ba6ecb8d87d6ab2eb17a598dd912a82592e8af21f3ec839adc76d54a4174f6d53ad130bc00cb74fc11150986b268c08d89ef8f1c1fd8a393b10160485c3c75c4655e9fc2ece1777aa518db70885f27b6ebda0dd3fb9dde39eac82ac432a3d13c93f9d0ae92b9331b493cdf0e1b1f005f180b75f5cc1f3bf489b2079fb0760ad8530b41faed7d9cc0b2930e27c075a4df646c5db48a7e799f505b96fa12621ae426828775bfdbd3c5a2cfc48126510b63ceabb1c95df23ca8ace10b29eab5e4df51e2ff9afae575366d8879582add33c1cdaa47d33107a66e5d9b8d379b405ecc7f2544e43892b0bb621ed894c4e861229b1ccefb900b4ef95aa8e286b988a385afa37b86b546a5020ade402ea43e18718a8a1b8989da01e0272ff05159aac512ba41290f6e1d7de0ea0f52ad49dd39970939d8b1cf76554fa1f7fb06c9e59b9aa9d6725ac8c3a993a57ffd94de8fde4751bc6e0242a7ce92f9cd919964c5f675a9006dc7cbb650e77536146062082ffed9b170e8f19d13c199a03cc4c34dbb3d4287b3f119abbd7b7d43bb51e4e3c8460d57eba993f340b82c4673186005a9a6a6692e6db1d8b8350ffea0678ed21af765271b66b7ba5e100233730da126b1fc9062344d8ef243faeca94bcaaf9917528a9065a01faa479dfe6f0e85e5a1e903f6b01e9e027cd045e534a88dc6ec5cb7263542da483a12f275cc407a894f8562ad07aa2c915a5e9a930b140815307d9a918ae95a9fa9d6d059190392ef36bc0a26f866b77a2aa71c5e5644d2b72c4eef44c682bc8453f5065445ea32a6fe4e948385d296bda8af8634e0fc5b24edd226b060d9569f60855e4ab0d491296f7877f251be39b9279a5dd9ce72edd13e1a1908ef8e09f2f4da7b88b0105184e4fbb6c6d97af551b99cfd846dae97bb79e3e5abe5b9abfd98d9c41af85e4655055fe45ceccd93df047916ccf985708d240a35b7be41941fa28c828f4d1cab56e94a6b72def06dd2d103128358e70fe982738db3e353691a76a53fae6ec14d132d6c38ab3910683f07a17bf160cb421a3e62d286c7c398e846f1a74c668596b433e841ab6f9126c995a66d198f2be69ab4f450d8864e554332ecde3955d7d76a788cb459f87d5ef6685a7680dea72b9e6187e4d44874e9ed251888e98f2c0ae7c187fce64f0765790132bedb1eabd1c17d431bfa3ecca177b6cf33f9856b95a833e5ff3a70e530a3bc2c6c27abb72cc6eea790291cd62aa27bdb6d87fd84860cd304745c588f9e3ef0c6bb9e96fb6a3e835eac13aab16b84b7fa418d668949a4f315a53e5bf50dcf40769f368ca293aa67b69a5769c1df48f050c44001b7475fac1c1fa5da68b5879fb618bf117689618bd30e292283efa0053373efa4117dffd46d0b6b3c4b667414a2edb75f88f65e9f1ef4d5207859c22da1afcdab60a87941cc73c937740a2d83a0f37d0e2506fde920af0bd10f3be9a0c5ea925ecaf499e72d0b2ab583f8fd085abf42f07b4866823a0fa1190ecf5dd1fac190aa65db634395ab500d5fe8c8fdb966049a76ba3873298a924020442824ac2b13fdad8008a3f27d7bfb25bf1ed3dd3aabc06b2ece694042d852abfc6118231cda3bc89fea7c93a701a5c577e9db6c6a9b2d7003190811ad34fb4c604c754bd966a90afde65a269d644165aa090189bcd64483b6591b4b43f35aebc3087cee97991305f350c720086a79fa566413f078cc2c02d774380527656bc689673cbd1d87cef103625c3638d358288c7fa275c36b2685745971e3038b101c583ce914f64747da85892ef6e60e39414b8da94219d7d8d827a0a19c6af8856647937c6976f6b919ac64be272022b174511ecb17773c964247fbd981b0b05ce215c4294e3850e17533c1a6ce4f34b97e9fe3f50c37b94ddbd329e769e951835dfef4fd9aa7d4c81a89fdc9f913cea8db0e515d6f282623e002fe3a437e27630a8736bb8b9474f60da6e639113cb2c249a5bb3a45e682b38c46b4b746293b26ed48becb930a45d07b4dc0519c89071db6838cdc832f6333351b74bc87103c4bd8876a6cc25e9f645de28a701c37c183cb689507ff9d9dc6b143bef9d1247a74523a574dd3f56403bb9472ab6913def164ee35a19a14e8021407634a955f2371f825d7ccc34d03f8bbc340901d86c663a0377262e1e54a9ef2eda3b688b3be96a822655f48fe1dfe9f0d510cfbbda2a84fa5b5a3d52feb6f35617cca7f5fc7f33e9721abe0cb0f0616867a4baaf7f98002ef41f63842b8aaf14c94a1ab9bcddb8539f9ab44d7326ac17d605b547032aa1e7b1bab7e9879a79e96853839bd2e2b92479d01978d253ad11250e8e4216a09a5933eac05043abacf73614b9778b8597ec38efd6522427394457c4b234398dd26ae3e720ef1bb4b68b336d1757eb4b7633442c1b1ec6891724c8b67a58842e71d7b3a53360c6604d5e3e3614a6470fd38b07c5b6c824310e023f0c7f4bd12cafa9776eb1de2a9f7da191c1d251825210f1216262ac4b1919b156eb045e953772dbf323d24aee19ee8d9b8e62f97b58fa3052a2500f613ac3b60b57f8a30f839a5afd391154bf8283efe40c61fb2561623c1dd375651c1a174a6670e09ac7acfab17764695bc18a5ae82649896947066fbe0baa36cb6bdcffa7e9498083d6e78f42993cc6a28b2574037ce585ccbb54fb45d979365797f627dbcd55871d898826c37d569bce81c9ef603751623bd490ca3745206253fcbf650cfd68fbcb61d618041867b35d07438e6fc04e96ceffb05d8eba879455d1258d89df499b525fdfbebe1588265e457d5a8412265725620b7e57b07075f365ab231c20a797e0532307baae8ea52882020ec958730c314fc1988f6c0fe16f0b566eb492f7a58bfbd620beb42ea45f07b273ee199c09702231c0fd034adc3a4f57e3fac61962f0acdca5f61777487d97b24ac57b1b8655b863fdc26df1c72a30b44f99b1dd1cdcc7e0c2dcea3f5cf9116fedee74c922a24d6f980ed23f30ad8d44744f750a49f4b2982678703487cf08f832dd1e2be9b8f2ded0d1731832d3afbd515cf0f8eb16404a4b656ef8b9c4f6d2ded7bcacb8124295a7b558e01677578cad6d4301e0080b78c92b530efcdb32f8ad94c178e453b86958c53d00c5a6abe0442bf0e6dd52ee67aa9d8d17e57ef3b7db0bff3a783e9f90e243b0cc809e283bc104066bbb8ae8a6748d61fda640f1fa43e1d7f1f9b1591c5831e533541855439c3df830a7b845628e5fe2f9ff3765ab52563e7fc0772b410f17bd34b11123b751b83f30c76aa50d7408f756c4172f805851ce01dd005b6ba1ce2b20153939e3c614d6c1bce7cc36db4e7189cc21453b164f7659a23499bc90ecd5013d11e636f2e11a99cec115dfd6a3ea89cf2b1fa4d6eb1b8437944d24ea3961a3f57f353a000bef21aa4fd7ad5fc7651ed307e6c1aac8d24e4a944418af18ce75ce99cbdf7797fa04a5c9af6f177516591adcd848510d78021914afac99be44afb98b3ac702236dbd952171319c9bcc88d9bb2731aa44d7e1c06de1c1acc225f3ed87b8b788337995b7438b4a42aa0cd71f49d72383b6af6d36ca6020e6d10d10e7faad5903119ac18d66413ebb873d1b25193d03d870e749cbcdb6f39d313763b63609d7679c59b06ba090ed7a513c640ea7e233146ea4c5191eea69ff1280661573ad7d05f48eece7bf63f5ebed2fba6d2ec354f18a42ea5b5644e7169f47db0174261852e689bed6257bfcaf9c477d12759aeb526cfbed66bfa3d64583ef0e6fbc2c7754c0e535ad099c77f841acc77ee38699b3ede51c8ebe6ae9c7b67a3d51eea78dfaf5e978741900ceb193fcd9bd8e71dcf1ef3dbed3803ef59936decc868742ecbffd084f67b02f95e9e93f6a11361c64b217e5244b19fb8f7c2869417a7edc82bd86d6426ba929b71e52d5844bac85d0b6efd9bcacdc57122f5cf14ff3db30c7d7cea107a24e970b7d744577b552199a17a967b42171d61c36a38edd26110fdaa57ff2df8a65609a38cf69a71ac9810ffb780fc19046359cad60b906f9b128fb895014566841ef3ddf31f1989b5e5c3fca2f09b8b6feec28dedf4478a25e0f62a38ae2e39296ebab1937f3daa5dcbbce0b4702d105064d9cb99127dfc14e67230c66095fd0d9f49fc4601ac82fce16c8d0b5c3a1c834694a0c91076731a95103e30d8c380e7d110139a9c5b10b9df2734a4cc403bc4f82c9fcd69c39cd3eb38164ce98e16f36cf9ebfad4dc44a9d29410f5e687ef68d4cc8f51f46d018bc8544bf289b0ad4d928a9f0d8a51bb548bda5babb220b7f14c1a7bc7add17e0dac3b6ff2519365579921b75fbedc95b89911b4f8073f7b5b4c6d953f756d4a924d6764aadda8a0c2585c6a86a5b1ecf45e0217a722fc22381f2443c4c069a859bc75f5eff57d9a708e285888b1dd9661f359cb623feab6e9f74fe32fc8b68f1f84ce171317e43d730c8573074d94290cae164537e536f57ca9b751d8bfd6ba9ff8e964594015849289487561c1a4616e7834b92e1e9a47b4382f9102864dc650c56b07cdd404a4daba985f4165dfe3260b3e5ce14c0c4e249eea33513f16ae809188741f1aa3301d82cd16986cd8178419826fb3bfa05c1c21e45fff8519cc939917cdc8783fb112b25a5f10511b493fb4346f5a4b5cb73f770f229fa6735bd79c016cf9a707dc8e2050cc8d262fec3b8b762a81418b8720b36bee19ec03e3be1eae1c1aef51f63c8127e70d72010fd85bea60f50868f2f82d4173707fde53098acb37320961e09a9a58763f5d906d3e241e6b73e3a38a4bd1b627b57578ca44ff1fda55c35845e7ffe625095802cbffc7fcb5ba8cfd401aa7526ddff61a9e604b420f9f89e1e907dfe1825994aed2b44d3564faa96c2eb66be1801d9ec2b26d55ee458610f9bb16cec79be0bb7986af3781fe266f3963a183740c963d3dbf8aaa272389149401a3b8f9446e40337b464b1f68f18e5d5bc4638dc9672845b46400475774ccc16f7d7e99614dbfdce1ecf5fa7315bb3191f6942080cbb053eec6f323f18574c79207e3164e4a45d7a567eeee36590be9ec9d2a4f503848dd617a9c1fc1e5e020aff15b06e9d6b89a226ee32168cc3dffa65f507a561862780be3ed67e5a96c073affface9bcf8a61b235de47bc23d7ff148b7286fcf125add5b090de8d08dc64d33add638e96cd7a08910f073419e06a3853ab5c1f24d2c768d03fda6e6f3a9b9d6d03887dc3f34eac3d9b210fa729b9913dba213f7742a9b047ca20286ce8e414515f391e86942cebfd20c553753edb705713cb190289f0a4fbb93bb3289408b50252ea28f6d2a2515cbe946300243807f84eeb8cd4fc7f28724291adb1c0fd83292a7ddf1c63b4b998c8258f2221deecbfdc99e7c02cf567aa219b9653763ec155c6f29bbfdce8fd40bbe7b080c7fe5b28bf3573c62cc3f520406a0ce50a6bbf373397ef6bf4787e887be45157a21c9a95c9e17d4eb7270dea5c3d98036637ae097486fc7e18258d11a028b2bf7d64285a43ac45fda2ecf5cf6eb2273e379176a98bf388f68bca4bc4bf8f8bab2d01d7b58a29a7dc17c2eea0766bc6f56e94bd9237dd0fafcabe55b71dcbfc2335869bb9062d12b1a1eca47c90e51292fb8f7783b8397d42672dd6a49ed667d3f1b7a1f3d46a7443eb91db3d402e75e82c265959b63becf91ea94091590721ed5d862384d1f635ecf818cdc79fa8b1c831775f0826cd7a8a584c05133cd6f74212dcd923f82782cd992e53bce289c0d66f20ef84e0eb6428777a523c835c8f091d351ed7f561aa4fb73152a0ff9b4ef5e55df76be90aae11797099266d8386a0f5a439d97b43a73d8b958b54b2d6182eb6b60b76cc5a6208296780ae9e8a506f70e6b2794a8762bbec7724243b9a29cfe2a5b2970f9d1015ad4bb355e688a98310898ccc1b69f1997c5373214e3bdf7e6ec8379d4f207f1def5c31334dd13dd5f464c573dee7a808c2b2f849bb919e484dd87fe33c87555ab9d2a78dbceb2f8bc6c25f20182fa0c376ff5e647000b48255ccce0a33138feb324252c7ec369844f59c4021496b5c92387850f236c29e269e24a1f1b9f86dc3fbc82d2edadb01558afafb2928d603218938b6f8972ad9ca0bae2eaa97ad475e7ebecf49e2f40053b18cbcfcdebab5364a2e4e11e732f9bfe245b21acbee22385d33ed007d235e33a140249a3304f4490de097d4ff034b0ebba0e25ec25803ae1b3617ea20461285d3ab5bd6fccaa0d61500c1419521e77a184032bba7da3f686879b639caad26320b883d4162a90d7c4250b09f095d89befdf98e249cbf20fe3b7675a658f4964f5ad2815e9f817534bcacd2d805f185f7e541434c6fd6a0f818784bcce2830c07d9fa9520e93daed19a31474e328e1d10b2f5ab8eaf56f0d300a09908a85b579a91563f706fb7517e4c04b75a441d781c82e3e5b87bcf4bcbcce6143d58ba648dda4307c51c436ff2495e9b55afa1e826a09e8661e3d1ac55cad6034903f26ef167b6e79359950cddd52d778dc8e5d0162d2ffcf957f853f7f8dbd8aaa6dcdc3864137388293a7a9740b61fd177378470195a55290c4b0a1eb54931d591ab8cbca156407392fde418949c0f42bc44294a243d4f2877f9814329a37146620d1fe0946bc4722626f8fcbaecfc6c79907046113cd7a7cce35e567da9da7ac149e7d968971ccfbd06b4983c7f3e5bdf400a2127d077123481a9bf29819f0d768ebe9ed010201662b1e7aa5757cd052ad8307c1e2471ee1039f49f71ac5b4d25c841b61bf0689b60b75a246d6cec90174a0fd02a3ba699599c77f3f9e3655afcb9d4a6bad5b60ea29adf9ef880a3e1b280b2bfa08892562b6951f22bcb109a9b8ba49e6e3dd8d5e4c36bc44c8c7afa6c9ebcb0743d613c2c3d1fcf954dc31cfacc294c19c07b279eb41f9aa9b92438fa4fc7e8aa60c6798016cdc636beb3be5ae65af9463543a863fb9a2cd809c51adc2ebcfbe7ee5bbb850bffa59a93d26714b335043d6e03ffef7561ceaf7df4b94597ee57764ebaa01ffeb58eda74e2b414613adf5d09bac7c2bcdcc5d3c5d0ab4a912ee109b87f0c31400a71036e16ee9d6f6f6894c85415640eb173a230a5a4c41c1bc1801e980c767e01dd30a27e6b166502ffe6d7980996d309198606c006360201a9e64779906a8b84956d58f2d2d2c3ac9f0289d8e5f55cafbced4d43426f715479bc0ae34f9c45aebfd4935d58b57a69ff4ad632a35fca573d559f81449a63c6e325c5a34c9952b07f5511eb74b3991ddf807b794d23f110c3ed4b1e0504e012eee7655b97075dff77d23e140a915a963070cc2bf3106270674921f3eebec013407e91cc2fbac4eec333fe96f2400058096fd4382eb6eca53601d7a73c9152cb5a7258b62827f27a58a2faa12c43115e98e477d2acecaf6e9fb05faa522f0179d633d4f8c1639975dc804bb0e60253d556621767d981b7494178893b400b167f616cf92ac2ffbdefbd54cfefe84a112f80cd9de5280302b1be26b4b1ac80b460595ae575c7e06d982035866068177d1679047edf58684d4ee941805953004ca58188098ff119d2679a8f2fcd2d22a4e65ee6758c7f40d4bd4305b9f1ce66ff09e20f95115d1822874f3c0f3fce5ed0b226d1cfc72858b717a8869fe37c3f81d197e82c1f18e39f6b4d339c82418aeb73eacc30fb7fab98c1c9cc30b80fc94d5e5a956db90c7dd29e315b30949233321237fee3cfdeca103f5d507852c52243a9e87cd98d241f3008e3c1069774048a6d35d519ae1e051fbe26538fac6b992f7bb6045364336cc1f051214363f80ae91bf26d7c0363fc7c90cd0419699358658d701c71f8b7d6985462503227275a811cd52041571fdb4f03e49ed0221a160f6cf25d6f4959781e1a5363fec79e7c006a314a9e6a165da558cfe293a80db2a53afb724a12051325f59fb4177cc9753907ed982b6c7ee6c6b32fe27afd6680c9a95e6f0c9ea68dbabca4a9cf11dab59cbc800b6de7ced24c5982c4a36fd6bbf99c328dc2e509b39b06ad9447a90eb95c831e837f5a63e3102c833ee2e90230cc0dc7a2d623208e1c39dadd27a0d92a33ce163a256d98bea9d5d4ff6076b89c0f40cad59d24e681364648422360acdc58daf8c8c869426ca27c6e452792b05497dfef1c0d83b7bd0f1e12ed961b0377c43b5eb4e85e7a0d650984a7425d5734fa9bdb63bed8cc7835f7a682cbb26429fc8caf490ad4faef6cf306c4231bdb04b2243c99ccbfaf5033072bbd731813491ff2e6a3f6ea7c8f104ad6047ece6478afb78550d434c32dfe9b2b557156b5731a37f87f5fa1e4124bfc9192a780e32f5ab910122eacbb015b1dde37ab5e1713c8e3d3e4df2744432310b437c4eac2f26b427863933cfdea3c650fe19587593812cfed2bd2049a8ad9c36a24c7223c12fa94b02c99596f9cbdcec7b9ceed0e8917ce55e4ddb553443467961628f296c76800faa156f54bc02f10d8f3671ebacbbfddcad20dea4ef9dac300ce6597610b17b3f569159c8601617d25e457215ff453dc3ce0d5ad0b5d34c156139467f592bbea7d2db7c67d5b282df8d36a1d41d8d93c54d71c540e6c9f553aa51be5cdb418db069c3247d19ad12265789dd58b3ae5703565961bad178f2860b7b41a1928e03622baa9cf94f2e0fbe13c4b3e32db76495c6bcb9d271be7087e30d36a98ef6ebbb260452568f91f883aa8a0bab42ae59684881ac9854c41de2002b509aab78f1ed39323d409654cd3fb9db106129be65fe04491ada7c366237bd538a1a22e285171b308969015c3daed032284077003152ae31ce98e91921d62b19ada29157ce804333665a07e4c486f85d9afefcf2740f18a1444297ce26c0cf2de0ed742ab5596a8b76f290130c684c36adf05fbea6addbf8c90fb0d8929b1bbcfa326ef11d066bb57ed8f8f85d25bc2f8a0b32859a7f49947ffa142b08cb4f710e888043854313c8a4bf7366188ea753f6eb5cdbecdd84e13f3346537d19b80bf8061a44983f43a0d8fb7edd3bdb302db0c674e07910c98e6d203a67ecf062d05577cd78cd3f1c107663b895e864e1ab5b1651ab114f7a000e479ae1f5640d11ed929cd558c98eb06f9331b68c8af1fceae7752fd41a583ba1978069cc16722565d3a2ee4c1d6d18284061c4376239042e079ac575ec7fe6fcb383fa1f9d08c54e897443eec19ea4c45d3339432c1f674d123395c6b65994d4af4ee9f2b0b59183da0fcd3a3fe70edc16f0556d7dda7a84845ae895eaad8ae4c64978d4e5829f33f6dcdb5aaa160d45df80a84c1e3bfb37472a970bddc81cdcdf039c09024de4f23ff04bdf93a492a37184642bdb93d421486f705f5b62e9ba1f9c56c3051a1d65d6adcdc2dd58db23210af812944bea89bae8fdc5722f2e3ad9cbd398c4a295eb083c0361c3a2cfcdc4fa9326708e61d313e0c98e459f8bb7c50c09bca18271e324f0609394f13039de500e749ae3ebaeab6bac9b6dc408b811168928974ec9d8557b0a953fc7654b3033b6c487f9d692dc697327002ebe86f59a1ef39dfe76b472bc2be707385e698aa27cf825fdc5d8b22085d533c7d6f1459d9473dac513317295a6b65ef75843f22a5cd29b90ebec596a7939ce1324d1e047b28b938e98bf70bb2f9352d7e7b72b93f8518d285d9c3de7192a1b2328b0551207dbc7222024ab733076eb0433357f5fd171716616c505526e915de5b6801ec10d5c4b98064b70fc22fb6b10edcb8f6c23aa6f95937a9ccfe00e45e438523e441bb99d9f15e71a056ccbfb5814a57b1ac88b512154164b82b45de2fe2d4bc55478c464fb857b213b153c3a009b78ee636d655eb882abf57e5a114565001c1dafec39bf4f361a1265d642f1af550d24908db09be8485d670e034245ede58a02fd711f10ee8d9482214a0389f7948c3f5481f90bd6b0b5fbe5fccd2ba154534ca6faf629d7de37e643c2bc38513af2d5a77af5b0bcd5051af8b3862fa5e4365f960ba71ed37acf53d450231c7439565551741e18bcb510a8a93e9a35008e57450e31bb2c599289a654c04faea589272d10e49d8c8e62773d43ce5d821122bfb6c837163beb2669ee099e92beb0c49a71b3883ea940b0c5170f810229d36d1b01a90d1b8236e4c6332c807740100612a378fc7ba61e94ecef60be348eda235de69fd852f13df7e213b9bd39f850e4e3fb26b8c21307c991ceb3153e765412038c15e6d97c5c92920233d30ce15c4a8bdd7f811a59e57757400cf30f86f9c6d0281e9d8bec6e6eea529fdec3bf9ef8498f2b2ab9e62486af67851cd782e1725e728c3d220ee5c107fe5e145af6ff370cadce2fa492780eed9c8e36aff3de54f07fd6af88c9187a836e1bc2e67c08e1de738745c16757cc96a76b02254f5f69f27505a27a43eca35fb5d22cb0717ba8333241ca2b5d9e1bc018496e87b2a2926cc66ef4cfd4d29093f181e2e5a6e10a8061dbdfc6ae41ee20fd5d1bf338e3ce24d4e3702712ad393717c1db52a212761bfe324e726b22203511e5cd68a8a3a309db52e71af3e3732563459e093c6ba76d88115bab2bca268a9fd5b053cd60abd974caaa4cf11a862f16c1c986827dee2fbf9c9e6930351c2942a63fb25495550a2190515e68f312e11068d071c0b91b1d13f964e9b8cab7cbabc71d904361738fb5a08af68613d97901596c9466a25b5743ca4d9d076d039a916adc3833159d0c50764c8eb8721db349cf1d5c760999cb4fcf94539fc1eae7856a0e91b29ccbe476125d90379be4c223acde9e29c1f0bd705389e027b6fdc4f83292ea212563cbb153115a99f023453223917c3d3ae898e72575730bedde8aff6eb1ed087ac301eb7f1aec88de83048c88c0e6a06dc593cba015989dc9d182f0a2d9d903f316a5f3e36a5194bda46fc0a15cd3ffa42b7c1b006d5e747ee411d2b942b32d3fa1a5b98789458f8a1869b17af7d718a024ea7c075975e6fd107305aa4ae9104413a04b5c0721611998f67c613f2fa22cc102378db7fb96bf3efcbf18e6624b47cec28a1f4fa7d3f14a2a30d0e2241b36f0995521105b6cd3e8e7c65066924af2961e613c8482d128f87d059b40da6e31e92d06e7d25e5f20072ce768238e1f0203b5c82fd08c0fe6113bb18c3de210a81e33d17a4c8047ef68261a553648fd655f86cf53843a097fe171f3900cbcfec0e8eb5b847dc91a2be64688f4042a332f924ff334abc399422b60816b43cdd3aee7845f51f239d9aa45524bee1b40eb0b979da3e5528727612d8a7c8ea1b9886643c79d8079622d9f2e9b771551e00e95e43da19c62ef279e53c24ca1c9e00844c18225a0c3b8bc828eec5c77154e279f9031c547f4b9b86e21d5b6ebe97d64a2a4292d0e6c62c5c60c6c15b4c77aa3f1ac998175c325052e90395f69b4aef38dbe3b6e03efa4209182f82f6869b5572e779f57bff1c5cf6594caa2121a9c73462f7366d56c2a78f6e21400de658b514aad8a4b1ca084381b47dd5fe1d8502769106c561112a15c102c6ec319363486e36d943b6fd115ecdc349b0011d9835d956249a1e623cba43e096c510d0ba62aad9f0656d91788210ca5666c8d9ef38991a26c2df708b74c24744dd14a2e5ad4dc93e7b420b06006bcc5bba529895890b144f4ad4fd6a46563cc2df410ec577a2f0bb03d6998d5ad43cce2ff6cdb41509dce1f121643ae8cca0d960303c6190bc00da1ed4121ad3f34765d95fffe25e206f1752236df5489b8dcb0fa3c93ac91d2fa876ae9248f1ded40214c4678f1ab780b5e26414bc827b89c20e05f854cf28a5ccf87fd1576d1671c5d63fbb3e019819b768430d0bfbcf2bf1cf0f6113d4f34734d4b203a16cad0b70aded5bdd7158ecf8338532585af34de36e97736d2d588613ee2d0652a99ffea40b7820de67201d8f817c65766dfc76cbb02c83e893d2746c9c046e0241fdf4f86fbddbd5324b2fe16bdaadb6a739bec4a545cd85c92042fb17b19dd220bb8224c6a5c5d79acf2a51c67ef07ced8d1ecb748a591cc5945ea1233986523d348e08e773b4d6e0f11579ee85c0e1141bbd724f7f6916728554e3abed9539b359b273d96312dc21f3c767955eef37d80fc667111d5003328e3e98ba1b0ac96de4e388db5a924d9783106e1883b5d7eb4276e8f93454b222ead4e364b3fcfec5f1fda71f2e95215d1b785e9c1c8816ee00a21f28a20b516dc4d597c20a88c08bd0c35107520a6e76486874d32cf0dd12469ff511d5de4edbd078899dfaae4ec7dd22b6b1c45733cf86a8dcbd3afa63ac808c0ae1ad8d39511b5fdaa04642bf206777ad66618670e48d0bcf10b2380a30923864be297b60303168d032f420ee8f94404dfab5437fa0779fb80d9c2a8bb431ec8df8b0f871cadbb38b642eace8d76b3b53ca4f2658b09ce63f696bdef5bed8db761e8106e6eb38356ec18106383c5f176d952d336c2de039eb247314e2feaad8148b52beae30914db6e8a06f6ee634e3551235a867b5f6f64c3590e2b4df9ecf69dad7376f75be4e6b917813eeb630bb21a4e9cd1c78693013767e5f1c9bf441529ba6ef824b66b5557b3f8fe3d10edd6e28660929b32254ffad1683508c691aad456503eff6beb71df1b96c884e460be453a46c70dba83cc33f8b52da7a596c009c3bdd668a26d4a9c9f6b32c32dde73ba24b1327339dd17feaa63cb260aea51cc5ce7def1082481a1b9d753052e5a926a16740d8c4848c8da48e9395fc36e8766dc7e6f3bfae27dac0716881e76a8356e72d03ace3b9f7713c01ee740f7e0a1cd928dfc0baef7284522c1661fed81ca024a71c335a1a9e43c543b4b2278642a67c163a7613bd194ead44761d4e75e5e2819c061e2eb565f1f1653b5f6dc472517c1570be4e6cec225dd23c12da352176a651d5d6ce81e3d10dad705dcd679080e812069f0271b4497fe03e871712f570a725c04544901ff4de8d3abe5939725e35b2c549c76ff3c3a824ba0b6f1d628d5dcdb74e932ffff62a229685d848f94acb032b4bf75ed65776d24dc515d2ae4601032c4890d00a8c30fcec93c6882c992b9e32ec301a07e949f33a1bd0eae6e0f1443dcbc4a1b4878f8621b8d1af1b857e918310068d60cc9438c7d369d2ec8abc918e9214b8d4c2391be3501c161672f1f3f5bac60cdd4d9d1b0de032ae3abd196ace14d62cd6ff64c33add3fdc0b806ea98cee87ea8616c1bc4a7939da48dadfacaab75da430896056c3b41264ce5a40f58b8d009bb62448d237e4a42d4b3ace03d50a410d69b076afa311df57b7a6c0b14333e12b942597c5d81ae7c7edf9adb85911d1310ed9a8fa131832b7e5ea0e5f6fc2194e109ba7912c8d36d04d6a77bfb688e50611b85e1519a25d42b31b4fa827c1d0e6a4b2a14d4a4d7055c0f73a0a40c22f69284ef579487b4a552e43a00e5372ab553956659ec2eceb991f27f0d2fac486f02b03e8e5d4350de97feed963dae3495c76d9e76f269b7012461698fe17296dcfa321c6b3ed5091e015d9ad9e865af892af4c787</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Next 主题博客个性化配置(2022年更新版本)</title>
    <url>/posts/75999130/</url>
    <content><![CDATA[<h1 id="Hexo-Next-主题博客个性化配置-2022年更行版本"><a href="#Hexo-Next-主题博客个性化配置-2022年更行版本" class="headerlink" title="Hexo-Next 主题博客个性化配置(2022年更行版本)"></a>Hexo-Next 主题博客个性化配置(2022年更行版本)</h1><h2 id="网页预览："><a href="#网页预览：" class="headerlink" title="网页预览："></a>网页预览：</h2><p><a href="https://swimminghao.netlify.app/">swimminghao.netlify.app</a><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/01/rRBwpH.png" alt="在这里插入图片描述"><br>因为本人比较喜欢简介风格的，所以整个界面都是<code>简约风格</code>的，一个好的博客，应该让人一眼就能看清楚技术分类,文章也应该就是文章，<code>让人能够最好的阅读你的博客</code> 这才是我们应该做的，所以没有太多花里胡哨的东西。</p>
<p><strong>使用工具：</strong></p>
<p><strong>Git<br>Github<br>visual studio code<br>Chrome</strong></p>
<h2 id="Hexo简易安装"><a href="#Hexo简易安装" class="headerlink" title="Hexo简易安装"></a>Hexo简易安装</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p><strong>软件版本</strong></p>
<p><strong>HEXO: 6.0.6<br>Hero-theme-next: 8.10.0</strong></p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h1 id="主题下载安装"><a href="#主题下载安装" class="headerlink" title="主题下载安装"></a>主题下载安装</h1><p>进入命令行，下载 <a href="https://so.csdn.net/so/search?q=NexT&spm=1001.2101.3001.7020">NexT</a> 主题，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next/ themes/next</span><br></pre></td></tr></table></figure>

<p>修改站点配置文件<code>_config.yml</code>，找到如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: landscape =&gt; next</span><br></pre></td></tr></table></figure>

<p>将 landscape 修改为 next 即可。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在 Hexo 中有<strong>两份</strong>主要的配置文件，其名称都是 <strong>_config.yml</strong>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的站点配置；另一份位于主<strong>题目录下</strong>，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 **<code>站点配置文件</code>**， 后者称为 **<code>主题配置文件</code>**。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/hexo/_config.yml</span><br><span class="line">/hexo/themes/next/_config.yml</span><br></pre></td></tr></table></figure>

<h2 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h2><p>打开站点配置文件，搜索 language，找到如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">author: authorName</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h2 id="新建标签及分类界面"><a href="#新建标签及分类界面" class="headerlink" title="新建标签及分类界面"></a>新建标签及分类界面</h2><p>打开 <strong>主题配置文件</strong>，搜索 menu，找到如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<p>把 tags 和 categories 前面的 # 删除，</p>
<h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><p>next 主题自带<strong>四种样式</strong>。</p>
<p>在主题配置文件<code>/next/_config.yml</code>中查找：<code>scheme</code>，找到如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line">scheme: Muse</span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line">选择你喜欢的一种样式，去掉前面的 <span class="comment">#，其他主题前加上 # 即可。</span></span><br></pre></td></tr></table></figure>

<h2 id="隐藏网页底部-powered-By-Hexo-x2F-强力驱动"><a href="#隐藏网页底部-powered-By-Hexo-x2F-强力驱动" class="headerlink" title="隐藏网页底部 powered By Hexo &#x2F; 强力驱动"></a>隐藏网页底部 powered By Hexo &#x2F; 强力驱动</h2><p>打开 themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.njk</p>
<p>找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;\%- <span class="keyword">if</span> theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=<span class="string">&quot;powered-by&quot;</span>&gt;</span><br><span class="line">    &#123;\%- <span class="type">set</span> <span class="variable">next_site</span> <span class="operator">=</span> <span class="string">&#x27;https://theme-next.js.org&#x27;</span> <span class="keyword">if</span> theme.scheme === <span class="string">&#x27;Gemini&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;https://theme-next.js.org/&#x27;</span> + theme.scheme | lower + <span class="string">&#x27;/&#x27;</span> %&#125;</span><br><span class="line">    &#123;&#123;- __(<span class="string">&#x27;footer.powered&#x27;</span>, next_url(<span class="string">&#x27;https://hexo.io&#x27;</span>, <span class="string">&#x27;Hexo&#x27;</span>) + <span class="string">&#x27; &amp; &#x27;</span> + next_url(next_site, <span class="string">&#x27;NexT.&#x27;</span> + theme.scheme)) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;\%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p>把这段代码首尾分别加上：<code>&lt;!--</code> 和<code>--&gt;</code>，或者直接删除。</p>
<h2 id="主页文章添加阴影"><a href="#主页文章添加阴影" class="headerlink" title="主页文章添加阴影"></a>主页文章添加阴影</h2><p>参考： <a href="https://www.jianshu.com/p/64caf29fdd0c">Hexo NexT 主题美化记录</a><br>打开<code>themes\next\source\css\_common\components\post\index.styl</code>文件，将<code>post-block</code>更改为如下代码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">if</span> <span class="string">(hexo-config(&#x27;motion.transition.post_block&#x27;))</span> &#123;</span><br><span class="line">    <span class="string">.post-block</span>&#123;</span><br><span class="line">        <span class="attr">margin-top:</span> <span class="string">60px;</span></span><br><span class="line">        <span class="attr">margin-bottom:</span> <span class="string">60px;</span></span><br><span class="line">        <span class="attr">padding:</span> <span class="string">25px;</span></span><br><span class="line">        <span class="string">background:rgba(255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span><span class="string">)</span> <span class="string">none</span> <span class="string">repeat</span> <span class="string">scroll</span> <span class="type">!important;</span> <span class="string">//添加透明效果</span></span><br><span class="line">        <span class="string">-webkit-box-shadow:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">5px</span> <span class="string">rgba(202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span><span class="string">);</span></span><br><span class="line">        <span class="string">-moz-box-shadow:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">5px</span> <span class="string">rgba(202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span><span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">.pagination</span>, <span class="string">.comments</span> &#123;</span><br><span class="line">      <span class="attr">opacity:</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="页脚增加网站运行时间统计"><a href="#页脚增加网站运行时间统计" class="headerlink" title="页脚增加网站运行时间统计"></a>页脚增加网站运行时间统计</h2><ol>
<li>打开<code>themes/next/layout/_partials/footer.njk</code>文件，在如下图位置加入代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;\%- <span class="keyword">if</span> config.<span class="property">symbols_count_time</span>.<span class="property">total_symbols</span> or config.<span class="property">symbols_count_time</span>.<span class="property">total_time</span> %&#125;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;wordcount&quot;</span>&gt;</span><br><span class="line">  &#123;\%- <span class="keyword">if</span> config.<span class="property">symbols_count_time</span>.<span class="property">total_symbols</span> %&#125;</span><br><span class="line">  &lt;span <span class="keyword">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-chart-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    &#123;\%- <span class="keyword">if</span> theme.<span class="property">symbols_count_time</span>.<span class="property">item_text_total</span> %&#125;</span><br><span class="line">      &lt;span&gt;&#123;&#123; <span class="title function_">__</span>(<span class="string">&#x27;symbols_count_time.count_total&#x27;</span>) + <span class="title function_">__</span>(<span class="string">&#x27;symbol.colon&#x27;</span>) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;\%- endif %&#125;</span><br><span class="line">    &lt;span title=<span class="string">&quot;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) &#125;&#125;&quot;</span>&gt;&#123;&#123; <span class="title function_">symbolsCountTotal</span>(site) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &#123;\%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;\%- <span class="keyword">if</span> config.<span class="property">symbols_count_time</span>.<span class="property">total_time</span> %&#125;</span><br><span class="line">  &lt;span <span class="keyword">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-coffee&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    &#123;\%- <span class="keyword">if</span> theme.<span class="property">symbols_count_time</span>.<span class="property">item_text_total</span> %&#125;</span><br><span class="line">      &lt;span&gt;&#123;&#123; <span class="title function_">__</span>(<span class="string">&#x27;symbols_count_time.time_total&#x27;</span>) &#125;&#125; &amp;asymp;&lt;/span&gt;</span><br><span class="line">    &#123;\%- endif %&#125;</span><br><span class="line">    &lt;span title=<span class="string">&quot;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125;&quot;</span>&gt;&#123;&#123; <span class="title function_">symbolsTimeTotal</span>(site, config.<span class="property">symbols_count_time</span>.<span class="property">awl</span>, config.<span class="property">symbols_count_time</span>.<span class="property">wpm</span>, <span class="title function_">__</span>(<span class="string">&#x27;symbols_count_time.time_minutes&#x27;</span>)) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &#123;\%- endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;\%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此位置插入代码</span></span><br><span class="line"></span><br><span class="line">&#123;\%- <span class="keyword">if</span> theme.<span class="property">busuanzi_count</span>.<span class="property">enable</span> %&#125;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;busuanzi-count&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>倒计时代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;sitetime&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">javascript</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">siteTime</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="string">&quot;siteTime()&quot;</span>, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> years = days * <span class="number">365</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> todayYear = today.<span class="title function_">getFullYear</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> todayMonth = today.<span class="title function_">getMonth</span>()+<span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> todayDate = today.<span class="title function_">getDate</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> todayHour = today.<span class="title function_">getHours</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> todayMinute = today.<span class="title function_">getMinutes</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> todaySecond = today.<span class="title function_">getSeconds</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        year - 作为date对象的年份，为4位年份值</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        month - 0-11之间的整数，做为date对象的月份</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        day - 1-31之间的整数，做为date对象的天数</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        minutes - 0-59之间的整数，做为date对象的分钟数</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        seconds - 0-59之间的整数，做为date对象的秒数</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">        microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> t1 = <span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2022</span>,<span class="number">01</span>,<span class="number">04</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>); <span class="comment">//你的建站时间</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> t2 = <span class="title class_">Date</span>.<span class="title function_">UTC</span>(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> diff = t2-t1;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> diffYears = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff/years);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> diffDays = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff/days)-diffYears*<span class="number">365</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> diffHours = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days)/hours);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> diffMinutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> diffSeconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sitetime&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot; Run for &quot;</span>+diffYears+<span class="string">&quot; Year &quot;</span>+diffDays+<span class="string">&quot; Days &quot;</span>+diffHours+<span class="string">&quot; Hours &quot;</span>+diffMinutes+<span class="string">&quot; m &quot;</span>+diffSeconds+<span class="string">&quot; s&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">siteTime</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>在<code>themes\next\source\css\main.styl</code>文件中给倒计时添加样式</li>
</ol>
<p><strong>不生效</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sitetime</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(left, <span class="number">#aa4b6b</span>, <span class="number">#6b6b83</span>, <span class="number">#3b8d99</span>);</span><br><span class="line">  -webkit-<span class="attribute">background-clip</span>: text;</span><br><span class="line">  -webkit-text-fill-<span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浏览页面显示当前浏览进度"><a href="#浏览页面显示当前浏览进度" class="headerlink" title="浏览页面显示当前浏览进度"></a>浏览页面显示当前浏览进度</h2><p>打开 themes&#x2F;next&#x2F;_config.yml，搜索关键字 <code>scrollpercent</code>，把 false 改为 true。</p>
<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/02/SIVZj0.png" alt="在这里插入图片描述"></p>
<h2 id="Local-Search本地搜索"><a href="#Local-Search本地搜索" class="headerlink" title="Local Search本地搜索"></a>Local Search本地搜索</h2><p>安装插件<code>hexo-generator-searchdb</code>,执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save	</span><br></pre></td></tr></table></figure>

<p>修改<code>hexo/_config.yml</code>站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>编辑 <strong>主题配置文件</strong>，启用本地搜索功能：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/02/b1OAJr.png" alt="在这里插入图片描述"></p>
<h2 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h2><p>在 <a href="https://www.easyicon.cc/">EasyIcon</a> 中找一张（32 * 32）的 ico 图标，或者去别的网站下载或者制作，并将图标名称改为 favicon.ico，然后把图标放在 <code>/themes/next/source/images</code> 里，并且修改主题配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">Put</span> <span class="string">your</span> <span class="string">favicon.ico</span> <span class="string">into</span> <span class="string">`hexo-site/source/`</span> <span class="string">directory.</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文章底部的-号的标签，改为图标"><a href="#修改文章底部的-号的标签，改为图标" class="headerlink" title="修改文章底部的#号的标签，改为图标"></a>修改文章底部的#号的标签，改为图标</h2><p>修改模板<code>/themes/next/layout/_macro/post.swig</code></p>
<p>搜索 <code>rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125;</code>，将 <code>&#123;&#123; tag_indicate &#125;&#125;</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/02/IPgd1C.png" alt="在这里插入图片描述"></p>
<h1 id="文章分享功能"><a href="#文章分享功能" class="headerlink" title="文章分享功能"></a>文章分享功能</h1><p>打开<code>themes/next/_config.yml</code> 搜索关键字<code>needmoreshare2</code> 修改为下面设置</p>
<p>用npm卸载掉<code>hexo-next-share</code>，搜索所有<code>hexo-next-share</code>文件夹删除干净，然后切换到<strong>网站文件夹</strong>下，运行<code>npm install theme-next/hexo-next-share --save</code>,将以下代码都复制进<strong>主题配置文件</strong>里</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NeedMoreShare2</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-needmoreshare2</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/revir/need-more-share2</span></span><br><span class="line"><span class="comment"># iconStyle: default | box</span></span><br><span class="line"><span class="comment"># boxForm: horizontal | vertical</span></span><br><span class="line"><span class="comment"># position: top / middle / bottom + Left / Center / Right</span></span><br><span class="line"><span class="comment"># networks:</span></span><br><span class="line"><span class="comment"># Weibo | Wechat | Douban | QQZone | Twitter | Facebook | Linkedin | Mailto | Reddit | Delicious | StumbleUpon | Pinterest</span></span><br><span class="line"><span class="comment"># GooglePlus | Tumblr | GoogleBookmarks | Newsvine | Evernote | Friendfeed | Vkontakte | Odnoklassniki | Mailru</span></span><br><span class="line"><span class="attr">needmoreshare:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css</span></span><br><span class="line">  <span class="attr">postbottom:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">middleCenter</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line">  <span class="attr">float:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">middleCenter</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Likely Share</span></span><br><span class="line"><span class="comment"># See: https://ilyabirman.net/projects/likely/, https://github.com/ilyabirman/Likely</span></span><br><span class="line"><span class="comment"># Likely supports four looks, nine social networks, any button text.</span></span><br><span class="line"><span class="comment"># You are free to modify the text value and order of any network.</span></span><br><span class="line"><span class="attr">likely:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.min.js</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.min.css</span></span><br><span class="line">  <span class="attr">look:</span> <span class="string">light</span> <span class="comment"># available values: normal, light, small, big</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">twitter:</span> <span class="string">Tweet</span></span><br><span class="line">    <span class="attr">facebook:</span> <span class="string">Share</span></span><br><span class="line">    <span class="attr">linkedin:</span> <span class="string">Link</span></span><br><span class="line">    <span class="attr">gplus:</span> <span class="string">Plus</span></span><br><span class="line">    <span class="attr">vkontakte:</span> <span class="string">Share</span></span><br><span class="line">    <span class="attr">odnoklassniki:</span> <span class="string">Class</span></span><br><span class="line">    <span class="attr">telegram:</span> <span class="string">Send</span></span><br><span class="line">    <span class="attr">whatsapp:</span> <span class="string">Send</span></span><br><span class="line">    <span class="attr">pinterest:</span> <span class="string">Pin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># share.js</span></span><br><span class="line"><span class="comment"># See: https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="comment"># networks: weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.js</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.css</span></span><br><span class="line">  <span class="attr">networks:</span> <span class="string">weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google</span></span><br><span class="line">  <span class="attr">wechat_qrcode:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">share.title</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">share.prompt</span></span><br></pre></td></tr></table></figure>

<p>效果图：<br><code>postbottom</code>为文章末尾分享 <code>float</code>则是在页面侧端分享<br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/02/ce3s7Z.png" alt="在这里插入图片描述"></p>
<h2 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h2><p>参考链接： <a href="https://swimminghao.netlify.app/posts/c30e6297/">hexo文章加密访问</a></p>
<h2 id="增加文章字数统计及阅读时常功能"><a href="#增加文章字数统计及阅读时常功能" class="headerlink" title="增加文章字数统计及阅读时常功能"></a>增加文章字数统计及阅读时常功能</h2><p>安装字数统计插件 <code>npm i hexo-symbols-count-time</code><br>在<code>hexo</code>的<code>_config.yml</code>下找到<code># Extensions</code>在下面配置插件配置如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字数统计插件 npm i hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment"># 文章时长统计</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span> <span class="comment"># 全局字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment"># 全局时长统计</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>  <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>

<h2 id="文章置顶功能"><a href="#文章置顶功能" class="headerlink" title="文章置顶功能"></a>文章置顶功能</h2><p>移除默认安装的插件：</p>
<p><code>npm uninstall hexo-generator-index --save</code><br>安装新插件:</p>
<p><code>npm install hexo-generator-index-pin-top --save</code><br>最后编辑有这需求的相关文章时，在Front-matter（文件最上方以—分隔的区域）加上一行：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="literal">top</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Post a.md</span><br><span class="line">title: a</span><br><span class="line">top: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Post b.md</span><br><span class="line">title: b</span><br><span class="line">top: <span class="number">10</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>文章 b 便会显示在文章 a 的前面</p>
<p>设置置顶图标<br>打开<code>/themes/next/layout/_macro/post.swig</code>文件，在<code>&lt;div class=&quot;post-meta-container&quot;&gt;</code>下方，插入如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;\% <span class="keyword">if</span> post.<span class="property">top</span> %&#125;</span><br><span class="line">    &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#123;\% endif %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/02/FmHSJT.png" alt="在这里插入图片描述"></p>
<h2 id="修改-Read-More-按钮样式"><a href="#修改-Read-More-按钮样式" class="headerlink" title="修改[Read More]按钮样式"></a>修改[Read More]按钮样式</h2><p>修改<code>themes/next/source/css/_common/components/post/index.styl</code>文件，加入自定义样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// <span class="selector-attr">[Read More]</span>按钮样式</span><br><span class="line"><span class="selector-class">.post-button</span> <span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#555</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.35</span>);</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">transition-property</span>: unset;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-button</span> <span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.35</span>);</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#a166ab</span> <span class="number">0%</span>, <span class="number">#ef4e7b</span> <span class="number">25%</span>, <span class="number">#f37055</span> <span class="number">50%</span>, <span class="number">#ef4e7b</span> <span class="number">75%</span>, <span class="number">#a166ab</span> <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/03/ymZvXQ.png" alt="在这里插入图片描述"></p>
<h2 id="修改-阅读全文-前显示文字数量即位置"><a href="#修改-阅读全文-前显示文字数量即位置" class="headerlink" title="修改 阅读全文 前显示文字数量即位置"></a>修改 阅读全文 前显示文字数量即位置</h2><p>打开 <code>themes/next/_config.yml</code>，搜索关键字 <code>auto_excerpt</code>， 修改length即可修改阅读全文前显示文字数量</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p><strong>或者在文章中任意位置添加<code>&lt;!-- more --&gt;</code></strong></p>
<p>建议在文章中加入 <code>&lt;!-- more --&gt;</code><br>自定义 [Read More] 按钮之前要显示的内容！</p>
<h2 id="修改链接文字样式"><a href="#修改链接文字样式" class="headerlink" title="修改链接文字样式"></a>修改链接文字样式</h2><p>打开<code>themes/next/source/css/_common/components/post/index.styl</code>添加以下代码:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.post-body</span> <span class="string">p</span> <span class="string">a&#123;</span></span><br><span class="line"> <span class="attr">color:</span> <span class="comment">#0593d3;</span></span><br><span class="line"> <span class="attr">border-bottom:</span> <span class="string">none;</span></span><br><span class="line"> <span class="string">&amp;:hover</span> &#123;</span><br><span class="line">   <span class="attr">color:</span> <span class="comment">#ff106c;</span></span><br><span class="line">   <span class="attr">text-decoration:</span> <span class="string">underline;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/03/6Ulm5b.png" alt="在这里插入图片描述"></p>
<h2 id="头像设置圆形-停留旋转效果"><a href="#头像设置圆形-停留旋转效果" class="headerlink" title="头像设置圆形,停留旋转效果"></a>头像设置圆形,停留旋转效果</h2><p>修改next主题配置文件,修改成以下代码:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/lion.png</span></span><br><span class="line">  <span class="comment"># lion.png放置在next/source/images文件夹下</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be displayed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/03/lQxmpv.png" alt="在这里插入图片描述"></p>
<h2 id="增加近期文章"><a href="#增加近期文章" class="headerlink" title="增加近期文章"></a>增加近期文章</h2><p>hexo主站<code>source</code> 目录下创建 <code>_data/sidebar.njk</code> 文件，加入如下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;# recent posts #&#125;</span><br><span class="line">&#123;\% if theme<span class="selector-class">.recent_posts</span> %&#125;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme<span class="selector-class">.recent_posts_layout</span>  &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">      &lt;!-- modify <span class="attribute">icon</span> <span class="selector-tag">to</span> fire by szw --&gt;</span><br><span class="line">      &lt;<span class="selector-tag">i</span> class=&quot;fa fa-history fa-&#123;&#123; theme<span class="selector-class">.recent_posts_icon</span> | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;</span><br><span class="line">      &#123;&#123; theme<span class="selector-class">.recent_posts_title</span> &#125;&#125;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span> class=&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">      &#123;\% set posts = site<span class="selector-class">.posts</span><span class="selector-class">.sort</span>(&#x27;-date&#x27;) %&#125;</span><br><span class="line">      &#123;\% for post in posts<span class="selector-class">.slice</span>(&#x27;<span class="number">0</span>&#x27;, &#x27;<span class="number">5</span>&#x27;) %&#125;</span><br><span class="line">        &lt;<span class="selector-tag">li</span> class=&quot;recent_posts_li&quot;&gt;</span><br><span class="line">          &lt;<span class="selector-tag">a</span> href=&quot;&#123;&#123; url_for(post<span class="selector-class">.path</span>) &#125;&#125;&quot; title=&quot;&#123;&#123; post<span class="selector-class">.title</span> &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post<span class="selector-class">.title</span> &#125;&#125;&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &#123;\% endfor %&#125;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&#123;\% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>并修改theme主题配置文件，取消sidebar的注释:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="string">source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>


<p>编辑<code>themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl</code>文件，标题溢出隐藏</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.links-of-blogroll-list</span> &#123;</span><br><span class="line">  <span class="attr">list-style:</span> <span class="string">none;</span></span><br><span class="line">  <span class="attr">margin:</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="attr">text-align:</span> <span class="string">cengter;</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">block;</span></span><br><span class="line">  <span class="attr">word-break:</span> <span class="string">keep-all;</span></span><br><span class="line">  <span class="attr">white-space:</span> <span class="string">nowrap;</span></span><br><span class="line">  <span class="attr">overflow:</span> <span class="string">hidden;</span></span><br><span class="line">  <span class="attr">text-overflow:</span> <span class="string">ellipsis;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>themes/next/_config.yml</code>中修改成下方代码</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 近期文章设置</span></span><br><span class="line"><span class="attr">recent_posts_title:</span> <span class="string">近期文章</span></span><br><span class="line"><span class="attr">recent_posts_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="attr">recent_posts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>效果图：</strong><br><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2022/03/03/heV4KR.png" alt="在这里插入图片描述"></p>
<h2 id="文章末尾添加”本文结束”标记"><a href="#文章末尾添加”本文结束”标记" class="headerlink" title="文章末尾添加”本文结束”标记"></a>文章末尾添加”本文结束”标记</h2><ul>
<li><p>在目录<code>themes/next/layout/_macro/</code>下添加<code>passage-end-tag.swig</code>，内容如下： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;\% if not is_index %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:20px;&quot;</span>&gt;</span>------------- 本 文 结 束&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp感 谢 您 的 阅 读 -------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;\% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>themes/next/layout/_macro/post.swig</code>文件，新增内容如下:</p>
</li>
<li><p>&#96;&#96;&#96;HTML<br><br>&#x2F;&#x2F;以下为新增代码</p>
<div>
    {\% if not is_index %}
    {\% include 'passage-end-tag.swig' %}
    {\% endif %}
 </div>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- 打开`主题配置文件`，添加代码如下：</span><br><span class="line">- ```js</span><br><span class="line">  # 文章末尾添加“本文结束”标记</span><br><span class="line"><span class="title">  passage_end_tag:</span></span><br><span class="line"><span class="title">  enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="为博客加上妹子"><a href="#为博客加上妹子" class="headerlink" title="为博客加上妹子"></a>为博客加上妹子</h1><p>live2d与busuanzi组件有bug冲突，安装了live2d，busuanzi就失效，所以我没有使用。</p>
<p><code>npm install -save hexo-helper-live2d</code><br>然后在在 hexo 的 _config.yml中添加参数：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-&lt;你喜欢的模型名字&gt;s</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>可供选择模型：</p>
<ul>
<li><code>live2d-widget-model-chitose</code></li>
<li><code>live2d-widget-model-epsilon2_1</code></li>
<li><code>live2d-widget-model-gf</code></li>
<li><code>live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)</code></li>
<li><code>live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)</code></li>
<li><code>live2d-widget-model-haruto</code></li>
<li><code>live2d-widget-model-hibiki</code></li>
<li><code>live2d-widget-model-hijiki</code></li>
<li><code>live2d-widget-model-izumi</code></li>
<li><code>live2d-widget-model-koharu</code></li>
<li><code>live2d-widget-model-miku</code></li>
<li><code>live2d-widget-model-ni-j</code></li>
<li><code>live2d-widget-model-nico</code></li>
<li><code>live2d-widget-model-nietzsche</code></li>
<li><code>live2d-widget-model-nipsilon</code></li>
<li><code>live2d-widget-model-nito</code></li>
<li><code>live2d-widget-model-shizuku</code></li>
<li><code>live2d-widget-model-tororo</code></li>
<li><code>live2d-widget-model-tsumiki</code></li>
<li><code>live2d-widget-model-unitychan</code></li>
<li><code>live2d-widget-model-wanko</code></li>
<li><code>live2d-widget-model-z16</code></li>
</ul>
<p>在站点目录下建文件夹<code>live2d_models</code>，</p>
<p>再在<code>live2d_models</code>下建文件夹<code>&lt;你喜欢的模型名字</code>&gt;,</p>
<p>再在<code>&lt;你喜欢的模型名字&gt;</code>下建json文件：<code>&lt;你喜欢的模型名字&gt;.model.json</code></p>
<p>安装模型。在命令行（即Git Bash）运行以下命令即可：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment">--save live2d-widget-model-&lt;你喜欢的模型名字&gt;</span></span><br></pre></td></tr></table></figure>

<p>复制你喜欢的模型名字：</p>
<h2 id="代码块复制选项"><a href="#代码块复制选项" class="headerlink" title="代码块复制选项"></a>代码块复制选项</h2><p>Next6 中自带了复制代码按钮，Next5 需要自己手动配置。</p>
<p>搜索 codeblock，找到如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line"><span class="attr">border_radius:</span> <span class="number">8</span>   <span class="comment"># 按钮圆滑度</span></span><br><span class="line"><span class="attr">copy_button:</span>  <span class="comment"># 设置是否开启代码块复制按钮</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">show_result:</span> <span class="literal">true</span>  <span class="comment"># 是否显示复制成功信息</span></span><br></pre></td></tr></table></figure>

<h2 id="修改加载特效"><a href="#修改加载特效" class="headerlink" title="修改加载特效"></a>修改加载特效</h2><p>由于网页不可能一直都秒进，总会等待一段时间的，所以可以设置顶部加载条。Next 已经集成了很多加载特效，可以在下面选项中在线调试测试一下。</p>
<p>next主题配置文件搜索<code>pace</code>，找到如下代码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="string">G#</span> <span class="attr">For more information:</span> <span class="string">https://github.com/CodeByZach/pace</span></span><br><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># All available colors:</span></span><br><span class="line">  <span class="comment"># black | blue | green | orange | pink | purple | red | silver | white | yellow</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">blue</span></span><br><span class="line">  <span class="comment"># All available themes:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">loading-bar</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h2><p>在做次优化之前，hexo-next文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。<br>比如：<code>https://zxiaoxuan.github.io/2019/08/12/hello-world/</code> 这样，如果文章标题是中文的话，URL链接是也会是中文，<br><img src="https://img-blog.csdnimg.cn/20190831093938325.png" alt="在这里插入图片描述"></p>
<p>那么要生存简洁且唯一的URL，怎么办呢</p>
<p><strong>安装插件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行此命令可能会不成功，提示你缺少相应的依赖，比如babel-eslint、mini-css-extract-plugin、webpack-cli…<br>使用npm命令安装即可，比如npm install <a href="mailto:&#x65;&#x73;&#x6c;&#105;&#x6e;&#116;&#x40;&#52;&#x2e;&#120;">&#x65;&#x73;&#x6c;&#105;&#x6e;&#116;&#x40;&#52;&#x2e;&#120;</a> babel-eslint@8 –save-dev</p>
</blockquote>
<p>修改根目录站点配置文件<code>config.yml</code>，改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">	<span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">	<span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<p>生成的链接将会是这样的(官方样例)：<br><strong>四种可供选择</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:<span class="regexp">//</span>post.zz173.com<span class="regexp">/posts/</span><span class="number">66</span>c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:<span class="regexp">//</span>post.zz173.com<span class="regexp">/posts/</span><span class="number">65535</span>.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:<span class="regexp">//</span>post.zz173.com<span class="regexp">/posts/</span><span class="number">8</span>ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:<span class="regexp">//</span>post.zz173.com<span class="regexp">/posts/</span><span class="number">1690090958</span>.html</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>生成完后，原<code>md</code>文件的<code>Front-matter</code> 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p>
<h2 id="评论-Waline-增强版"><a href="#评论-Waline-增强版" class="headerlink" title="评论 Waline 增强版"></a>评论 Waline 增强版</h2><p>参考链接<a href="%5Bhexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E8%AE%BF%E9%97%AE%5D(https://swimminghao.netlify.app/posts/a07389a8/)">Hexo NexT Waline评论</a></p>
<h2 id="各版块透明度修改"><a href="#各版块透明度修改" class="headerlink" title="各版块透明度修改"></a>各版块透明度修改</h2><p><strong>内容板块透明</strong><br>博客根目录 <code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件 <code>.content-wrap</code> 标签下 <code>background: white</code>修改为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>.<span class="number">7</span>); //<span class="number">0</span>.<span class="number">7</span>是透明度</span><br></pre></td></tr></table></figure>

<p><strong>菜单栏背景</strong><br>博客根目录 <code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.header-inner</code>标签下 background: white修改为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>.<span class="number">7</span>); //<span class="number">0</span>.<span class="number">7</span>是透明度</span><br></pre></td></tr></table></figure>

<p><strong>站点概况背景</strong><br>博客根目录<code>themes\next\source\css\_schemes\Pisces\_sidebar.styl</code> 文件<code>.sidebar-inner</code> 标签下 background: white修改为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>.<span class="number">7</span>); //<span class="number">0</span>.<span class="number">7</span>是透明度</span><br></pre></td></tr></table></figure>

<p>然后修改博客根目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.sidebar</code> 标签下 <code>background: $body-bg-color</code>修改为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>.<span class="number">7</span>); //<span class="number">0</span>.<span class="number">7</span>是透明度</span><br></pre></td></tr></table></figure>

<p><strong>按钮背景</strong><br>博客根目录<code>themes\next\source\css\_common\components\post\post-button.styl</code> 同上修改对应位置为 <code>background: transparent;</code></p>
<h2 id="标签修改"><a href="#标签修改" class="headerlink" title="标签修改"></a>标签修改</h2><p>打开<code>themes/next/layout/page.swig</code></p>
<p>修改这里可以修改标签页的标签显示<br><img src="https://img-blog.csdnimg.cn/2019092019070486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在这里添加东西会在标签页面上显示<br><img src="https://img-blog.csdnimg.cn/20190920190746932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="彩色标签云"><a href="#彩色标签云" class="headerlink" title="彩色标签云"></a>彩色标签云</h2><p>在<code>/themes/next/layout/</code>目录下，新增<code>tag-color.swig</code>文件，加入下方代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     <span class="keyword">var</span> alltags = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;tag-cloud-tags&#x27;</span>);</span><br><span class="line">     <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = tags.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">var</span> r=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">75</span>+<span class="number">130</span>);</span><br><span class="line">       <span class="keyword">var</span> g=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">75</span>+<span class="number">100</span>);</span><br><span class="line">       <span class="keyword">var</span> b=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">75</span>+<span class="number">80</span>);</span><br><span class="line">       tags[i].<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;rgb(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+g+<span class="string">&quot;,&quot;</span>+b+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="comment">/*font-family: Helvetica, Tahoma, Arial;*/</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="comment">/*font-weight: 100;*/</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">counter-reset</span>: tags;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">padding-left</span>: <span class="number">5px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">5px</span> <span class="number">0px</span> <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:before</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">content</span>: <span class="string">&quot;?&quot;</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">5px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="comment">/*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">transition-duration</span>: <span class="number">0.15s</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在&#x2F;themes&#x2F;next&#x2F;layout&#x2F;page.swig&#x2F;中引入tag-color.swig：</p>
<p>在下方加上 <code>&#123;\% include &#39;tag-color.swig&#39; %&#125;</code> 代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;div <span class="keyword">class</span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line">          &lt;!--    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;&#123; _p(&#x27;counter.tag_cloud&#x27;, site.tags.length) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  --&gt;</span><br><span class="line">             <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			  &#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#x27;#FFF&#x27;, end_color: &#x27;#FFF&#x27;&#125;) &#125;&#125;            </span></span><br><span class="line"><span class="language-xml">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">+     &#123;\% include <span class="string">&#x27;tag-color.swig&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>或者将上方代码直接添加到下方</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190922224709732.png" alt="在这里插入图片描述"></p>
<h2 id="将标签云放到首页"><a href="#将标签云放到首页" class="headerlink" title="将标签云放到首页"></a>将标签云放到首页</h2><p>在路径：<code>/themes/next/layout/index.swig</code> 中</p>
<p><code>&#123;\% block content %&#125;</code>下面添加下方代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;\% block content %&#125;</span><br><span class="line"></span><br><span class="line">	&lt;div <span class="keyword">class</span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line">	  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#x27;#fff&#x27;, end_color: &#x27;#fff&#x27;&#125;) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	&#123;\% include <span class="string">&#x27;tag-color.swig&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190920194842525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="归档页美化"><a href="#归档页美化" class="headerlink" title="归档页美化"></a>归档页美化</h2><p>修改&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;post-collapse.swig后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;\% macro <span class="title function_">render</span>(post) %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;article <span class="keyword">class</span>=<span class="string">&quot;post post-type-&#123;&#123; post.type | default(&#x27;normal&#x27;) &#125;&#125;&quot;</span> itemscope itemtype=<span class="string">&quot;http://schema.org/Article&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;post-header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &lt;&#123;\% if theme.seo %&#125;h3&#123;\% else %&#125;h2&#123;\% endif %&#125; class=&quot;post-title&quot;&gt;</span></span><br><span class="line"><span class="language-xml">        &#123;\% if post.link %&#125;&#123;# Link posts #&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;post-title-link post-title-link-external&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(post.link) &#125;&#125;&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;&#123; post.title or post.link &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-external-link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;\% else %&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;post-title-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;\% if post.type === &#x27;picture&#x27; %&#125;</span></span><br><span class="line"><span class="language-xml">                &#123;&#123; post.content &#125;&#125;</span></span><br><span class="line"><span class="language-xml">              &#123;\% else %&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123; post.title | default(__(&#x27;post.untitled&#x27;)) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;\% endif %&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;\% endif %&#125;</span></span><br><span class="line"><span class="language-xml">      &lt;/&#123;\% if theme.seo %&#125;h3&#123;\% else %&#125;h2&#123;\% endif %&#125;&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-meta&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">time</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;dateCreated&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">datetime</span>=<span class="string">&quot;&#123;&#123; moment(post.date).format() &#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">content</span>=<span class="string">&quot;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;&#123; date(post.date, &#x27;MM-DD&#x27;) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">time</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line">  &lt;/article&gt;</span><br><span class="line"></span><br><span class="line">&#123;\% endmacro %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客系统设计(支持hexo和halo同步)</title>
    <url>/posts/d2168e68/</url>
    <content><![CDATA[<h1 id="个人博客系统设计-支持hexo和halo同步"><a href="#个人博客系统设计-支持hexo和halo同步" class="headerlink" title="个人博客系统设计(支持hexo和halo同步)"></a>个人博客系统设计(支持hexo和halo同步)</h1><ol>
<li>本文主要介绍自己的博客系统是如何设计的，并使用<a href="https://github.com/linshenkx/haloSyncServer">Halo博客同步器</a> 将hexo（git pages: <a href="https://linshenkx.github.io/">https://linshenkx.github.io</a> ）文章自动同步到halo( <a href="http://linshenkx.cn/">http://linshenkx.cn</a> )。<br>实现一次编写、两套博客系统并存、多个网址访问的效果。</li>
<li>test<h2 id="一-总览"><a href="#一-总览" class="headerlink" title="一 总览"></a>一 总览</h2></li>
</ol>
<h3 id="达到效果"><a href="#达到效果" class="headerlink" title="达到效果"></a>达到效果</h3><table>
<thead>
<tr>
<th>个人博客网址</th>
<th>介绍</th>
<th>对应git仓库&#x2F;管理界面</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://linshenkx.gitee.io/">https://linshenkx.gitee.io</a></td>
<td>hexo next gitee pages</td>
<td><a href="https://gitee.com/linshenkx/linshenkx">https://gitee.com/linshenkx/linshenkx</a></td>
</tr>
<tr>
<td><a href="https://linshenkx.github.io/">https://linshenkx.github.io</a></td>
<td>hexo next github pages</td>
<td><a href="https://github.com/linshenkx/linshenkx.github.io">https://github.com/linshenkx/linshenkx.github.io</a></td>
</tr>
<tr>
<td><a href="https://linshen.netlify.app/">https://linshen.netlify.app</a></td>
<td>netlify加速，文章同步自blog源码仓库</td>
<td><a href="https://app.netlify.com/teams/linshenkx">https://app.netlify.com/teams/linshenkx</a></td>
</tr>
<tr>
<td><a href="https://linshenkx.cn/">https://linshenkx.cn</a></td>
<td>halo个人网站，文章同步自blog源码仓库</td>
<td><a href="https://linshenkx.cn/admin/index.html#/dashboard">https://linshenkx.cn/admin/index.html#/dashboard</a></td>
</tr>
</tbody></table>
<p>blog博客源码仓库（核心，私有）：<a href="https://github.com/linshenkx/blog">https://github.com/linshenkx/blog</a></p>
<h3 id="博客发布流程"><a href="#博客发布流程" class="headerlink" title="博客发布流程"></a>博客发布流程</h3><ol>
<li>编写博客<br>在blog工程下写博客，工程为标准hexo，博客为markdown文件放在source&#x2F;_posts目录下，使用多层级分类存放</li>
<li>发布到git pages<br>完成博客的增删改后，在工程目录下执行<code>hexo clean &amp;&amp; hexo d -g</code>部署到git pages。<br>这里我配置了同时发布到github和gitee，需要注意的是，gitee的git pages需要手动去触发更新才能生效。</li>
<li>提交并推送工程<br>提交并推送blog工程的修改。<br>netlify将自动获取blog工程，并执行hexo部署脚本（效果和git pages一样，只是用netlify访问据说会快一点）<br>自己开发的<a href="https://github.com/linshenkx/haloSyncServer">Halo博客同步器</a>也会检测到blog工程更新，根据更新情况将变化同步到halo博客系统中。</li>
</ol>
<h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二 设计思路"></a>二 设计思路</h2><h3 id="1-起因"><a href="#1-起因" class="headerlink" title="1 起因"></a>1 起因</h3><p>本来我一直是在使用csdn的，但是网页端写作确实不方便，而且还可能受网络情况限制。<br>所以我后面一般都是用印象笔记做记录，在印象笔记写好再看心情整理到csdn上去。<br>但是悄不注意的，在21年初csdn改版，同时也改变了排名和引流规则。<br>之前一个星期2500到3000的访问量现在只剩1500到2000了。</p>
<p>嗯，不可忍。换。</p>
<h3 id="2-调研"><a href="#2-调研" class="headerlink" title="2 调研"></a>2 调研</h3><p>市面上的博客系统可根据对Git Pages的支持（即是否支持生成静态网站）分为两大类：</p>
<p>一是以hexo为代表的静态网站生成器：如hexo、hugo、jekyll，较成熟，有较多第三方主题和插件，可与git pages搭配使用，也可自行部署。</p>
<p>二是以halo为代表的五花八门的个人博客系统，功能更加强大，自由度更高，通常带后台管理，但不支持git pages，需自行部署。</p>
<h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3 分析"></a>3 分析</h3><p>个人博客的话使用git pages比较稳定，网址固定，可以永久使用，而且可以通过搭配不同的git服务商来保证访问速度。<br>但是git pages的缺点也很明显，是静态网站，虽然可以搭配第三方插件增强，但说到底还是个静态网站。</p>
<p>而如果自己买服务器，买域名，用第三方个人博客系统，就可以玩得比较花里胡哨了，但谁知道会用多久呢。<br>服务器、域名都要自己负责，三五年之后还能不能访问就比较难说了。<br>但是年轻人嘛，总还是花里胡哨点才香。</p>
<p>那我就全都要。</p>
<p>git pages作为专业性较强的个人网站可以永久访问，<br>然后再弄个服务器放个博客系统自己玩。</p>
<h3 id="4-选型"><a href="#4-选型" class="headerlink" title="4 选型"></a>4 选型</h3><p>静态网站生成器选的是hexo，传统一点，支持的插件和主题比较多。<br>hugo虽然也不错，但似乎国内用的不多，支持可能还不够完善。</p>
<p>然后hexo的主题用的最经典的next，比较成熟，功能也很完善<br>虽然整体比较严肃压抑，但可以自己加个live2d增添点活力，<br>作为一个展示专业性的博客网站这样也就够了</p>
<p>自定义博客系统的话我选的是halo，最主要原因是它是java写的，利于二次开发（事实上后面用着也确实有问题，还提交了一个issue）<br>而且功能比较强大，生态比较完善，虽然第三方主题少且基本都没更新，但是…实在是找不出其他一个能打的了<br>另外halo支持导入markdown，且功能基本都通过rest接口放开，适合开发者使用</p>
<h2 id="三-设计实现"><a href="#三-设计实现" class="headerlink" title="三 设计实现"></a>三 设计实现</h2><h3 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1 hexo"></a>1 hexo</h3><p>hexo本身只是静态网站生成器，你可以把hexo项目本身发布成为git pages项目，<br>像github、gitee这些会识别出这是一个hexo项目，然后进行编译，得到静态资源供外部访问。<br>这也是最简单的用法。</p>
<p>但是不推荐。</p>
<p>因为git pages项目一般都要求是public的（且名称固定，一个git账号只有一个git pages仓库），<br>hexo项目包含你的博客markdown源文件和其他的个人信息。<br>我们只是想把必要的生成后的静态网页放出去而已，至于项目的配置信息和markdown源文件应该藏起来。</p>
<p>所以需要使用 hexo-deployer-git 插件进行git pages的部署。<br>即放到git公开的文件只有生成后的网页文件而已，git只是把你生成后的index.html进行直接展示，不会再去编译了<br>（需要在source目录下添加.nojekyll文件表明为静态网页，无须编译）</p>
<p>而项目本身为了更好地进行管理和记录，还是要发布到git上面的，作为一个普通的私有仓库，名称可以任意（如 blog）</p>
<p>这样，每次要增删改完文章只需要执行<code>hexo clean &amp;&amp; hexo d -g</code>即可发布到git仓库上<br>注意，不同git服务商git pages规则不一样。<br>比方说我gitee和github的用户名都是linshenkx<br>但是gitee要求的仓库名是linshenkx，而github的仓库名就必须是linshenkx.github.io了<br>而github的git pages仓库在接收到推送后就自动（编译）部署<br>gitee则需要到仓库web界面手动触发更新</p>
<p>截至到这一步是大多数人的做法，即git上两个仓库并存，一（或多）个git pages公有仓库做展示，一个blog仓库存放博客源码<br>注意：如果git pages仓库允许私有，则可以使用一个仓库多个分支来实现相同效果。<br>但还是推荐使用两个仓库，因为这样更通用，设计上也更合理。</p>
<p>工程总体结构如下，为普通hexo工程：<br><a href="https://lian-gallery.oss-cn-guangzhou.aliyuncs.com/img/1631718173(1).png"><img src="https://lian-gallery.oss-cn-guangzhou.aliyuncs.com/img/1631718173(1).png" alt="img"></a><br>博客源码目录结构如下，为多层级结构：<br><a href="https://lian-gallery.oss-cn-guangzhou.aliyuncs.com/img/1631718305(1).png"><img src="https://lian-gallery.oss-cn-guangzhou.aliyuncs.com/img/1631718305(1).png" alt="img"></a></p>
<h3 id="2-halo"><a href="#2-halo" class="headerlink" title="2 halo"></a>2 halo</h3><p>halo的使用看官方文档一般就够了，这里需要补充的是其代理配置。<br>因为halo的在线下载更新主题功能通常需要连接到github，我习惯通过代理访问<br>这里提供一下配置方法<br>即在容器启动时添加JVM参数即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name halo --network host -e JVM_OPTS=&quot;-Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=7890 -Dhttps.proxyHost=127.0.0.1 -Dhttps.proxyPort=7890&quot; -v /opt/halo/workspace:/root/.halo --restart=always halohub/halo</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="3-markdown图片"><a href="#3-markdown图片" class="headerlink" title="3 markdown图片"></a>3 markdown图片</h3><p>markdown图片的存放一直是个麻烦的问题。<br>最害怕遇到就是图链的失效，而且往往自己还不能发现。<br>理想状态下就是markdown一张图片支持配置多个图床链接，第一个图床链接超时就使用下一个。<br>这种服务端的处理思想很明显不适合放到客户端。<br>退而求其次，配置一个链接，访问这个链接会触发对多个图床的访问，然后那个快用那个。<br>这个效果技术上不难实现，也有个商业产品（聚合图床）是这样的，缺点是收费。<br>然后我又在github、gitee上找了各个图床软件，都不怎么样（这个时间成本都够给聚合图床开几年会员了）<br>最终还是妥协，用云存储吧，选了阿里<br>七牛、腾讯也都试了，其实都差不多，看个人爱好，没有太特别的理由</p>
<p>如果你用typora写markdown的话很方便，它支持picgo插件</p>
<p>但我习惯在idea里面编写，idea也有一些markdown-image插件，基本都不好用<br>所以我还是安装了picgo，开了快捷键，复制图片直接快捷键粘贴体验也还是比较舒服的<br>picgo的特点是插件多，不过插件质量一般，有很多bug</p>
<p>花了两天时间纠结、测试，最后的方案是：idea编辑+阿里云存储+picgo上传</p>
<h3 id="4-同步"><a href="#4-同步" class="headerlink" title="4 同步"></a>4 同步</h3><p>这才是重点</p>
<h4 id="1-同步的方向"><a href="#1-同步的方向" class="headerlink" title="1 同步的方向"></a>1 同步的方向</h4><p>即在哪里写文章，同步到哪里</p>
<p>我还是习惯用idea写markdown文档而不是在网页上。<br>所以确定是流向为 hexo-&gt;halo</p>
<h4 id="2-技术支撑"><a href="#2-技术支撑" class="headerlink" title="2 技术支撑"></a>2 技术支撑</h4><p>halo支持导入markdown文件，所以主要问题为hexo的markdown博客源码文件的获取<br>hexo文章存储路径为 source&#x2F;_posts ，有多层级文件夹，可以简单地理解成文件IO操作获取文章内容。<br>但关键是存储在git上，这里可以用JGit进行操作。<br>同时，JGit支持获取两次commit之间的文件变化情况。<br>即可以捕获到文章的增删改操作，而不用每次都全量地同步。</p>
<h4 id="3-成果"><a href="#3-成果" class="headerlink" title="3 成果"></a>3 成果</h4><p>又处理了一些细节问题，最终还是自己做了个haloSyncServer同步程序，<br>封装成docker，放服务器上跑，实现同步。<br>待整理后开源。</p>
<p>2021年11月更新<br>开源地址为：<a href="https://github.com/linshenkx/haloSyncServer">https://github.com/linshenkx/haloSyncServer</a><br>效果<br><a href="https://lian-gallery.oss-cn-guangzhou.aliyuncs.com/img/1637394238(1).jpg"><img src="https://lian-gallery.oss-cn-guangzhou.aliyuncs.com/img/1637394238(1).jpg" alt="img"></a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划答疑篇</title>
    <url>/posts/995671e7/</url>
    <content><![CDATA[<h1 id="动态规划答疑篇"><a href="#动态规划答疑篇" class="headerlink" title="动态规划答疑篇"></a>动态规划答疑篇</h1><h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>这篇文章就给你讲明白两个读者问得最多的问题：</p>
<p>1、到底什么才叫「最优子结构」，和动态规划什么关系。</p>
<p>2、为什么动态规划遍历<code>dp</code>数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历，有的无论咋遍历都是对的。</p>
<h2 id="一、最优子结构详解"><a href="#一、最优子结构详解" class="headerlink" title="一、最优子结构详解"></a>一、最优子结构详解</h2><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。</p>
<p>我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p>
<p>我给你提出的这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p>
<p>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p>
<p>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p>
<p>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划详解</a> 说过，想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p>
<p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a : school) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Student b : school) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a is b) <span class="keyword">continue</span>;</span><br><span class="line">        result = max(result, |a.score - b.score|);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p>
<p>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。</p>
<p>前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484469&idx=1&sn=e8d321c8ad62483874a997e9dd72da8f&chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 和 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484690&idx=1&sn=eea075701a5d96dd5c6e3dc6a993cac5&chksm=9bd7fb1aaca0720c58c9d9e02a8b9211a289bcea359633a95886d7808d2846898d489ce98078&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋（进阶篇）</a> 就展示了如何改造问题，不同的最优子结构，可能导致不同的解法和效率。</p>
<p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxVal(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxVal(root.right);</span><br><span class="line">    <span class="keyword">return</span> max(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看这个问题也符合最优子结构，以<code>root</code>为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p>
<p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p>
<p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p>
<p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。</p>
<p>这里就不举那些正宗动态规划的例子了，读者可以翻翻历史文章，看看状态转移是如何遵循最优子结构的，这个话题就聊到这，下面再来看另外个动态规划迷惑行为。</p>
<h3 id="二、dp-数组的遍历方向"><a href="#二、dp-数组的遍历方向" class="headerlink" title="二、dp 数组的遍历方向"></a>二、dp 数组的遍历方向</h3><p>我相信读者做动态规划问题时，肯定会对<code>dp</code>数组的遍历顺序有些头疼。我们拿二维<code>dp</code>数组来举例，有时候我们是正向遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p>有时候我们反向遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p>有时候可能会斜向遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斜着遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a> 中有的地方就正反皆可。</p>
<p>那么，如果仔细观察的话可以发现其中的原因的。你只要把住两点就行了：</p>
<p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p>
<p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p>
<p>下面来具体解释上面两个原则是什么意思。</p>
<p>比如编辑距离这个经典的问题，详解见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect">经典动态规划：编辑距离</a>，我们通过对<code>dp</code>数组的定义，确定了 base case 是<code>dp[..][0]</code>和<code>dp[0][..]</code>，最终答案是<code>dp[m][n]</code>；而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i-1][j-1]</code>转移而来，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/H23fMQ_20210507174659.png" alt="图片"></p>
<p>那么，参考刚才说的两条原则，你该怎么遍历<code>dp</code>数组？肯定是正向遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="comment">// 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span></span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>

<p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案<code>dp[m][n]</code>。</strong></p>
<p>再举一例，回文子序列问题，详见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484666&idx=1&sn=e3305be9513eaa16f7f1568c0892a468&chksm=9bd7faf2aca073e4f08332a706b7c10af877fee3993aac4dae86d05783d3d0df31844287104e&scene=21#wechat_redirect">子序列解题模板：最长回文子序列</a>，我们通过过对<code>dp</code>数组的定义，确定了 base case 处在中间的对角线，<code>dp[i][j]</code>需要从<code>dp[i+1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i+1][j-1]</code>转移而来，想要求的最终答案是<code>dp[0][n-1]</code>，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/L4hOYZ_20210507174734.png" alt="图片"></p>
<p>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/UGCkQ2_20210507174820.png" alt="图片"></p>
<p><strong>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>的左边、下边、左下边已经计算完毕，最终得到正确结果。</strong></p>
<p>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划设计之最长递增子序列</title>
    <url>/posts/117b65dd/</url>
    <content><![CDATA[<h1 id="动态规划设计之最长递增子序列"><a href="#动态规划设计之最长递增子序列" class="headerlink" title="动态规划设计之最长递增子序列"></a>动态规划设计之最长递增子序列</h1><h2 id="预计阅读时间：-9-分钟"><a href="#预计阅读时间：-9-分钟" class="headerlink" title="预计阅读时间： 9 分钟"></a>预计阅读时间： 9 分钟</h2><p>很多读者反应，就算看了前文 <a href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247483818&idx=1&sn=6035f861d1b2bfd0178e842f26ac4836&chksm=fb3361e8cc44e8fe331154bfd32bd7b3b4f159bfad5d38d4a6b0b9f0d7e3485b93b828ee72cc&scene=21#wechat_redirect">动态规划详解</a>，了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。</p>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。</p>
<p>比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p>
<p>先看一下题目，很容易理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/MEAMGr_20210715222744.png" alt="图片"></p>
<p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p>
<h2 id="一、动态规划解法"><a href="#一、动态规划解法" class="headerlink" title="一、动态规划解法"></a>一、动态规划解法</h2><p><strong>动态规划的核心设计思想是数学归纳法。</strong></p>
<p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k&lt;n 时成立，然后想办法证明 k&#x3D;<em>n</em> 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <em>dp</em>[0…<em>i</em>−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出<em>dp[i] ?</em></p>
<p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？</p>
<p><strong>我们的定义是这样的：****dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。</strong></p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/S9DvIE_20210715222829.png" alt="图片"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/vrYoH4_20210715222841.png" alt="图片"></p>
<p>算法演进的过程是这样的：<img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640_20210715222950.gif" alt="图片"></p>
<p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？</p>
<p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p>
<p>我们已经知道了 <em>d**p</em>[0…4] 的所有结果，我们如何通过这些已知结果推出 <em>d**p</em>[5] 呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/xpC5LY_20210715223016.png" alt="图片"></p>
<p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p>
<p>nums[5] &#x3D; 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p>
<p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p>
<p>![图片](<a href="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640">https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/640</a> (1)_20210715223303.gif)</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/QksgN5_20210715223039.png" alt="图片"></p>
<p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？</p>
<p>类似数学归纳法，你已经可以通过 dp[0…4] 算出 dp[5] 了，那么任意 dp[i] 你肯定都可以算出来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/9CYook_20210715223056.png" alt="图片"></p>
<p>还有一个细节问题，就是 base case。dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210715223113307_20210715223113.png" alt="图片"></p>
<p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：</p>
<p>首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p>然后根据 dp 数组的定义，运用数学归纳法的思想，假设 <em>d**p</em>[0…<em>i</em>−1] 都已知，想办法求出 <em>d**p</em>[<em>i</em>]，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p>
<h2 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h2><p>这个解法的时间复杂度会将为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以如果大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p>
<p>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。</p>
<p>为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下思路。</p>
<p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/DFBLV6_20210715223123.png" alt="图片"></p>
<p>处理这些扑克牌要遵循以下规则：</p>
<p>只能把点数小的牌压到点数比它大的牌上。如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去。如果当前牌有多个堆可供选择，则选择最左边的堆放置。</p>
<p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 A 的值是最大的，而不是 1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210715223138612_20210715223138.png" alt="图片"></p>
<p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Cnd9HF_20210715223145.png" alt="图片"></p>
<p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是我们想求的最长递增子序列的长度，证明略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/8SHDGY_20210715223158.png" alt="图片"></p>
<p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。</p>
<p>PS：旧文 <a href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484090&idx=1&sn=5635cf1c4fd8a8570b63c7ae9b4304c2&chksm=fb3362f8cc44ebee0a19a4cfba7f2e13923e05f47e15f2e99a1f42b01aeee83b946aceac3d4c&scene=21#wechat_redirect">二分查找算法详解</a> 详细介绍了二分查找的细节及变体，这里就完美应用上了。如果没读过强烈建议阅读。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/f6Golz_20210715223219.png" alt="图片"></p>
<p>至此，二分查找的解法也讲解完毕。</p>
<p>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。</p>
<p>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法和动态规划，到底谁是谁爹</title>
    <url>/posts/e775a8f2/</url>
    <content><![CDATA[<h1 id="回溯算法和动态规划，到底谁是谁爹？"><a href="#回溯算法和动态规划，到底谁是谁爹？" class="headerlink" title="回溯算法和动态规划，到底谁是谁爹？"></a>回溯算法和动态规划，到底谁是谁爹？</h1><p>我们前文经常说回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。</p>
<p>那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/RGwzua_20210422224714.png" alt="图片"></p>
<p>那么，它俩具体有啥区别呢？回溯算法和动态规划之间，是否可能互相转化呢？</p>
<p>今天就用力扣第 494 题「目标和」来详细对比一下回溯算法和动态规划，真可谓群魔乱舞：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/fMFTnw_20210422224839.png" alt="图片"></p>
<p>注意，给出的例子 <code>nums</code> 全是 1，但实际上可以是任意正整数哦。</p>
<h2 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="一、回溯思路"></a>一、回溯思路</h2><p>其实我第一眼看到这个题目，花了两分钟就写出了一个回溯解法。</p>
<p>任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法，前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法解题框架</a> 就写了回溯算法框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>关键就是搞清楚什么是「选择」，而对于这道题，「选择」不是明摆着的吗？</p>
<p>**对于每个数字 <code>nums[i]</code>，我们可以选择给一个正号 <code>+</code> 或者一个负号 <code>-</code>**，然后利用回溯模板穷举出来所有可能的结果，数一数到底有几种组合能够凑出 <code>target</code> 不就行了嘛？</p>
<p>伪码思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">backtrack</span><span class="params">(nums, i)</span>:</span><br><span class="line">    <span class="type">if</span> <span class="variable">i</span> <span class="operator">=</span>= len(nums):</span><br><span class="line">        <span class="keyword">if</span> 达到 target:</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> op in &#123; +<span class="number">1</span>, -<span class="number">1</span> &#125;:</span><br><span class="line">        选择 op * nums[i]</span><br><span class="line">        # 穷举 nums[i + <span class="number">1</span>] 的选择</span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>如果看过我们之前的几篇回溯算法文章，这个代码可以说是比较简单的了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法模板 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明恰好凑出 target</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 - 号</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest -= nums[i]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 + 号</span></span><br><span class="line">    rest -= nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的读者可能问，选择 <code>-</code> 的时候，为什么是 <code>rest += nums[i]</code>，选择 <code>+</code> 的时候，为什么是 <code>rest -= nums[i]</code> 呢，是不是写反了？</p>
<p>不是的，「如何凑出 <code>target</code>」和「如何把 <code>target</code> 减到 0」其实是一样的。我们这里选择后者，因为前者必须给 <code>backtrack</code> 函数多加一个参数，我觉得不美观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们给 <code>nums[i]</code> 选择 <code>+</code> 号，就要让 <code>rest - nums[i]</code>，反之亦然。</p>
<p>以上回溯算法可以解决这个问题，时间复杂度为 <code>O(2^N)</code>，<code>N</code> 为 <code>nums</code> 的大小。这个复杂度怎么算的？回忆前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&chksm=9bd7fbbcaca072aa75e2a241064a403fde1e579d57ab846cd8537a54253ceb2c8b93cc3bf38e&scene=21#wechat_redirect">学习数据结构和算法的框架思维</a>，发现这个回溯算法就是个二叉树的遍历问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest - nums[i]);</span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest + nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的高度就是 <code>nums</code> 的长度嘛，所以说时间复杂度就是这棵二叉树的节点数，为 <code>O(2^N)</code>，其实是非常低效的。</p>
<p>那么，这个问题如何用动态规划思想进行优化呢？</p>
<h2 id="二、消除重叠子问题"><a href="#二、消除重叠子问题" class="headerlink" title="二、消除重叠子问题"></a>二、消除重叠子问题</h2><p>动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。</p>
<p>如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 <code>backtrack</code> 函数来说，会变的参数为 <code>i</code> 和 <code>rest</code>。</p>
<p>前文 动态规划之编辑距离 说了一种一眼看出重叠子问题的方法，先抽象出递归框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest - nums[i]);</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest + nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个简单的例子，如果 <code>nums[i] = 0</code>，会发生什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest);</span><br><span class="line">    backtrack(i + <span class="number">1</span>, rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看，这样就出现了两个「状态」完全相同的递归函数，无疑这样的递归计算就是重复的。<strong>这就是重叠子问题，而且只要我们能够找到一个重叠子问题，那一定还存在很多的重叠子问题</strong>。</p>
<p>因此，状态 <code>(i, rest)</code> 是可以用备忘录技巧进行优化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp(nums, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line">HashMap&lt;String, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把它俩转成字符串才能作为哈希表的键</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i + <span class="string">&quot;,&quot;</span> + rest;</span><br><span class="line">    <span class="comment">// 避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (memo.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还是穷举</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp(nums, i + <span class="number">1</span>, rest - nums[i]) + dp(nums, i + <span class="number">1</span>, rest + nums[i]);</span><br><span class="line">    <span class="comment">// 记入备忘录</span></span><br><span class="line">    memo.put(key, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前我们都是用 Python 的元组配合哈希表 <code>dict</code> 来做备忘录的，其他语言没有元组，可以用把「状态」转化为字符串作为哈希表的键，这是一个常用的小技巧。</p>
<p>这个解法通过备忘录消除了很多重叠子问题，效率有一定的提升，但是这就结束了吗？</p>
<h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><p>事情没有这么简单，先来算一算，消除重叠子问题之后，算法的时间复杂度是多少？其实最坏情况下依然是 <code>O(2^N)</code>。</p>
<p>为什么呢？因为我们只不过恰好发现了重叠子问题，顺手用备忘录技巧给优化了，但是底层思路没有变，依然是暴力穷举的回溯算法，依然在遍历一棵二叉树。<strong>这只能叫对回溯算法进行了「剪枝」，提升了算法在某些情况下的效率</strong>，但算不上质的飞跃。</p>
<p>其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……</p>
<p>首先，如果我们把 <code>nums</code> 划分成两个子集 <code>A</code> 和 <code>B</code>，分别代表分配 <code>+</code> 的数和分配 <code>-</code> 的数，那么他们和 <code>target</code> 存在如下关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sum(A) - sum(B) = target</span><br><span class="line"><span class="title function_">sum</span><span class="params">(A)</span> = target + sum(B)</span><br><span class="line">sum(A) + sum(A) = target + sum(B) + sum(A)</span><br><span class="line"><span class="number">2</span> * sum(A) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<p>综上，可以推出 <code>sum(A) = (target + sum(nums)) / 2</code>，也就是把原问题转化成：**<code>nums</code> 中存在几个子集 <code>A</code>，使得 <code>A</code> 中元素的和为 <code>(target + sum(nums)) / 2</code>**？</p>
<p>类似的子集划分问题我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485103&idx=1&sn=8a9752e18ed528e5c18d973dcd134260&chksm=9bd7f8a7aca071b14c736a30ef7b23b80914c676414b01f8269808ef28da48eb13e90a432fff&scene=21#wechat_redirect">经典背包问题：子集划分</a> 讲过，现在实现这么一个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以这样调用这个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) sum += n;</span><br><span class="line">    <span class="comment">// 这两种情况，不可能存在合法的子集划分</span></span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || (sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets(nums, (sum + target) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，变成背包问题的标准形式：</p>
<p><strong>有一个背包，容量为 <code>sum</code>，现在给你 <code>N</code> 个物品，第 <code>i</code> 个物品的重量为 <code>nums[i - 1]</code>（注意 <code>1 &lt;= i &lt;= N</code>），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包</strong>？</p>
<p>现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：</p>
<p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p>
<p>对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
<p><strong>第二步要明确 <code>dp</code> 数组的定义</strong>。</p>
<p>按照背包问题的套路，可以给出如下定义：</p>
<p><code>dp[i][j] = x</code> 表示，若只在前 <code>i</code> 个物品中选择，若当前背包的容量为 <code>j</code>，则最多有 <code>x</code> 种方法可以恰好装满背包。</p>
<p>翻译成我们探讨的子集问题就是，若只在 <code>nums</code> 的前 <code>i</code> 个元素中选择，若目标和为 <code>j</code>，则最多有 <code>x</code> 种方法划分子集。</p>
<p>根据这个定义，显然 <code>dp[0][..] = 0</code>，因为没有物品的话，根本没办法装背包；<code>dp[..][0] = 1</code>，因为如果背包的最大载重为 0，「什么都不装」就是唯一的一种装法。</p>
<p>我们所求的答案就是 <code>dp[N][sum]</code>，即使用所有 <code>N</code> 个物品，有几种方法可以装满容量为 <code>sum</code> 的背包。</p>
<p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>回想刚才的 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p>
<p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么恰好装满背包的方法数就取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p>
<p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么只要看前 <code>i - 1</code> 个物品有几种方法可以装满 <code>j - nums[i-1]</code> 的重量就行了，所以取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p>
<p>PS：注意我们说的 <code>i</code> 是从 1 开始算的，而数组 <code>nums</code> 的索引时从 0 开始算的，所以 <code>nums[i-1]</code> 代表的是第 <code>i</code> 个物品的重量，<code>j - nums[i-1]</code> 就是背包装入物品 <code>i</code> 之后还剩下的容量。</p>
<p><strong>由于 <code>dp[i][j]</code> 为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br></pre></td></tr></table></figure>

<p>然后，根据状态转移方程写出动态规划算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 两种选择的结果之和</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 背包的空间不足，只能选择不装物品 i</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，发现这个 <code>dp[i][j]</code> 只和前一行 <code>dp[i-1][..]</code> 有关，那么肯定可以优化成一维 <code>dp</code>：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="built_in">int</span> subsets(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> <span class="keyword">sum</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.length;</span><br><span class="line">    <span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="keyword">sum</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// j 要从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="keyword">sum</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="keyword">sum</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对照二维 <code>dp</code>，只要把 <code>dp</code> 数组的第一个维度全都去掉就行了，唯一的区别就是这里的 <code>j</code> 要从后往前遍历，原因如下</strong>：</p>
<p>因为二维压缩到一维的根本原理是，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还没被新结果覆盖的时候，相当于二维 <code>dp</code> 中的 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-nums[i-1]]</code>。</p>
<p>那么，我们就要做到：<strong>在计算新的 <code>dp[j]</code> 的时候，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还是上一轮外层 for 循环的结果</strong>。</p>
<p>如果你从前往后遍历一维 <code>dp</code> 数组，<code>dp[j]</code> 显然是没问题的，但是 <code>dp[j-nums[i-1]]</code> 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。</p>
<p>现在，这道题算是彻底解决了。</p>
<p>总结一下，回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出状态压缩，还得反向遍历。</p>
<p>现在搞得我都忘了自己是来干嘛的了。嗯，这也许就是动态规划的魅力吧。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法团灭排列组合子集问题</title>
    <url>/posts/6e5dcbe0/</url>
    <content><![CDATA[<h1 id="回溯算法团灭排列-x2F-组合-x2F-子集问题"><a href="#回溯算法团灭排列-x2F-组合-x2F-子集问题" class="headerlink" title="回溯算法团灭排列&#x2F;组合&#x2F;子集问题"></a>回溯算法团灭排列&#x2F;组合&#x2F;子集问题</h1><h2 id="回溯算法团灭排列-x2F-组合-x2F-子集问题-1"><a href="#回溯算法团灭排列-x2F-组合-x2F-子集问题-1" class="headerlink" title="回溯算法团灭排列&#x2F;组合&#x2F;子集问题"></a>回溯算法团灭排列&#x2F;组合&#x2F;子集问题</h2><h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。这几个问题都可以用回溯算法解决。</p>
<h3 id="一、子集"><a href="#一、子集" class="headerlink" title="一、子集"></a>一、子集</h3><p>问题很简单，输入一个<strong>不包含重复数字</strong>的数组，要求算法输出这些数字的所有子集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 <code>nums = [1,2,3]</code>，你的算法应输出 8 个子集，包含空集和本身，顺序可以不同：</p>
<p>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]</p>
<p><strong>第一个解法是利用数学归纳的思想</strong>：假设我现在知道了规模更小的子问题的结果，如何推导出当前问题的结果呢？</p>
<p>具体来说就是，现在让你求 <code>[1,2,3]</code> 的子集，如果你知道了 <code>[1,2]</code> 的子集，是否可以推导出 <code>[1,2,3]</code> 的子集呢？先把  <code>[1,2]</code> 的子集写出来瞅瞅：</p>
<p>[ [],[1],[2],[1,2] ]</p>
<p>你会发现这样一个规律：</p>
<p>subset(<code>[1,2,3]</code>) - subset(<code>[1,2]</code>)</p>
<p>&#x3D; [3],[1,3],[2,3],[1,2,3]</p>
<p>而这个结果，就是把 sebset(<code>[1,2]</code>) 的结果中每个集合再添加上 3。</p>
<p>换句话说，如果 <code>A = subset([1,2])</code> ，那么：</p>
<p>subset(<code>[1,2,3]</code>)</p>
<p>&#x3D; A + [A[i].add(3) for i &#x3D; 1..len(A)]</p>
<p>这就是一个典型的递归结构嘛，<code>[1,2,3]</code> 的子集可以由 <code>[1,2]</code> 追加得出，<code>[1,2]</code> 的子集可以由 <code>[1]</code> 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。</p>
<p>翻译成代码就很容易理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// base case，返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.back();</span><br><span class="line">    nums.pop_back();</span><br><span class="line">    <span class="comment">// 先递归算出前面元素的所有子集</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = subsets(nums);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.push_back(res[i]);</span><br><span class="line">        res.back().push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个问题的时间复杂度计算比较容易坑人</strong>。我们之前说的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是 N，但我们发现每次递归 for 循环的迭代次数取决于 <code>res</code> 的长度，并不是固定的。</p>
<p>根据刚才的思路，<code>res</code> 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。或者不用这么麻烦，你想想一个大小为 N 的集合的子集总共有几个？2^N 个对吧，所以说至少要对 <code>res</code> 添加 2^N 次元素。</p>
<p>那么算法的时间复杂度就是 O(2^N) 吗？还是不对，2^N 个子集是 <code>push_back</code> 添加进 <code>res</code> 的，所以要考虑 <code>push_back</code> 这个操作的效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    res.push_back(res[i]); <span class="comment">// O(N)</span></span><br><span class="line">    res.back().push_back(n); <span class="comment">// O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>res[i]</code> 也是一个数组呀，<code>push_back</code> 是把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。</p>
<p>综上，总的时间复杂度就是 O(N*2^N)，还是比较耗时的。</p>
<p>空间复杂度的话，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p>
<p><strong>第二种通用方法就是回溯算法</strong>。旧文「回溯算法详解」写过回溯算法的模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>只要改造回溯算法的模板就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> &#123;</span><br><span class="line">    res.push_back(track);</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，对 <code>res</code> 的更新是一个<strong>前序遍历</strong>，也就是说，<code>res</code> 就是树上的所有节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/sULT7a_20210507182400.png" alt="图片"></p>
<h3 id="二、组合"><a href="#二、组合" class="headerlink" title="二、组合"></a>二、组合</h3><p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 <code>n = 4, k = 2</code>，输出如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，<code>[1,2]</code> 和 <code>[2,1]</code> 也算重复）：</p>
<p>[<br> [1,2],<br> [1,3],<br> [1,4],<br> [2,3],<br> [2,4],<br> [3,4]<br>]</p>
<p>这就是典型的回溯算法，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度，直接套我们以前讲过的回溯算法模板框架就行了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/y3DT6L_20210507182421.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; track;</span><br><span class="line">    backtrack(n, k, <span class="number">1</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; track)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达树的底部</span></span><br><span class="line">    <span class="keyword">if</span> (k == track.size()) &#123;</span><br><span class="line">        res.push_back(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(i);</span><br><span class="line">        backtrack(n, k, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>backtrack</code> 函数和计算子集的差不多，<strong>区别在于，更新 <code>res</code> 的地方是树的底端</strong>。</p>
<h3 id="三、排列"><a href="#三、排列" class="headerlink" title="三、排列"></a>三、排列</h3><p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span>;</span><br></pre></td></tr></table></figure>

<p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：</p>
<p>[<br> [1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1]<br>]</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法详解</a> 中就是拿这个问题来解释回溯模板的。这里又列出这个问题，是将「排列」和「组合」这两个回溯算法的代码拿出来对比。</p>
<p>首先画出回溯树来看一看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/uRIb5X_20210507182434.png" alt="图片"></p>
<p>我们当时使用 Java 代码写的解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯模板依然没有变，但是根据排列问题和组合问题画出的树来看，排列问题的树比较对称，而组合问题的树越靠右节点越少。</p>
<p>在代码中的体现就是，排列问题每次通过 <code>contains</code> 方法来排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。</p>
<p><strong>以上，就是排列组合和子集三个问题的解法，总结一下</strong>：</p>
<p>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 <code>start</code> 参数排除已选择的数字。</p>
<p>组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 <code>start</code> 排除已经选择过的数字。</p>
<p>排列问题是回溯思想，也可以表示成树结构套用算法模板，不同之处在于使用 <code>contains</code> 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。</p>
<p>对于这三个问题，关键区别在于回溯树的结构，不妨多观察递归树的结构，很自然就可以理解代码的含义了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何拆解复杂问题：实现一个计算器</title>
    <url>/posts/92e48ba5/</url>
    <content><![CDATA[<h1 id="如何拆解复杂问题：实现一个计算器"><a href="#如何拆解复杂问题：实现一个计算器" class="headerlink" title="如何拆解复杂问题：实现一个计算器"></a>如何拆解复杂问题：实现一个计算器</h1><p>我记得很多大学数据结构的教材上，在讲栈这种数据结构的时候，应该都会用计算器举例，但是有一说一，讲的真的垃圾，我只感受到被数据结构支配的恐惧，丝毫没有支配数据结构的快感。</p>
<p>不知道多少未来的计算机科学家就被这种简单的数据结构劝退了。</p>
<p><em><strong>1、</strong></em>输入一个字符串，可以包含<code>+ - * / (</code>)&#96;&#96;、数字、空格，你的算法返回运算结果。</p>
<p><em><strong>2、</strong></em>要符合运算法则，括号的优先级最高，先乘除后加减。</p>
<p><em><strong>3、</strong></em>除号是整数除法，无论正负都向 0 取整（5&#x2F;2&#x3D;2，-5&#x2F;2&#x3D;-2）。</p>
<p><em><strong>4、</strong></em>可以假定输入的算式一定合法，且计算过程不会出现整型溢出，不会出现除数为 0 的意外情况。</p>
<p>比如输入如下字符串，算法会返回 9：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> * (<span class="number">2</span>-<span class="number">6</span> /(<span class="number">3</span> -<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到，这就已经非常接近我们实际生活中使用的计算器了，虽然我们以前肯定都用过计算器，但是如果简单思考一下其算法实现，就会大惊失色：</p>
<p><em><strong>1、</strong></em>按照常理处理括号，要先计算最内层的括号，然后向外慢慢化简。这个过程我们手算都容易出错，何况写成算法呢！</p>
<p><em><strong>2、</strong></em>要做到先乘除，后加减，这一点教会小朋友还不算难，但教给计算机恐怕有点困难。</p>
<p><em><strong>3、</strong></em>要处理空格。我们为了美观，习惯性在数字和运算符之间打个空格，但是计算之中得想办法忽略这些空格。</p>
<p>那么本文就来聊聊怎么实现上述一个功能完备的计算器功能，<strong>关键在于层层拆解问题，化整为零，逐个击破</strong>，相信这种思维方式能帮大家解决各种复杂问题。</p>
<p>下面就来拆解，从最简单的一个问题开始。</p>
<h2 id="一、字符串转整数"><a href="#一、字符串转整数" class="headerlink" title="一、字符串转整数"></a>一、字符串转整数</h2><p>是的，就是这么一个简单的问题，首先告诉我，怎么把一个字符串形式的<strong>正</strong>整数，转化成 int 型？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;458&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[i];</span><br><span class="line">    n = <span class="number">10</span> * n + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n 现在就等于 458</span></span><br></pre></td></tr></table></figure>

<p>这个还是很简单的吧，老套路了。但是即便这么简单，依然有坑：**<code>(c - &#39;0&#39;)</code>的这个括号不能省略，否则可能造成整型溢出**。</p>
<p>因为变量<code>c</code>是一个 ASCII 码，如果不加括号就会先加后减，想象一下<code>n</code>如果接近 INT_MAX，就会溢出。所以用括号保证先减后加才行。</p>
<h2 id="二、处理加减法"><a href="#二、处理加减法" class="headerlink" title="二、处理加减法"></a>二、处理加减法</h2><p>现在进一步，<strong>如果输入的这个算式只包含加减法，而且不存在空格</strong>，你怎么计算结果？我们拿字符串算式<code>1-12+3</code>为例，来说一个很简单的思路：</p>
<p><em><strong>1、</strong></em>先给第一个数字加一个默认符号<code>+</code>，变成<code>+1-12+3</code>。</p>
<p><em><strong>2、</strong></em>把一个运算符和数字组合成一对儿，也就是三对儿<code>+1</code>，<code>-12</code>，<code>+3</code>，把它们转化成数字，然后放到一个栈中。</p>
<p><em><strong>3、</strong></em>将栈中所有的数字求和，就是原算式的结果。</p>
<p>我们直接看代码，结合一张图就看明白了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(string s)</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="comment">// 记录算式中的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录 num 前的符号，初始化为 +</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[i];</span><br><span class="line">        <span class="comment">// 如果是数字，连续读取到 num</span></span><br><span class="line">        <span class="keyword">if</span> (isdigit(c)) </span><br><span class="line">            num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="comment">// 如果不是数字，就是遇到了下一个符号，</span></span><br><span class="line">        <span class="comment">// 之前的数字和符号就要存进栈中</span></span><br><span class="line">        <span class="keyword">if</span> (!isdigit(c) || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (sign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stk.push(num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stk.push(-num); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新符号为当前符号，数字清零</span></span><br><span class="line">            sign = c;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将栈中所有结果求和就是答案</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        res += stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我估计就是中间带<code>switch</code>语句的部分有点不好理解吧，**<code>i</code>就是从左到右扫描，<code>sign</code>和<code>num</code>跟在它身后。**当<code>s[i]</code>遇到一个运算符时，情况是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/1331pt_20210507173639.png" alt="图片"></p>
<p>所以说，此时要根据<code>sign</code>的 case 不同选择<code>nums</code>的正负号，存入栈中，然后更新<code>sign</code>并清零<code>nums</code>记录下一对儿符合和数字的组合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/aqyyv2_20210507173723.png" alt="图片"></p>
<p>另外注意，不只是遇到新的符号会触发入栈，当<code>i</code>走到了算式的尽头（<code>i == s.size() - 1</code>），也应该将前面的数字入栈，方便后续计算最终结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HuuIs3_20210507173811.png" alt="图片"></p>
<p>至此，仅处理紧凑加减法字符串的算法就完成了，请确保理解以上内容，后续的内容就基于这个框架修修改改就完事儿了。</p>
<h2 id="三、处理乘除法"><a href="#三、处理乘除法" class="headerlink" title="三、处理乘除法"></a>三、处理乘除法</h2><p>其实思路跟仅处理加减法没啥区别，拿字符串<code>2-3*4+5</code>举例，核心思路依然是把字符串分解成符号和数字的组合。</p>
<p>比如上述例子就可以分解为<code>+2</code>，<code>-3</code>，<code>*4</code>，<code>+5</code>几对儿，我们刚才不是没有处理乘除号吗，很简单，<strong>其他部分都不用变</strong>，在<code>switch</code>部分加上对应的 case 就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[i];</span><br><span class="line">    <span class="keyword">if</span> (isdigit(c)) </span><br><span class="line">        num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isdigit(c) || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sign) &#123;</span><br><span class="line">            <span class="type">int</span> pre;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.push(num); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.push(-num); <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 只要拿出前一个数字做对应运算即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                pre = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                stk.push(pre * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                pre = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                stk.push(pre / num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新符号为当前符号，数字清零</span></span><br><span class="line">        sign = c;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>乘除法优先于加减法体现在，乘除法可以和栈顶的数结合，而加减法只能把自己放入栈</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/849zPF_20210507173855.png" alt="图片"></p>
<p>现在我们<strong>思考一下****如何处理字符串中可能出现的空格字符</strong>。其实也非常简单，想想空格字符的出现，会影响我们现有代码的哪一部分？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 c 非数字</span></span><br><span class="line"><span class="keyword">if</span> (!isdigit(c) || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;...&#125;</span><br><span class="line">    sign = c;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然空格会进入这个 if 语句，但是我们并不想让空格的情况进入这个 if，因为这里会更新<code>sign</code>并清零<code>nums</code>，空格根本就不是运算符，应该被忽略。</p>
<p>那么只要多加一个条件即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!isdigit(c) &amp;&amp; c != <span class="string">&#x27; &#x27;</span>) || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们的算法已经可以按照正确的法则计算加减乘除，并且自动忽略空格符，剩下的就是如何让算法正确识别括号了。</p>
<h2 id="四、处理括号"><a href="#四、处理括号" class="headerlink" title="四、处理括号"></a>四、处理括号</h2><p>处理算式中的括号看起来应该是最难的，但真没有看起来那么难。</p>
<p>为了规避编程语言的繁琐细节，我把前面解法的代码翻译成 Python 版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">calculate</span><span class="params">(s: str)</span> -&gt; <span class="type">int</span>:</span><br><span class="line"></span><br><span class="line">    def <span class="title function_">helper</span><span class="params">(s: List)</span> -&gt; <span class="type">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="title function_">len</span><span class="params">(s)</span> &gt; <span class="number">0</span>:</span><br><span class="line">            c = s.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = <span class="number">10</span> * num + <span class="type">int</span>(c)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (not c.isdigit() and c != <span class="string">&#x27; &#x27;</span>) or <span class="title function_">len</span><span class="params">(s)</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="type">if</span> <span class="variable">sign</span> <span class="operator">=</span>= <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="type">elif</span> <span class="variable">sign</span> <span class="operator">=</span>= <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="type">elif</span> <span class="variable">sign</span> <span class="operator">=</span>= <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack[-<span class="number">1</span>] = stack[-<span class="number">1</span>] * num</span><br><span class="line">                <span class="type">elif</span> <span class="variable">sign</span> <span class="operator">=</span>= <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    # python 除法向 <span class="number">0</span> 取整的写法</span><br><span class="line">                    stack[-<span class="number">1</span>] = <span class="type">int</span>(stack[-<span class="number">1</span>] / <span class="type">float</span>(num))                    </span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(stack)</span><br><span class="line">    # 需要把字符串转成列表方便操作</span><br><span class="line">    <span class="keyword">return</span> helper(list(s))</span><br></pre></td></tr></table></figure>

<p>这段代码跟刚才 C++ 代码完全相同，唯一的区别是，不是从左到右遍历字符串，而是不断从左边<code>pop</code>出字符，本质还是一样的。</p>
<p>那么，为什么说处理括号没有看起来那么难呢，<strong>因为括号具有递归性质</strong>。我们拿字符串<code>3*(4-5/2)-6</code>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calculate(`<span class="number">3</span>*(<span class="number">4</span>-<span class="number">5</span>/<span class="number">2</span>)-<span class="number">6</span>`)</span><br><span class="line">= <span class="number">3</span> * calculate(`<span class="number">4</span>-<span class="number">5</span>/<span class="number">2</span>`) - <span class="number">6</span></span><br><span class="line">= <span class="number">3</span> * <span class="number">2</span> - <span class="number">6</span></span><br><span class="line">= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以脑补一下，无论多少层括号嵌套，通过 calculate 函数递归调用自己，都可以将括号中的算式化简成一个数字。<strong>换句话说，括号包含的算式，我们直接视为一个数字就行了</strong>。</p>
<p>现在的问题是，递归的开始条件和结束条件是什么？<strong>遇到<code>(</code>开始递归，遇到<code>)</code>结束递归</strong>：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def calculate(s: str) -&gt; <span class="keyword">int</span>:</span><br><span class="line"></span><br><span class="line">    def helper(s: List) -&gt; <span class="keyword">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">sign</span> = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">c</span> = s.<span class="keyword">pop</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">c</span>.isdigit():</span><br><span class="line">                num = <span class="number">10</span> * num + <span class="keyword">int</span>(<span class="keyword">c</span>)</span><br><span class="line">            # 遇到左括号开始递归计算 num</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">c</span> == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                num = helper(s)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (not <span class="keyword">c</span>.isdigit() <span class="built_in">and</span> <span class="keyword">c</span> != <span class="string">&#x27; &#x27;</span>) <span class="built_in">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">sign</span> == <span class="string">&#x27;+&#x27;</span>: ...</span><br><span class="line">                elif <span class="keyword">sign</span> == <span class="string">&#x27;-&#x27;</span>: ... </span><br><span class="line">                elif <span class="keyword">sign</span> == <span class="string">&#x27;*&#x27;</span>: ...</span><br><span class="line">                elif <span class="keyword">sign</span> == <span class="string">&#x27;/&#x27;</span>: ...</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">sign</span> = <span class="keyword">c</span></span><br><span class="line">            # 遇到右括号返回递归结果</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">c</span> == <span class="string">&#x27;)&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> sum(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="keyword">list</span>(s))</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/lipbTF_20210507174049.png" alt="图片"></p>
<p>你看，加了两三行代码，就可以处理括号了，这就是递归的魅力。至此，计算器的全部功能就实现了，通过对问题的层层拆解化整为零，再回头看，这个问题似乎也没那么复杂嘛。</p>
<h2 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h2><p>本文借实现计算器的问题，主要想表达的是一种处理复杂问题的思路。</p>
<p>我们首先从字符串转数字这个简单问题开始，进而处理只包含加减法的算式，进而处理包含加减乘除四则运算的算式，进而处理空格字符，进而处理包含括号的算式。</p>
<p><strong>可见，对于一些比较困难的问题，其解法并不是一蹴而就的，而是步步推进，螺旋上升的</strong>。如果一开始给你原题，你不会做，甚至看不懂答案，都很正常，关键在于我们自己如何简化问题，如何以退为进。</p>
<p><strong>退而求其次是一种很聪明策略</strong>。你想想啊，假设这是一道考试题，你不会实现这个计算器，但是你写了字符串转整数的算法并指出了容易溢出的陷阱，那起码可以得 20 分吧；如果你能够处理加减法，那可以得 40 分吧；如果你能处理加减乘除四则运算，那起码够 70 分了；再加上处理空格字符，80 有了吧。我就是不会处理括号，那就算了，80 已经很 OK 了好不好。</p>
<p>我们要支配算法，而不是被算法支配。如果这种思维方式对大家有些启发，希望点个在看分享。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列解题模板：最长回文子序列</title>
    <url>/posts/7f30ba70/</url>
    <content><![CDATA[<h1 id="子序列解题模板：最长回文子序列"><a href="#子序列解题模板：最长回文子序列" class="headerlink" title="子序列解题模板：最长回文子序列"></a>子序列解题模板：最长回文子序列</h1><h2 id="预计阅读时间：6-分钟"><a href="#预计阅读时间：6-分钟" class="headerlink" title="预计阅读时间：6 分钟"></a>预计阅读时间：6 分钟</h2><p>子序列问题是常见的算法问题，而且并不好解决。</p>
<p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p>
<p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484486&idx=1&sn=0bdcb94c6390307ea32427757ec0072c&chksm=9bd7fa4eaca073583623cdb93b05dc9e1d0757b25697bb40b29b3e450124e929ff1a8eaac50f&scene=21#wechat_redirect">最长公共子序列</a>，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p>
<p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。</p>
<p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p>
<p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p>
<h2 id="一、两种思路"><a href="#一、两种思路" class="headerlink" title="一、两种思路"></a>一、两种思路</h2><p><strong>1、****第一种思路模板是一个一维的 dp 数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个我们写过的例子 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484498&idx=1&sn=df58ef249c457dd50ea632f7c2e6e761&chksm=9bd7fa5aaca0734c29bcf7979146359f63f521e3060c2acbf57a4992c887aeebe2a9e4bd8a89&scene=21#wechat_redirect">最长递增子序列</a>，在这个思路中 dp 数组的定义是：</p>
<p>*<em>在子数组<code>array[0..i]</code>中，以*</em><code>array[i]</code>**结尾的目标子序列（最长递增子序列）的长度是<code>dp[i]</code>**。</p>
<p>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。</p>
<p><strong>2、****第二种思路模板是一个二维的 dp 数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">dp</span>[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种思路运用相对更多一些，尤其是涉及两个字符串&#x2F;数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。</p>
<p><strong>2.1</strong> <strong>涉及两个字符串&#x2F;数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p>
<p>**在子数组<code>arr1[0..i]</code>和子数组<code>arr2[0..j]</code>中，我们要求的子序列（最长公共子序列）长度为<code>dp[i][j]</code>**。</p>
<p><strong>2.2</strong> <strong>只涉及一个字符串&#x2F;数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：</p>
<p>**在子数组<code>array[i..j]</code>中，我们要求的子序列（最长回文子序列）的长度为<code>dp[i][j]</code>**。</p>
<p>第一种情况可以参考这两篇旧文：<a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484484&idx=1&sn=74594297022c84952162a68b7f739133&chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&scene=21#wechat_redirect">详解编辑距离</a> 和 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484486&idx=1&sn=0bdcb94c6390307ea32427757ec0072c&chksm=9bd7fa4eaca073583623cdb93b05dc9e1d0757b25697bb40b29b3e450124e929ff1a8eaac50f&scene=21#wechat_redirect">最长公共子序列</a>。</p>
<p>下面就借最长回文子序列这个问题，详解一下第二种情况下如何使用动态规划。</p>
<h3 id="二、最长回文子序列"><a href="#二、最长回文子序列" class="headerlink" title="二、最长回文子序列"></a>二、最长回文子序列</h3><p>之前解决了 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484471&idx=1&sn=7c26d04a1f035770920d31377a1ebd42&chksm=9bd7fa3faca07329189e9e8b51e1a665166946b66b8e8978299ba96d5f2c0d3eafa7db08b681&scene=21#wechat_redirect">最长回文子串</a> 的问题，这次提升难度，求最长回文子序列的长度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/LAjRcC_20210507181302.png" alt="图片"></p>
<p>我们说这个问题对 dp 数组的定义是：**在子串<code>s[i..j]</code>中，最长回文子序列的长度为<code>dp[i][j]</code>**。一定要记住这个定义才能理解算法。</p>
<p>为啥这个问题要这样定义二维的 dp 数组呢？我们前文多次提到，<strong>找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分</strong>，这样定义容易归纳，容易发现状态转移关系。</p>
<p>具体来说，如果我们想求<code>dp[i][j]</code>，假设你知道了子问题<code>dp[i+1][j-1]</code>的结果（<code>s[i+1..j-1]</code>中最长回文子序列的长度），你是否能想办法算出<code>dp[i][j]</code>的值（<code>s[i..j]</code>中，最长回文子序列的长度）呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/2kxUZI_20210507181356.png" alt="图片"></p>
<p>可以！<strong>这取决于<code>s[i]</code>和<code>s[j]</code>的字符</strong>：</p>
<p><strong>如果它俩相等</strong>，那么它俩加上<code>s[i+1..j-1]</code>中的最长回文子序列就是<code>s[i..j]</code>的最长回文子序列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/aUzko6_20210507181418.png" alt="图片"></p>
<p><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在<code>s[i..j]</code>的最长回文子序列中，那么把它俩<strong>分别</strong>加入<code>s[i+1..j-1]</code>中，看看哪个子串产生的回文子序列更长即可：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/syOQNF_20210507181435.png" alt="图片"></p>
<p>以上两种情况写成代码就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">    <span class="comment">// 它俩一定在最长回文子序列中</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span></span><br><span class="line">    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>至此，状态转移方程就写出来了，根据 dp 数组的定义，我们要求的就是<code>dp[0][n - 1]</code>，也就是整个<code>s</code>的最长回文子序列的长度。</p>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是<code>dp[i][j] = 1,(i == j)</code>。</p>
<p>因为<code>i</code>肯定小于等于<code>j</code>，所以对于那些<code>i &gt; j</code>的位置，根本不存在什么子序列，应该初始化为 0。</p>
<p>另外，看看刚才写的状态转移方程，想求<code>dp[i][j]</code>需要知道<code>dp[i+1][j-1]</code>，<code>dp[i+1][j]</code>，<code>dp[i][j-1]</code>这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/K0G91r_20210507181558.png" alt="图片"></p>
<p><strong>为了保证每次计算<code>dp[i][j]</code>，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Ckwq8R_20210507181610.png" alt="图片"></p>
<p>我选择反着遍历，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(string s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.size();</span><br><span class="line">    <span class="comment">// dp 数组全部初始化为 0</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">dp</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)</span>);</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，最长回文子序列的问题就解决了。</p>
<p>主要还是正确定义 dp 数组的含义，遇到子序列问题，首先想到两种动态规划思路，然后根据实际问题看看哪种思路容易找到状态转移关系。</p>
<p>另外，找到状态转移和 base case 之后，<strong>一定要观察 DP table</strong>，看看怎么遍历才能保证通过已计算出来的结果解决新的问题</p>
<p>有了以上思路方向，子序列问题也不过如此嘛。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>完全二叉树的节点数，你真的会算吗？</title>
    <url>/posts/dbdb8baa/</url>
    <content><![CDATA[<h1 id="完全二叉树的节点数，你真的会算吗？"><a href="#完全二叉树的节点数，你真的会算吗？" class="headerlink" title="完全二叉树的节点数，你真的会算吗？"></a>完全二叉树的节点数，你真的会算吗？</h1><p>如果让你数一下一棵普通二叉树有多少个节点，这很简单，只要在二叉树的遍历框架上加一点代码就行了。</p>
<p>但是，如果给你一棵<strong>完全二叉树</strong>，让你计算它的节点个数，你会不会？算法的时间复杂度是多少？</p>
<p>这个算法的时间复杂度应该是 O(logN*logN)，如果你心中的算法没有达到这么高效，那么本文就是给你写的。</p>
<p>首先要明确一下两个关于二叉树的名词「完全二叉树」和「满二叉树」。</p>
<p>我们说的<strong>完全二叉树</strong>如下图，每一层都是<strong>紧凑靠左</strong>排列的：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdEP9mVB4tqBYfNT69s5yTbm0UlN0d2fmKXn6RCv25WiapjvnsxLZ7mkobu5v1NPQY3cVkt8iawyMYvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们说的<strong>满二叉树</strong>如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/UuUXKT_20210810164344.png" alt="图片"></p>
<p>说句题外话，关于这两个定义，中文语境和英文语境似乎有点区别，我们说的完全二叉树对应英文 Complete Binary Tree，没有问题。但是我们说的满二叉树对应英文 Perfect Binary Tree，而英文中的 Full Binary Tree 是指一棵二叉树的所有节点要么没有孩子节点，要么有两个孩子节点。如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/GzzIX6_20210810164402.png" alt="图片"></p>
<p>以上定义出自 wikipedia，这里就是顺便一提，其实名词叫什么都无所谓，重要的是算法操作。</p>
<p><strong>本文就按我们中文的语境，记住「满二叉树」和「完全二叉树」的区别，等会会用到</strong>。</p>
<h3 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="一、思路分析"></a>一、思路分析</h3><p>现在回归正题，如何求一棵完全二叉树的节点个数呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入一棵完全二叉树，返回节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span>;</span><br></pre></td></tr></table></figure>

<p>如果是一个<strong>普通</strong>二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果是一棵<strong>满</strong>二叉树，节点总数就和树的高度呈指数关系，时间复杂度 O(logN)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点总数就是 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完全</strong>二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root, r = root;</span><br><span class="line">    <span class="comment">// 记录左、右子树的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合刚才针对满二叉树和普通二叉树的算法，上面这段代码应该不难理解，就是一个结合版，但是<strong>其中降低时间复杂度的技巧是非常微妙的</strong>。</p>
<h3 id="二、复杂度分析"><a href="#二、复杂度分析" class="headerlink" title="二、复杂度分析"></a>二、复杂度分析</h3><p>开头说了，这个算法的时间复杂度是 O(logN*logN)，这是怎么算出来的呢？</p>
<p>直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">return <span class="number">1</span> + count<span class="constructor">Nodes(<span class="params">root</span>.<span class="params">left</span>)</span> + count<span class="constructor">Nodes(<span class="params">root</span>.<span class="params">right</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发<code>hl == hr</code>而立即返回，不会递归下去</strong>。</p>
<p>为什么呢？原因如下：</p>
<p><strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Z2YcMA_20210810164429.png" alt="图片"></p>
<p>看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发<code>hl == hr</code>，只消耗 O(logN) 的复杂度而不会继续递归。</p>
<p>综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。</p>
<p>所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快慢指针的一些证明</title>
    <url>/posts/196710be/</url>
    <content><![CDATA[<h1 id="快慢指针在链表中的一些证明"><a href="#快慢指针在链表中的一些证明" class="headerlink" title="快慢指针在链表中的一些证明"></a>快慢指针在链表中的一些证明</h1><p>目录</p>
<h3 id="一、一定会相遇的证明"><a href="#一、一定会相遇的证明" class="headerlink" title="一、一定会相遇的证明"></a>一、一定会相遇的证明</h3><h3 id="二、环长度"><a href="#二、环长度" class="headerlink" title="二、环长度"></a>二、环长度</h3><h3 id="三、连接点"><a href="#三、连接点" class="headerlink" title="三、连接点"></a>三、连接点</h3><h3 id="四、带环链表总长度"><a href="#四、带环链表总长度" class="headerlink" title="四、带环链表总长度"></a>四、带环链表总长度</h3><h3 id="五、例题"><a href="#五、例题" class="headerlink" title="五、例题"></a>五、例题</h3><h2 id="一、一定会相遇的证明-1"><a href="#一、一定会相遇的证明-1" class="headerlink" title="一、一定会相遇的证明"></a>一、一定会相遇的证明</h2><h4 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h4><p>1、如果链表没有环，那么快指针比慢指针先到达尾部（null)。</p>
<p>2、如果链表有环的话，因为快指针走的比慢指针快，所以在环中相遇的过程可以看作是快指针从环后边追赶慢指针的过程。</p>
<p>用递归法证明，快慢指针一定会相遇：</p>
<p>（1)快指针与慢指针之间差一步。此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇。<br>（2)快指针与慢指针之间差两步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，转化为第一种情况。<br>（3)快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)即N-1步。重复这个过程，直到快指针和慢指针相遇。</p>
<p>因此，此题得证。所以快指针必然与慢指针相遇。</p>
<h4 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h4><p>如果链表存在环，快慢指针就一定能相遇。设快指针每次移动q步，慢指针每次移动s步，环的长度为n，环之前的链表长度为m，如下图所示</p>
<p><img src="https://pic2.zhimg.com/50/da087f6034204e3713f69f94542c99e1_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/da087f6034204e3713f69f94542c99e1_720w.jpg?source=1940ef5c" alt="img"></p>
<p>假设慢指针第一次到达环时移动了x次，位置为a，此时快指针也移动了x次，位置为b，</p>
<p>则此时快慢指针相遇的等式为<img src="https://www.zhihu.com/equation?tex=(b+q*y)mod(n)+=+(a+s*y)mod(n)" alt="[公式]">，</p>
<p>也即<img src="https://www.zhihu.com/equation?tex=((b-a)++(q-s)*y)mod(n)+=+0+" alt="[公式]">（1）成立，</p>
<p>又：</p>
<p><img src="https://www.zhihu.com/equation?tex=b=(q*x+-+m)mod(n)" alt="[公式]">（2），</p>
<p><img src="https://www.zhihu.com/equation?tex=a=(s*x-m)mod(n)" alt="[公式]">（3），</p>
<p>由（1）（2）（3）可得出<img src="https://www.zhihu.com/equation?tex=(q-s)(x+y)mod(n)=0" alt="[公式]">成立，显而易见（q(x+y)-s(x+y) &#x3D;&#x3D; n *k(k&#x3D;1,2,3,…)），x+y是n的整数倍的时候，该式一定成立。</p>
<p>————————————————找环的起点分割线——————————————<br>假设快指针每次移动2步，慢指针每次移动1步，则根据上述证明可知，<img src="https://www.zhihu.com/equation?tex=x=m" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=a=0" alt="[公式]">，相遇的位置在y处；求环的起点，就是求m的大小，此时令一指针p1从头结点出发，每次移动1步，令一指针q1从相遇处出发，每次移动1步，则p1与q1再次相遇的地方就是环的起点处，因为此时两个指针均移动m步，由<img src="https://www.zhihu.com/equation?tex=(y+m)mod(n)=0" alt="[公式]">可知，相遇</p>
<p><strong>推导：慢指针进入环后，快指针最多多绕一个圈。</strong></p>
<p><strong>快指针F先进环，慢指针S后进。</strong></p>
<p><strong>假设慢指针进环那一刻快指针差m步能追上（0&lt;&#x3D; m &lt; Length环），根据上边结论，两个指针走m次就会相遇了。</strong></p>
<p><strong>因为m &lt; Length环，所以快指针在慢指针进环那一刻最多比慢指针多绕一个圈</strong>。</p>
<h2 id="二、环长度-1"><a href="#二、环长度-1" class="headerlink" title="二、环长度"></a>二、环长度</h2><p>快指针和慢指针第一次相遇时的节点pq（碰撞点），快指针和慢指针从该点开始继续往前走，再次碰撞时所用的操作数就是环的长度Length环。</p>
<p>证明:由上边的推导可得，这里的m为Lengh环。</p>
<h2 id="三、连接点-1"><a href="#三、连接点-1" class="headerlink" title="三、连接点"></a>三、连接点</h2><p><img src="https://images2015.cnblogs.com/blog/833392/201704/833392-20170409211030332-1528137014.png" alt="img"></p>
<p>假设慢指针进入环中时，即连接点p，快指针（q）需要m步才能追上慢指针。</p>
<p>p和q第一次相遇时，碰撞点在pq处。此时，p走到pq时用了m步。</p>
<p> 假设head到p的距离为a，环长度为Length环，慢指针走了s步，则快指针走了2s步。</p>
<p>从上图可知:</p>
<p>s &#x3D; a + m</p>
<p>2s &#x3D; a + m + n * Length环（n为快指针绕环的圈数）</p>
<p>可得</p>
<p>a &#x3D; n * Length环 - m</p>
<p>也就是：若在头结点和相遇结点分别设一指针，同步(单步)前进，则最后一定相遇在环入口结点p。</p>
<p>可根据这个结论来找到入口节点。</p>
<h2 id="四、带环链表总长度-1"><a href="#四、带环链表总长度-1" class="headerlink" title="四、带环链表总长度"></a>四、带环链表总长度</h2><p>找到连接点p后，求head到p的长度，再加上环的长度，即为链表的总长。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/posts/50cab45/</url>
    <content><![CDATA[<h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><h2 id="滑动窗口算法-1"><a href="#滑动窗口算法-1" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p><strong>滑动窗口框架套路详解</strong></p>
<p>在滑动窗口算法框架中，我编写一首小诗来歌颂滑动窗口算法的伟大：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdEsLiaY9d9CcVdNcPTAdO5MRwZhsxtTc6BaDMpHQtibCX5kY406sxFeaClrlft3j6XiaJ48jq0Gnj2dQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>关于双指针的快慢指针和左右指针的用法，可以参见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484505&idx=1&sn=0e9517f7c4021df0e6146c6b2b0c4aba&chksm=9bd7fa51aca07347009c591c403b3228f41617806429e738165bd58d60220bf8f15f92ff8a2e&scene=21#wechat_redirect">双指针技巧汇总</a>，<strong>本文就解决一类最难掌握的双指针技巧：滑动窗口技巧，并总结出一套框架，可以保你闭着眼直接套出答案。</strong></p>
<p>说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法技巧的时间复杂度是 O(N)，比一般的字符串暴力算法要高效得多。</p>
<p><strong><em>其实困扰大家的</em>，不是算法的思路，而是各种细节问题</strong>。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<p><strong>所以今天我就写一套滑动窗口算法的代码框架，我连在哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出边界问题</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span>(<span class="params">string s, string t</span>) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; need, <span class="variable language_">window</span>;</span><br><span class="line">    <span class="keyword">for</span> (char c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    int left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    int valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="title function_">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        char c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">window</span> needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            char d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中两处<code>...</code>表示的更新窗口数据的地方，到时候你直接往里面填就行了</strong>。</p>
<p>而且，这两个<code>...</code>处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。</p>
<p><strong>说句题外话，其实有很多人喜欢执着于表象，不喜欢探求问题的本质。</strong>比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。</p>
<p>我也是服了，算法看的是时间复杂度，你能确保自己的时间复杂度最优就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……</p>
<p>重点在于算法思想，你把框架思维了然于心套出解法，然后随你再魔改代码好吧，你高兴就好。</p>
<p>言归正传，<strong>下面就直接上*<em>四道*</em> LeetCode 原题来套这个框架</strong>，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。</p>
<p>本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：</p>
<p><code>unordered_map</code>就是哈希表（字典），它的一个方法<code>count(key)</code>相当于 Java 的<code>containsKey(key)</code>可以判断键 key 是否存在。</p>
<p>可以使用方括号访问键对应的值<code>map[key]</code>。需要注意的是，如果该<code>key</code>不存在，C++ 会自动创建这个 key，并把<code>map[key]</code>赋值为 0。</p>
<p>所以代码中多次出现的<code>map[key]++</code>相当于 Java 的<code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p>
<h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p>LeetCode 76 题，Minimum Window Substring，难度 <strong>Hard</strong>，我带大家看看它到底有多 <strong>Hard</strong>：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowk6hiaxmGN6ibHiaTqxHMqYvCRA4lWuRCQicPSfZY78De1GmwkXviar4psjw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>就是说要在<code>S</code>(source) 中找到包含<code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.size(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p><em><strong>1、</strong></em>我们在字符串<code>S</code>中使用双指针中的左右指针技巧，初始化<code>left = right = 0</code>，<strong>把索引左闭右开区间<code>[left, right)</code>称为一个「窗口」</strong>。</p>
<p><em><strong>2、</strong></em>我们先不断地增加<code>right</code>指针扩大窗口<code>[left, right)</code>，直到窗口中的字符串符合要求（包含了<code>T</code>中的所有字符）。</p>
<p><em><strong>3、</strong></em>此时，我们停止增加<code>right</code>，转而不断增加<code>left</code>指针缩小窗口<code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含<code>T</code>中的所有字符了）。同时，每次增加<code>left</code>，我们都要更新一轮结果。</p>
<p><em><strong>4、</strong></em>重复第 2 和第 3 步，直到<code>right</code>到达字符串<code>S</code>的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code>和<code>window</code>相当于计数器，分别记录<code>T</code>中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEow6FwvAvsZKyCTCtrmLcvKDxhYAJEqI36cAZxfoIWLFibEhmz9IfHf24Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>增加<code>right</code>，直到窗口<code>[left, right)</code>包含了<code>T</code>中所有字符：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowCyAS47jbjAGEfqUVRzkKDWbT6Y8JiarUicPMVR2yI72X3X6hjBGj4bGw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>现在开始增加<code>left</code>，缩小窗口<code>[left, right)</code>。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowoE6BjdgVFKZwEb1q6VibCzIsNuoYmHuNicVdlDibQrQD6lRJbibjkBxO4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code>不再继续移动。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowZQrqU81dPoEicq1J93aicY0A70IdicorFC5kfhJKa66CibKQTJxY4A60jA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>之后重复上述过程，先移动<code>right</code>，再移动<code>left</code>…… 直到<code>right</code>指针到达字符串<code>S</code>的末端，算法结束。</p>
<p>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。<strong>现在我们来看看这个滑动窗口代码框架怎么用</strong>：</p>
<p>首先，初始化<code>window</code>和<code>need</code>两个哈希表，记录窗口中的字符和需要凑齐的字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br></pre></td></tr></table></figure>

<p>然后，使用<code>left</code>和<code>right</code>变量初始化窗口的两端，不要忘了，区间<code>[left, right)</code>是左闭右开的，所以初始情况下窗口没有包含任何元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中<code>valid</code>变量表示窗口中满足<code>need</code>条件的字符个数</strong>，如果<code>valid</code>和<code>need.size</code>的大小相同，则说明窗口已满足条件，已经完全覆盖了串<code>T</code>。</p>
<p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p>
<p><strong>1、</strong>当移动<code>right</code>扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p><strong>2、</strong>什么条件下，窗口应该暂停扩大，开始移动<code>left</code>缩小窗口？</p>
<p><strong>3、</strong>当移动<code>left</code>缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p><strong>4、</strong>我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加<code>window</code>计数器；如果一个字符将移出窗口的时候，应该减少<code>window</code>计数器；当<code>valid</code>满足<code>need</code>时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<p>下面是完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string <span class="title function_">minWindow</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">len</span> <span class="operator">=</span>= INT_MAX ?</span><br><span class="line">        <span class="string">&quot;&quot;</span> : s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当我们发现某个字符在<code>window</code>的数量满足了<code>need</code>的需要，就要更新<code>valid</code>，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p>
<p>当<code>valid == need.size()</code>时，说明<code>T</code>中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。</p>
<p>移动<code>left</code>收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p>
<p>至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。<strong>以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿</strong>。</p>
<p>下面就直接利用这套框架秒杀几道题吧，你基本上一眼就能看出思路了。</p>
<h3 id="二、字符串排列"><a href="#二、字符串排列" class="headerlink" title="二、字符串排列"></a>二、字符串排列</h3><p>LeetCode 567 题，Permutation in String，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowmo3G9oN6XDmHeHjGic6tUauwoZia40pxjbicJXtN1RcjMMRDkfcGaVNVg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注意哦，输入的<code>s1</code>是可以包含重复字符的，所以这个题难度不小。</p>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个<code>S</code>和一个<code>T</code>，请问你<code>S</code>中是否存在一个子串，包含<code>T</code>中所有字符且不包含其他字符</strong>？</p>
<p>首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line">bool <span class="title function_">checkInclusion</span><span class="params">(string t, string s)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p><strong>1、</strong>本题移动<code>left</code>缩小窗口的时机是窗口大小大于<code>t.size()</code>时，因为排列嘛，显然长度应该是一样的。</p>
<p><strong>2、</strong>当发现<code>valid == need.size()</code>时，就说明窗口中就是一个合法的排列，所以立即返回<code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="三、找所有字母异位词"><a href="#三、找所有字母异位词" class="headerlink" title="三、找所有字母异位词"></a>三、找所有字母异位词</h3><p>这是 LeetCode 第 438 题，Find All Anagrams in a String，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowe98rknTABmhPaxgzV5Vv9gHdEpNUDia6CO0gxuPpNR5My6ogK8wuibTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？<strong>相当于，输入一个串<code>S</code>，一个串<code>T</code>，找到<code>S</code>中所有<code>T</code>的排列，返回它们的起始索引</strong>。</p>
<p>直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="title function_">findAnagrams</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入<code>res</code>即可。</p>
<h3 id="四、最长无重复子串"><a href="#四、最长无重复子串" class="headerlink" title="四、最长无重复子串"></a>四、最长无重复子串</h3><p>这是 LeetCode 第 3 题，Longest Substring Without Repeating Characters，难度 Medium：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdGQlBxOlAet1AXGPoibCzEowdOEyLaTVTiabiabMHr2Z7SzZZ08fxMDZt4uzzRcfvoI7sJzfdORvH0tA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(string s)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是变简单了，连<code>need</code>和<code>valid</code>都不需要，而且更新窗口内数据也只需要简单的更新计数器<code>window</code>即可。</p>
<p>当<code>window[c]</code>值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动<code>left</code>缩小窗口了嘛。</p>
<p>唯一需要注意的是，在哪里更新结果<code>res</code>呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p>
<p>这里和之前不一样，**要在收缩窗口完成后更新<code>res</code>**，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p>
<h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p><strong>建议背诵并默写这套框架，顺便背诵一下文章开头的那首诗。以后就再也不怕子串、子数组问题了。</strong></p>
<p>我觉得吧，能够看到这的都是高手，要么就是在成为高手的路上。有了框架，任他窗口怎么滑，东哥这波车开得依然稳如老狗。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>益智游戏克星：BFS暴力搜索算法</title>
    <url>/posts/20eb9dff/</url>
    <content><![CDATA[<h1 id="益智游戏克星：BFS暴力搜索算法"><a href="#益智游戏克星：BFS暴力搜索算法" class="headerlink" title="益智游戏克星：BFS暴力搜索算法"></a>益智游戏克星：BFS暴力搜索算法</h1><h2 id="益智游戏克星：BFS暴力搜索算法-1"><a href="#益智游戏克星：BFS暴力搜索算法-1" class="headerlink" title="益智游戏克星：BFS暴力搜索算法"></a>益智游戏克星：BFS暴力搜索算法</h2><p>滑动拼图游戏大家应该都玩过，下图是一个 4x4 的滑动拼图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5zWwfF_20210507183108.png" alt="图片"></p>
<p>拼图中有一个格子是空的，可以利用这个空着的格子移动其他数字。你需要通过移动这些数字，得到某个特定排列顺序，这样就算赢了。</p>
<p>我小时候还玩过一款叫做「华容道」的益智游戏，也和滑动拼图比较类似：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ueMqO0_20210507183151.png" alt="图片"></p>
<p>那么这种游戏怎么玩呢？我记得是有一些套路的，类似于魔方还原公式。但是我们今天不来研究让人头秃的技巧，<strong>这些益智游戏通通可以用暴力搜索算法解决，所以今天我们就学以致用，用 BFS 算法框架来秒杀这些游戏</strong>。</p>
<h3 id="一、题目解析"><a href="#一、题目解析" class="headerlink" title="一、题目解析"></a>一、题目解析</h3><p>LeetCode 第 773 题就是滑动拼图问题，题目的意思如下：</p>
<p>给你一个 2x3 的滑动拼图，用一个 2x3 的数组<code>board</code>表示。拼图中有数字 0~5 六个数，其中数字 0 就表示那个空着的格子，你可以移动其中的数字，当<code>board</code>变为<code>[[1,2,3],[4,5,0]]</code>时，赢得游戏。</p>
<p>请你写一个算法，计算赢得游戏需要的最少移动次数，如果不能赢得游戏，返回 -1。</p>
<p>比如说输入的二维数组<code>board = [[4,1,2],[5,0,3]]</code>，算法应该返回 5：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/DnxfJo_20210507183245.png" alt="图片"></p>
<p>如果输入的是<code>board = [[1,2,3],[4,0,5]]</code>，则算法返回 -1，因为这种局面下无论如何都不能赢得游戏。</p>
<h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><p>对于这种计算最小步数的问题，我们就要敏感地想到 BFS 算法。</p>
<p>这个题目转化成 BFS 问题是有一些技巧的，我们面临如下问题：</p>
<p>1、一般的 BFS 算法，是从一个起点<code>start</code>开始，向终点<code>target</code>进行寻路，但是拼图问题不是在寻路，而是在不断交换数字，这应该怎么转化成 BFS 算法问题呢？</p>
<p>2、即便这个问题能够转化成 BFS 问题，如何处理起点<code>start</code>和终点<code>target</code>？它们都是数组哎，把数组放进队列，套 BFS 框架，想想就比较麻烦且低效。</p>
<p>首先回答第一个问题，<strong>BFS 算法并不只是一个寻路算法，而是一种暴力搜索算法</strong>，只要涉及暴力穷举的问题，BFS 就可以用，而且可以最快地找到答案。</p>
<p>你想想计算机怎么解决问题的？哪有那么多奇技淫巧，本质上就是把所有可行解暴力穷举出来，然后从中找到一个最优解罢了。</p>
<p>明白了这个道理，我们的问题就转化成了：<strong>如何穷举出<code>board</code>当前局面下可能衍生出的所有局面</strong>？这就简单了，看数字 0 的位置呗，和上下左右的数字进行交换就行了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KoSRd4_20210507183301.png" alt="图片"></p>
<p>这样其实就是一个 BFS 问题，每次先找到数字 0，然后和周围的数字进行交换，形成新的局面加入队列…… 当第一次到达<code>target</code>时，就得到了赢得游戏的最少步数。</p>
<p>对于第二个问题，我们这里的<code>board</code>仅仅是 2x3 的二维数组，所以可以压缩成一个一维字符串。<strong>其中比较有技巧性的点在于，二维数组有「上下左右」的概念，压缩成一维后，如何得到某一个索引上下左右的索引</strong>？</p>
<p>很简单，我们只要手动写出来这个映射就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**这个含义就是，在一维字符串中，索引<code>i</code>在二维数组中的的相邻索引为<code>neighbor[i]</code>**，：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CkiHlV_20210507183314.png" alt="图片"></p>
<p>至此，我们就把这个问题完全转化成标准的 BFS 问题了，借助前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485134&idx=1&sn=fd345f8a93dc4444bcc65c57bb46fc35&chksm=9bd7f8c6aca071d04c4d383f96f2b567ad44dc3e67d1c3926ec92d6a3bcc3273de138b36a0d9&scene=21#wechat_redirect">BFS 算法框架套路详解</a> 的代码框架，直接就可以套出解法代码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">slidingPuzzle</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>, n = <span class="number">3</span>;</span><br><span class="line">    <span class="type">string</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">string</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;123450&quot;</span>;</span><br><span class="line">    <span class="comment">// 将 2x3 的数组转化成字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            start.push_back(board[i][j] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录一维字符串的相邻索引</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* BFS 算法框架开始 *******/</span></span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_set&lt;string&gt; visited;</span><br><span class="line">    q.push(start);</span><br><span class="line">    visited.insert(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">cur</span> <span class="operator">=</span> q.front(); q.pop();</span><br><span class="line">            <span class="comment">// 判断是否达到目标局面</span></span><br><span class="line">            <span class="keyword">if</span> (target == cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到数字 0 的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; cur[idx] != <span class="string">&#x27;0&#x27;</span>; idx++);</span><br><span class="line">            <span class="comment">// 将数字 0 和相邻的数字交换位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> adj : neighbor[idx]) &#123;</span><br><span class="line">                <span class="type">string</span> <span class="variable">new_board</span> <span class="operator">=</span> cur;</span><br><span class="line">                swap(new_board[adj], new_board[idx]);</span><br><span class="line">                <span class="comment">// 防止走回头路</span></span><br><span class="line">                <span class="keyword">if</span> (!visited.count(new_board)) &#123;</span><br><span class="line">                    q.push(new_board);</span><br><span class="line">                    visited.insert(new_board);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/******* BFS 算法框架结束 *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就解决了，其实框架完全没有变，套路都是一样的，我们只是花了比较多的时间将滑动拼图游戏转化成 BFS 算法。</p>
<p><strong>很多益智游戏都是这样，虽然看起来特别巧妙，但都架不住暴力穷举</strong>，常用的算法就是回溯算法或者 BFS 算法，感兴趣的话我们以后再聊。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典动态规划：0-1 背包问题</title>
    <url>/posts/87975f1/</url>
    <content><![CDATA[<h1 id="经典动态规划：0-1-背包问题"><a href="#经典动态规划：0-1-背包问题" class="headerlink" title="经典动态规划：0-1 背包问题"></a>经典动态规划：0-1 背包问题</h1><p>后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。</p>
<p>今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题，简单描述一下吧：</p>
<p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>举个简单的例子，输入如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span></span><br><span class="line">wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>算法返回 6，选择前两件物品装进背包，总重量 3 小于<code>W</code>，可以获得最大价值 6。</p>
<p>题目就是这么简单，一个典型的动态规划问题。<strong>这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。</strong>这也许就是 0-1 背包这个名词的来历。</p>
<p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划套路详解</a> 中的套路，直接走流程就行了。</p>
<h2 id="动规标准套路"><a href="#动规标准套路" class="headerlink" title="动规标准套路"></a>动规标准套路</h2><p>看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的，今天再来手把手演示一下：</p>
<p><strong>第一步****要明确两点，「状态」和「选择」</strong>。</p>
<p>先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p>
<p>再说选择，也很容易想到啊，对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p>
<p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>PS：此框架出自历史文章 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a>。</p>
<p><strong>第二步**<strong>要明确</strong></strong><code>dp</code>数组的定义**。</p>
<p><code>dp</code>数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用<code>dp</code>数组把状态表示出来。</p>
<p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维<code>dp</code>数组，一维表示可选择的物品，一维表示背包的容量。</p>
<p><strong><code>dp[i][w]</code>的定义如下：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</strong></p>
<p>比如说，如果 <code>dp[3][5]</code> &#x3D; 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p>
<p>PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种动规套路都被扒得清清楚楚了。</p>
<p><strong>根据这个定义，我们想求的最终答案就是</strong>**<code>dp[N][W]</code>。base case 就是<code>dp[0][..] = dp[..][0] = 0</code>**，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p>
<p>细化上面的框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = max(</span><br><span class="line">            把物品 i 装进背包,</span><br><span class="line">            不把物品 i 装进背包</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<p><strong>第三步****，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>简单说就是，上面伪码中「把物品<code>i</code>装进背包」和「不把物品<code>i</code>装进背包」怎么用代码体现出来呢？</p>
<p><strong>这一步要结合对</strong><strong><code>dp</code>数组的定义和我们的算法逻辑来分析：</strong></p>
<p>先重申一下刚才我们的<code>dp</code>数组的定义：</p>
<p><code>dp[i][w]</code>表示：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>时，这种情况下可以装下的最大价值是<code>dp[i][w]</code>。</p>
<p><strong>如果你没有把这第</strong><strong><code>i</code>个物品装入背包</strong>，那么很显然，最大价值<code>dp[i][w]</code>应该等于<code>dp[i-1][w]</code>。你不装嘛，那就继承之前的结果。</p>
<p><strong>如果你把这第</strong><strong><code>i</code>个物品装入了背包</strong>，那么<code>dp[i][w]</code>应该等于<code>dp[i-1][w-wt[i-1]] + val[i-1]</code>。</p>
<p>首先，由于<code>i</code>是从 1 开始的，所以对<code>val</code>和<code>wt</code>的取值是<code>i-1</code>。</p>
<p>而<code>dp[i-1][w-wt[i-1]]</code>也很好理解：你如果想装第<code>i</code>个物品，你怎么计算这时候的最大价值？<strong>换句话说，在装第</strong><strong><code>i</code>个物品的前提下，背包能装的最大价值是多少？</strong></p>
<p>显然，你应该寻求剩余重量<code>w-wt[i-1]</code>限制下能装的最大价值，加上第<code>i</code>个物品的价值<code>val[i-1]</code>，这就是装第<code>i</code>个物品的前提下，背包可以装的最大价值。</p>
<p>综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = max(</span><br><span class="line">            dp[i-<span class="number">1</span>][w],</span><br><span class="line">            dp[i-<span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>]</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<p><strong>最后一步****，把伪码翻译成代码，处理一些边界情况</strong>。</p>
<p>我用 C++ 写的代码，把上面的思路完全翻译了一遍，并且处理了<code>w - wt[i-1]</code>可能小于 0 导致数组索引越界的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> &#123;</span><br><span class="line">    <span class="comment">// vector 全填入 0，base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">dp</span><span class="params">(N + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>)</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i-<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你看这个解法代码，是不是感觉非常简单，就是把我们刚才分析的思路原封不动翻译了一下而已。</p>
<p>所以说，明确了动态规划的套路，思路就显得行云流水，非常自然就出答案了。</p>
<p>至此，背包问题就解决了。相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导逻辑比较容易想到，基本上你明确了<code>dp</code>数组的定义，就可以理所当然地确定状态转移了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典动态规划：戳气球问题</title>
    <url>/posts/93bfdc7a/</url>
    <content><![CDATA[<h1 id="经典动态规划：戳气球问题"><a href="#经典动态规划：戳气球问题" class="headerlink" title="经典动态规划：戳气球问题"></a>经典动态规划：戳气球问题</h1><p>今天我们要聊的这道题「Burst Balloon」和之前我们写过的那篇 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋问题</a> 分析过的高楼扔鸡蛋问题类似，知名度很高，但难度确实也很大。因此 labuladong 公众号就给这道题赐个座，来看一看这道题目到底有多难。</p>
<p>它是 LeetCode 第 312 题，题目如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NNiTSq_20210507180038.png" alt="图片"></p>
<p>首先必须要说明，这个题目的状态转移方程真的比较巧妙，所以说如果你看了题目之后完全没有思路恰恰是正常的。虽然最优答案不容易想出来，但基本的思路分析是我们应该力求做到的。所以本文会先分析一下常规思路，然后再引入动态规划解法。</p>
<h2 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="一、回溯思路"></a>一、回溯思路</h2><p>先来顺一下解决这种问题的套路：</p>
<p><strong>我们前文多次强调过，很显然只要涉及求最值，没有任何奇技淫巧，一定是穷举所有可能的结果，然后对比得出最值</strong>。</p>
<p>所以说，只要遇到求最值的算法问题，首先要思考的就是：如何穷举出所有可能的结果？</p>
<p>穷举主要有两种算法，就是回溯算法和动态规划，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」。</p>
<p>如何将我们的扎气球问题转化成回溯算法呢？这个应该不难想到的，<strong>我们其实就是想穷举戳气球的顺序</strong>，不同的戳气球顺序可能得到不同的分数，我们需要把所有可能的分数中最高的那个找出来，对吧。</p>
<p>那么，这不就是一个「全排列」问题嘛，我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法框架套路详解</a> 中有全排列算法的详解和代码，其实只要稍微改一下逻辑即可，伪码思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/* 输入一组气球，返回戳破它们获得的最大分数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回溯算法的伪码解法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> socre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums 为空) &#123;</span><br><span class="line">        res = max(res, score);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> nums[i-<span class="number">1</span>] * nums[i] * nums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        在 nums 中删除元素 nums[i]</span><br><span class="line">        <span class="comment">// 递归回溯</span></span><br><span class="line">        backtrack(nums, score + point);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        将 temp 还原到 nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法就是这么简单粗暴，但是相应的，算法的效率非常低。这个解法等同于全排列，所以时间复杂度是阶乘级别，非常高，题目说了<code>nums</code>的大小<code>n</code>最多为 500，所以回溯算法肯定是不能通过所有测试用例的。</p>
<h2 id="二、动态规划思路"><a href="#二、动态规划思路" class="headerlink" title="二、动态规划思路"></a>二、动态规划思路</h2><p>这个动态规划问题和我们之前的动态规划系列文章相比有什么特别之处？为什么它比较难呢？</p>
<p><strong>原因在于，这个问题中我们每戳破一个气球<code>nums[i]</code>，得到的分数和该气球相邻的气球<code>nums[i-1]</code>和<code>nums[i+1]</code>是有相关性的</strong>。</p>
<p>我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect">动态规划套路框架详解</a> 说过运用动态规划算法的一个重要条件：<strong>子问题必须独立</strong>。所以对于这个戳气球问题，如果想用动态规划，必须巧妙地定义<code>dp</code>数组的含义，避免子问题产生相关性，才能推出合理的状态转移方程。</p>
<p>如何定义<code>dp</code>数组呢，这里需要对问题进行一个简单地转化。题目说可以认为<code>nums[-1] = nums[n] = 1</code>，那么我们先直接把这两个边界加进去，形成一个新的数组<code>points</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 两端加入两个虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在气球的索引变成了从<code>1</code>到<code>n</code>，<code>points[0]</code>和<code>points[n+1]</code>可以认为是两个「虚拟气球」。</p>
<p>那么我们可以改变问题：<strong>在一排气球<code>points</code>中，请你戳破气球<code>0</code>和气球<code>n+1</code>之间的所有气球（不包括<code>0</code>和<code>n+1</code>），使得最终只剩下气球<code>0</code>和气球<code>n+1</code>两个气球，最多能够得到多少分</strong>？</p>
<p>现在可以定义<code>dp</code>数组的含义：</p>
<p>**<code>dp[i][j] = x</code>表示，戳破气球<code>i</code>和气球<code>j</code>之间（开区间，不包括<code>i</code>和<code>j</code>）的所有气球，可以获得的最高分数为<code>x</code>**。</p>
<p>那么根据这个定义，题目要求的结果就是<code>dp[0][n+1]</code>的值，而 base case 就是<code>dp[i][j] = 0</code>，其中<code>0 &lt;= i &lt;= n+1, j &lt;= i+1</code>，因为这种情况下，开区间<code>(i, j)</code>中间根本没有气球可以戳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>现在我们要根据这个<code>dp</code>数组来推导状态转移方程了，根据我们前文的套路，所谓的推导「状态转移方程」，实际上就是在思考怎么「做选择」，也就是这道题目最有技巧的部分：</p>
<p>不就是想求戳破气球<code>i</code>和气球<code>j</code>之间的最高分数吗，如果「正向思考」，就只能写出前文的回溯算法；<strong>我们需要「反向思考」，想一想气球<code>i</code>和气球<code>j</code>之间最后一个被戳破的气球可能是哪一个</strong>？</p>
<p>其实气球<code>i</code>和气球<code>j</code>之间的所有气球都可能是最后被戳破的那一个，不防假设为<code>k</code>。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：<code>i</code>和<code>j</code>就是两个「状态」，最后戳破的那个气球<code>k</code>就是「选择」。</p>
<p><strong>根据刚才对<code>dp</code>数组的定义，如果最后一个戳破气球<code>k</code>，<code>dp[i][j]</code>的值应该为</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][k] + dp[k][j] </span><br><span class="line">         + points[i]*points[k]*points[j]</span><br></pre></td></tr></table></figure>

<p>你不是要最后戳破气球<code>k</code>吗？那得先把开区间<code>(i, k)</code>的气球都戳破，再把开区间<code>(k, j)</code>的气球都戳破；最后剩下的气球<code>k</code>，相邻的就是气球<code>i</code>和气球<code>j</code>，这时候戳破<code>k</code>的话得到的分数就是<code>points[i]*points[k]*points[j]</code>。</p>
<p>那么戳破开区间<code>(i, k)</code>和开区间<code>(k, j)</code>的气球最多能得到的分数是多少呢？嘿嘿，就是<code>dp[i][k]</code>和<code>dp[k][j]</code>，这恰好就是我们对<code>dp</code>数组的定义嘛！</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/BgWf3s_20210507180154.png" alt="图片"></p>
<p>结合这个图，就能体会出<code>dp</code>数组定义的巧妙了。由于是开区间，<code>dp[i][k]</code>和<code>dp[k][j]</code>不会影响气球<code>k</code>；而戳破气球<code>k</code>时，旁边相邻的就是气球<code>i</code>和气球<code>j</code>了，最后还会剩下气球<code>i</code>和气球<code>j</code>，这也恰好满足了<code>dp</code>数组开区间的定义。</p>
<p>那么，对于一组给定的<code>i</code>和<code>j</code>，我们只要穷举<code>i &lt; k &lt; j</code>的所有气球<code>k</code>，选择得分最高的作为<code>dp[i][j]</code>的值即可，这也就是状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">    <span class="comment">// 择优做选择，使得 dp[i][j] 最大</span></span><br><span class="line">    dp[i][j] = Math.max(</span><br><span class="line">        dp[i][j], </span><br><span class="line">        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写出状态转移方程就完成这道题的一大半了，但是还有问题：对于<code>k</code>的穷举仅仅是在做「选择」，但是应该如何穷举「状态」<code>i</code>和<code>j</code>呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(</span><br><span class="line">                dp[i][j], </span><br><span class="line">                dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">            );</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="三、写出代码"><a href="#三、写出代码" class="headerlink" title="三、写出代码"></a>三、写出代码</h2><p><strong>关于「状态」的穷举，最重要的一点就是：状态转移所依赖的状态必须被提前计算出来</strong>。</p>
<p>拿这道题举例，<code>dp[i][j]</code>所依赖的状态是<code>dp[i][k]</code>和<code>dp[k][j]</code>，那么我们必须保证：在计算<code>dp[i][j]</code>时，<code>dp[i][k]</code>和<code>dp[k][j]</code>已经被计算出来了（其中<code>i &lt; k &lt; j</code>）。</p>
<p>那么应该如何安排<code>i</code>和<code>j</code>的遍历顺序，来提供上述的保证呢？我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484832&idx=1&sn=44ad2505ac5c276bf36eea1c503b78c3&chksm=9bd7fba8aca072be32f66e6c39d76ef4e91bdbf4ef993014d4fee82896687ad61da4f4fc4eda&scene=21#wechat_redirect">动态规划答疑篇</a> 写过处理这种问题的一个鸡贼技巧：<strong>根据 base case 和最终状态进行推导</strong>。</p>
<p>PS：最终状态就是指题目要求的结果，对于这道题目也就是<code>dp[0][n+1]</code>。</p>
<p>我们先把 base case 和最终的状态在 DP table 上画出来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/u3gd6W_20210507180507.png" alt="图片"></p>
<p>对于任一<code>dp[i][j]</code>，我们希望所有<code>dp[i][k]</code>和<code>dp[k][j]</code>已经被计算，画在图上就是这种情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Nhk1gt_20210507180419.png" alt="图片"></p>
<p>那么，为了达到这个要求，可以有两种遍历方法，要么斜着遍历，要么从下到上从左到右遍历：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/F2pPqp_20210507180541.png" alt="图片"></p>
<p>斜着遍历有一点难写，所以一般我们就从下往上遍历，下面看完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i][j], </span><br><span class="line">                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就完全解决了，十分巧妙，但也不是那么难，对吧？</p>
<p>关键在于<code>dp</code>数组的定义，需要避免子问题互相影响，所以我们反向思考，将<code>dp[i][j]</code>的定义设为开区间，考虑最后戳破的气球是哪一个，以此构建了状态转移方程。</p>
<p>对于如何穷举「状态」，我们使用了小技巧，通过 base case 和最终状态推导出<code>i,j</code>的遍历方向，保证正确的状态转移。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典动态规划：高楼扔鸡蛋</title>
    <url>/posts/e7520fcc/</url>
    <content><![CDATA[<h1 id="经典动态规划：高楼扔鸡蛋"><a href="#经典动态规划：高楼扔鸡蛋" class="headerlink" title="经典动态规划：高楼扔鸡蛋"></a>经典动态规划：高楼扔鸡蛋</h1><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484675&from_itemidx=1&count=3&nolastread=1#wechat_redirect">手把手刷动态规划 25个</a></p>
<h2 id="预计阅读时间：7-分钟"><a href="#预计阅读时间：7-分钟" class="headerlink" title="预计阅读时间：7 分钟"></a>预计阅读时间：7 分钟</h2><p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p>
<p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了不太划算。</p>
<p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p>
<h2 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h2><p>题目是这样：你面前有一栋从 1 到<code>N</code>共<code>N</code>层的楼，然后给你<code>K</code>个鸡蛋（<code>K</code>至少为 1）。现在确定这栋楼存在楼层<code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于<code>F</code>的楼层都会碎，低于<code>F</code>的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层<code>F</code>呢？</p>
<p>PS：F 可以为 0，比如说鸡蛋在 1 层都能摔碎，那么 F &#x3D; 0。</p>
<p>也就是让你找摔不碎鸡蛋的最高楼层<code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p>
<p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p>
<p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p>
<p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p>
<p>现在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p>
<p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p>
<p>最好的策略是使用二分查找思路，我先去第<code>(1 + 7) / 2 = 4</code>层扔一下：</p>
<p>如果碎了说明<code>F</code>小于 4，我就去第<code>(1 + 3) / 2 = 2</code>层试……</p>
<p>如果没碎说明<code>F</code>大于等于 4，我就去第<code>(5 + 7) / 2 = 6</code>层试……</p>
<p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试<code>log7</code>向上取整等于 3 次，比刚才的 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p>
<p>PS：这有点像 Big O 表示法计算算法的复杂度。</p>
<p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制<code>K</code>，直接使用二分思路就不行了</strong>。</p>
<p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层<code>F</code>了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。</p>
<p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p>
<p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p>
<p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。</p>
<p>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p>
<p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p>
<h2 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h2><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p>
<p>**「状态」很明显，就是当前拥有的鸡蛋数<code>K</code>和需要测试的楼层数<code>N</code>**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p>
<p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p>
<p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的<code>dp</code>数组或者带有两个状态参数的<code>dp</code>函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 当前状态为 (K 个鸡蛋，N 层楼)</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="type">int</span> res</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        res = min(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p>
<p>我们在第<code>i</code>层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p>
<p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数<code>K</code>应该减一，搜索的楼层区间应该从<code>[1..N]</code>变为<code>[1..i-1]</code>共<code>i-1</code>层楼；</p>
<p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数<code>K</code>不变，搜索的楼层区间应该从 <code>[1..N]</code>变为<code>[i+1..N]</code>共<code>N-i</code>层楼。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CvIp2u_20210429194724.png" alt="图片"></p>
<p>PS：细心的读者可能会问，在第<code>i</code>层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第<code>i</code>层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第<code>i</code>层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p>
<p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第<code>i</code>层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>递归的 base case 很容易理解：当楼层数<code>N</code>等于 0 时，显然不需要扔鸡蛋；当鸡蛋数<code>K</code>为 1 时，显然只能线性扫描所有楼层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">    <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">superEggDrop</span><span class="params">(K: <span class="type">int</span>, N: <span class="type">int</span>)</span>:</span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="title function_">dp</span><span class="params">(K, N)</span> -&gt; <span class="type">int</span>:</span><br><span class="line">        # base <span class="keyword">case</span></span><br><span class="line">        <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        # 避免重复计算</span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        res = <span class="type">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        # 穷举所有可能的选择</span><br><span class="line">        <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">1</span>, N + <span class="number">1</span>)</span>:</span><br><span class="line">            res = min(res, </span><br><span class="line">                      max(</span><br><span class="line">                            dp(K, N - i), </span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                         ) + <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)。</p>
<h2 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h2><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录&#x2F;DP table 优化，真的没啥新意。</p>
<p>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层<code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p>
<p>比方说你有 2 个鸡蛋，面对 10 层楼，你得拿一个鸡蛋去某一层楼扔对吧？那选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于鸡蛋碎没碎，下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。</p>
<p>其实，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K<em>N</em>logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p>
<p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最小值。</p>
<p>这里就不展开以上解法了，有兴趣的读者可以点击「阅读原文」查看。</p>
<p>我觉得吧，我们这种解法就够了：<strong>找状态，做选择</strong>，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，二分查找的优化应该可以看懂，之后的优化也就随缘吧。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典动态规划：高楼扔鸡蛋（进阶篇）</title>
    <url>/posts/d0fbc9db/</url>
    <content><![CDATA[<h1 id="经典动态规划：高楼扔鸡蛋（进阶篇）"><a href="#经典动态规划：高楼扔鸡蛋（进阶篇）" class="headerlink" title="经典动态规划：高楼扔鸡蛋（进阶篇）"></a>经典动态规划：高楼扔鸡蛋（进阶篇）</h1><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484675&from_itemidx=1&count=3&nolastread=1#wechat_redirect">手把手刷动态规划 25个</a></p>
<h2 id="预计阅读时间：9-分钟"><a href="#预计阅读时间：9-分钟" class="headerlink" title="预计阅读时间：9 分钟"></a>预计阅读时间：9 分钟</h2><p>我们在 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">上篇文章</a> 聊了高楼扔鸡蛋问题，讲了一种效率不是很高，但是较为容易理解的动态规划解法。后台很多读者问如何更高效地解决这个问题，今天就谈两种思路，来优化一下这个问题，分别是二分查找优化和重新定义状态转移。</p>
<p>如果还不知道高楼扔鸡蛋问题的读者可以看下 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484675&idx=1&sn=4a4ac1c0f1279530b42fedacc6cca6e6&chksm=9bd7fb0baca0721dda1eaa1d00b9a520672dc9d5c3be762eeca869be35d7ce232922ba8e928b&scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋</a>，<strong>那篇文章详解了题目的含义和基本的动态规划解题思路，请确保理解前文，<strong><strong>因为</strong></strong>今天的优化都是基于这个基本解法的</strong>。</p>
<p>二分搜索的优化思路也许是我们可以尽力尝试写出的，而修改状态转移的解法可能是不容易想到的，可以借此见识一下动态规划算法设计的玄妙，当做思维拓展。</p>
<h2 id="一、二分搜索优化"><a href="#一、二分搜索优化" class="headerlink" title="一、二分搜索优化"></a>一、二分搜索优化</h2><p>之前提到过这个解法，核心是因为状态转移方程的单调性，这里可以具体展开看看。</p>
<p>题目要求最坏情况下至少需要扔几次鸡蛋才能测出鸡蛋恰好摔不碎的楼层<code>F</code>。首先简述一下原始动态规划的思路：</p>
<p><strong>1</strong>、暴力穷举尝试在所有楼层<code>1 &lt;= i &lt;= N</code>扔鸡蛋，每次选择尝试次数<strong>最少</strong>的那一层；</p>
<p><strong>2</strong>、每次扔鸡蛋有两种可能，要么碎，要么没碎；</p>
<p><strong>3</strong>、如果鸡蛋碎了，<code>F</code>应该在第<code>i</code>层下面，否则，<code>F</code>应该在第<code>i</code>层上面；</p>
<p><strong>4</strong>、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数<strong>更多</strong>，因为我们想求的是最坏情况下的结果。</p>
<p>核心的状态转移代码是这段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 当前状态为 K 个鸡蛋，面对 N 层楼</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/CyPTgO_20210429195258.png" alt="图片"></p>
<p>如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。</p>
<p>首先我们根据<code>dp(K, N)</code>数组的定义（有<code>K</code>个鸡蛋面对<code>N</code>层楼，最少需要扔 dp(K, N) 次），<strong>很容易知道<code>K</code>固定时，这个函数随着<code>N</code>的增加一定是单调递增的</strong>，无论你策略多聪明，楼层增加的话，测试次数一定要增加。</p>
<p>那么注意<code>dp(K - 1, i - 1)</code>和<code>dp(K, N - i)</code>这两个函数，其中<code>i</code>是从 1 到<code>N</code>单增的，如果我们固定<code>K</code>和<code>N</code>，<strong>把这两个函数看做关于<code>i</code>的函数，前者随着<code>i</code>的增加应该也是单调递增的，而后者随着<code>i</code>的增加应该是单调递减的</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/6NYUjf_20210429195215.png" alt="图片"></p>
<p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。</p>
<p>我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484598&idx=1&sn=69edaf4a7f6bfd0b1185cae5d0689c1d&chksm=9bd7fabeaca073a8820bc93cb67a8e26fa9eaa1ab9717b7e3ac41b4aac12235067c8af3520d5&scene=21#wechat_redirect">二分搜索只能用来查找元素吗？</a>讲过，二分查找的运用很广泛，形如下面这种形式的 for 循环代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOK(i))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个<code>dp</code>函数的曲线，我们要找的最低点其实就是这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp(K - <span class="number">1</span>, i - <span class="number">1</span>) == dp(K, N - i))</span><br><span class="line">        <span class="keyword">return</span> dp(K, N - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">superEggDrop</span><span class="params">(self, K: <span class="type">int</span>, N: <span class="type">int</span>)</span> -&gt; <span class="type">int</span>:</span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="title function_">dp</span><span class="params">(K, N)</span>:</span><br><span class="line">        <span class="type">if</span> <span class="variable">K</span> <span class="operator">=</span>= <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="type">if</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        # <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        #     res = min(res, </span><br><span class="line">        #             max( </span><br><span class="line">        #                 dp(K - <span class="number">1</span>, i - <span class="number">1</span>), </span><br><span class="line">        #                 dp(K, N - i)      </span><br><span class="line">        #                 ) + <span class="number">1</span> </span><br><span class="line">        #             )</span><br><span class="line"></span><br><span class="line">        res = <span class="type">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        # 用二分搜索代替线性搜索</span><br><span class="line">        lo, hi = <span class="number">1</span>, N</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) <span class="comment">// 2</span></span><br><span class="line">            broken = dp(K - <span class="number">1</span>, mid - <span class="number">1</span>) # 碎</span><br><span class="line">            not_broken = dp(K, N - mid) # 没碎</span><br><span class="line">            # res = min(max(碎，没碎) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> broken &gt; not_broken:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">                res = min(res, broken + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">                res = min(res, not_broken + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K<em>N</em>logN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效不少。</p>
<h2 id="二、重写状态转移"><a href="#二、重写状态转移" class="headerlink" title="二、重写状态转移"></a>二、重写状态转移</h2><p>前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484469&idx=1&sn=e8d321c8ad62483874a997e9dd72da8f&chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 就提过，找动态规划的状态转移本就是见仁见智，比较玄学的事情。不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异。这里就是一个很好的例子。</p>
<p>再回顾一下我们之前定义的<code>dp</code>数组含义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">dp</span><span class="params">(k, n)</span> -&gt; <span class="type">int</span></span><br><span class="line"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="line"># 返回这个状态下最少的扔鸡蛋次数</span><br></pre></td></tr></table></figure>

<p>用 dp 数组表示的话也是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[k][n] = m</span><br><span class="line"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="line"># 这个状态下最少的扔鸡蛋次数为 m</span><br></pre></td></tr></table></figure>

<p>按照这个定义，就是<strong>确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数</strong>。最终我们想要的答案就是<code>dp(K, N)</code>的结果。</p>
<p>这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，只不过是更聪明的穷举。</p>
<p>现在，我们稍微修改<code>dp</code>数组的定义，<strong>确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定<code>F</code>的最高楼层数</strong>。</p>
<p>有点绕口，具体来说是这个意思：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[k][m] = n</span><br><span class="line"># 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋</span><br><span class="line"># 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼</span><br><span class="line"></span><br><span class="line"># 比如说 dp[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">7</span> 表示：</span><br><span class="line"># 现在有 <span class="number">1</span> 个鸡蛋，允许你扔 <span class="number">7</span> 次;</span><br><span class="line"># 这个状态下最多给你 <span class="number">7</span> 层楼，</span><br><span class="line"># 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎</span><br><span class="line"># （一层一层线性探查嘛）</span><br></pre></td></tr></table></figure>

<p>这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？</p>
<p>我们最终要求的其实是扔鸡蛋次数<code>m</code>，但是这时候<code>m</code>在状态之中而不是<code>dp</code>数组的结果，可以这样处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="comment">// 状态转移...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目不是<strong>给你<code>K</code>鸡蛋，<code>N</code>层楼，让你求最坏情况下最少的测试次数<code>m</code></strong> 吗？<code>while</code>循环结束的条件是<code>dp[K][m] == N</code>，也就是<strong>给你<code>K</code>个鸡蛋，允许测试<code>m</code>次，最坏情况下最多能测试<code>N</code>层楼</strong>。</p>
<p>注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/image-20210429195434229_20210429195434.png" alt="图片"></p>
<p>这个图描述的仅仅是某一个楼层<code>i</code>，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种<code>dp</code>定义根本不需要这些了，基于下面两个事实：</p>
<p><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上</strong>。</p>
<p><strong>2、无论你上楼还是下楼，总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</strong>。</p>
<p>根据这个特点，可以写出下面的状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[k][m] = dp[k][m-<span class="number">1</span>] + dp[k-<span class="number">1</span>][m-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong><code>dp[k][m - 1]</code>就是楼上的楼层数</strong>，因为鸡蛋个数<code>k</code>不变，也就是鸡蛋没碎，扔鸡蛋次数<code>m</code>减一；</p>
<p><strong><code>dp[k - 1][m - 1]</code>就是楼下的楼层数</strong>，因为鸡蛋个数<code>k</code>减一，也就是鸡蛋碎了，同时扔鸡蛋次数<code>m</code>减一。</p>
<p>PS：这个<code>m</code>为什么要减一而不是加一？之前定义得很清楚，这个<code>m</code>是一个允许的次数上界，而不是扔了几次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/72KWkN_20210429195454.png" alt="图片"></p>
<p>至此，整个思路就完成了，只要把状态转移方程填进框架即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case:</span></span><br><span class="line">    <span class="comment">// dp[0][..] = 0</span></span><br><span class="line">    <span class="comment">// dp[..][0] = 0</span></span><br><span class="line">    <span class="comment">// Java 默认初始化数组都为 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">            dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你还觉得这段代码有点难以理解，其实它就等同于这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; dp[K][m] &lt; N; m++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>看到这种代码形式就熟悉多了吧，因为我们要求的不是<code>dp</code>数组里的值，而是某个符合条件的索引<code>m</code>，所以用<code>while</code>循环来找到这个<code>m</code>而已。</p>
<p>这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。</p>
<p>另外注意到<code>dp[m][k]</code>转移只和左边和左上的两个状态有关，所以很容易优化成一维<code>dp</code>数组，这里就不写了。</p>
<h2 id="三、进一步思考"><a href="#三、进一步思考" class="headerlink" title="三、进一步思考"></a>三、进一步思考</h2><p>再往下就要用一些数学方法了，不具体展开，就简单提一下思路吧。</p>
<p>在刚才的思路之上，<strong>注意函数<code>dp(m, k)</code>是随着<code>m</code>单增的，因为鸡蛋个数<code>k</code>不变时，允许的测试次数越多，可测试的楼层就越高。</strong></p>
<p>这里又可以借助二分搜索算法快速逼近<code>dp[K][m] == N</code>这个终止条件，时间复杂度进一步下降为 O(KlogN)，我们可以设<code>g(k,m)</code>等于……</p>
<p>算了算了，打住吧。我觉得我们能够写出 O(K<em>N</em>logN) 的二分优化算法就行了，后面的这些解法呢，听个响鼓个掌就行了，把欲望限制在能力的范围之内才能拥有快乐！</p>
<p>不过可以肯定的是，根据二分搜索代替线性扫描 m 的取值，代码的大致框架肯定是修改穷举 m 的 for 循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把线性搜索改成二分搜索</span></span><br><span class="line"><span class="comment">// for (int m = 1; dp[K][m] &lt; N; m++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = N;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (... &lt; N) &#123;</span><br><span class="line">        lo = ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结一下吧，<strong>第一个二分优化是利用了<code>dp</code>函数的单调性</strong>，用二分查找技巧快速搜索答案；<strong>第二种优化是巧妙地修改了状态转移方程</strong>，简化了求解了流程，但相应的，解题逻辑比较难以想到；后续还可以用一些数学方法和二分搜索进一步优化第二种解法，不过看了看镜子中的发量，算了。</p>
<p>本文终，希望对你有一点启发。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典面试题：如何寻找最⻓回文子串</title>
    <url>/posts/afbd7c28/</url>
    <content><![CDATA[<h1 id="经典面试题：如何寻找最⻓回文子串"><a href="#经典面试题：如何寻找最⻓回文子串" class="headerlink" title="经典面试题：如何寻找最⻓回文子串"></a>经典面试题：如何寻找最⻓回文子串</h1><h2 id="预计阅读时间：5-分钟"><a href="#预计阅读时间：5-分钟" class="headerlink" title="预计阅读时间：5 分钟"></a>预计阅读时间：5 分钟</h2><p>回文串是面试常常遇到的问题（虽然问题本身没啥意义），本文就告诉你回文串问题的核心思想是什么。</p>
<p>首先，明确一下什：<strong>回文串就是正着读和反着读都一样的字符串</strong>。</p>
<p>比如说字符串<code>aba</code>和<code>abba</code>都是回文串，因为它们对称，反过来还是和本身一样。反之，字符串<code>abac</code>就不是回文串。</p>
<p>可以看到回文串的的长度可能是奇数，也可能是偶数，这就添加了回文串问题的难度，解决该类问题的核心是<strong>双指针</strong>。下面就通过一道最长回文子串的问题来具体理解一下回文串问题：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4lLwdm05DtOeOPia4eSQF3HJWKPuI6XXSumtytXXkvgQPwO1szjiaWicF84yMiaIwmFyRic4RmocZz3qvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string <span class="title function_">longestPalindrome</span><span class="params">(string s)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h3><p>对于这个问题，我们首先应该思考的是，给一个字符串<code>s</code>，如何在<code>s</code>中找到一个回文子串？</p>
<p>有一个很有趣的思路：既然回文串是一个正着反着读都一样的字符串，那么如果我们把<code>s</code>反转，称为<code>s&#39;</code>，然后在<code>s</code>和<code>s&#39;</code>中寻找<strong>最长公共子串</strong>，这样应该就能找到最长回文子串。</p>
<p>比如说字符串<code>abacd</code>，反过来是<code>dcaba</code>，它俩的最长公共子串是<code>aba</code>，也就是最长回文子串。</p>
<p>但是这个思路是错误的，比如说字符串<code>aacxycaa</code>，反转之后是<code>aacyxcaa</code>，最长公共子串是<code>aac</code>，但是最长回文子串应该是<code>aa</code>。</p>
<p>虽然这个思路不正确，但是<strong>这种把问题转化为其他形式的思考方式是非常值得提倡的</strong>。</p>
<p>下面，就来说一下正确的思路，如何使用双指针。</p>
<p><strong>寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串</strong>。对于最长回文子串，就是这个意思：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>但是呢，我们刚才也说了，回文串的长度可能是奇数也可能是偶数，如果是<code>abba</code>这种情况，没有一个中心字符，上面的算法就没辙了。所以我们可以修改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>PS：读者可能发现这里的索引会越界，等会会处理。</p>
<h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p>按照上面的思路，先要实现一个函数来寻找最长回文串，这个函数是有点技巧的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HpyEbX_20210507183744.png" alt="图片"></p>
<p>为什么要传入两个指针<code>l</code>和<code>r</code>呢？<strong>因为这样实现可以同时处理回文串长度为奇数和偶数的情况</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    # 找到以 s[i] 为中心的回文串</span><br><span class="line">    palindrome(s, i, i)</span><br><span class="line">    # 找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">    更新答案</span><br></pre></td></tr></table></figure>

<p>下面看下<code>longestPalindrome</code>的完整代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/VFGLHs_20210507183807.png" alt="图片"></p>
<p>至此，这道最长回文子串的问题就解决了，时间复杂度 O(N^2)，空间复杂度 O(1)。</p>
<p>值得一提的是，这个问题可以用动态规划方法解决，时间复杂度一样，但是空间复杂度至少要 O(N^2) 来存储 DP table。这道题是少有的动态规划非最优解法的问题。</p>
<p>另外，这个问题还有一个巧妙的解法，时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为没必要掌握。该算法的名字叫 Manacher’s Algorithm（马拉车算法），有兴趣的读者可以自行搜索一下。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>10、【对线面试官】TreadLocal</title>
    <url>/posts/2d4446ad/</url>
    <content><![CDATA[<h1 id="10、【对线面试官】TreadLocal"><a href="#10、【对线面试官】TreadLocal" class="headerlink" title="10、【对线面试官】TreadLocal"></a>10、【对线面试官】TreadLocal</h1><h2 id="今天要不来聊聊ThreadLocal吧？"><a href="#今天要不来聊聊ThreadLocal吧？" class="headerlink" title="今天要不来聊聊ThreadLocal吧？"></a>今天要不来聊聊ThreadLocal吧？</h2><ol>
<li>我个人对ThreadLocal理解就是</li>
<li>它能够提供了线程的局部变量让每个线程都可以通过set&#x2F;get来对这个局部变量进行操作</li>
<li>不会和其他线程的局部变量进行冲突，实现了线程的数据隔离</li>
</ol>
<h2 id="你在工作中有用到过ThreadLocal吗？"><a href="#你在工作中有用到过ThreadLocal吗？" class="headerlink" title="你在工作中有用到过ThreadLocal吗？"></a>你在工作中有用到过ThreadLocal吗？</h2><ol>
<li>这块是真不多，不过还是有一处的。就是我们项目有个的DateUtils工具类</li>
<li>这个工具类主要是对时间进行格式化</li>
<li>格式化&#x2F;转化的实现是用的SimpleDateFormat</li>
<li>但众所周知SimpleDateFormat不是线程安全的 ，所以我们就用ThreadLocal来让每个线程装载着自己的SimpleDateFormat对象</li>
<li>以达到在格式化时间时，线程安全的目的</li>
<li>在方法上创建SimpleDateFormat对象也没问题，但每调用一次就创建一次有点不优雅</li>
<li>在工作中ThreadLocal的应用场景确实不多，但要不我给你讲讲Spring是怎么用的？</li>
</ol>
<h2 id="spring中的应用"><a href="#spring中的应用" class="headerlink" title="spring中的应用"></a>spring中的应用</h2><ol>
<li>Spring提供了事务相关的操作，而我们知道事务是得保证一组操作同时成功或失败的</li>
<li>这意味着我们一次事务的所有操作需要在同一个数据库连接上</li>
<li>但是在我们日常写代码的时候是不需要关注这点的</li>
<li>Spring就是用的ThreadLocal来实现，Th readLocal存储的类型是一个Map</li>
<li>Map中的key是DataSource，value是C onnection（为了应对多数据源的情况，所以是一个Map）</li>
<li>用了ThreadLocal保证了同一个线程获取一个Connection对象，从而保证一次事务的所有操作需要在同一个数据库连接上</li>
</ol>
<h2 id="你知道ThreadLocal内存泄露这个知识点吗？"><a href="#你知道ThreadLocal内存泄露这个知识点吗？" class="headerlink" title="你知道ThreadLocal内存泄露这个知识点吗？"></a>你知道ThreadLocal内存泄露这个知识点吗？</h2><ol>
<li>了解的，要不我先来讲讲ThreadLocal的原理？<ul>
<li>ThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap这么个内部类</li>
<li>而有趣的是，ThreadLocalMap的引用是在Thread上定义的</li>
<li>ThreadLocal本身并不存储值，它只是作为key来让线程从ThreadLocalMap获取value</li>
<li>所以，得出的结论就是ThreadLocalMap该结构本身就在Thread下定义，而ThreadLocal只是作为key，存储set到ThreadLocalMap的变量当然是线程私有的咯</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NxSnnq_20211029171330.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>11、【对线面试官】CountDownLatch和CyclicBarrier</title>
    <url>/posts/58f7b356/</url>
    <content><![CDATA[<h1 id="11、【对线面试官】CountDownLatch和CyclicBarrier"><a href="#11、【对线面试官】CountDownLatch和CyclicBarrier" class="headerlink" title="11、【对线面试官】CountDownLatch和CyclicBarrier"></a>11、【对线面试官】CountDownLatch和CyclicBarrier</h1><h2 id="我现在有个场景：现在我有50个任务，这50个任务在完成之后，才能执行下一个「函数」，要是你，你怎么设计？"><a href="#我现在有个场景：现在我有50个任务，这50个任务在完成之后，才能执行下一个「函数」，要是你，你怎么设计？" class="headerlink" title="我现在有个场景：现在我有50个任务，这50个任务在完成之后，才能执行下一个「函数」，要是你，你怎么设计？"></a>我现在有个场景：现在我有50个任务，这50个任务在完成之后，才能执行下一个「函数」，要是你，你怎么设计？</h2><ol>
<li>可以用JDK给我们提供的线程工具类，CountDownLatch和CyclicBarrier都可以完成这个需求。</li>
<li>这两个类都可以等到线程完成之后，才去执行某些操作</li>
</ol>
<h2 id="那既然都能实现的话？那CountDownLatch和CyclicBarrier有什么什么区别呢？"><a href="#那既然都能实现的话？那CountDownLatch和CyclicBarrier有什么什么区别呢？" class="headerlink" title="那既然都能实现的话？那CountDownLatch和CyclicBarrier有什么什么区别呢？"></a>那既然都能实现的话？那CountDownLatch和CyclicBarrier有什么什么区别呢？</h2><ul>
<li>主要的区别就是CountDownLatch用完了，就结束了，没法复用。而CyclicBarrier不一样，它可以复用。</li>
<li>比如说，你得给我解释：CountDownLatch和CyclicBarrier都是线程同步的工具类<br>od</li>
<li>CountDownLatch允许一个或多个线程一直等待，直到这些线程完成它们的操作</li>
<li>而CyclicBarrier不一样，它往往是当线程到达某状态后，暂停下来等待其他线程等到所有线程均到达以后，才继续执行</li>
<li>可以发现这两者的等待主体是不一样的。</li>
<li>CountDownLatch调用await（）通常是主线程&#x2F;调用线程，而CyclicBarrier调用await（）是在任务线程调用的</li>
<li>所以，CyclicBarrier中的阻塞的是任务的线程，而主线程是不受影响的</li>
<li>简单叙述完这些基本概念后，可以特意抛出这两个类都是基于AQS实现的</li>
<li>countDownLatch<ol>
<li>前面提到了CountDownLatch也是基于AQS实现的，它的实现机制很简单</li>
<li>当我们在构建CountDownLatch对象时，传入的值其实就会赋值给AQS的关键变量state</li>
<li>执行countDown方法时，其实就是利用CAS将state-1<br>执行await方法时，其实就是判断state是否为0，不为0则加入到队列中，将该线程阻塞掉（除了头结点）</li>
<li>因为头节点会一直自旋等待state为0，当state为0时，头节点把剩余的在队列中阻塞的节点也一并唤醒</li>
</ol>
</li>
<li>CycllicBarrier<ol>
<li>从源码不难发现的是，它没有像CountDo wnLatch和ReentrantLock使用AQS的stat e变量，而CyclicBarrier是直接借助ReentrantLock加上Condition等待唤醒的功能进而实现的</li>
<li>在构建CyclicBarrier时，传入的值会赋值给CyclicBarrier内部维护count变量，也会赋值给parties变量（这是可以复用的关键）</li>
<li>每次调用await时，会将count-1，操作count值是直接使用ReentrantLock来保证线程安全性</li>
<li>如果count不为0，则添加则condition队列中</li>
<li>如果count等于0时，则把节点从condition队列添加至AQS的队列中进行全部唤醒，并且将parties的值重新赋值为count的值（实现复用）</li>
</ol>
</li>
</ul>
<h2 id="那如果是这样的话，那我多次用CountDownLatch不也可以解决问题吗？"><a href="#那如果是这样的话，那我多次用CountDownLatch不也可以解决问题吗？" class="headerlink" title="那如果是这样的话，那我多次用CountDownLatch不也可以解决问题吗？"></a>那如果是这样的话，那我多次用CountDownLatch不也可以解决问题吗？</h2><ol>
<li>是这样的，我提出了个场景，它确实很像可以用CountDownLatch和CyclicBarrier解决</li>
<li>但是，作为面试者的你可以尝试向我获取更多的信息</li>
<li>我可没说一个任务就用一个线程处理哦</li>
<li>放一步讲，即便我是想考察CountDownLatch和CyclicBarrier的知识，但是过程也是很重要的。我会看你在这个过程中思考的以及沟通</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>CountDownlatch基于AQS实现，会将构造CountDownLatch的入参传递至state，countDown（）就是在利用CAS将state减- 1，await（）实际就是让头节点一直在等待s tate为0时，释放所有等待的线程</li>
<li>而CyclicBarrier则利用ReentrantLock和Condition，自身维护了count和parties变量。每次调用await将count-1，并将线程加入到condition队列上。等到count为0时，则将condition队列的节点移交至AQS队列，并全部释放。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>12、【对线面试官】List</title>
    <url>/posts/31fa5cf/</url>
    <content><![CDATA[<h1 id="12、【对线面试官】List"><a href="#12、【对线面试官】List" class="headerlink" title="12、【对线面试官】List"></a>12、【对线面试官】List</h1><h2 id="要不今天来讲讲Java的List吧，你对List了解多少？"><a href="#要不今天来讲讲Java的List吧，你对List了解多少？" class="headerlink" title="要不今天来讲讲Java的List吧，你对List了解多少？"></a>要不今天来讲讲Java的List吧，你对List了解多少？</h2><ol>
<li>List在Java里边是一个接口，常见的实现类有ArrayList和LinkedList，在开发中用得最多的是ArrayList</li>
<li>ArrayList的底层数据结构是数组，Linked List底层数据结构是链表。</li>
</ol>
<h2 id="那Java本身就有数组了，为什么要用ArrayList呢？"><a href="#那Java本身就有数组了，为什么要用ArrayList呢？" class="headerlink" title="那Java本身就有数组了，为什么要用ArrayList呢？"></a>那Java本身就有数组了，为什么要用ArrayList呢？</h2><ol>
<li>原生的数组会有一个特点：你在使用的时候必须要为它创建大小，而ArrayList不用。</li>
<li>在日常开发的时候，往往我们是不知道要给数组分配多大（不固定）</li>
<li>如果数组的大小指定多了，内存浪费；如果数组大小指定少了，装不下。</li>
<li>假设我们给定数组的大小是10，要往这个数组里边填充元素，我们只能添加10个元素。</li>
<li>而ArrayList不一样，ArrayList我们在使用的时候可以往里边添加20个，30个，甚至更多的元素</li>
<li>因为ArrayList是实现了动态扩容的<ol>
<li>当我们new ArrayList（）的时候，默认会有一个空的Object数组，大小为0。</li>
<li>当我们第一次add添加数据的时候，会给这个数组初始化一个大小，这个大小默认值为10</li>
<li>使用ArrayList在每一次add的时候，它都会先去计算这个数组够不够空间</li>
<li>如果空间是够的，那直接追加上去就好了。如果不够，那就得扩容</li>
</ol>
</li>
</ol>
<h2 id="那怎么扩容？一次扩多少？"><a href="#那怎么扩容？一次扩多少？" class="headerlink" title="那怎么扩容？一次扩多少？"></a>那怎么扩容？一次扩多少？</h2><ol>
<li>在源码里边，有个grow方法，每一次扩原来的1.5倍。比如说，初始化的值是10嘛。</li>
<li>现在我第11个元素要进来了，发现这个数组的空间不够了，所以会扩到15</li>
<li>空间扩完容之后，会调用arraycopy来对数组进行拷贝</li>
</ol>
<h2 id="我又想问问，为什么你在前面提到，在日常开发中用得最多的是ArrayList呢？"><a href="#我又想问问，为什么你在前面提到，在日常开发中用得最多的是ArrayList呢？" class="headerlink" title="我又想问问，为什么你在前面提到，在日常开发中用得最多的是ArrayList呢？"></a>我又想问问，为什么你在前面提到，在日常开发中用得最多的是ArrayList呢？</h2><ol>
<li>是由底层的数据结构来决定的，在日常开发中，遍历的需求比增删要多，即便是增删也是往往在List的尾部添加就OK了。</li>
<li>像在尾部添加元素，ArrayList的时间复杂度也就O（1）</li>
<li>另外的是，ArrayList的增删底层调用的copyOf（）被优化过</li>
<li>现代CPU对内存可以块操作，ArrayList的增删一点儿也不会比LinkedList慢</li>
</ol>
<h2 id="了解，Vector你知道这个吗？"><a href="#了解，Vector你知道这个吗？" class="headerlink" title="了解，Vector你知道这个吗？"></a>了解，Vector你知道这个吗？</h2><ol>
<li>嗯，Vector是底层结构是数组，一般现在我们已经很少用了。</li>
<li>相对于ArrayList，它是线程安全的，在扩容的时候它是直接扩容两倍的</li>
<li>比如现在有10个元素，要扩容的时候，就会将数组的大小增长到20</li>
</ol>
<h2 id="嗯，那如果我们不用Vector，线程安全的List还有什么？"><a href="#嗯，那如果我们不用Vector，线程安全的List还有什么？" class="headerlink" title="嗯，那如果我们不用Vector，线程安全的List还有什么？"></a>嗯，那如果我们不用Vector，线程安全的List还有什么？</h2><ol>
<li>首先，我们也可以用Collections来将ArayList来包装一下，变成线程安全。&#96;</li>
<li>在java.util.concurrent包下还有一个类，叫做CopyOnWriteArrayList</li>
<li>要讲CopyOnWriteArrayList之前，我还是想说说copy-on-write这个意思，下面我会简称为cow</li>
<li>比如说在Linux中，我们知道所有的进程都是init进程fork出来的</li>
<li>除了进程号之外，fork出来的子进程，默认跟父进程是一模一样的。</li>
<li>当使用了cow机制；子进程在被fork之后exec之前，两个进程用的是相同的内存空间的</li>
<li>这意味着子进程的代码段、数据段、堆栈都是指向父进程的物理空间</li>
<li>当父子进程中有更改的行为发生时，再为子进程分配相应物理空间。</li>
<li>这样做的好处就是，等到真正发生修改的时候，才去分配资源，可以减少分配或者复制大量资源时带来的瞬间延时。</li>
<li>简单来说，就可以理解为我们的懒加载，或者说单例模式的懒汉式。等真正用到的时候再分配</li>
<li>在文件系统中，其实也有cow的机制。</li>
<li>文件系统的cow就是在修改数据的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改。</li>
<li>比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。</li>
<li>如果这时候断电了，原来A的内容还在。这样做的好处就是可以保证数据的完整性，瞬间挂掉了容易恢复。</li>
</ol>
<h2 id="你还是回到CopyOnWriteArrayList上吧；你说的cow机制我了解了"><a href="#你还是回到CopyOnWriteArrayList上吧；你说的cow机制我了解了" class="headerlink" title="你还是回到CopyOnWriteArrayList上吧；你说的cow机制我了解了"></a>你还是回到CopyOnWriteArrayList上吧；你说的cow机制我了解了</h2><ol>
<li>额。CopyOnWriteArrayList是一个线程安全的List，底层是通过复制数组的方式来实现的。</li>
<li>要不我来简单说说它的add（）方法的实现吧</li>
<li>在add（）方法的实现里，首先他会加lock锁锁住然后会复制出一个新的数组，往新的数组里边add真正的元素最后把 array的指向改变为新的数组</li>
<li>get（）方法又或是size（）方法只是获取array所指向的数组的元素或者大小</li>
<li>可以发现的是， CopyOnWriteArrayList</li>
<li>跟文件系统的COW机制是很像的</li>
</ol>
<h2 id="那你能说说CopyOnWriteArrayList有什么缺点吗？"><a href="#那你能说说CopyOnWriteArrayList有什么缺点吗？" class="headerlink" title="那你能说说CopyOnWriteArrayList有什么缺点吗？"></a>那你能说说CopyOnWriteArrayList有什么缺点吗？</h2><ol>
<li>很显然， CopyOnWriteArrayList是很耗费内存的，每次set（）add（）都会复制一个数组出来</li>
<li>另外就是 Copy On WriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性。</li>
<li>假设两个线程，线程A去读 CopyOnWri取 teArrayList的数据，还没读完</li>
<li>现在线程B把这个List给清空了，线程A此时还是可以把剩余的数据给读出来。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>13、【对线面试官】Map</title>
    <url>/posts/f78aff48/</url>
    <content><![CDATA[<h1 id="13、【对线面试官】Map"><a href="#13、【对线面试官】Map" class="headerlink" title="13、【对线面试官】Map"></a>13、【对线面试官】Map</h1><h2 id="今天来讲讲Map吧，你对Map了解多少？就讲JDK1-8就好咯"><a href="#今天来讲讲Map吧，你对Map了解多少？就讲JDK1-8就好咯" class="headerlink" title="今天来讲讲Map吧，你对Map了解多少？就讲JDK1.8就好咯"></a>今天来讲讲Map吧，你对Map了解多少？就讲JDK1.8就好咯</h2><ul>
<li>Map在Java里边是一个接口，常见的实现类有HashMap、 LinkedHashMap、TreeMap和ConcurrentHashMap</li>
</ul>
<ol>
<li>在Java里边，哈希表的实现由数组+链表所组成</li>
<li>HashMap底层数据结构是数组+链表&#x2F;红黑树</li>
<li>LinkedHashMap底层数据结构是数组+链表+双向链表</li>
<li>TreeMap底层数据结构是红黑树</li>
<li>而ConcurrentHashMap底层数据结构也是数组+链表&#x2F;红黑树</li>
</ol>
<h2 id="我们先以HashMap开始吧，你能讲讲当你new一个HashMap的时候，会发生什么吗？"><a href="#我们先以HashMap开始吧，你能讲讲当你new一个HashMap的时候，会发生什么吗？" class="headerlink" title="我们先以HashMap开始吧，你能讲讲当你new一个HashMap的时候，会发生什么吗？"></a>我们先以HashMap开始吧，你能讲讲当你new一个HashMap的时候，会发生什么吗？</h2><ol>
<li>如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75</li>
<li>还有就是：HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。</li>
<li>我们把元素放进HashMap的时候，需要算出这个元素所在的位置（hash）</li>
<li>在HashMap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置</li>
<li>为什么HashMap的大小只能是2次幂，因为只有大小为2次幂时，才能合理用位运算替代取模。</li>
<li>而负载因子的大小决定着哈希表的扩容和哈希冲突。</li>
<li>比如现在我默认的HashMap大小为16，负载因子为0.75，这意味着数组最多只能放12个元素，一旦超过12个元素，则哈希表需要扩容</li>
<li>怎么算出是12呢？很简单，就是16*0.7 5。每次put元素进去的时候，都会检查HashMap的大小有没有超过这个阈值，如果有，则需要扩容。</li>
<li>鉴于上面的说法（HashMap的大小只能是2次幂），所以扩容的时候时候默认是扩原来的2倍</li>
<li>还有就是扩容这个操作肯定是耗时的，那能不能把负载因子调高一点，比如我要调至为1，那我的HashMap就等到16个元素的时候才扩容呢。</li>
<li>当然是可以的，但是不推荐。负载因子调高了，这意味着哈希冲突的概率会增高，哈希冲突概率增高，同样会耗时（因为查找的速度变慢了）</li>
</ol>
<h2 id="算了。我还想继续问下，在put元素的时候，传递的Key是怎么算哈希值的？"><a href="#算了。我还想继续问下，在put元素的时候，传递的Key是怎么算哈希值的？" class="headerlink" title="算了。我还想继续问下，在put元素的时候，传递的Key是怎么算哈希值的？"></a>算了。我还想继续问下，在put元素的时候，传递的Key是怎么算哈希值的？</h2><ol>
<li>实现就在hash方法上，可以发现的是，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。</li>
<li>这样做的好处可以增加了随机性，减少了碰撞冲突的可能性。</li>
</ol>
<h2 id="你简单再说下put和get方法的实现吧"><a href="#你简单再说下put和get方法的实现吧" class="headerlink" title="你简单再说下put和get方法的实现吧"></a>你简单再说下put和get方法的实现吧</h2><ol>
<li>在put的时候，首先对key做hash运算，计算出该key所在的index。</li>
<li>如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。</li>
<li>假设key是相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小*负载因子），如果满了，则扩容</li>
<li>在get的时候，还是对key做hash运算，计算出该key所在的index，然后判断是否有hash冲突</li>
<li>假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。</li>
</ol>
<h2 id="那在HashMap中是怎么判断一个元素是否相同的呢？"><a href="#那在HashMap中是怎么判断一个元素是否相同的呢？" class="headerlink" title="那在HashMap中是怎么判断一个元素是否相同的呢？"></a>那在HashMap中是怎么判断一个元素是否相同的呢？</h2><ol>
<li>首先会比较hash值，随后会用&#x3D;&#x3D;运算符和equals（）来判断该元素是否相同。</li>
<li>说白了就是：如果只有hash值相同，那说明该元素哈希冲突了，如果hash值和equals（）|| &#x3D;&#x3D;都相同，那说明该元素是同个。</li>
</ol>
<h2 id="你说HashMap的数据结构是数组-链表-x2F-红黑树，那什么情况拿下才会用到红黑树呢？"><a href="#你说HashMap的数据结构是数组-链表-x2F-红黑树，那什么情况拿下才会用到红黑树呢？" class="headerlink" title="你说HashMap的数据结构是数组+链表&#x2F;红黑树，那什么情况拿下才会用到红黑树呢？"></a>你说HashMap的数据结构是数组+链表&#x2F;红黑树，那什么情况拿下才会用到红黑树呢？</h2><ol>
<li>当数组的大小大于64且链表的大小大于8的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。</li>
<li>这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量。</li>
<li>链表查询时间复杂度O（N），插入时间复杂度O（1），红黑树查询和插入时间复杂度O（logN）</li>
</ol>
<h2 id="你在日常开始中LinkedHashMap用的多吗？"><a href="#你在日常开始中LinkedHashMap用的多吗？" class="headerlink" title="你在日常开始中LinkedHashMap用的多吗？"></a>你在日常开始中LinkedHashMap用的多吗？</h2><ol>
<li>在前面也提到了，LinkedHashMap底层结构是数组+链表+双向链表，实际上它继承了HashMap，在HashMap的基础上维护了一个双向链表</li>
<li>有了这个双向链表，我们的插入可以是有序的，这里的有序不是指大小有序而是插入有序</li>
<li>LinkedHashMap在遍历的时候实际用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能</li>
</ol>
<h2 id="那TreeMap呢？"><a href="#那TreeMap呢？" class="headerlink" title="那TreeMap呢？"></a>那TreeMap呢？</h2><ol>
<li>TreeMap在现实开发中用得也不多，Tre eMap的底层数据结构是红黑树</li>
<li>TreeMap的key不能为null（如果为null，那还怎么排序呢），TreeMap有序是通过Comparator来进行比较的，如果comparator为null，那么就使用自然顺序</li>
</ol>
<h2 id="再来讲讲线程安全的Map吧？-HashMap是线程安全的吗？"><a href="#再来讲讲线程安全的Map吧？-HashMap是线程安全的吗？" class="headerlink" title="再来讲讲线程安全的Map吧？ HashMap是线程安全的吗？"></a>再来讲讲线程安全的Map吧？ HashMap是线程安全的吗？</h2><ol>
<li>HashMap不是线程安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如说：线程Aput进去了，线程Bget不出来。</li>
<li>想要线程安全，一般使用ConcurrentHashMap</li>
<li>ConcurrentHashMap是线程安全的Map 实现类，它在juc包下的。</li>
<li>线程安全的Map实现类除了ConcurrentHashMap还有一个叫做Hashtable。</li>
<li>当然了，也可以使用Collections来包装出一个线程安全的Map。</li>
<li>但无论是Hashtable还是Collections包装出来的都比较低效（因为是直接在外层套synchronize），所以我们一般有线程安全问题考量的，都使用ConcurrentHashMap</li>
<li>ConcurrentHashMap的底层数据结构是数组+链表&#x2F;红黑树，它能支持高并发的访问和更新，是线程安全的。</li>
<li>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。</li>
<li>在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁</li>
</ol>
<h2 id="嗯，你可以给我讲讲JDK7和JDK8中HashMap和ConcurrentHashMap的区别吗？"><a href="#嗯，你可以给我讲讲JDK7和JDK8中HashMap和ConcurrentHashMap的区别吗？" class="headerlink" title="嗯，你可以给我讲讲JDK7和JDK8中HashMap和ConcurrentHashMap的区别吗？"></a>嗯，你可以给我讲讲JDK7和JDK8中HashMap和ConcurrentHashMap的区别吗？</h2><ol>
<li>我在学习的时候也看过JDK7的HashMap和ConcurrentHashMap，其实还是有很多不一样的地方</li>
<li>比如JDK7的HashMap在扩容时是头插法，在JDK8就变成了尾插法，在JDK7的HashMap还没有引入红黑树</li>
<li>ConcurrentHashMap在JDK7还是使用分段锁的方式来实现，而JDK8就又不一样了。但JDK7细节我大多数都忘了。</li>
<li>我就没用过JDK7的API，我想着现在最低应该也是用JDK8了吧？所以我就没去仔细看了。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>14、【对线面试官】SpringMVC</title>
    <url>/posts/c2bf7fb6/</url>
    <content><![CDATA[<h1 id="14、【对线面试官】SpringMVC"><a href="#14、【对线面试官】SpringMVC" class="headerlink" title="14、【对线面试官】SpringMVC"></a>14、【对线面试官】SpringMVC</h1><h2 id="今天要不来聊聊SpringMVC吧？"><a href="#今天要不来聊聊SpringMVC吧？" class="headerlink" title="今天要不来聊聊SpringMVC吧？"></a>今天要不来聊聊SpringMVC吧？</h2><ol>
<li>我先简单说下我对SpringMVC的理解哈</li>
<li>SpringMVC我觉得它是对Servlet的封装，屏蔽掉Servlet很多的细节卫</li>
<li>接下来我举几个例子</li>
<li>可能我们刚学Servlet的时候，要获取参数需要不断的getParameter</li>
<li>现在只要在SpringMVC方法定义对应的J avaBean，只要属性名与参数名一致，SpringMVC就可以帮我们实现「将参数封装到JavaBean」上了</li>
<li>又比如，以前使用Servlet 「上传文件」，需要处理各种细节，写一大堆处理的逻辑（还得导入对应的jar）</li>
<li>现在一个在SpringMVC的方法上定义出MultipartFile接口，又可以屏蔽掉上传文件的细节了。</li>
<li>例子还有很多，我就不赘述了。</li>
</ol>
<h2 id="既然你说SpringMVC是对Servlet的封装，你了解SpringMVC请求处理的流程吗？"><a href="#既然你说SpringMVC是对Servlet的封装，你了解SpringMVC请求处理的流程吗？" class="headerlink" title="既然你说SpringMVC是对Servlet的封装，你了解SpringMVC请求处理的流程吗？"></a>既然你说SpringMVC是对Servlet的封装，你了解SpringMVC请求处理的流程吗？</h2><ol>
<li>总体流程大概是这样的<ul>
<li>首先有个统一处理请求的入口</li>
<li>随后根据请求路径找到对应的映射器</li>
<li>找到处理请求的适配器</li>
<li>4）：拦截器前置处理</li>
<li>5）：真实处理请求（也就是调用真正的代码）</li>
<li>6）：视图解析器处理</li>
<li>7）：拦截器后置处理</li>
</ul>
</li>
</ol>
<h2 id="嗯，了解，可以再稍微深入点吗？"><a href="#嗯，了解，可以再稍微深入点吗？" class="headerlink" title="嗯，了解，可以再稍微深入点吗？"></a>嗯，了解，可以再稍微深入点吗？</h2><ol>
<li>统一的处理入口，对应SpringMVC下的源码是在DispatcherServlet下实现的</li>
<li>该对象在初始化就会把映射器、适配器、视图解析器、异常处理器、文件处理器等等给初始化掉</li>
<li>至于会初始化哪些具体实例，看下DispatcherServlet.properties就知道了，都配置在那了</li>
<li>所有的请求其实都会被doService方法处理，里边最主要就是调用doDispatch方法</li>
<li>通过doDispatch方法我们就可以看到整个SpringMVC处理的流程</li>
<li>查找映射器的时候实际就是找到「最佳匹配」的路径，具体方法实现我记得好像是在lookupHandlerMethod方法上</li>
<li>从源码可以看到「查找映射器」实际返回的是HandlerExecutionChain，里边有映射器Handler+拦截器List</li>
<li>前面提到的拦截器前置处理和后置处理就是用的HandlerExecutionChain中的拦截器List</li>
<li>获取得到HandlerExecutionChain后，就会去获取适配器，一般我们获取得到的就是RequestMappingHandlerAdapter</li>
<li>在代码里边可以看到的是，经常用到的@ResponseBody和@Requestbody的解析器</li>
<li>就会在初始化的时候加到参数解析器List中</li>
<li>得到适配器之后，就会执行拦截器前置处理</li>
<li>拦截器前置处理执行完后，就会调用适配器对象实例的hanlde方法执行真正的代码逻辑处理</li>
<li>核心的处理逻辑在invokeAndHandle方法中，会获取得到请求的参数并调用，处理返回值</li>
<li>参数的封装以及处理会被适配器的参数解析器进行处理，具体的处理逻辑取决于HttpMessageConverter的实例对象</li>
</ol>
<h2 id="嗯，了解了。要不你再压缩下关键的信息"><a href="#嗯，了解了。要不你再压缩下关键的信息" class="headerlink" title="嗯，了解了。要不你再压缩下关键的信息"></a>嗯，了解了。要不你再压缩下关键的信息</h2><ol>
<li><p>DispatcherServlet （入口）</p>
</li>
<li><p>DispatcherServlet.properties（会初始化的对象）</p>
</li>
<li><p>HandlerMapping （映射器，</p>
</li>
<li><p>HandlerExecutionChain（映射器最终实例+拦截器List）</p>
</li>
<li><p>HttpRequestHandlerAdapter（适配器</p>
</li>
<li><p>HttpMessageConverter（数据转换</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ERUrGo_20211029183808.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>15、【对线面试官】Spring基础</title>
    <url>/posts/51360fe0/</url>
    <content><![CDATA[<h1 id="15、【对线面试官】Spring基础"><a href="#15、【对线面试官】Spring基础" class="headerlink" title="15、【对线面试官】Spring基础"></a>15、【对线面试官】Spring基础</h1><h2 id="要不你来讲讲Spring的IOC和AOP你是怎么理解的呗？"><a href="#要不你来讲讲Spring的IOC和AOP你是怎么理解的呗？" class="headerlink" title="要不你来讲讲Spring的IOC和AOP你是怎么理解的呗？"></a>要不你来讲讲Spring的IOC和AOP你是怎么理解的呗？</h2><ol>
<li>我个人理解下：SpringIOC解决的是对象管理和对象依赖的问题。</li>
<li>本来是我们自己手动new出来的对象，现在则把对象交给Spring的IOC容器管理</li>
<li>IOC容器可以理解为一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系</li>
<li>等我们需要用对象的时候，从工厂里边获取就好了</li>
</ol>
<h2 id="哦，你说的就是「控制反转」和「注入依赖」吧？"><a href="#哦，你说的就是「控制反转」和「注入依赖」吧？" class="headerlink" title="哦，你说的就是「控制反转」和「注入依赖」吧？"></a>哦，你说的就是「控制反转」和「注入依赖」吧？</h2><ol>
<li>我认为「控制反转」指的就是：把原有自己掌控的事交给别人去处理</li>
<li>它更多的是一种思想或者可以理解为设计模式</li>
<li>比如：本来由我们自己new出来的对象，现在交由IOC容器，把对象的控制权交给它方了.</li>
<li>而「依赖注入」在我的理解下，它其实是「控制反转」的实现方式</li>
<li>对象无需自行创建或者管理它的依赖关系，依赖关系将被「自动注入」到需要它们的对象当中去</li>
</ol>
<h2 id="嗯，那我想问问，用SpringIOC有什么好处吗？"><a href="#嗯，那我想问问，用SpringIOC有什么好处吗？" class="headerlink" title="嗯，那我想问问，用SpringIOC有什么好处吗？"></a>嗯，那我想问问，用SpringIOC有什么好处吗？</h2><h2 id="或者换个问法：本来我可以new出来的对象，为什么我要交由Spring-IOC容器管理呢？"><a href="#或者换个问法：本来我可以new出来的对象，为什么我要交由Spring-IOC容器管理呢？" class="headerlink" title="或者换个问法：本来我可以new出来的对象，为什么我要交由Spring IOC容器管理呢？"></a>或者换个问法：本来我可以new出来的对象，为什么我要交由Spring IOC容器管理呢？</h2><ol>
<li>主要的好处在于「将对象集中统一管理」并且「降低耦合度」</li>
<li>如果面试官理解了「工厂模式」，那就知道为什么我们不直接new对象</li>
<li>要说理由的话，可以举很多例子，比如说：</li>
<li>我用SpringIOC可以方便单元测试、对象创建复杂、对象依赖复杂、单例等等的，什么都可以交给Spring IOC</li>
<li>理论上自己new出来的都可以解决上面的问题，Spring在各种场景组合下有可能不是最优解</li>
<li>但new出来的你要自己管理，可能你得自己写工厂，得实现一大套的东西才能满足需求</li>
<li>写着写着有可能还是Spring的那一套</li>
<li>但现在Spring现在已经帮你实现了啊！</li>
<li>如果项目里的对象都是就new下就完事了，没有多个实现类，那没事，不用Spring也没啥问题</li>
<li>并且Spring核心不仅仅IOC啊，除了把对象创建出来，还有一整套的Bean生命周期管理</li>
<li>比如说你要实现对象增强，AOP不就有了吗？不然你还得自己创建代理</li>
</ol>
<h2 id="那你继续来聊下Spring-AOP呗？"><a href="#那你继续来聊下Spring-AOP呗？" class="headerlink" title="那你继续来聊下Spring AOP呗？"></a>那你继续来聊下Spring AOP呗？</h2><ol>
<li>Spring AOP解决的是非业务代码抽取的问题</li>
<li>AOP底层的技术是动态代理，在Spring 内实现依赖的是BeanPostProcessor</li>
<li>比如我们需要在方法上注入些「重复性」的非业务代码，就可以利用Spring AOP</li>
<li>所谓的「面向切面编程」在我理解下其实就是在方法前后增加非业务代码</li>
</ol>
<h2 id="那你在工作中实际用到过AOP去优化你的代码吗？"><a href="#那你在工作中实际用到过AOP去优化你的代码吗？" class="headerlink" title="那你在工作中实际用到过AOP去优化你的代码吗？"></a>那你在工作中实际用到过AOP去优化你的代码吗？</h2><ol>
<li>·有的。当时我用AOP来对我们公司现有的监控客户端进行封装</li>
<li>一个系统离不开监控，监控基本的指标有QPS、RT、ERROR等等</li>
<li>对外暴露的监控客户端只能在代码里写对应的上报信息（灵活，但会与业务代码掺杂在一起）</li>
<li>于是我利用注解+AOP的方式封装了一把，只要方法&#x2F;类上带有我自定义的注解</li>
<li>方法被调用时，就会上报AQS、RT等信息实现了非业务代码与业务代码分离的效果</li>
</ol>
<h2 id="了解，你们项目一般是怎么把对象交给IOC容器管理的？"><a href="#了解，你们项目一般是怎么把对象交给IOC容器管理的？" class="headerlink" title="了解，你们项目一般是怎么把对象交给IOC容器管理的？"></a>了解，你们项目一般是怎么把对象交给IOC容器管理的？</h2><h2 id="换个问法：一般是怎么定义Bean的？"><a href="#换个问法：一般是怎么定义Bean的？" class="headerlink" title="换个问法：一般是怎么定义Bean的？"></a>换个问法：一般是怎么定义Bean的？</h2><ol>
<li>Spring提供了4种方式，分别是：<br>1）：注解2）：XML3）：JavaConfig 4）：基于Groovy 的DSL配置</li>
<li>一般项目我们用注解或XML比较多，少部分用JavaConfig</li>
<li>日常写业务代码一般用注解来定义各种对象，责任链这种一般配置在XML「注解」解决不了的就用JavaConfig</li>
<li>总体而言，还是得看项目的代码风格吧</li>
<li>反正就是定义元数据，能给到Spring解析就好了</li>
</ol>
<h2 id="要不来聊聊你使用Spring的感受？"><a href="#要不来聊聊你使用Spring的感受？" class="headerlink" title="要不来聊聊你使用Spring的感受？"></a>要不来聊聊你使用Spring的感受？</h2><ol>
<li>当我还是初学Spring的时候，我觉得Spring很麻烦，需要有一大堆的配置信息才能跑起来</li>
<li>光是搭建环境就需要耗费我好长的时间</li>
<li>毕竟版本冲突，依赖冲突什么的就可能个下午就过去了</li>
<li>但毕竟一个系统环境只搭一次嘛，所以还好（后来用上了SpringBoot这又更方便了）</li>
<li>回来，IOC和AOP在工作用的时候还是很爽的</li>
<li>毕竟搞个注解什么的，配置下就可以把对象交给Spring管理了</li>
<li>配合Spring的生态，@Transactional注解什么的，都好用得飞起</li>
<li>不过，Spring给我们封装得太好了</li>
<li>经常就会有奇奇怪怪的”bug”出现，也踩过很多的坑了</li>
<li>Bean经常没办法创建成功，导致项目启动失败..</li>
<li>对象的循环依赖问题.</li>
<li>同一个接口，多个实现，识别不出我要创建哪个对象.</li>
<li>为什么catch了异常，Spring事务为什么还会自动回滚..</li>
<li>等等等</li>
</ol>
<h2 id="循环以来"><a href="#循环以来" class="headerlink" title="循环以来"></a>循环以来</h2><ol>
<li><p>到这里，Spring整个解决循环依赖问题的实现思路已经比较清楚了。对于整体过程，读者朋友只要理解两点：</p>
<ul>
<li>Spring是通过递归的方式获取目标bean及其所依赖的bean的；</li>
<li>Spring实例化一个bean的时候，是分两步进行的，首先实例化目标bean，然后为其注入属性。</li>
</ul>
<p>结合这两点，也就是说，Spring在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>16、【对线面试官】SpringBean生命周期</title>
    <url>/posts/32e97c2c/</url>
    <content><![CDATA[<h1 id="16、【对线面试官】SpringBean生命周期"><a href="#16、【对线面试官】SpringBean生命周期" class="headerlink" title="16、【对线面试官】SpringBean生命周期"></a>16、【对线面试官】SpringBean生命周期</h1><h2 id="今天要不来聊聊Spring对Bean的生命周期管理？"><a href="#今天要不来聊聊Spring对Bean的生命周期管理？" class="headerlink" title="今天要不来聊聊Spring对Bean的生命周期管理？"></a>今天要不来聊聊Spring对Bean的生命周期管理？</h2><ol>
<li>嗯，没问题的。</li>
<li>很早之前我就看过源码，但Spring源码的实现类都太长了</li>
<li>我也记不得很清楚某些实现类的名字</li>
<li>要不我大概来说下流程？</li>
<li>首先要知道的是：普通Java对象和Spring.所管理的Bean实例化的过程是有些区别的<br>在普通Java环境下创建对象简要的步骤可以分为以下几步：<ul>
<li>java源码被编译为被编译为class文件</li>
<li>等到类需要被初始化时（比如说new、反射等）</li>
<li>class文件被虚拟机通过类加载器加载到JVM</li>
<li>初始化对象供我们使用</li>
</ul>
</li>
<li>简单来说，可以理解为它是用Class对象作为「模板」进而创建出具体的实例</li>
<li>而Spring所管理的Bean不同的是，除了Class.对象之外，还会使用BeanDefinition的实例来描述对象的信息</li>
<li>比如说，我们可以在Spring.所管理的Bean有一系列的描述：@Scope、@Lazy、@DependsOn等等</li>
<li>可以理解为：Class只描述了类的信息，而BeanDefinition：描述了对象的信息</li>
</ol>
<h2 id="你就是想告诉我，Spring有BeanDefinition来存储着我们日常给Spring-Bean定义的元数据（-Scope、-Lazy、-DependsOn等等），对吧？"><a href="#你就是想告诉我，Spring有BeanDefinition来存储着我们日常给Spring-Bean定义的元数据（-Scope、-Lazy、-DependsOn等等），对吧？" class="headerlink" title="你就是想告诉我，Spring有BeanDefinition来存储着我们日常给Spring Bean定义的元数据（@Scope、@Lazy、@DependsOn等等），对吧？"></a>你就是想告诉我，Spring有BeanDefinition来存储着我们日常给Spring Bean定义的元数据（@Scope、@Lazy、@DependsOn等等），对吧？</h2><ol>
<li>Spring在启动的时候需要「扫描」在XML&#x2F;注解&#x2F;JavaConfig中需要被Spring管理的Bean信息</li>
<li>随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中</li>
<li>我记得这个Map的key应该是beanName，value则是BeanDefinition.对象</li>
<li>到这里其实就是把定义的元数据加载起来，目前真实对象还没实例化</li>
<li>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑</li>
<li>比如说，我们平时定义的占位符信息，就是通过BeanFactoryPostProcessor的子类PropertyPlaceholderConfigurer进行注入进去</li>
<li>当然了，这里我们也可以自定义BeanFactoryPostProcessor来对我们定义好的Bean元数据进行获取或者修改。只是一般我们不会这样干，实际上也很有少的使用场景。</li>
<li>BeanFactoryPostProcessor&#x2F;后置处理器执行完了以后，就到了实例化对象啦</li>
<li>在Spring.里边是通过反射来实现的，一般情况下会通过反射选择合适的构造器来把对象实例化</li>
<li>但这里把对象实例化，只是把对象给创建出来，而对象具体的属性是还没注入的。</li>
<li>比如我的对象是UserService，而UserService对象依赖着SendService对象，这时候的SendService还是null的</li>
<li>所以，下一步就是把对象的相关属性给注入</li>
<li>相关属性注入完之后，往下接着就是初始化的工作了</li>
<li>首先判断该Bean是否实现了Aware相关的接口，如果存在则填充相关的资源<br>比如我这边在项目用到的：我希望通过代码程序的方式去获取指定的Spring Bean</li>
<li>我们这边会抽取成一个工具类，去实现ApplicationContextAware接口，来获取ApplicationContexti对象进而获取Spring Bean</li>
<li>Aware相关的接口处理完之后，就会到BeanPostProcessor后置处理器啦</li>
<li>BeanPostProcessor后置处理器有两个方法，一个是before，一个是after。<br>（那肯定是before先执行、after）后执行）</li>
<li>这个BeanPostProcessor）后置处理器是AOP实现的关键<br>关键子类AnnotationAwareAspectJAutoProxyCreator</li>
<li>所以，执行完Aware相关的接口就会执行，BeanPostProcessor相关子类的before方法。</li>
<li>BeanPostProcessor相关子类的before方法执行完，则执行init相关的方法，比如说@PostConstruct、实现了InitializingBean接口、定义的init-method方法</li>
<li>当时我还去官网去看他们的被调用「执行顺序」分别是：@PostConstruct、实现了InitializingBean：接口以及init-nethod方法</li>
<li>这些都是Spring：给我们的「扩展」，像@PostConstruct我就经常用到</li>
<li>比如说：对象实例化后，我要做些初始化的相关工作或者就启个线程去Kafka拉取数据</li>
<li>等到init方法执行完之后，就会执行BeanPostProcessor的after方法</li>
<li>基本重要的流程已经走完了，我们就可以获取到对象去使用了</li>
<li>销毁的时候就看有没有配置相关的destroy方法，执行就完事了</li>
</ol>
<h2 id="你看过Spring：是怎么解决循环依赖的吗？如果现在有个A对象，它的属性是B对象，而B对象的属性也是A对象说白了就是A依赖B，而B又依赖A，Spring是怎么做的？"><a href="#你看过Spring：是怎么解决循环依赖的吗？如果现在有个A对象，它的属性是B对象，而B对象的属性也是A对象说白了就是A依赖B，而B又依赖A，Spring是怎么做的？" class="headerlink" title="你看过Spring：是怎么解决循环依赖的吗？如果现在有个A对象，它的属性是B对象，而B对象的属性也是A对象说白了就是A依赖B，而B又依赖A，Spring是怎么做的？"></a>你看过Spring：是怎么解决循环依赖的吗？如果现在有个A对象，它的属性是B对象，而B对象的属性也是A对象说白了就是A依赖B，而B又依赖A，Spring是怎么做的？</h2><ol>
<li>从上面我们可以知道，对象属性的注入在对象实例化之后的嘛。</li>
<li>它的大致过程是这样的：首先A对象实例化，然后对属性进行注入，发现依赖B对象<br>B对象此时还没创建出来，所以转头去实例化B对象</li>
<li>B对象实例化之后，发现需要依赖A对象，那A对象已经实例化了嘛，所以B对<br>象最终能完成创建</li>
<li>B对象返回到A对象的属性注入的方法上，A对象最终完成创建。这就是大致的过程。</li>
</ol>
<h2 id="哦？听起来你还会原理哦？"><a href="#哦？听起来你还会原理哦？" class="headerlink" title="哦？听起来你还会原理哦？"></a>哦？听起来你还会原理哦？</h2><ol>
<li>至于原理，其实就是用到了三级的缓存</li>
<li>所谓的三级缓存其实就是三个Map.…首先明确一定，我对这里的三级缓存定义是这样的：<br>singletonObjects（一级，日常实际获取Bean的地方）；</li>
<li>earlySingletonObjects（二级，已实例化，但还没进行属性注入，由三级缓存放进来）；</li>
<li>singletonFactories（三级，Value：是一个对象工厂）；</li>
<li>再回到刚才讲述的过程中，A对象实例化之后，属性注入之前，其实会把A对象放入三级缓存中</li>
<li>key是BeanName，Value：是ObjectFactory</li>
<li>等到A对象属性注入时，发现依赖B，又去实例化B时</li>
<li>B属性注入需要去获取A对象，这里就是从三级缓存里拿出ObjectFactory，从ObjectFactory得到对应的Bean（就是对象A)</li>
<li>把三级缓存的A记录给干掉，然后放到二级缓存中</li>
<li>显然，二级缓存存储的key是BeanName，value就是Bean（这里的Bean还没做完属性注入相关的工作）</li>
<li>等到完全初始化之后，就会把二级缓存给remove掉，塞到一级缓存中</li>
<li>我们自己去getBean的时候，实际上拿到的是一级缓存的</li>
<li>大致的过程就是这样</li>
</ol>
<h2 id="那我想问一下，为什么是三级缓存？"><a href="#那我想问一下，为什么是三级缓存？" class="headerlink" title="那我想问一下，为什么是三级缓存？"></a>那我想问一下，为什么是三级缓存？</h2><ol>
<li>首先从第三级缓存说起（就是key是BeanName，Value为ObjectFactory）</li>
<li>我们的对象是单例的，有可能A对象依赖的B对象是有AOP的（B对象需要代理）</li>
<li>假设没有第三级缓存，只有第二级缓存（Value存对象，而不是工厂对象）</li>
<li>那如果有AOP的情况下，岂不是在存入第二级缓存之前都需要先去做AOP代理？这不合适嘛</li>
<li>这里肯定是需要考虑代理的情况的，比如A对象是一个被AOP增量的对象，B依赖A时，得到的A肯定是代理对象的</li>
<li>所以，三级缓存的Value是ObjectFactory，可以从里边拿到代理对象</li>
<li>而二级缓存存在的必要就是为了性能，从三级缓存的工厂里创建出对象，再扔到二级缓存（这样就不用每次都要从工厂里拿）</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>首先是Spring Bean的生命周期过程，Sprng使用BeanDefinition：来装载着我们给Bean定义的元数据</p>
</li>
<li><p>实例化Bean的时候会遍历BeanDefinitionMap</p>
</li>
<li><p>Springl的Bean实例化和属性赋值是分开两步来做的</p>
</li>
<li><p>在Spring Beanl的生命周期，Spring预留了很多的hook给我们去扩展</p>
<p>1）：Bean实例化之前有BeanFactoryPostProcessor<br>2）：Bean实例化之后，初始化时，有相关的Aware接口供我们去拿到Context相关信息<br>3）：环绕着初始化阶段，有BeanPostProcessor（AOP的关键）<br>4）：在初始化阶段，有各种的init方法供我们去自定义</p>
</li>
<li><p>而循环依赖的解决主要通过三级的缓存</p>
</li>
<li><p>在实例化后，会把自己扔到三级缓存（此时的key是BeanName，Value是ObjectFactory)</p>
</li>
<li><p>在注入属性时，发现需要依赖B，也会走B的实例化过程，B属性注入依赖A，从三级缓存找到A</p>
</li>
<li><p>删掉三级缓存，放到二级缓存</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/q5B8nQ_20211228115227.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/ldYlbE_20211228115337.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/czgjnh_20211228115425.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>17、【对线面试官】Redis基础</title>
    <url>/posts/36f701ea/</url>
    <content><![CDATA[<h1 id="17、【对线面试官】Redis基础"><a href="#17、【对线面试官】Redis基础" class="headerlink" title="17、【对线面试官】Redis基础"></a>17、【对线面试官】Redis基础</h1><h2 id="你先来讲讲为什么要用Redis吧？"><a href="#你先来讲讲为什么要用Redis吧？" class="headerlink" title="你先来讲讲为什么要用Redis吧？"></a>你先来讲讲为什么要用Redis吧？</h2><ol>
<li>我个人是这样理解的：无论Redis也好、MySQL也好、HDFS也好、HBase也好</li>
<li>他们都是存储数据的地方</li>
<li>因为它们的设计理念的不同，我们会根据不同的应用场景使用不同的存储</li>
<li>像Redis一般我们会把它用作于缓存</li>
<li>当然啦，日常有的应用场景比较简单，用个HashMap也能解决很多的问题了，没必要上Redis</li>
<li>这就好比，有的单机限流可能应对某些场景就够用了，也没必要说一定要上分布式限流把系统搞得复杂</li>
</ol>
<h2 id="那你在项目里有用到Redis吗？怎么用的？"><a href="#那你在项目里有用到Redis吗？怎么用的？" class="headerlink" title="那你在项目里有用到Redis吗？怎么用的？"></a>那你在项目里有用到Redis吗？怎么用的？</h2><ol>
<li>Redis肯定是用到的，我负责的项目几乎都会有Redisl的踪影</li>
<li>我举几个我这边项目用的案例呗？</li>
<li>我这边负责消息管理平台，简单来说就是发消息的</li>
<li>那发完消息肯定我们是得知道消息有没有下发成功的，是吧？</li>
<li>于是我们系统有一套完整的链路追踪体系</li>
<li>其中实时的数据我们就用Redis来进行存储，有实时肯定就会有离线的嘛（离线的数据我们是存储到Hive的）</li>
<li>对消息进行实时链路追踪，我这边就用了Redis好几种的数据结构，分别有Set、List和Hash</li>
<li>我再稍微铺垫下链路追踪的背景吧~</li>
<li>要在消息管理平台发消息，首先得在后台新建一个「模板」，有模板自然会有一个模板ID</li>
<li>对模板D进行扩展，比如说加上日期和固定的业务参数，形成的ID可以唯一标识某个模板的下发链路</li>
<li>在系统上，我这边叫它为UMPID</li>
<li>在发送入口处会对所有需要下发的消息打上UMPID，然后在关键链路上打上对应的点位</li>
<li>接下来的工作就是清洗出统一的模型，然后根据不同维度进行处理啦。比如说：</li>
<li>我要看某一天下发的所有模板有哪些，那只要我把清洗出来后数据的，将对应UMPID扔到了Set就好了</li>
<li>我要看某一个模板的消息下发的整体链路情况，那我以UMPID为Key，Value是Hash结构，Key是state，Value则是人数</li>
<li>这里的state我们在下发的过程中打的关键点位，比如接收到消息打个51，消息被去重了打个61，消息成功下发了打个81…</li>
<li>以UMPID为Key，Hash结构的Key（State）进行不断的累加，就可以实现某一个模板的消息下发的整体链路情况</li>
<li>我要看某个用户当天下发的消息有哪些，以及这些消息的整体链路是如何。</li>
<li>这边我用的是List结构，Key是userld，Value则是UMPID+state（关键点位）+processTime（处理时间）</li>
</ol>
<ul>
<li>简单来说，就是通过Redis丰富的数据结构来实现对下发消息多个维度的统计</li>
<li>不同的应用场景选择不同的数据结构，再等到透出做处理的时候，就变得十分简单了</li>
<li>消息下发过程中去重或者一般正常的场景就直接Key-Value就能符合需求了</li>
<li>像bitmap、hyperloglogs、sortset、steam等等这些数据结构在我所负责的项目用得是真不多</li>
<li>要是我有机会去到贵公司，贵公司有相关的应用场景，我相信我也很快就能掌握</li>
<li>这些数据结构底层都由对应的object来支撑着，objecti记录对应的「编码」</li>
<li>其实就是会根据key-value存储的数量或者长度来使用选择不同的底层数据结构实现</li>
<li>比如说：ziplist压缩列表这个底层数据结构有可能上层的实现是list、hash和sortset</li>
<li>Hash结构的底层数据结构可能是hash和ziplist</li>
<li>在节省内存和性能的考量之中切换,Redis还是有点屌的啊。</li>
</ul>
<h2 id="就你上面那个实时链路场景，可以用其他的存储替代吗？"><a href="#就你上面那个实时链路场景，可以用其他的存储替代吗？" class="headerlink" title="就你上面那个实时链路场景，可以用其他的存储替代吗？"></a>就你上面那个实时链路场景，可以用其他的存储替代吗？</h2><ol>
<li>嗯，理论上是可以的（或许可以尝试用HBase），但总体来说没这么好吧</li>
<li>因为Redis拥有丰富的数据结构，在透出的时候，处理会非常的方便。</li>
<li>如果不用Redis的话，还得做很多解析的工作</li>
<li>并且，我那场景的并发还是相当大的（就一条消息发送，可能就产生10条记录）</li>
<li>监控峰值命令处理数会去到20K+QPS，当然了，这场景我肯定用了Pipeline的（不然处理会慢很多）</li>
<li>综合上面并发量和实时性以及数据结构，用Redis：是一个比较好的选择。</li>
</ol>
<h2 id="你觉得为什么Redis可以这么快？"><a href="#你觉得为什么Redis可以这么快？" class="headerlink" title="你觉得为什么Redis可以这么快？"></a>你觉得为什么Redis可以这么快？</h2><ol>
<li>首先，它是纯内存操作，内存本身就很快</li>
<li>其次，它是单线程的，Redis服务器核心是基于非阻塞的O多路复用机制，单线程避免了多线程的频繁上下文切换问题</li>
<li>至于这个单线程，其实官网也有过说明（：表示使用Redis往往的瓶颈在于内与和网络，而不在于CPU</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>18、【对线面试官】Redis持久化</title>
    <url>/posts/eb97ef3e/</url>
    <content><![CDATA[<h1 id="18、【对线面试官】Redis持久化"><a href="#18、【对线面试官】Redis持久化" class="headerlink" title="18、【对线面试官】Redis持久化"></a>18、【对线面试官】Redis持久化</h1><h2 id="嗯，开始吧，今天要不来聊聊Redisl的持久化机制吧？"><a href="#嗯，开始吧，今天要不来聊聊Redisl的持久化机制吧？" class="headerlink" title="嗯，开始吧，今天要不来聊聊Redisl的持久化机制吧？"></a>嗯，开始吧，今天要不来聊聊Redisl的持久化机制吧？</h2><ol>
<li><p>在上一次面试已经说过了Redis：是基于内存的</p>
</li>
<li><p>假设我们不做任何操作，只要Redis服务器重启（或者中途故障挂掉了），那内存的数据就会没掉</p>
</li>
<li><p>所以Redis：提供了持久化机制给我们用，分别是RDB和AOF</p>
<p>1）RDB指的就是：根据我们自己配置的时间或者手动去执行BGSAVE或SAVE命令，Redisi就会去生成RDB文件</p>
<p>2）这个RDB文件实际上就是一个经过压缩的二进制文件，Redis可以通过这个文件在启动的时候来还原我们的数据</p>
<p>1）而AOF则是把Redis服务器接收到的所有写命令都记录到日志中</p>
<p>2）Redis重跑一遍这个记录下的日志文件，就相当于还原了数据</p>
</li>
</ol>
<h2 id="那我就想问了，你上次不是说Redis是单线程吗？那比如你说的RDB，它会执行SAVE或BESAVE命令，生成文件。那不是非常耗时的吗，那如果只有一个线程处理，那其他的请求不就得等了？"><a href="#那我就想问了，你上次不是说Redis是单线程吗？那比如你说的RDB，它会执行SAVE或BESAVE命令，生成文件。那不是非常耗时的吗，那如果只有一个线程处理，那其他的请求不就得等了？" class="headerlink" title="那我就想问了，你上次不是说Redis是单线程吗？那比如你说的RDB，它会执行SAVE或BESAVE命令，生成文件。那不是非常耗时的吗，那如果只有一个线程处理，那其他的请求不就得等了？"></a>那我就想问了，你上次不是说Redis是单线程吗？那比如你说的RDB，它会执行SAVE或BESAVE命令，生成文件。那不是非常耗时的吗，那如果只有一个线程处理，那其他的请求不就得等了？</h2><ol>
<li>嗯，没错，Redis是单线程的。</li>
<li>以RDB持久化的过程为例，假设我们在配置上是定时去执行RDB存储</li>
<li>Redis有自己的一套事件处理机制，主要处理文件事件（命令请求和应答等等）和时间事件（RDB定时持久化、清理过期的Key等的）</li>
<li>所以，定时的RDB实际上就是一个时间事件</li>
<li>线程不停地轮询就绪的事件，发现RDB的事件可执行时，则调用BGSAVE命令</li>
<li>而BGSAVE命令实际上会fork出一个子进程来进行完成持久化（生成RDB文件）</li>
<li>在fork的过程中，父进程（主线程）肯定是阻塞的。</li>
<li>但fork完之后，是fork出来的子进程去完成持久化。处理请求的进程该干嘛的就干嘛</li>
<li>所以说啊，Redis：是单线程，理解是没错的，但没说人家不能fork进程来处理事情。</li>
<li>还有就是，其实Redis在较新的版本中，有些地方都使用了多线程来进行处理</li>
<li>比如说，一些删除的操作（UNLINK、FLUSHALL ASYNC等等）还有Redis6.x之后对网络数据的解析都用了多线程处理了。</li>
<li>只不过，核心的处理命令请求和响应还是单线程。</li>
</ol>
<h2 id="那AOF呢？AOF不是也要写文件吗？难道也是fork了个子进程去做的？"><a href="#那AOF呢？AOF不是也要写文件吗？难道也是fork了个子进程去做的？" class="headerlink" title="那AOF呢？AOF不是也要写文件吗？难道也是fork了个子进程去做的？"></a>那AOF呢？AOF不是也要写文件吗？难道也是fork了个子进程去做的？</h2><ol>
<li>emm，不是的。AOF是在命令执行完之后，把命令写在buffer缓冲区的（直接追加写）</li>
<li>那想要持久化，肯定得存盘嘛。Redis：提供了几种策略供我们选择什么时候把缓冲区的数据写到磁盘</li>
<li>我记得好像有：每秒一次&#x2F;每条命令都执行从不存盘；一般我们会选每秒一次</li>
<li>Redis会启一个线程去刷盘，也不是用主线程去干的</li>
</ol>
<h2 id="那如果把执行过的命令都存起来；等启动的时候是可以再把这些写命令再执行一遍，达到恢复数据的效果；这样会有什么样的问题吗？"><a href="#那如果把执行过的命令都存起来；等启动的时候是可以再把这些写命令再执行一遍，达到恢复数据的效果；这样会有什么样的问题吗？" class="headerlink" title="那如果把执行过的命令都存起来；等启动的时候是可以再把这些写命令再执行一遍，达到恢复数据的效果；这样会有什么样的问题吗？"></a>那如果把执行过的命令都存起来；等启动的时候是可以再把这些写命令再执行一遍，达到恢复数据的效果；这样会有什么样的问题吗？</h2><ol>
<li>嗯，问题就是，如果这些写入磁盘的「命令集合」不做任何处理，那该「命令集合」就会一直膨胀</li>
<li>其实就是该文件会变得非常大</li>
<li>Redis当然也考虑了这一点，它会fork个子进程会对「原始」命令集合进行重写</li>
<li>说白了就是会压缩，压缩完了之后只要替换原始文件就好了</li>
</ol>
<h2 id="那我又想问了，既然它是fork一个进程来对AOF进行重写的；前面你也提到了再fork时，主进程是阻塞的，但fork后，主进程会继续接收命令；你是说重写完（压缩）会进行文件覆盖；那这样不会丢数据吗？毕竟主进程在fork之后是一直会接收命令的"><a href="#那我又想问了，既然它是fork一个进程来对AOF进行重写的；前面你也提到了再fork时，主进程是阻塞的，但fork后，主进程会继续接收命令；你是说重写完（压缩）会进行文件覆盖；那这样不会丢数据吗？毕竟主进程在fork之后是一直会接收命令的" class="headerlink" title="那我又想问了，既然它是fork一个进程来对AOF进行重写的；前面你也提到了再fork时，主进程是阻塞的，但fork后，主进程会继续接收命令；你是说重写完（压缩）会进行文件覆盖；那这样不会丢数据吗？毕竟主进程在fork之后是一直会接收命令的"></a>那我又想问了，既然它是fork一个进程来对AOF进行重写的；前面你也提到了再fork时，主进程是阻塞的，但fork后，主进程会继续接收命令；你是说重写完（压缩）会进行文件覆盖；那这样不会丢数据吗？毕竟主进程在fork之后是一直会接收命令的</h2><ol>
<li>其实做法很简单啊，在fork子进程之后，把新接收到命令再写到另一个缓冲区不就好了吗</li>
</ol>
<h2 id="那AOF和RDB用哪一个呢？"><a href="#那AOF和RDB用哪一个呢？" class="headerlink" title="那AOF和RDB用哪一个呢？"></a>那AOF和RDB用哪一个呢？</h2><ol>
<li>主要是看业务场景吧，我们这边是基于Redis使用了一套开源的key-value存储</li>
<li>使用Redis前，首先要去新增实例，在新增时会让你选择对应的使用场景</li>
<li>就是会让你通过不同的应用场景进行配置选择</li>
<li>比如说，业务上是允许重启时部分数据丢失的，那RDB就够用了</li>
<li>RDB在启动的时候恢复数据会比AOF快很多</li>
<li>在Redis4.0以后也支持了AOF和RDB混合</li>
<li>至于AOF的话，官网是不建议仅仅只使用AOF的，如果对数据丢失容忍度是有要求的，建议是开启AOF+RDB一起用</li>
<li>总的来说，不同的场景使用不同的持久化策略吧</li>
<li>我们公司也是不建议把Redis当做存储去使用的（毕竟没有事务保证，也还是可能导致数据丢失）</li>
</ol>
<h2 id="顺便我想问下，假如Redisl的内存满了，但业务还在写数据，会怎么样？"><a href="#顺便我想问下，假如Redisl的内存满了，但业务还在写数据，会怎么样？" class="headerlink" title="顺便我想问下，假如Redisl的内存满了，但业务还在写数据，会怎么样？"></a>顺便我想问下，假如Redisl的内存满了，但业务还在写数据，会怎么样？</h2><ol>
<li>嗯，这个问题我也遇到过</li>
<li>一般来说，我们会淘汰那些「不活跃」的数据，然后把新的数据写进去</li>
<li>更多情况下，还是做好对应的监控和容量的考量吧。等容量达到阈值的时候，及时发现和扩容</li>
</ol>
<h2 id="那要不来讲讲扩容和Redisl的架构吧？"><a href="#那要不来讲讲扩容和Redisl的架构吧？" class="headerlink" title="那要不来讲讲扩容和Redisl的架构吧？"></a>那要不来讲讲扩容和Redisl的架构吧？</h2><p>下次吧</p>
<h2 id="那要不来讲讲扩容和Redisl的架构吧？-1"><a href="#那要不来讲讲扩容和Redisl的架构吧？-1" class="headerlink" title="那要不来讲讲扩容和Redisl的架构吧？"></a>那要不来讲讲扩容和Redisl的架构吧？</h2><ol>
<li>Redis的官网啊，看了这么多技术官网，我觉得Redis的官网弄得是真不错</li>
<li>《Redis设计与实现》这本书也挺不错的</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>19、【对线面试官】kafka基础</title>
    <url>/posts/49c930c7/</url>
    <content><![CDATA[<h1 id="19、【对线面试官】kafka基础"><a href="#19、【对线面试官】kafka基础" class="headerlink" title="19、【对线面试官】kafka基础"></a>19、【对线面试官】kafka基础</h1><h2 id="今天要不来聊聊消息队列吧？我看你项目不少地方都写到Kafka了-你简单说明下你使用Kafka的场景吧"><a href="#今天要不来聊聊消息队列吧？我看你项目不少地方都写到Kafka了-你简单说明下你使用Kafka的场景吧" class="headerlink" title="今天要不来聊聊消息队列吧？我看你项目不少地方都写到Kafka了.你简单说明下你使用Kafka的场景吧"></a>今天要不来聊聊消息队列吧？我看你项目不少地方都写到Kafka了.你简单说明下你使用Kafka的场景吧</h2><ol>
<li><p>使用消息队列的目的总的来说可以有三种情况：解耦、异步和削峰</p>
</li>
<li><p>比如举我项目的例子吧，我现在维护一个消息管理平台系统，对外提供发送接口给各个业务方调用</p>
</li>
<li><p>他们调用接口之后，实际上『不是同步』下发了消息。</p>
</li>
<li><p>在接口处理层只是把该条消息放到了消息队列上，随后就直接返回结果给接口调用者了。</p>
</li>
<li><p>这样的好处就是：</p>
<p>1）接口的吞吐量会大幅度提高（因为未做真正实际调用，接口RT会非常低）【异步】</p>
<p>2）即便有大批量的消息调用接口都不会让系统受到影响（流量由消息队列承载）【削峰】</p>
</li>
</ol>
<h2 id="有点抽象，再举个实际案例？"><a href="#有点抽象，再举个实际案例？" class="headerlink" title="有点抽象，再举个实际案例？"></a>有点抽象，再举个实际案例？</h2><ol>
<li><p>又比如说，我这边还有个项目是广告订单归因工程，主要做的事情就是得到订单数据，给各个业务广告计算对应的佣金。</p>
</li>
<li><p>订单的数据是从消息队列里取出的</p>
</li>
<li><p>这样设计的好处就是：</p>
<p>1）交易团队的同学只要把订单消息写到消息队列，该订单数据的Topic由各个业务方自行消费使用【解耦】【异步】</p>
<p>2）即便下单QPS猛增，对下游业务无太大的感知（因为下游业务只消费消息队列的数据，不会直接影响到机器性能）【削峰】</p>
</li>
</ol>
<h2 id="那我想问下，你觉得为什么消息队列能削峰？或者换个问法，为什么Kafka能承载这么大的QPS？"><a href="#那我想问下，你觉得为什么消息队列能削峰？或者换个问法，为什么Kafka能承载这么大的QPS？" class="headerlink" title="那我想问下，你觉得为什么消息队列能削峰？或者换个问法，为什么Kafka能承载这么大的QPS？"></a>那我想问下，你觉得为什么消息队列能削峰？或者换个问法，为什么Kafka能承载这么大的QPS？</h2><ol>
<li><p>消息队列「最核心的功能就是把生产的数据存储起来，然后给各个业务把数据再读取出来。</p>
</li>
<li><p>跟我们处理请求时不一样，我们在业务处理时可能会调别人的接口，可能会需要去查数据库…等等等一系列的操作才行</p>
</li>
<li><p>这些业务操作都是非常耗时的，像Kafka在「存储」和「读取」这个过程中又做了很多的优化</p>
</li>
<li><p>举几个例子，比如说：</p>
<p>1）我们往一个Topic发送消息或者读取消息时，实际内部是多个Partition在处理【并行】</p>
<p>2）在存储消息时，Kafka内部是顺序写磁盘的，并且利用了操作系统的缓冲区来提高性能【append+cache】</p>
<p>3）在读写数据中也减少CPU拷贝的次数【零拷贝】</p>
</li>
</ol>
<h2 id="嗯，你既然提到减少CPU拷贝的次数，可以给我说下这项技术吗？"><a href="#嗯，你既然提到减少CPU拷贝的次数，可以给我说下这项技术吗？" class="headerlink" title="嗯，你既然提到减少CPU拷贝的次数，可以给我说下这项技术吗？"></a>嗯，你既然提到减少CPU拷贝的次数，可以给我说下这项技术吗？</h2><ol>
<li><p>嗯，可以的，其实就是零拷贝技术。</p>
</li>
<li><p>比如我们正常调用read函数时，会发生以下的步骤（以读磁盘的数据为例）：</p>
<p>1）DMA把磁盘数据拷贝到读内核缓存区</p>
<p>2）CPU把读内核缓冲区的数据拷贝到用户空间</p>
</li>
<li><p>正常调用write函数时，会发生以下的步骤（数据写到网卡为例）：</p>
<p>1）CPU把用户空间的数据拷贝到Socket内核缓存区</p>
<p>2）DMA把Socket内核缓冲区的数据拷贝到网卡</p>
</li>
<li><p>可以发现完成「一次读写」需要2次DMA拷贝，2次CPU拷贝。</p>
</li>
<li><p>而DMA拷贝是省不了的，所谓的零拷贝技术就是把CPU的拷贝给省掉</p>
</li>
<li><p>并且为了避免用户进程直接操作内核，保证内核安全，应用程序在调用系统函数时，会发生上下文切换（上述的过程一共会发生4次）</p>
</li>
<li><p>目前零拷贝技术主要有：mmap和sendfile</p>
</li>
<li><p>比如说：mmap是将读缓冲区的地址和用户空间的地址进行映射，实现读内核缓冲区和应用缓冲区共享</p>
</li>
<li><p>从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝</p>
</li>
<li><p>使用mmap的后一次读写就可以简化为：、</p>
<p>一、DMA把硬盘数据拷贝到读内核缓冲</p>
<p>二、CPU把读内核缓存区拷贝至Socket内核缓冲区。</p>
<p>三、DMA把Socket内核缓冲区拷贝至网</p>
</li>
<li><p>由于读内核缓冲区与用户空间做了映射，所以会省了一次CPU拷贝</p>
</li>
<li><p>而sendfile+DMA Scatter&#x2F;Gather！则是把读内核缓存区的文件描述符&#x2F;长度信息发到Socket内核缓冲区，实现CPU零拷贝</p>
</li>
<li><p>使用sendfile+DMA Scatter&#x2F;Gather一次读写就可以简化为：</p>
<p>1）DMA把硬盘数据拷贝至读内核缓冲区</p>
<p>2）CPU把读缓冲区的文件描述符和长度信息发到Socket缓冲区。</p>
<p>3）DMA根据文件描述符和数据长度从读内核缓冲区把数据拷贝至网卡</p>
</li>
<li><p>回到kafka上吧</p>
</li>
<li><p>从Producer-》Broker，Kafka是把网卡的数据持久化硬盘，用的是mmap（从2次<br>CPU拷贝减至1次） </p>
</li>
<li><p>从Broker-》Consumer，Kafka是从硬盘的数据发送至网卡，用的是sendFile（实<br>现CPU零拷贝）</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kafka能这么快的原因就是实现了并行、充分利用操作系统cache、顺序写和零拷贝</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>20、【对线面试官】使用kafka会考虑什么问题</title>
    <url>/posts/c5b7e17d/</url>
    <content><![CDATA[<h1 id="20、【对线面试官】使用kafka会考虑什么问题"><a href="#20、【对线面试官】使用kafka会考虑什么问题" class="headerlink" title="20、【对线面试官】使用kafka会考虑什么问题"></a>20、【对线面试官】使用kafka会考虑什么问题</h1><h2 id="你提到了你这边会从交易的消息报获取到订单的数据，然后做业务的处理；也提到了你用的是Kafka，我想问下，Kafka会丢数据吗？"><a href="#你提到了你这边会从交易的消息报获取到订单的数据，然后做业务的处理；也提到了你用的是Kafka，我想问下，Kafka会丢数据吗？" class="headerlink" title="你提到了你这边会从交易的消息报获取到订单的数据，然后做业务的处理；也提到了你用的是Kafka，我想问下，Kafka会丢数据吗？"></a>你提到了你这边会从交易的消息报获取到订单的数据，然后做业务的处理；也提到了你用的是Kafka，我想问下，Kafka会丢数据吗？</h2><ol>
<li><p>嗯，使用Kafkal时，有可能会有以下场景会丢消息</p>
</li>
<li><p>比如说，我们用Producer发消息至Broke的时候，就有可能会丢消息</p>
</li>
<li><p>如果你不想丢消息，那在发送消息的时候，需要选择带有callBack的api进行发送</p>
</li>
<li><p>其实就意味着，如果你发送成功了，会回调告诉你已经发送成功了。如果失败了，那收到回调之后自己在业务上做重试就好了。</p>
</li>
<li><p>等到把消息发送到Brokerl以后，也有可能丢消息</p>
</li>
<li><p>一般我们的线上环境都是集群环境下嘛，但可能你发送的消息后broker就挂了，这时挂掉的broker还没来得及把数据同步给别的broker，数据就自然就丢了</p>
</li>
<li><p>发送到Broker之后，也不能保证数据就一定不丢了，毕竟Broker会把数据存储到磁盘之前，走的是操作系统缓存</p>
</li>
<li><p>也就是异步刷盘这个过程还有可能导致数据会丢</p>
</li>
<li><p>嗯，到这里其实我已经说了三个场景了，分别是：producer-》broker，broker-》broker之间同步，以及broker-》磁盘</p>
</li>
<li><p>要解决上面所讲的问题也比较简单，这块也没什么好说的…</p>
</li>
<li><p>不想丢数据，那就使用带有callback的api设置acks、retries、factor等等些参数来保证Producer发送的消息不会丢就好啦。</p>
</li>
</ol>
<h2 id="一般来说，还是client消费broker丢消息的场景比较多；那你们在消费数据的时候是怎么保证数据的可靠性的呢？"><a href="#一般来说，还是client消费broker丢消息的场景比较多；那你们在消费数据的时候是怎么保证数据的可靠性的呢？" class="headerlink" title="一般来说，还是client消费broker丢消息的场景比较多；那你们在消费数据的时候是怎么保证数据的可靠性的呢？"></a>一般来说，还是client消费broker丢消息的场景比较多；那你们在消费数据的时候是怎么保证数据的可靠性的呢？</h2><ol>
<li><p>首先，要想client端消费数据不能丢，肯定是不能使用autoCommit的，所以必须是手动提交的。</p>
</li>
<li><p>我们这边是这样实现的：</p>
<p>一、从Kafka拉取消息、（一次批量拉取500条，这里主要看配置）<br>二、为每条拉取的消息分配一个msgld（递增）<br>三、将msgld存入内存队列（sortSet）中<br>四、使用Map存储msgld.与msg（有offset相关的信息）的映射关系</p>
<p>五、当业务处理完消息后，ack时，获取当前处理的消息nsgld，然后从sortSet删除该msgld（此时代表已经处理过了）<br>六、接着与sortSet队列的首部第一个ld比较（其实就是最小的msgld），如果当前msgld&lt;&#x3D;sort Set第一个ID，则提交当前offset</p>
<p>七、系统即便挂了，在下次重启时就会从sortSet队首的消息开始拉取，实现至少处理一次语义<br>八、会有少量的消息重复，但只要下游做好幂等就OK了</p>
</li>
</ol>
<h2 id="嗯，你也提到了幂等，你们是怎么实现幂等性的呢？"><a href="#嗯，你也提到了幂等，你们是怎么实现幂等性的呢？" class="headerlink" title="嗯，你也提到了幂等，你们是怎么实现幂等性的呢？"></a>嗯，你也提到了幂等，你们是怎么实现幂等性的呢？</h2><ol>
<li>嗯，还是以处理订单消息为例好了。</li>
<li>幂等Key我们由订单编号+订单状态所组成（一笔订单的状态只会处理一次）</li>
<li>在处理之前，我们首先会去查Redis：是否存在该Key，如果存在，则说明我们已经处理过了，直接丢掉</li>
<li>如果Redis没处理过，则继续往下处理，最终的逻辑是将处理过的数据插入到业务DB上，再到最后把幂等Key插入到Redis上</li>
<li>显然，单纯通过Redis是无法保证幂等的</li>
<li>所以，Redis其实只是一个「前置」处理，最终的幂等性是依赖数据库的唯一Key来保证的（唯一Key实际上也是订单编号+状态）</li>
<li>而插入DB是依赖事务的，所以是没问题的</li>
<li>总的来说，就是通过Redis做前置处理，DB唯一索引做最终保证来实现幂等性的</li>
</ol>
<h2 id="你们那边遇到过顺序消费的问题吗？"><a href="#你们那边遇到过顺序消费的问题吗？" class="headerlink" title="你们那边遇到过顺序消费的问题吗？"></a>你们那边遇到过顺序消费的问题吗？</h2><ol>
<li><p>嗯，也是有的，我举个例子</p>
</li>
<li><p>订单的状态比如有支付、确认收货、完成等等，而订单下还有计费、退款的消息报</p>
</li>
<li><p>理论上来说，支付的消息报肯定要比退款消息报先到嘛，但程序处理的过程中可不一定的嘛</p>
</li>
<li><p>所以在这边也是有消费顺序的问题（先处理了支付，才能退款啊）</p>
</li>
<li><p>但在广告场景下不是「强顺序」的，只要保证最终一致性就好了。</p>
</li>
<li><p>所以我们这边处理「乱序」消息的实现是这样的：</p>
<p>1）宽表：将每一个订单状态，单独分出一个或多个独立的字段。消息来时只更新对应的字段就好，消息只会存在短暂的状态不一致问题，但是状态最终是一致的</p>
<p>2）消息补偿机制：另一个进行消费相同topicl的数据，消息落盘，延迟处理。将消息与DB进行对比，如果发现数据不一致，再重新发送消息至主进程处理</p>
<p>3）还有部分场景，可能我们只需要把相同userld&#x2F;orderld.发送到相同的partition（因为一个partition由一个Consumer消费），又能解决大部分消费顺序的问题了呢。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>21、【对线面试官】Mysql索引</title>
    <url>/posts/ace2edeb/</url>
    <content><![CDATA[<h1 id="21、【对线面试官】Mysql索引"><a href="#21、【对线面试官】Mysql索引" class="headerlink" title="21、【对线面试官】Mysql索引"></a>21、【对线面试官】Mysql索引</h1><h2 id="我看你简历上写了MySQL，对MySQL-InnoDB引擎的索引了解吗？"><a href="#我看你简历上写了MySQL，对MySQL-InnoDB引擎的索引了解吗？" class="headerlink" title="我看你简历上写了MySQL，对MySQL InnoDB引擎的索引了解吗？"></a>我看你简历上写了MySQL，对MySQL InnoDB引擎的索引了解吗？</h2><ol>
<li>嗯啊，使用索引可以加快查询速度，其实上就是将无序的数据变成有序（有序就能加快检索速度）</li>
<li>在InnoDB引擎中，索引的底层数据结构是**<code>B+树</code>**</li>
</ol>
<h2 id="那为什么不使用红黑树或者B树呢？"><a href="#那为什么不使用红黑树或者B树呢？" class="headerlink" title="那为什么不使用红黑树或者B树呢？"></a>那为什么不使用红黑树或者B树呢？</h2><ol>
<li><p>MySQL的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中</p>
</li>
<li><p>红黑树是「二叉查找树」的变种，一个Node节点只能存储一个Key和一个Value</p>
</li>
<li><p>B和B+树跟红黑树不一样，它们算是「多路搜索树」，相较于「二叉搜索树」而言，一个Node节点可以存储的信息会更多，「多路搜索树」的高度会比「二叉搜索树」更低。</p>
</li>
<li><p>了解了区别之后，其实就很容易发现，在数据不能一次加载至内存的场景下，数据需要被检索出来</p>
</li>
<li><p>选择B或B+树的理由就很充分了（一个Node节点存储信息更多（相较于二叉搜索树），树的高度更低，树的高度影响检索的速度）</p>
</li>
<li><p>B+树相对于B树而言，它又有两种特性。</p>
<p>1）B+树非叶子节点不存储数据，在相同的数据量下，B+树更加矮壮。（这个应该不用多解释了，数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮）</p>
<p>2）B+树叶子节点之间组成一个链表，方便于遍历查询（遍历操作在MySQL中比较常见）</p>
</li>
<li><p>我稍微解释一下吧，你可以脑补下画面</p>
</li>
<li><p>我们在MySQL InnoDB引擎下，每创建一个索引，相当于生成了一颗B+树。</p>
</li>
<li><p>如果该索引是「聚集（聚簇）索引」，那当前B+树的叶子节点存储着「主键和当前行的数据」</p>
</li>
<li><p>如果该索引是「非聚簇索引小」，那当前B+树的叶子节点存储着「主键和当前索引列值」</p>
</li>
<li><p>比如写了一句sql：select*from user where id&gt;&#x3D;10，那只要定位到id为10的记录，然后在叶子节点之间通过遍历链表（叶子节点组成的链表），即可找到往后的记录了。</p>
</li>
<li><p>由于B树是会在非叶子节点也存储数据，要遍历的时候可能就得跨层检索，相对麻烦些。</p>
</li>
<li><p>基于树的层级以及业务使用场景的特性，所以MySQL选择了B+树作为索引的底层数据结构。</p>
</li>
<li><p>对于哈希结构，其实InnoDB引擎是「自适应」哈希索引的（hash索引的创建由lnnoDB存储引擎自动优化创建，我们是干预不了）</p>
</li>
</ol>
<h2 id="你知道什么是回表吗？"><a href="#你知道什么是回表吗？" class="headerlink" title="你知道什么是回表吗？"></a>你知道什么是回表吗？</h2><ol>
<li>所谓的回表其实就是，当我们使用非聚簇索引查询数据时，检索出来的数据可能包含其他列</li>
<li>但走的索引树叶子节点只能查到当前列值以及主键ID，所以需要根据主键ID再去查一遍数据，得到SQL所需的列</li>
<li>举个例子，我这边建了给订单号ID建了个索引，但我的SQL是：select orderld，orderName from orderdetail where orderld &#x3D; 123</li>
<li>SQL走订单ID索引，但在订单ID的索引树的叶子节点只有orderld和ld，而我们还想检索出orderName，所以MySQL会拿到ID再去查出orderName给我们返回，这种操作就叫回表</li>
</ol>
<h2 id="如何避免回表"><a href="#如何避免回表" class="headerlink" title="如何避免回表"></a>如何避免回表</h2><ol>
<li>想要避免回表，可以使用覆盖索引</li>
<li>所谓的覆盖索引，实际上就是你想要查出的列刚好在叶子节点上都存在，比如我建了orderld和orderName.联合索引l，刚好我需要查询也是orderld和orderName，这些数据都存在索引树的叶子节点上，就不需要回表操作了。</li>
</ol>
<h2 id="既然你也提到了联合索引，我想问下你了解最左匹配原则吗"><a href="#既然你也提到了联合索引，我想问下你了解最左匹配原则吗" class="headerlink" title="既然你也提到了联合索引，我想问下你了解最左匹配原则吗"></a>既然你也提到了联合索引，我想问下你了解最左匹配原则吗</h2><ol>
<li>嗯，要说明这个概念，还是举例子比较容易</li>
<li>如有索引（a，b，c，d），查询条件a&#x3D;1and b&#x3D;2 and c&gt;3 and d&#x3D;4，则会在每个节点依次命中a、b、c，无法命中d</li>
<li>先匹配最左边的，索引只能用于查找key是否存在（相等），遇到范围查询（&gt;、&lt;、between、like左匹配）等就不能进一步匹配了，后续退化为线性查找</li>
<li>这就是最左匹配原则</li>
</ol>
<h2 id="嗯嗯，我还想问下你们主键是怎么生成的？"><a href="#嗯嗯，我还想问下你们主键是怎么生成的？" class="headerlink" title="嗯嗯，我还想问下你们主键是怎么生成的？"></a>嗯嗯，我还想问下你们主键是怎么生成的？</h2><p>主键就自增的</p>
<h2 id="那假设我不用MySQL自增的主键，你觉得会有什么问题呢？"><a href="#那假设我不用MySQL自增的主键，你觉得会有什么问题呢？" class="headerlink" title="那假设我不用MySQL自增的主键，你觉得会有什么问题呢？"></a>那假设我不用MySQL自增的主键，你觉得会有什么问题呢？</h2><ol>
<li>首先主键得保证它的唯一性和空间尽可能短吧，这两块是需要考虑的。</li>
<li>另外，由于索引的特性（有序），如果生成像uuid类似的主键，那插入的的性能是比自增的要差的</li>
<li>因为生成的uuid，在插入时有可能需要移动磁盘块（比如，块内的空间在当前时刻已经存储满了，但新生成的uuid需要插入已满的块内，就需要移动块的数据）</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>23、【对线面试官】InnoDB引擎中的事务</title>
    <url>/posts/b4eb9a6c/</url>
    <content><![CDATA[<h1 id="这次我想问下，你是怎么理解InnoDB引擎中的事务的？"><a href="#这次我想问下，你是怎么理解InnoDB引擎中的事务的？" class="headerlink" title="这次我想问下，你是怎么理解InnoDB引擎中的事务的？"></a>这次我想问下，你是怎么理解InnoDB引擎中的事务的？</h1><ol>
<li>在我的理解下，事务可以使「一组操作」要么全部成功，要么全部失败</li>
<li>事务其目的是为了「保证数据最终的一致性」。</li>
<li>举个例子，我给你发支付宝转了888块红包。那自然我的支付宝余额会扣减888块，你的支付宝余额会增加888块。</li>
<li>而事务就是保证我的余额扣减跟你的余额增添是同时成功或者同时失败的，这样这次转账就正常了</li>
</ol>
<h2 id="嗯，那你了解事务的几大特性吗？"><a href="#嗯，那你了解事务的几大特性吗？" class="headerlink" title="嗯，那你了解事务的几大特性吗？"></a>嗯，那你了解事务的几大特性吗？</h2><p>嗯，就是ACID嘛，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<ol>
<li><p>原子性指的是：当前事务的操作要么同时成功，要么同时失败。原子性由undo Iog日志来保证，因为undo log记载着数据修改前的信息。</p>
<p>1）比如我们要insert一条数据了，那undo Iog会记录的一条对应的delete日志。我们要update一条记录时，那undo log会记录之前的「旧值」的update记录。</p>
<p>2）如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB引擎就是利用undo log记录下的数据，来将数据「恢复」到事务开始之前</p>
</li>
<li><p>隔离性指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。</p>
<p>1）如果多个事务可以在同一时刻操作同一份数据，那么就会可能会产生脏读、重复读、幻读的问题。</p>
<p>2）于是，事务与事务之间需要存在「一定」的隔离。在nnoDB引擎中，定义了四种隔离级别供我们使用：分别是：read uncommit（读未提交）、read commit（读已提交）、repeatable read（可重复复读）、serializable（串行）</p>
<p>3）不同的隔离级别对事务之间的隔离性是不一样的（级别越高事务隔离性越好，但性能就越低），而隔离性是由MySQL的各种锁来实现的，只是它屏蔽了加锁的细节。</p>
</li>
<li><p>持久性指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上。</p>
<p>1）而持久性由redo log日志来保证，当我们要修改数据时，MySQL是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改。</p>
<p>2）为了防止内存修改完了，MySQL就挂掉了（如果内存改完，直接挂掉，那这次的修改相当于就丢失了）。</p>
<p>3）MySQL引入了redo log，内存写完了，然后会写一份redo log，这份redo log记载着这次在某个页上做了什么修改。</p>
<p>4）即便MySQL在中途挂了，我们还可以根据redo log：来对数据进行恢复。</p>
<p>5）redo log是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx页做了xxx修改），文件的体积很小，恢复速度也很快。</p>
</li>
<li><p>「一致性」可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证</p>
<p>1）比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致。</p>
</li>
</ol>
<h2 id="刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？"><a href="#刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？" class="headerlink" title="刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？"></a>刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？</h2><ol>
<li><p>嗯，为了讲清楚隔离级别，我顺带来说下MySQL锁相关的知识吧。</p>
<p>1）在InnoDB引擎下，按锁的粒度分类，可以简单分为行锁和表锁。</p>
<p>2）行锁实际上是作用在索引之上的（索引上次已经说过了，这里就不赘述了）</p>
<p>3）当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是行锁），如果没有命中索引，那我们锁的就是整个索引树（表锁）。</p>
<p>4）简单来说就是：锁住的是整棵树还是某几个节点，完全取决于SQL条件是否有命中到对应的索引节点。</p>
<p>5）而行锁又可以简单分为读锁（共享锁、S锁）和写锁（排它锁、X锁）。</p>
<p>6）读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。写锁是排他的，写锁会阻塞其他的写锁和读锁。</p>
</li>
<li><p>我现在就再回到隔离级别上吧，就直接以例子来说明啦。</p>
<p>1）首先来说下read uncommit（读未提交）。比如说：A向B转账，A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。</p>
<p>​    （1）简单的定义就是：事务B读取到了事务A还没提交的数据，这种用专业术语来说叫做「脏读」。</p>
<p>​    （2）对于锁的维度而言，其实就是在read uncommit隔离级别下，读不会加任何锁，而写会加排他锁。读什么锁都不加，这就让排他锁无法排它了。</p>
<p>​    （3）我们又知道，对于更新操作而言，lnnODB是肯定会加写锁的（数据库是不可能允许在同一时间，更新同一条记录的）。而读操作，如果不加任何锁，那就会造成上面的脏读。</p>
<p>​    （4）脏读在生产环境下肯定是无法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极大地降低数据库性能。</p>
<ul>
<li><p>在MySQL InnoDB引擎层面，又有新的解决方案（解决加锁后读写性能问题），叫做MVCC（Multi-Version Concurrency Control）多版本并发控制</p>
</li>
<li><p>在MVCC下，就可以做到读写不阻塞，且避免了类似脏读这样的问题。那MVCC是怎么做的呢？</p>
</li>
<li><p>MVCC通过生成数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取</p>
</li>
</ul>
<p>  （5）回到事务隔离级别下，针对于read commit（读已提交）隔离级别，它生成的就是语句级快照，而针对于repeatable read（可重复读），它生成的就是事务级的快照。</p>
<p>2）前面提到过read uncommit隔离级别下会产生脏读，而read commit（读已提交）隔离级别解决了脏读</p>
<p>​    （1）思想其实很简单：在读取的时候生成一个”版本号”，等到其他事务commit了之后，才会读取最新已commit的”版本号”数据。</p>
<p>​    （2）比如说：事务A读取了记录（生成版本号），事务B修改了记录（此时加了写锁），事务A再读取的时候，是依据最新的版本号来读取的（当事务B执行commit了之后，会生成一个新的版本号），如果事务B还没有commit.那事务A读取的还是之前版本号的数据。</p>
<p>​    （3）通过「版本」的概念，这样就解决了脏读的问题，而通过「版本」又可以对应快照的数据。read commit（读已提交）解决了脏读。</p>
<p>3）read commit（读已提交）解决了脏读，但也会有其他并发的问题。「不可重复读」：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改。</p>
<p>​    （1）不可重复读的例子：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的】</p>
<p>​    （2）了解MVCC基础之后，就很容易想到repeatable read（可重复复读）隔离级别是怎么避免不可重复读的问题了（前面也提到了）。</p>
<p>​    （3）repeatable read（可重复复读）隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了（commit），也只会读取当前事务版本的数据。</p>
<p>​    （4）在InnoDB引擎下的的repeatable read（可重复复读）隔离级别下，在MVCC下，快照读，已经解决了幻读的问题（因为它是读历史版本的数据）</p>
<p>​    （5）而如果是当前读（比如select*from table for update），则需要配合间隙锁来解决幻读的问题。</p>
<p>4）剩下的就是serializable（串行）隔离级别了，它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的。</p>
</li>
</ol>
<h2 id="我看你提到了MVCC了，不妨来说下他的原理？"><a href="#我看你提到了MVCC了，不妨来说下他的原理？" class="headerlink" title="我看你提到了MVCC了，不妨来说下他的原理？"></a>我看你提到了MVCC了，不妨来说下他的原理？</h2><ol>
<li>MVCC的主要是通过read view和undo log来实现的</li>
<li>undo log前面也提到了，它会记录修改数据之前的信息，事务中的原子性就是通过undo log：来实现的。所以，有undo log可以帮我们找到「版本」的数据</li>
<li>而read view实际上就是在查询时，lnnoDB会生成一个read view，read view有几个重要的字段，看下去就懂了</li>
<li>分别是：trx ids（尚未提交commit的事务版本号集合），low limit id（下一次要生成的事务D值），low limit id（尚未提交版本号的事务D最小值）以及creator trx id（当前的事务版本号）</li>
<li>在每行数据有两列隐藏的字段，分别是DB_TRX_ID（记录着当前ID）以及DB_ROLL _PTR（指向上一个版本数据在undolog里的位置指针）</li>
<li>垫到这了，很容易就发现，MVCC其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于undo log中。</li>
<li>而针对于不同的隔离级别（read commit和repeatable read），无非就是read commit隔离级别下，每次都获取一个新的read view，repeatable read隔离级别则每次事务只获取一个read view</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>事务为了保证数据的最终一致性</p>
</li>
<li><p>事务有四大特性，分别是原子性、一致性、隔离性、持久性</p>
</li>
<li><ul>
<li>原子性由undo log保证</li>
<li>持久性由redo log 保证</li>
<li>隔离性由数据库隔离级别供我们选择，分别有read uncommit,read commit,repeatable read,serializable</li>
<li>一致性是事务的目的，一致性由应用程序来保证</li>
</ul>
</li>
<li><p>事务并发会存在各种问题，分别有脏读、重复读、幻读问题。上面的不同隔离级别可以解决掉由于并发事务所造成的问题，而隔离级别实际上就是由MySQL锁来实现的</p>
</li>
<li><p>频繁加锁会导致数据库性能低下，引入了MVCC多版本控制来实现读写不阻塞，提高数据库性能</p>
</li>
<li><p>MVCC原理即通过read view 以及undo log来实现</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>23、【对线面试官】Mysql调优</title>
    <url>/posts/3e598844/</url>
    <content><![CDATA[<h1 id="23、【对线面试官】Mysql调优"><a href="#23、【对线面试官】Mysql调优" class="headerlink" title="23、【对线面试官】Mysql调优"></a>23、【对线面试官】Mysql调优</h1><h2 id="要不你来讲讲你们对MySQL是怎么调优的？"><a href="#要不你来讲讲你们对MySQL是怎么调优的？" class="headerlink" title="要不你来讲讲你们对MySQL是怎么调优的？"></a>要不你来讲讲你们对MySQL是怎么调优的？</h2><ul>
<li>哇，这命题很大阿…我认为，对于开发者而言，对MySQL的调优重点一般是在「开发规范」、「数据库索引」又或者说解决线上慢查询上。</li>
<li>而对于MySQL内部的参数调优，由专业的DBA来搞。</li>
</ul>
<h2 id="那你来聊聊你们平时开发的规范和索引这块，平时是怎么样的吧。"><a href="#那你来聊聊你们平时开发的规范和索引这块，平时是怎么样的吧。" class="headerlink" title="那你来聊聊你们平时开发的规范和索引这块，平时是怎么样的吧。"></a>那你来聊聊你们平时开发的规范和索引这块，平时是怎么样的吧。</h2><ul>
<li><p>嗯，首先，我们在生产环境下，创建数据库表，都是在工单系统下完成的（那就自然需要DBA审批）</p>
</li>
<li><p>如果在创建表时检测到没有创建索引，那就会直接提示warning</p>
</li>
<li><p>理论上来说，如果表有一定的数据量，那就应该要创建对应的索引</p>
</li>
<li><p>从数据库查询数据需要注意的地方还是蛮多的，其中很多都是平时积累来的比如说：</p>
<ul>
<li>1.是否能使用「覆盖索引」，减少「回表」所消耗的时间。意味着，我们在select的时候，一定要指明对应的列，而不是select</li>
<li>2.考虑是否组建「联合索引小」，如果组建「联合索引小」，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」</li>
<li>3.对索引进行函数操作或者表达式计算会导致索引失效</li>
<li>4.利用子查询优化超多分页场景。比如limit offset，n在MySQL是获取offset+n的记录，再返回n条。而利用子查询则是查出n条，通过ID检索对应的记录出来，提高查询效率。</li>
<li>5.通过explain命令来查看SQL的执行计划，看看自己写的SQL是否走了索引，走了什么索引。通过show profile来查看SQL对系统资源的损耗情况（不过一般还是比较少用到的）</li>
<li>6.在开启事务后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间（比如在事务内需要插入&amp;&amp;修改数据，那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放）</li>
</ul>
</li>
</ul>
<h2 id="嗯，你提到了事务，之前也讲过了事务的隔离级别嘛，那你线上用的是什么隔离级别？"><a href="#嗯，你提到了事务，之前也讲过了事务的隔离级别嘛，那你线上用的是什么隔离级别？" class="headerlink" title="嗯，你提到了事务，之前也讲过了事务的隔离级别嘛，那你线上用的是什么隔离级别？"></a>嗯，你提到了事务，之前也讲过了事务的隔离级别嘛，那你线上用的是什么隔离级别？</h2><ul>
<li>嗯，我们这边用的是Read Commit（读已提交），MySQL默认用的是Repeatable read（可重复读）</li>
<li>选用什么隔离级别，主要看应用场景嘛，因为隔离级别越低，事务并发性能越高。</li>
<li>（一般互联网公司都选择Read Commit作为主要的隔离级别）</li>
<li>像Repeatable read（可重复读）隔离级别，就有可能因为「间隙锁」导致的死锁问题。</li>
<li>但，MySQL默认的隔离级别为Repeatable read。很大一部分原因是在最开始的时候，MySQL的binlog没有row模式，在read commit隔离级别下会存在「主从数据不一致」的问题</li>
<li>binlog记录了数据库表结构和表数据「变更」，比如update&#x2F;delete&#x2F;insert&#x2F;truncate&#x2F;create。在MySQL中，主从同步实际上就是应用了binlog：来实现的</li>
<li>有了该历史原因，所以MySQL就将默认的隔离级别设置为Repeatable read</li>
</ul>
<h2 id="了解了，那我顺便想问下，你们遇到过类似的问题吗：即便走对了索引，线上查询还是慢。"><a href="#了解了，那我顺便想问下，你们遇到过类似的问题吗：即便走对了索引，线上查询还是慢。" class="headerlink" title="了解了，那我顺便想问下，你们遇到过类似的问题吗：即便走对了索引，线上查询还是慢。"></a>了解了，那我顺便想问下，你们遇到过类似的问题吗：即便走对了索引，线上查询还是慢。</h2><ul>
<li>如果走对了索引，但查询还是慢，那一般来说就是表的数据量实在是太大了。</li>
<li>首先，考虑能不能把「旧的数据」给”删掉”，对于我们公司而言，我们都会把数据同步到Hive，说明已经离线存储了一份了。</li>
<li>那如果「旧的数据」已经没有查询的业务了，那最简单的办法肯定是”删掉”部分数据咯。数据量降低了，那自然，检索速度就快了…</li>
<li>但，只有极少部分业务可以删掉数据</li>
<li>随后，就考虑另一种情况，能不能在查询数据库之前，直接走一层缓存（Redis)。<ul>
<li>而走缓存的话，又要看业务能不能忍受读取的「非真正实时」的数据（毕竟Redis和MySQL的数据一致性需要保证），如果查询条件相对复杂且多变的话（涉及各种group by和sum），那走缓存也不是一种好的办法，维护起来就不方便了…</li>
<li>再看看是不是有「字符串」检索的场景导致查询低效，如果是的话，可以考虑把表的数据导入至Elasticsearch类的搜索引擎，后续的线上查询就直接走Elasticsearch了。</li>
<li>MySQL-&gt;Elasticsearch需要有对应的同步程序（一般就是监听MySQL的binlog，解析binlog.后导入到Elasticsearch）</li>
<li>如果还不是的话，那考虑要不要根据查询条件的维度，做相对应的聚合表，线上的请求就查询聚合表的数据，不走原表。<ul>
<li>比如，用户下单后，有一份订单明细，而订单明细表的量级太大。但在产品侧（前台）透出的查询功能是以「天」维度来展示的，那就可以将每个用户的每天数据聚合起来，在聚合表就是一个用户一天只有一条汇总后的数据。</li>
<li>查询走聚合后的表，那速度肯定杠杠的（聚合后的表数据量肯定比原始表要少很多）</li>
<li>思路大致的就是「以空间换时间」，相同的数据换别的地方也存储一份，提高查询效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="那我还想问下，除了读之外，写性能同样有瓶颈，怎么办？"><a href="#那我还想问下，除了读之外，写性能同样有瓶颈，怎么办？" class="headerlink" title="那我还想问下，除了读之外，写性能同样有瓶颈，怎么办？"></a>那我还想问下，除了读之外，写性能同样有瓶颈，怎么办？</h2><ul>
<li>如果在MySQL读写都有瓶颈，那首先看下目前MySQL的架构是怎么样的。</li>
<li>如果是单库的，那是不是可以考虑升级至主从架构，实现读写分离。<ul>
<li>简单理解就是：主库接收写请求，从库接收读请求。从库的数据由主库发送的binlog进而更新，实现主从数据一致（在一般场景下，主从的数据是通过异步来保证最终一致性的）</li>
</ul>
</li>
<li>如果在主从架构下，读写仍存在瓶颈，那就要考虑是否要分库分表了<ul>
<li>至少在我前公司的架构下，业务是区分的。流量有流量数据库，广告有广告的数据库，商品有商品的数据库</li>
<li>所以，我这里讲的分库分表的含义是：在原来的某个库的某个表进而拆分。<ul>
<li>比如，现在我有一张业务订单表，这张订单表在广告库中，假定这张业务订单表已经有1亿数据量了，现在我要分库分表<ul>
<li>那就会将这张表的数据分至多个广告库以及多张表中</li>
<li>分库分表的最明显的好处就是把请求进行均摊（本来单个库单个表有一亿的数据，那假设我分开8个库，那每个库1200+W的数据量，每个库下分8张表，那每张表就150W的数据量）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="你们是以什么来作为分库分表键的？"><a href="#你们是以什么来作为分库分表键的？" class="headerlink" title="你们是以什么来作为分库分表键的？"></a>你们是以什么来作为分库分表键的？</h2><ul>
<li>按照我们这边的经验，一般来说是按照userld的（因为按照用户的维度查询比较多），如果要按照其他的维度进行查询，那还是参照上面的的思路（以空间换时间）。</li>
</ul>
<h2 id="那分库分表后的D是怎么生成的？"><a href="#那分库分表后的D是怎么生成的？" class="headerlink" title="那分库分表后的D是怎么生成的？"></a>那分库分表后的D是怎么生成的？</h2><ul>
<li>这就涉及到分布式D生成的方式了，思路有很多。有借助MySQL自增的，有借助Redis自增的，有基于「雪花算法」自增的</li>
<li>具体使用哪种方式，那就看公司的技术栈了，一般使用Redis和基于「雪花算法」实现用得比较多。</li>
<li>至于为什么强调自增（还是跟索引是有序有关，前面已经讲过了，你应该还记得）</li>
</ul>
<h2 id="嗯，那如果我要分库分表了，迁移的过程是怎么样的呢"><a href="#嗯，那如果我要分库分表了，迁移的过程是怎么样的呢" class="headerlink" title="嗯，那如果我要分库分表了，迁移的过程是怎么样的呢"></a>嗯，那如果我要分库分表了，迁移的过程是怎么样的呢</h2><ul>
<li>我们一般采取「双写」的方式来进行迁移，大致步骤就是：<ul>
<li>1.增量的消息各自往新表和旧表写一份</li>
<li>2.将旧表的数据迁移至新库</li>
<li>3.迟早新表的数据都会追得上旧表（在某个节点上数据是同步的）</li>
<li>4.校验新表和老表的数据是否正常（主要看能不能对得上）</li>
<li>5.开启双读（一部分流量走新表，一部分流量走老表），相当于灰度上线的过程</li>
<li>6.读流量全部切新表，停止老表的写入</li>
</ul>
</li>
<li>另外，提前准备回滚机制，临时切换失败能恢复正常业务以及有修数据的相关程序。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>数据库表存在一定数据量，就需要有对应的索引</li>
<li>发现慢查询时，检查是否走对索引，是否能用更好的索引进行优化查询速度，查看使用索引的姿势有没有问题</li>
<li>当索引解决不了慢查询时，一般由于业务表的数据量太大导致，利用空间换时间的思想（NOSQL、聚合、冗余…)</li>
<li>当读写性能均遇到瓶颈时，先考虑能否升级数据库架构即可解决问题，若不能则需要考虑分库分表</li>
<li>分库分表虽然能解决掉读写瓶颈，但同时会带来各种问题，需要提前调研解决方案和踩坑</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>24、【对线面试官】为什么需要Java内存模型</title>
    <url>/posts/691a1255/</url>
    <content><![CDATA[<h1 id="24、【对线面试官】为什么需要Java内存模型"><a href="#24、【对线面试官】为什么需要Java内存模型" class="headerlink" title="24、【对线面试官】为什么需要Java内存模型"></a>24、【对线面试官】为什么需要Java内存模型</h1><h2 id="今天想跟你聊聊Java内存模型，这块你了解过吗？"><a href="#今天想跟你聊聊Java内存模型，这块你了解过吗？" class="headerlink" title="今天想跟你聊聊Java内存模型，这块你了解过吗？"></a>今天想跟你聊聊Java内存模型，这块你了解过吗？</h2><ul>
<li><p>嗯，我简单说下我的理解吧。那我就从为什么要有Java内存模型开始讲起吧</p>
<ul>
<li><p>单线程下，可见性&#x2F;有序性&#x2F;原子性都没问题</p>
</li>
<li><p>CPU为了效率，有了高速缓存、有了指令重排序等等，整块架构都变得复杂了。我们写的程序肯定也想要「充分」利用CPU的资源啊！于是乎，我们使用起了多线程</p>
<ul>
<li><p>多线程在意味着并发，并发就意味着我们需要考虑线程安全问题</p>
<ul>
<li>1.缓存数据不一致：多个线程同时修改「共享变量」，CPU核心下的高速缓存是「不共享」的，那多个cache与内存之间的数据同步该怎么做？</li>
<li>2.CPU指令重排序在多线程下会导致代码在非预期下执行，最终会导致结果存在错误的情况。</li>
</ul>
</li>
<li><p>针对于「缓存不一致」问题，CPU也有其解决办法，常被大家所认识的有两种：</p>
<p>1.使用「总线锁」：某个核心在修改数据的过程中，其他核心均无法修改内存中的数据。（类似于独占内存的概念，只要有CPU在修改，那别的CPU就得等待当前CPU释放）</p>
<p>2.缓存一致性协议（MESI协议，其实协议有很多，只是举个大家都可能见过的）。MESI拆开英文是（Modified（修改状态）、Exclusive（独占状态）、Share（共享状态）、Invalid（无效状态））</p>
</li>
<li><p>缓存一致性协议我认为可以理解为「缓存锁」，它针对的是「缓存行」（Cache Iine）进行”加锁”，所谓「缓存行」其实就是高速缓存存储的最小单位。</p>
</li>
<li><p>MESI协议的原理大概就是：当每个CPU读取共享变量之前，会先识别数据的「对象状态」（是修改、还是共享、还是独占、还是无效）。</p>
</li>
<li><p>如果是独占，说明当前CPU将要得到的变量数据是最新的，没有被其他CPU所同时读取</p>
</li>
<li><p>如果是共享，说明当前CPU将要得到的变量数据还是最新的，有其他的CPU在同时读取，但还没被修改</p>
</li>
<li><p>如果是修改，说明当前CPU正在修改该变量的值，同时会向其他CPU发送该数据状态为invalid（无效）的通知，得到其他CPU响应后（其他CPU将数据状态从共享（share）变成invalid（无效），会当前CPU将高速缓存的数据写到主存，并把自己的状态从modify（修改）变成exclusive（独占）</p>
</li>
<li><p>如果是无效，说明当前数据是被改过了，需要从主存重新读取最新的数据。</p>
</li>
<li><p>其实MESI协议做的就是判断「对象状态」，根据「对象状态」做不同的策略移动</p>
</li>
<li><p>关键就在于某个CPU在对数据进行修改时，需要「同步」通知其他CPU，表示这个数据被我修改了，你们不能用了。</p>
</li>
<li><p>比较于「总线锁」，MESI协议的”锁粒度”更小了，性能那肯定会更高咯</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="但据我了解，CPU还有优化，你还知道吗？"><a href="#但据我了解，CPU还有优化，你还知道吗？" class="headerlink" title="但据我了解，CPU还有优化，你还知道吗？"></a>但据我了解，CPU还有优化，你还知道吗？</h2><ul>
<li>同步，意味着等待，等待意味着什么都干不了。CPU肯定不乐意啊，所以又优化了一把。</li>
<li>优化思路就是从「同步」变成「异步」。</li>
<li>在修改时会「同步」告诉其他CPU，而现在则把最新修改的值写到「store buffe」中，并通知其他CPU记得要改状态，随后CPU就直接返回干其他事了。</li>
<li>等到收到其它CPU发过来的响应消息，再将数据更新到高速缓存中。</li>
<li>其他CPU接收到invalid（无效）通知时，也会把接收到的消息放入「invalid queue」中，只要写到「invalid queue.」就会直接返回告诉修改数据的CPU已经将状态置为「invalid」</li>
<li>而异步又会带来新问题：那我现在CPU修改完A值，写到「store buffer」了，CPU就可以干其他事了</li>
<li>那如果该CPU又接收指令需要修改A值，但上一次修改的值还在「store buffer.」中呢，没修改至高速缓存呢。</li>
<li>所以CPU在读取的时候，需要去「storebuffer.」看看存不存在，存在则直接取，不存在才读主存的数据。【Store Forwarding】</li>
<li>好了，解决掉第一个异步带来的问题了。（相同的核心对数据进行读写，由于异步，很可能会导致第二次读取的还是旧值，所以首先读「store buffer」。</li>
<li>那当然啊，那「异步化」会导致相同核心读写共享变量有问题，那当然也会导致「不同」核心读写共享变量有问题啊</li>
<li>CPU1修改了A值，已把修改后值写到「store buffer.」并通知CPU2对该值进行invalid（无效）操作，而CPU2可能还没收到invalid（无效）通知，就去做了其他的操作，导致CPU2读到的还是旧值。</li>
<li>即便CPU2收到了invalid（无效）通知，但CPU1的值还没写到主存，那CPU2再次向主存读取的时候，还是旧值…</li>
<li>变量之间很多时候是具有「相关性」（a&#x3D;1；b&#x3D;0；b&#x3D;a），这对于CPU又是无感知的.…</li>
<li>总体而言，由于CPU对「缓存一致性协议」进行的异步优化「store buffer」「invalid queue.」，很可能导致后面的指令很可能查不到前面指令的执行结果（各个指令的执行顺序非代码执行顺序），这种现象很多时候被称作「CPU乱序执行」</li>
<li>为了解决乱序问题（也可以理解为可见性问题，修改完没有及时同步到其他的CPU），又引出了「内存屏障」的概念。</li>
<li>「内存屏障」其实就是为了解决「异步优化」导致「CPU乱序执行」&#x2F;「缓存不及时可见」的问题，那怎么解决的呢？嗯，就是把「异步优化」给”禁用“掉</li>
<li>内存屏障可以分为三种类型：写屏障，读屏障以及全能屏障（包含了读写屏障）</li>
<li>屏障可以简单理解为：在操作数据的时候，往数据插入一条”特殊的指令”。只要遇到这条指令，那前面的操作都得「完成」。</li>
<li>那写屏障就可以这样理解：CPU当发现写屏障的指令时，会把该指令「之前」存在于「store Buffer.」所有写指令刷入高速缓存。</li>
<li>通过这种方式就可以让CPU修改的数据可以马上暴露给其他CPU，达到「写操作」可见性的效果。</li>
<li>那读屏障也是类似的：CPU当发现读屏障的指令时，会把该指令「之前」存在于「invalid queue」所有的指令都处理掉</li>
<li>通过这种方式就可以确保当前CPU的缓存状态是准确的，达到「读操作」一定是读取最新的效果。</li>
</ul>
<h2 id="聊了半天，我一直在讲硬件-x2F-操作系统的东西，我要回到正题上了。"><a href="#聊了半天，我一直在讲硬件-x2F-操作系统的东西，我要回到正题上了。" class="headerlink" title="聊了半天，我一直在讲硬件&#x2F;操作系统的东西，我要回到正题上了。"></a>聊了半天，我一直在讲硬件&#x2F;操作系统的东西，我要回到正题上了。</h2><ul>
<li>由于不同CPU架构的缓存体系不一样、缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化Java开发人员的工作。Java封装了一套规范，这套规范就是「Java内存模型」</li>
<li>再详细地说，「Java内存模型」希望屏蔽各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果。</li>
<li>目的是解决多线程存在的原子性、可见性（缓存一致性）以及有序性问题。</li>
</ul>
<h2 id="那要不简单聊聊Java内存模型的规范和内容吧？"><a href="#那要不简单聊聊Java内存模型的规范和内容吧？" class="headerlink" title="那要不简单聊聊Java内存模型的规范和内容吧？"></a>那要不简单聊聊Java内存模型的规范和内容吧？</h2><p>下次</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>并发问题产生的三大根源是「可见性」「有序性」「原子性」</p>
</li>
<li><p>可见性：CPU架构下存在高速缓存，每个核心下的L1&#x2F;L2高速缓存不共享（不可见）</p>
</li>
<li><p>有序性：主要有三部分可能导致打破（编译器和处理器可以在不改变「单线程」程序语义的情况下，可以对代码语句顺序进行调整重新排序</p>
</li>
<li><ul>
<li>编译器优化导致重排序（编译器重排）</li>
<li>指令集并行重排序（CPU原生重排）</li>
<li>内存系统重排序（CPU架构下很可能有store buffer &#x2F;invalid queue 缓冲区，这种「异步」很可能会导致指令重排）</li>
</ul>
</li>
<li><p>原子性：Java的一条语句往往需要多条 CPU 指令完成(i++)，由于操作系统的线程切换很可能导致 i++ 操作未完成，其他线程“中途”操作了共享变量  i ，导致最终结果并非我们所期待的。</p>
</li>
<li><p>在CPU层级下，为了解决「缓存一致性」问题，有相关的“锁”来保证，比如“总线锁”和“缓存锁”。</p>
</li>
<li><ul>
<li>总线锁是锁总线，对共享变量的修改在相同的时刻只允许一个CPU操作。</li>
<li>缓存锁是锁缓存行(cache line)，其中比较出名的是MESI协议，对缓存行标记状态，通过“同步通知”的方式，来实现(缓存行)数据的可见性和有序性</li>
<li>但“同步通知”会影响性能，所以会有内存缓冲区(store buffer&#x2F;invalid queue)来实现「异步」进而提高CPU的工作效率</li>
<li>引入了内存缓冲区后，又会存在「可见性」和「有序性」的问题，平日大多数情况下是可以享受「异步」带来的好处的，但少数情况下，需要强「可见性」和「有序性」，只能”禁用”缓存的优化。</li>
<li>“禁用”缓存优化在CPU层面下有「内存屏障」，读屏障&#x2F;写屏障&#x2F;全能屏障，本质上是插入一条”屏障指令”，使得缓冲区(store buffer&#x2F;invalid queue)在屏障指令之前的操作均已被处理，进而达到 读写 在CPU层面上是可见和有序的。</li>
</ul>
</li>
<li><p>不同的CPU实现的架构不一样，Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>25、【对线面试官】java从编译到执行，发生了什么</title>
    <url>/posts/b7f54c91/</url>
    <content><![CDATA[<h1 id="25、【对线面试官】java从编译到执行，发生了什么"><a href="#25、【对线面试官】java从编译到执行，发生了什么" class="headerlink" title="25、【对线面试官】java从编译到执行，发生了什么"></a>25、【对线面试官】java从编译到执行，发生了什么</h1><h2 id="从基础先问起吧，你是怎么理解Java是一门「跨平台」的语言，也就是「一次编译，到处运行的」？"><a href="#从基础先问起吧，你是怎么理解Java是一门「跨平台」的语言，也就是「一次编译，到处运行的」？" class="headerlink" title="从基础先问起吧，你是怎么理解Java是一门「跨平台」的语言，也就是「一次编译，到处运行的」？"></a>从基础先问起吧，你是怎么理解Java是一门「跨平台」的语言，也就是「一次编译，到处运行的」？</h2><ul>
<li>因为有JVM</li>
<li>Java源代码会被编译为class文件，class文件是运行在JVM之上的。</li>
<li>当我们日常开发安装JDK的时候，可以发现JDK是分「不同的操作系统」，JDK里是包含JVM的，所以Java依赖着JVM实现了『跨平台』</li>
<li>通俗点来讲，JVM是面向操作系统的，它负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理。</li>
</ul>
<h2 id="那要不你来聊聊从源码文件（java）到代码执行的过程呗？"><a href="#那要不你来聊聊从源码文件（java）到代码执行的过程呗？" class="headerlink" title="那要不你来聊聊从源码文件（java）到代码执行的过程呗？"></a>那要不你来聊聊从源码文件（java）到代码执行的过程呗？</h2><ul>
<li><p>简单总结的话，我认为就4个步骤：编译-&gt;加载-&gt;解释-&gt;执行</p>
<ul>
<li><p>编译：将源码文件编译成JVM可以解释的class文件。</p>
<ul>
<li>编译过程会对源代码程序做「语法分析」「语义分析」「注解处理」等等处理，最后才生成字节码文件。</li>
<li>比如对泛型的擦除和我们经常用的Lombok就是在编译阶段干的。</li>
</ul>
</li>
<li><p>加载：将编译后的class文件加载到JVM中。</p>
<ul>
<li><p>在加载阶段又可以细化几个步骤：装载-&gt;连接-&gt;初始化</p>
<ul>
<li>【装载时机】为了节省内存的开销，并不会一次性把所有的类都装载至JVM，而是等到「有需要」的时候才进行装载（比如new和反射等等）</li>
<li>【装载发生】class文件是通过「类加载器」装载到jvm中的，为了防止内存中出现多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上）</li>
<li>【装载规则】JDK中的本地方法类一般由根加载器（Bootstrp loader）装载，JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</li>
</ul>
</li>
<li><p>装载这个阶段它做的事情总结：查找并加载类的二进制数据，在JVM「堆」中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM「方法区」中</p>
<ul>
<li>通过「装载」这个步骤后，现在已经把class文件装载到JVM中了，并创建出对应的Class.对象以及类信息存储至方法区了。</li>
</ul>
</li>
<li><p>「连接」这个阶段它做的事情总结：对class的信息进行验证、为「类变量」分配内存空间并对其赋默认值。</p>
<ul>
<li><p>连接又可以细化为几个步骤：验证-》准备-》解析</p>
<p>1.验证：验证类是否符合Java规范和JVM规范</p>
<p>2.准备：为类的静态变量分配内存，初始化为系统的初始值</p>
<p>3.解析：将符号引用转为直接引用的过程</p>
</li>
<li><p>通过「连接」这个步骤后，现在已经对class信息做校验并分配了内存空间和默认值了。</p>
</li>
</ul>
</li>
<li><p>「初始化」阶段总结：为类的静态变量赋予正确的初始值。</p>
<ul>
<li>过程大概就是收集class的静态变量、静态代码块、静态方法至clinit（）方法，随后从上往下开始执行。</li>
<li>如果「实例化对象」则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。</li>
</ul>
</li>
</ul>
</li>
<li><p>解释：把字节码转换为操作系统识别的指令</p>
<ul>
<li>在解释阶段会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器（JIT）</li>
<li>JVM会对「热点代码」做编译，非热点代码直接进行解释。当JVM发现某个方法或代码块的运行特别频繁的时候，就有可能把这部分代码认定为「热点代码」</li>
<li>使用「热点探测」来检测是否为热点代码。「热点探测」一般有两种方式，计数器和抽样。HotSpot使用的是「计数器」的方式进行探测，为每个方法准备了两类计数器：方法调用计数器和回边计数器</li>
<li>这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</li>
<li>即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言</li>
</ul>
</li>
<li><p>执行：操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</p>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>Java跨平台因为有JVM屏蔽了底层操作系统</p>
</li>
<li><p>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行</p>
</li>
<li><ul>
<li>「编译」经过 语法分析、语义分析、注解处理 最后才生成会class文件</li>
<li>「加载」又可以细分步骤为：装载-&gt;连接-&gt;初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析</li>
<li>「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度</li>
<li>「执行」调用系统的硬件执行最终的程序指令</li>
<li></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/36XlDf_20211229115158.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>26、【对线面试官】双亲委派机制</title>
    <url>/posts/3973d3db/</url>
    <content><![CDATA[<h1 id="26、【对线面试官】双亲委派机制"><a href="#26、【对线面试官】双亲委派机制" class="headerlink" title="26、【对线面试官】双亲委派机制"></a>26、【对线面试官】双亲委派机制</h1><h2 id="接着上次的话题吧，要不你来详细讲讲双亲委派机制？"><a href="#接着上次的话题吧，要不你来详细讲讲双亲委派机制？" class="headerlink" title="接着上次的话题吧，要不你来详细讲讲双亲委派机制？"></a>接着上次的话题吧，要不你来详细讲讲双亲委派机制？</h2><ul>
<li>上次提到了：class文件是通过「类加载器」装载至JVM中的</li>
<li>为了防止内存中存在多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载类，而是把请求委托给父加载器去完成，依次向上）</li>
<li>JDK中的本地方法类一般由根加载器（Bootstrp loader）装载JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载入而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/aWnCRl_20211229133925.png" alt="java类加载结构图"></p>
<h2 id="打破双亲委派机制是什么意思？"><a href="#打破双亲委派机制是什么意思？" class="headerlink" title="打破双亲委派机制是什么意思？"></a>打破双亲委派机制是什么意思？</h2><ul>
<li>很好理解啊，意思就是：只要我加载类的时候，不是从App ClassLoader-》ExtClassLoader-&gt;BootStrap ClassLoader这个顺序找，那就算是打破了啊</li>
<li>因为加载classi核心的方法在LoaderClass类的loadClass方法上（双亲委派机制的核心实现）</li>
<li>那只要我自定义个ClassLoader，重写loadClass方法（不依照往上开始寻找类加载器），那就算是打破双亲委派机制了。</li>
</ul>
<h2 id="那你知道有哪个场景破坏了双亲委派机制吗？"><a href="#那你知道有哪个场景破坏了双亲委派机制吗？" class="headerlink" title="那你知道有哪个场景破坏了双亲委派机制吗？"></a>那你知道有哪个场景破坏了双亲委派机制吗？</h2><ul>
<li>tomcat</li>
<li>部署项目时，会把war包放到tomcat的webapp下，这意味着一个tomcat可以运行多个Web应用程序<ul>
<li>那假设我现在有两个Web应用程序，它们都有一个类，叫做User，并且它们的类全限定名都一样，比如都是com.yyy.User。但是他们的具体实现是不一样的</li>
<li>那么Tomcat是如何保证它们是不会冲突的呢？</li>
</ul>
</li>
<li>答案就是，那就是tomcat做了Web应用层级的隔离。Tomcat给每个Web应用创建一个类加载器实例（WebAppClassLoader），该加载器重写了loadClass方法，优先加载当前应用目录下的类，如果当前找不到了，才一层一层往上找</li>
</ul>
<h2 id="Tomcat还有哪些类加载器吗？"><a href="#Tomcat还有哪些类加载器吗？" class="headerlink" title="Tomcat还有哪些类加载器吗？"></a>Tomcat还有哪些类加载器吗？</h2><ul>
<li><p>并不是Web应用程序下的所有依赖都需要隔离的，比如Redis，因为如果版本相同，没必要每个Web应用程序都独自加载一份，就可以Web应用程序之间共享</p>
<ul>
<li>做法也很简单，Tomcat就在WebAppClassLoader.上加了个父类加载器（SharedClassLoader），如果WebAppClassLoader自身没有加载到某个类，那就委托SharedClassLoader去加载。</li>
<li>（无非就是把需要应用程序之间需要共享的类放到一个共享目录下，Share ClassLoader读共享目录的类就好了）</li>
</ul>
</li>
<li><p>为了隔绝Web应用程序与Tomcat本身的类，又有类加载器（CatalinaClassLoader）来装载Tomcat本身的依赖</p>
</li>
<li><p>如果Tomcat本身的依赖和Web应用还需要共享，那么还有类加载器（CommonClassLoader）来装载进而达到共享</p>
</li>
<li><p>各个类加载器的加载目录可以到tomcat的catalina.properties配置文件上查看</p>
<center>Tomcat的类加载结构图</center>
![](https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Q0RM1Q_20211229140203.png)</li>
</ul>
<h2 id="JDBC你不是知道吗，听说它也是破坏了双亲委派模型的，你是怎么理解的？"><a href="#JDBC你不是知道吗，听说它也是破坏了双亲委派模型的，你是怎么理解的？" class="headerlink" title="JDBC你不是知道吗，听说它也是破坏了双亲委派模型的，你是怎么理解的？"></a>JDBC你不是知道吗，听说它也是破坏了双亲委派模型的，你是怎么理解的？</h2><ul>
<li><p>JDBC定义了接口。具体实现类由各个厂商进行实现嘛（比如MySQL）</p>
<ul>
<li>类加载有个规则：如里一个类由类加载器A加载那么，这个类的依赖类也是由「相同的类加载器」加载。</li>
<li>我们用JDBC的时候，是用DriverManager进而获取Connection，DriverManager在java.sql包下，显然是由BootStrap类加载器进行装载</li>
<li>当我们使用DriverManager.getConnection()时，得到的一定是厂商实现的类.</li>
<li>但因为这些实现类又不在java包中，BootStrap ClassLoaders并不能加载到各个厂商实现的类</li>
</ul>
</li>
<li><p>DriverManager的解决方案就是，在DriverManager切始化的时候，得到「线程上下文加载器」</p>
<ul>
<li>获取Connection的时候，是使用「线程上下文加载器」去加载Connection的，而这里的线程上下文加载器实际上还是App ClassLoader</li>
<li>所以在获取Connection的时候，还是先找ExtClassLoader和BootStrapClassLoader，只不过这两加载器肯定是加载不到的，最终会由AppClassLoader进行加载</li>
</ul>
</li>
</ul>
<ul>
<li>那这种情况，有的人觉得破坏了双亲委派机制，因为本来明明应该是由BootStrapClassLoader进行加载的，结果来了手「线程上下文加载器」，改掉了<br>类加载器</li>
<li>有的人觉得没破坏双亲委派机制，只是改成由「线程上下文加载器」进行类载，但还是遵守着：「依次往上找父类加载器进行加载，都找不到时才由自身加载」。认为“原则“上是没变的。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>前置知识</strong>：JDK中默认类加载器有三个：AppClassLoader、Ext ClassLoader、BootStrap ClassLoader。AppClassLoader的父加载器为Ext ClassLoader、Ext ClassLoader的父加载器为BootStrap ClassLoader。这里的父子关系并不是通过继承实现的，而是组合。</p>
<p><strong>什么是双亲委派机制</strong>：加载器在加载过程中，先把类交由父类加载器进行加载，父类加载器没找到才由自身加载。</p>
<p><strong>双亲委派机制目的</strong>：为了防止内存中存在多份同样的字节码（安全）</p>
<p><strong>类加载规则</strong>：如果一个类由类加载器A加载，那么这个类的依赖类也是由「相同的类加载器」加载。</p>
<p><strong>如何打破双亲委派机制</strong>：自定义ClassLoader，重写loadClass方法（只要不依次往上交给父加载器进行加载，就算是打破双亲委派机制）</p>
<p><strong>打破双亲委派机制案例</strong>：Tomcat</p>
<ol>
<li>为了Web应用程序类之间隔离，为每个应用程序创建WebAppClassLoader类加载器</li>
<li>为了Web应用程序类之间共享，把ShareClassLoader作为WebAppClassLoader的父类加载器，如果WebAppClassLoader加载器找不到，则尝试用ShareClassLoader进行加载</li>
<li>为了Tomcat本身与Web应用程序类隔离，用CatalinaClassLoader类加载器进行隔离，CatalinaClassLoader加载Tomcat本身的类</li>
<li>为了Tomcat与Web应用程序类共享，用CommonClassLoader作为CatalinaClassLoader和ShareClassLoader的父类加载器</li>
<li>ShareClassLoader、CatalinaClassLoader、CommonClassLoader的目录可以在Tomcat的catalina.properties进行配置</li>
</ol>
<p><strong>线程上下文加载器</strong>：由于类加载的规则，很可能导致父加载器加载时依赖子加载器的类，导致无法加载成功（BootStrap ClassLoader无法加载第三方库的类），所以存在「线程上下文加载器」来进行加载。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>27、【对线面试官】深入浅出Java内存模型</title>
    <url>/posts/e1774332/</url>
    <content><![CDATA[<h1 id="27、【对线面试官】深入浅出Java内存模型"><a href="#27、【对线面试官】深入浅出Java内存模型" class="headerlink" title="27、【对线面试官】深入浅出Java内存模型"></a>27、【对线面试官】深入浅出Java内存模型</h1><h2 id="上一次已经问过了为什么要有Java内存模型"><a href="#上一次已经问过了为什么要有Java内存模型" class="headerlink" title="上一次已经问过了为什么要有Java内存模型"></a>上一次已经问过了为什么要有Java内存模型</h2><ul>
<li>答案是：Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果</li>
<li>强调下：Java内存模型它是一种「规范」，Java虚拟机会实现这个规范。</li>
</ul>
<h2 id="先聊下Java内存模型的抽象结构？"><a href="#先聊下Java内存模型的抽象结构？" class="headerlink" title="先聊下Java内存模型的抽象结构？"></a>先聊下Java内存模型的抽象结构？</h2><ul>
<li>Java内存模型定义了：Java线程对内存数据进行交互的规范。<ul>
<li>线程之间的「共享变量」存储在「主内存」中，每个线程都有自己私有的「本地内存」，「本地内存」存储了该线程以读&#x2F;写共享变量的副本。</li>
<li>本地内存是Java内存模型的抽象概念，并不是真实存在的。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/xjTbHO_20211229144348.png"></p>
<ul>
<li>Java内存模型规定了：线程对变量的所有操作都必须在「本地内存」进行，「不能直接读写主内存」的变量<ul>
<li>Java内存模型定义了8种操作来完成「变量如何从主内存到本地内存，以及变量如何从本地内存到主内存」</li>
<li>分别是read&#x2F;load&#x2F;use&#x2F;assign&#x2F;store&#x2F;write&#x2F;lock&#x2F;unlock操作</li>
<li>对变量一个读写操作就涵盖这些操作</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/IIGEvs_20211229144725.png"></p>
<h2 id="happen-before规则"><a href="#happen-before规则" class="headerlink" title="happen-before规则"></a>happen-before规则</h2><ul>
<li><p>按我的理解下，happen-before实际上也是一套「规则」。Java内存模型定义了这套规则，目的是为了阐述「操作之间」的内存「可见性」</p>
<ul>
<li>从上次讲述「指令重排」就提到了，在CPU和编译器层面上都有指令重排的问题。</li>
</ul>
</li>
<li><p>但：在某些重要的场景下，这一组操作都不能进行重排序，「前面一个操作的结果对后续操作必须是可见的」。</p>
<ul>
<li><p>Java内存模型就提出了happen-before这套规则，规则总共有8条</p>
<ul>
<li>比如传递性、volatile变量规则、程序顺序规则、监视器锁的规则…</li>
</ul>
</li>
</ul>
</li>
<li><p>有了happen-before这些规则。我们写的代码只要在这些规则下，前一个操作的结果对后续操作是可见的，是不会发生重排序的。</p>
</li>
</ul>
<h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><ul>
<li><p>volatile是java的一个关键字</p>
</li>
<li><p>特性：可见性和有序性（禁止重排序）</p>
</li>
<li><p>java内存模型这个规范，很大程度下就为了解决可见性和有序性的问题。</p>
</li>
</ul>
<h2 id="volatile是怎么做到可见性和有序性的"><a href="#volatile是怎么做到可见性和有序性的" class="headerlink" title="volatile是怎么做到可见性和有序性的"></a>volatile是怎么做到可见性和有序性的</h2><ul>
<li><p>为了实现volatile有序性和可见性，定义了4种内存屏障的「规范」，</p>
</li>
<li><p>分别是LoadLoad&#x2F;LoadStore&#x2F;StroreLoad&#x2F;StoreStrore</p>
</li>
<li><p>本质上，就是在volatile前后加上了内存屏障，使得编译器和CPU无法进行重排序，致使有序，并且对volatile变量对其他线程可见</p>
</li>
<li><p>Hotspot虚拟机实现</p>
<ul>
<li>在「汇编」层面上实际是通过Lock前缀指令来实现的（lock支持大部分平台，而fence指令是x86平台的）</li>
<li>locK指令能保证：禁止CPU和编译器的重排序（保证了有序性）、保证CPU写核<br>  心的指令可以立即生效且其他核心的缓存数据失效（保证了可见性）。</li>
</ul>
</li>
</ul>
<h2 id="volatile和MESl协议是啥关系？"><a href="#volatile和MESl协议是啥关系？" class="headerlink" title="volatile和MESl协议是啥关系？"></a>volatile和MESl协议是啥关系？</h2><ul>
<li>没有直接关联</li>
<li>Java内存模型关注的是编程语言层面上，它是高维度的抽象。</li>
<li>MESI是CPU缓存一致性协议，不同的CPU架构都不一样，可能有的CPU压根就没用MESI协议.</li>
<li>只不过MESI名声大，大家就都拿他来举例子了。</li>
<li>MESI可能只是在「特定的场景下」为实现volatile的可见性&#x2F;有序性而使用到的一部分罢了</li>
<li>为了让Java程序员屏蔽上面这些底层知识，快速地入门使用volatile变量</li>
<li>Java内存模型的happen-before规则中就有对volatile变量规则的定义：对一个volatile变量的写操作相对于后续对这个volatile变量的读操作可见</li>
<li>只要变量声明了volatile关键字，写后再读，读必须可见写的值。（可见性、有序性）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>为什么存在Java内存模型</strong>：Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果</p>
<p><strong>Java内存模型抽象结构</strong>：线程之间的「共享变量」存储在「主内存」中，每个线程都有自己私有的「本地内存」，「本地内存」存储了该线程以读&#x2F;写共享变量的副本。线程对变量的所有操作都必须在「本地内存」进行，而「不能直接读写主内存」的变量</p>
<p><strong>happen-before规则</strong>：Java内存模型规定在某些场景下（一共8条），前面一个操作的结果对后续操作必须是可见的。这8条规则成为happen-before规则</p>
<p><strong>volatile</strong>：volatile是Java的关键字，修饰的变量是可见性且有序的（不会被重排序）。可见性&amp;&amp;有序性，由Java内存模型定义的「内存屏障」完成，实际HotSpot虚拟机实现Java内存模型规范，汇编底层是通过Lock指令来实现。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>28、【对线面试官】JVM内存模型</title>
    <url>/posts/6f64b3a6/</url>
    <content><![CDATA[<h1 id="28、【对线面试官】JVM内存模型"><a href="#28、【对线面试官】JVM内存模型" class="headerlink" title="28、【对线面试官】JVM内存模型"></a>28、【对线面试官】JVM内存模型</h1><h2 id="聊聊JVM的内存结构吧？"><a href="#聊聊JVM的内存结构吧？" class="headerlink" title="聊聊JVM的内存结构吧？"></a>聊聊JVM的内存结构吧？</h2><ul>
<li>class文件会被类加载器装载至JVM中，并且JVM会负责程序「运行时」的「内存管理」</li>
<li>而JVM的内存结构，往往指的就是JVM定义的「运行时数据区域」</li>
<li>简单来说就分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/VHXC3i_20211229151038.png"></p>
<h2 id="顺便讲下你这图上每个区域的内容"><a href="#顺便讲下你这图上每个区域的内容" class="headerlink" title="顺便讲下你这图上每个区域的内容"></a>顺便讲下你这图上每个区域的内容</h2><ul>
<li>程序计数器<ul>
<li>Java是多线程的语言，假设线程数大于CPU数，就很会有「线程切換」现象，切换意昧着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」</li>
<li>所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环跳转、异常、线程恢复等都依赖于计数器）</li>
</ul>
</li>
<li>虚拟机栈<ul>
<li>每个线程在创建的时候都会创建一个虚拟机栈，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址</li>
<li>作用：它保存方法的局部变量、部分变量的计算并参与了方法的调用和返回。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/GOLAU2_20211229151640.png"></p>
<ul>
<li><p>本地方法栈</p>
<ul>
<li>本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理Java函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。</li>
</ul>
</li>
<li><p>方法区</p>
<ul>
<li>前面提到了运行时数据区这个「分区」是JVM的「规范」，具体的落地实现，不同的虚拟机厂商可能是不一样的</li>
<li>所以「方法区」也只是JVM中规范的一部分</li>
<li>Hotspot虚拟机，就会常常提到「永久代」这个词。 Hotspotl虚拟机在「JDK8前」用「永久代」实现了「方法区」，而很多其他厂商的虚拟机其实是没有「永久代」的概念的</li>
<li>在JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了</li>
<li>方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池<ul>
<li>类信息又包括了类的版本、字段、方法、接口和父类等信息。</li>
<li>常量池又可以分「静态常量池」和「运行时常量池」<ul>
<li>静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。</li>
<li>「运行时常量池」存储的是「类加载」时生成的「直接引用」等信息</li>
<li>值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的</li>
<li>但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储</li>
<li>对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆</li>
</ul>
</li>
<li>总体来说，就是逻辑分区和物理实际存储的位置，是不一样的</li>
</ul>
</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li><p>「堆」是线程共享的区域，几乎类的实例和数组分配的内存都来自于它</p>
</li>
<li><p>「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为Eden和 Survivor区，最后 Survivor由From Survivor 和 To Survivor组成</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Xm317A_20211229152833.png"></p>
<h2 id="从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？"><a href="#从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？" class="headerlink" title="从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？"></a>从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？</h2><ul>
<li>最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。</li>
<li>按JDK8版本，总结起来其实就相当于：「类信息」是存储在「元空间」的（也有人把「类信息」这块叫做「类信息常量池」）</li>
<li>而「常量池」用JDK7开始，从「物理存储」角度上就在「堆中」，这是没有变化的。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5Ha0EV_20211229152636.png"></p>
<h2 id="JVM内存结构和Java內存模型有啥区别吧？"><a href="#JVM内存结构和Java內存模型有啥区别吧？" class="headerlink" title="JVM内存结构和Java內存模型有啥区别吧？"></a>JVM内存结构和Java內存模型有啥区别吧？</h2><ul>
<li>Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层（Java层面上）在操作内存时在不同的平台上也有相同的效果</li>
<li>JVM内存结构（又称为运行时数据区域），它描述着当我们的 class文件加载至虚拟机后，各个分区的「逻辑结构」是如何的，每个分区承担的作用</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>JVM内存结构组成</strong>：JVM内存结构又称为「运行时数据区域」。主要有五部分组成：虚拟机栈、本地方法栈、程序计数器、方法区和堆。其中方法区和堆是线程共享的。虚拟机栈、本地方法栈以及程序计数器是线程隔离的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>29、【对线面试官】垃圾回收机制</title>
    <url>/posts/9544a93a/</url>
    <content><![CDATA[<h1 id="29、【对线面试官】垃圾回收机制"><a href="#29、【对线面试官】垃圾回收机制" class="headerlink" title="29、【对线面试官】垃圾回收机制"></a>29、【对线面试官】垃圾回收机制</h1><h2 id="聊聊Java的垃圾回收机制"><a href="#聊聊Java的垃圾回收机制" class="headerlink" title="聊聊Java的垃圾回收机制?"></a>聊聊Java的垃圾回收机制?</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Xm317A_20211229152833.png"></p>
<ul>
<li>我们使用Java的时候，会创建很多对象，但我们未曾「手动」将这些对象进行清除,而如果用C++语言的时候，用完是需要自己free（释放）掉的</li>
<li>写Java的时候不用自己手动释放”垃圾”呢？原因很简单，JVM帮我们做了（自动回收垃圾）</li>
<li>垃圾的定义：只要对象不再被使用了，那我们就认为该对象就是垃圾，对象所占用的空间就可以被回收·</li>
</ul>
<h2 id="是怎么判断对象不再被使用的呢？"><a href="#是怎么判断对象不再被使用的呢？" class="headerlink" title="是怎么判断对象不再被使用的呢？"></a>是怎么判断对象不再被使用的呢？</h2><ul>
<li><p>常用的算法有两个「引用计数法」和「可达性分析法」</p>
<ul>
<li><p>引用计数法思路很简单：当对象被引用则+1，但对象引用失败则-1。当计数器为0时，说明对象不再被引用，可以被可回收</p>
</li>
<li><p>缺点就是：如果对象存在循环依赖，那就无法定位该对象，是否应该被回收（A依赖B，B依赖A）</p>
</li>
<li><p>是可达性分析法：它从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收</p>
<ul>
<li><p>「 GC Roots」是一组必须「活跃」的引用</p>
</li>
<li><p>从「 GC Root」出发，程序通过直接引用或者间接引用，能够找到可能正在被使用的对象</p>
<ul>
<li>比如：JVM内存结构中的虚拟机栈，虚拟机栈里的栈帧，栈帧中的局部变量，局部变量就存储着引用。</li>
<li>那如果栈帧位于虚拟机栈的栈顶，是不是说明这个栈帧是活跃的（换言之，是线程正在被调用的）</li>
<li>既然是线程正在调用的，那栈帧里的指向「堆」的对象引用，就一定是「活跃」的引用</li>
<li>所以，当前活跃的栈帧指向堆里的对象引用就可以是「 GC Roots」</li>
</ul>
</li>
<li><p>当然了，能作为「 GC Roots」也不单单只有上面那一块</p>
<ul>
<li>比如类的静态变量引用是「 GC Roots」，被「Java本地方法」所引用的对象也是「 GC Roots」等等</li>
</ul>
</li>
<li><p>「 GC Roots」是一组必须「活跃」的「引用」，只要跟「GC Roots」没有直接或者间接引用相连，那就是垃圾。JVM用的就是「可达性分析算法」来判断对象是否为垃圾</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="标记完，怎么删除的（垃圾回收算法）"><a href="#标记完，怎么删除的（垃圾回收算法）" class="headerlink" title="标记完，怎么删除的（垃圾回收算法）"></a>标记完，怎么删除的（垃圾回收算法）</h2><ul>
<li>标记清除<ul>
<li>缺点：直接清除会有「内存碎片」的问题：可能我有10M的空余内存，但程序申请9M内存空间却申请不下来（10M的内存空间是垃圾清除后的，不连续的）</li>
</ul>
</li>
<li>标记复制<ul>
<li>「标记」存活的对象「复制」到另一块空间，复制完了之后，直接把原有的整块空间给干掉！这样就没有内存碎片的问题了</li>
<li>缺点：内存利用率低，得有一块新的区域给我复制（移动）过去</li>
</ul>
</li>
<li>标记整理<ul>
<li>当前区域内进行移动，存活对象一到一边，垃圾移到一边，再统一删除，就不会有内存碎片了</li>
</ul>
</li>
</ul>
<h2 id="老年代、年轻代"><a href="#老年代、年轻代" class="headerlink" title="老年代、年轻代"></a>老年代、年轻代</h2><ul>
<li>大部分对象的生命周期都很短，而只有少部分对象可能会存活很长时间</li>
<li>回收垃圾的时候，程序是有短暂的时间不能正常继续运作啊。（JVM在回收的时候，用户线程不能继续分配修改引用），为了使「 stop the word」持续的时间尽可能短以及提高并发式GC所能应付的内存分配速率</li>
<li>所以很多的垃圾收集器上都会在「物理」或者「逻辑」上，把这两类对象进行区分<ul>
<li>死得快的对象所占的区域叫做「年轻代」，活得久的对象所占的区域叫做「老年代」</li>
<li>但也不是所有的「垃圾收集器」都会有，只不过我们现在线上用的可能都是JDK8，JDK8及以下所使用到的垃圾收集器都是有「分代」概念的</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul>
<li><p>垃圾回收的过程，其实就对应着几种「垃圾回收算法」分别是</p>
<ul>
<li>标记清除算法、标记复制算法和标记整理算法【「标记」「复制」「整理」】</li>
</ul>
</li>
<li><p>「年轻代」的垃圾收集器有： Seria、Parallel Scavenge、 Pardew</p>
<ul>
<li>年轻代的垃圾回收器使用的都是「标记复制算法」</li>
<li>所以在「堆内存」划分中，将年轻代划分出 Survivor区（ Survivor From和 ourvor To），目的就是为了有一块完整的内存空间供垃圾回收器进行拷贝（移动）</li>
<li>新对象则放入Eden区</li>
<li>堆内存大小默认比例：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/6qtuUz_20211229160130.png"></p>
</li>
<li><p>「老年代」的垃圾收集器有： Serial Old、 Parallel Old、CMS</p>
</li>
<li><p>Serial是单线程的， Parallel是多线程。这些垃圾收集器实际上就是「实现了」垃圾回收算法（标记复制、标记整理以及标记清除算法）</p>
</li>
<li><p>CMS是「JDK8之前」是比较新的垃圾收集器，它的特点是能够尽可能减少「stop the word」时间。在垃圾回收时让用户线程和GC线程能够并发执行」</p>
</li>
</ul>
<h2 id="新创建的对象一般是在「新生代」嘛，那在什么时候会到「老年代」中呢？"><a href="#新创建的对象一般是在「新生代」嘛，那在什么时候会到「老年代」中呢？" class="headerlink" title="新创建的对象一般是在「新生代」嘛，那在什么时候会到「老年代」中呢？"></a>新创建的对象一般是在「新生代」嘛，那在什么时候会到「老年代」中呢？</h2><ul>
<li>两种情况<ul>
<li>如果对象太大了，就会直接进入老年代（对象创建时就很大 或者 Survivor区没办法存下该对象）</li>
<li>如果对象太老了，那就会晋升至老年代（每发生一次 Monor GC，存活的对象年龄+1，达到默认值15则晋升老年代）或者（动态对象年龄判定可以进入老年代）</li>
</ul>
</li>
</ul>
<h2 id="那-Monor-GC什么时候会触发呢？"><a href="#那-Monor-GC什么时候会触发呢？" class="headerlink" title="那 Monor GC什么时候会触发呢？"></a>那 Monor GC什么时候会触发呢？</h2><ul>
<li>当Eden区空间不足时，就会触发 Monor GC</li>
</ul>
<h2 id="那在「年轻代」GC的时候，从-GC-Roots出发，那不也会扫描到「老年代」的对象吗？那那那-不就相当于全堆扫描吗？那这分代还有意义吗？"><a href="#那在「年轻代」GC的时候，从-GC-Roots出发，那不也会扫描到「老年代」的对象吗？那那那-不就相当于全堆扫描吗？那这分代还有意义吗？" class="headerlink" title="那在「年轻代」GC的时候，从 GC Roots出发，那不也会扫描到「老年代」的对象吗？那那那.不就相当于全堆扫描吗？那这分代还有意义吗？"></a>那在「年轻代」GC的时候，从 GC Roots出发，那不也会扫描到「老年代」的对象吗？那那那.不就相当于全堆扫描吗？那这分代还有意义吗？</h2><ul>
<li><p>JVM解决方案</p>
<ul>
<li>Hotspot虚拟机「老的GC」（G1以下）是要求整个GC堆在连续的地址空间上</li>
<li>所以会有一条分界线（一侧是老年代，另一侧是年轻代），所以可以通过「地址」就可以判断对象在哪个分代上、</li>
<li>当做 Monor GCI的时候，从 GC Roots出发，如果发现「老年代」的对象，那就不往下走了（ Monor GC对老年代的区域毫无兴趣）</li>
</ul>
</li>
</ul>
<h2 id="但又有个问题，那如果「年轻代」的对象被「老年代」引用了呢？（老年代对象持有年轻代对象的引用），那时候肯定是不能回收掉「年轻代」的对象的？"><a href="#但又有个问题，那如果「年轻代」的对象被「老年代」引用了呢？（老年代对象持有年轻代对象的引用），那时候肯定是不能回收掉「年轻代」的对象的？" class="headerlink" title="但又有个问题，那如果「年轻代」的对象被「老年代」引用了呢？（老年代对象持有年轻代对象的引用），那时候肯定是不能回收掉「年轻代」的对象的？"></a>但又有个问题，那如果「年轻代」的对象被「老年代」引用了呢？（老年代对象持有年轻代对象的引用），那时候肯定是不能回收掉「年轻代」的对象的？</h2><ul>
<li>解决方案<ul>
<li>Hotspot虚拟机下有「 card table」（卡表）来避免全局扫描「老年代」对象</li>
<li>「堆内存」的每一小块区域形成「卡页」，卡表实际上就是卡页的集合。当判断一个卡页中有存在对象的跨代引用时，将这个页标记为「脏页」</li>
<li>那知道了「卡表」之后，就很好办了。每次 Monor GC的时候只需要去「卡表找到「脏页」，找到后加入至 GC Root，而不用去遍历整个「老年代」的对象了。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>什么是垃圾</strong>：只要对象不再被使用，那即是垃圾</p>
<p><strong>如何判断为垃圾</strong>：可达性分析算法和引用计算算法，JVM使用的是可达性分析算法</p>
<p><strong>什么是GC Roots</strong>：GC Roots是一组必须活跃的引用，跟GC Roots无关联的引用即是垃圾，可被回收</p>
<p><strong>常见的垃圾回收算法</strong>：标记清除、标记复制、标记整理</p>
<p><strong>为什么需要分代</strong>：大部分对象都死得早，只有少部分对象会存活很长时间。在堆内存上都会在物理或逻辑上进行分代，为了使「stop the word」持续的时间尽可能短以及提高并发式GC所能应付的内存分配速率。</p>
<p><strong>Minor GC</strong>：当Eden区满了则触发，从GC Roots往下遍历，年轻代GC不关心老年代对象</p>
<p><strong>什么是card table</strong>【卡表】：空间换时间（类似bitmap），能够避免扫描老年代的所有对象，进而顺利进行Minor GC （案例：老年代对象持有年轻代对象引用）</p>
<p><strong>堆内存占比</strong>：年轻代占堆内存1&#x2F;3，老年代占堆内存2&#x2F;3。Eden区占年轻代8&#x2F;10，Survivor区占年轻代2&#x2F;10（其中From 和To 各站1&#x2F;10)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>2、【对线面试官】今天来聊聊Java泛型</title>
    <url>/posts/5a56f011/</url>
    <content><![CDATA[<p>#2、【对线面试官】今天来聊聊Java泛型</p>
<h2 id="泛型了解"><a href="#泛型了解" class="headerlink" title="泛型了解"></a>泛型了解</h2><ol>
<li>在Java中的泛型简单来说就是：在创建对象或调用方法的时候才明确下具体的类型</li>
<li>使用泛型的好处就是代码更加简洁（不再需要强制转换），程序更加健壮（在编译期间没有警告，在运行期就不会出现ClassCastException异常）</li>
</ol>
<h2 id="工作中用得多吗"><a href="#工作中用得多吗" class="headerlink" title="工作中用得多吗"></a>工作中用得多吗</h2><ol>
<li>在操作集合的时候，还是很多的，毕竟方便啊。List lists &#x3D; new ArrayList&lt;&gt;();lists.add （”面试造火箭”）；</li>
<li>如果是其他场景的话，那就是在写「基础组件」的时候了。</li>
</ol>
<h2 id="你是怎么写的"><a href="#你是怎么写的" class="headerlink" title="你是怎么写的"></a>你是怎么写的</h2><ol>
<li><p>再明确一下泛型就是「在创建对象或调用方法的时候才明确下具体的类型」</p>
</li>
<li><p>而组件为了做到足够的通用性，是不知道「用户」传入什么类型参数进来的所以在这种情况下用泛型就是很好的实践。</p>
</li>
<li><p>这块可以参考SpringData JPA的JpaRepository写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"> List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line"></span><br><span class="line"> List&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line"> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S entity)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> T <span class="title function_">getOne</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要写组件，还是离不开Java反射机制（能够从运行时获取信息），所以一般组件是泛型+反射来实现的。</p>
</li>
<li><p>回到我所讲的组件吧，背景是这样的：我这边有个需求，需要根据某些字段进行聚合。</p>
</li>
<li><p>换到SQL其实就是select sum（column 1),sum(column2) from table group by fie ld1,field2</p>
</li>
<li><p>需要sum和group by的列肯定是由业务方自己传入，而SQL的表其实就是我们的POJO（传入的字段也肯定是POJO的属性）</p>
</li>
<li><p>单个业务实际可以在参数上写死POJO，但为了做得更加通用，我把入参设置为泛型</p>
</li>
<li><p>拿到参数后，通过反射获取其字段具体的值，做累加就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 需要group by 和 sum 的字段名</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">cacheMap</span><span class="params">(List&lt;String&gt; groupByKeys, List&lt;String&gt; sumValues)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.groupByKeys = groupByKeys;</span><br><span class="line">  <span class="built_in">this</span>.sumValues = sumValues;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">(T e)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从pojo 取出需要group by 的字段 list</span></span><br><span class="line">  List&lt;Object&gt; key = buildPrimaryKey(e);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// primaryMap 是存储结果的Map</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> primaryMap.get(key);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果从存储结果找到有相应记录</span></span><br><span class="line">  <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String elem : sumValues) &#123;</span><br><span class="line">      <span class="comment">// 反射获取对应的字段，做累加处理</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(elem, e);</span><br><span class="line">      <span class="keyword">if</span> (field.get(e) <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        field.set(value, (Integer) field.get(e) + (Integer) field.get(value));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.get(e) <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        field.set(value, (Long) field.get(e) + (Long) field.get(value));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型异常,请处理异常&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理时间记录</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(<span class="string">&quot;updated&quot;</span>, value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != field) &#123;</span><br><span class="line">      field.set(value, DateTimeUtils.getCurrentTime());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// group by 字段 第一次进来</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      primaryMap.put(key, Tclone(e));</span><br><span class="line">      createdMap.put(key, DateTimeUtils.getCurrentTime());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;first put value error &#123;&#125;&quot;</span> , e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>理解了泛型的作用之后，再去审视自己代码时，就可以判断是否需要用到泛型了。</p>
</li>
</ol>
<h2 id="价值体现"><a href="#价值体现" class="headerlink" title="价值体现"></a>价值体现</h2><ol>
<li>主要是在平时工作中，写代码的时候会多想想，遇到能用到的地方会优化下代码</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>30、【对线面试官】CMS垃圾回收器</title>
    <url>/posts/6f559dce/</url>
    <content><![CDATA[<h1 id="30、【对线面试官】CMS垃圾回收器"><a href="#30、【对线面试官】CMS垃圾回收器" class="headerlink" title="30、【对线面试官】CMS垃圾回收器"></a>30、【对线面试官】CMS垃圾回收器</h1><h2 id="今天还是来聊聊CMS垃圾收集器呗？"><a href="#今天还是来聊聊CMS垃圾收集器呗？" class="headerlink" title="今天还是来聊聊CMS垃圾收集器呗？"></a>今天还是来聊聊CMS垃圾收集器呗？</h2><ul>
<li>如果用Seria和 Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直至垃圾回收结束！</li>
<li>CMS的全称： Concurrent Mark Sweep，翻译过来是「并发标记清除」</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/1u2iZp_20211229164510.png"></p>
<ul>
<li>用CMS对比上面的垃圾收集器（ Seria和Parllel和 parNew）：它最大的不同点就是「并发」：在GC线程工作的时候，用户线程「不会完全停止」，用户线程在「部分场景下」与GC线程一起并发执行</li>
<li>无论是什么垃圾收集器， Stop The Word&#x2F;是一定无法避免的！</li>
<li>CMS只是在「部分」的GC场景下可以让GC线程与用户线程并发执行</li>
<li>目的：为了避免「老年代GC」出现「长时间」的卡顿（ Stop The Word )</li>
</ul>
<h2 id="CMS工作流程"><a href="#CMS工作流程" class="headerlink" title="CMS工作流程"></a>CMS工作流程</h2><ul>
<li><p>CMS可以简单分为5个步骤：初始标记、并发标记、并发预清理、重新标记以及并发清除</p>
<ul>
<li><p>从步骤可看出，CMS主要是实现了「标记清除」垃圾回收算法</p>
</li>
<li><p>「初始标记」</p>
<ul>
<li>「初始标记」会标记 GCroots「直接关联」的对象以及「年轻代」指向「老年代」的对象</li>
<li>「初始标记」这个过程是会发生 Stop The Word的。但这个阶段的速度算是很快的，因为没有「向下追溯」（只标记一层）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FqsTqd_20211229162246.png"></p>
</li>
<li><p>「并发标记」</p>
<ul>
<li>「并发标记」这个过程是不会停止用户线程的（不会发生 Stop The Word）。这一阶段主要是从 GC Roots向下「追溯」，标记所有可达的对象</li>
<li>并发标记」在GC的角度而言，是比较耗费时间的（需要追溯）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/cUUH7w_20211229162544.png"></p>
</li>
<li><p>「并发预处理」</p>
<ul>
<li>「并发预处理」这个阶段主要是：希望能减少下一个阶段「重新标记」所消耗的时间</li>
<li>因为下一个阶段「重新标记」是需要Stop The World的，「并发标记」这个阶段由于用户线程是没有被挂起的，所以对象是有可能发生变化的</li>
<li>可能有些对象，从新生代晋升到了老年代。可能有些对象，直接分配到了老年代（大对象）。可能老年代或者新生代的对象引用发生了变化</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/NeI2CU_20211229163018.png"></p>
</li>
<li><p>「重新标记」</p>
<ul>
<li>「重新标记」阶段会 Stop The Word，这个过程的停顿时间其实很大程度上取决于上面「并发预处理」阶段</li>
<li>这是一个追赶的过程：边在标记存活对象，一边用户线程在执行产生垃圾）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/o97JPO_20211229163156.png"></p>
</li>
<li><p>「并发清除」</p>
<ul>
<li>一边用户线程在执行，一边GC线程在回收不可达的对象</li>
<li>这个过程，还是有可能用户线程在不断产生垃圾，但只能留到下一次GC进行处<br>理了，产生的这些垃圾被叫做“浮动垃圾”</li>
<li>完了以后会重置CMS算法相关的内部数据，为下一次GC循环做准备</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TJihOR_20211229163307.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="为什么要扫年轻代？"><a href="#为什么要扫年轻代？" class="headerlink" title="为什么要扫年轻代？"></a>为什么要扫年轻代？</h2><ul>
<li>CMS主要回收老年代的对象。年轻代有可能会指向老年代的对象，不扫就不知道是不是垃圾了</li>
</ul>
<h2 id="「并发预处理」问题解决"><a href="#「并发预处理」问题解决" class="headerlink" title="「并发预处理」问题解决"></a>「并发预处理」问题解决</h2><ul>
<li>针对老年代的对象，其实还是可以借助类 card table的存储（将老年代对象发生变化所对应的卡页标记为 dirty）</li>
<li>所以「并发预处理」这个阶段会扫描可能由于「并发标记」时导致老年代发生变化的对象，会再扫描一遍标记为diy的卡页</li>
<li>对于新生代的对象，我们还是得遍历新生代来看看在「并发标记」过程中有没有对象引用了老年代.</li>
<li>JVM里给我们提供了很多「参数」，有可能在这个过程中会触发一次minor GC（触发了 minor GC是意味着就可以更少地遍历新生代的对象）</li>
</ul>
<h2 id="相比G1，那你觉得CMS有什么缺点呢？"><a href="#相比G1，那你觉得CMS有什么缺点呢？" class="headerlink" title="相比G1，那你觉得CMS有什么缺点呢？"></a>相比G1，那你觉得CMS有什么缺点呢？</h2><ul>
<li><p>1.空间需要预留：CMS垃圾收集器可以一边回收垃圾，一边处理用户线程，那需要在这个过程中保证有充足的内存空间供用户使用。</p>
<ul>
<li>如果CMS运行过程中预留的空间不够用了，会报错（ Concurrent Mode Failure），这时会启动 Serial Old垃圾收集器进行老年代的垃圾回收，会导致停顿的时间很长</li>
</ul>
</li>
<li><p>2.内存碎片问题：CMS本质上是实现了「标记清除算法」的收集器（从过程就可以看得出），这会意味着会产生内存碎片</p>
<ul>
<li>由于碎片太多，又可能会导致内存空间不足所触发 full GC，CMS一般会在触发full GC这个过程对碎片进行整理</li>
<li>整理涉及到「移动」&#x2F;「标记」，那这个过程肯定会 Stop The Word的，如果内存足够大（意味着可能装载的对象足够多），那这个过程卡顿也是需要一定的时间的。</li>
</ul>
</li>
<li><p>使用CMS的弊端好像就是一个死循环</p>
<ul>
<li>1.内存碎片过多，导致空间利用率减低。</li>
<li>2.空间本身就需要预留给用户线程使用，现在碎片内存又加剧了空间的问题，导致有可能垃圾收集器降级为 Serial old，卡顿时间更长</li>
<li>3.要处理内存碎片的问题（整理），同样会卡顿</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>CMS把垃圾回收的过程给”细分”了，然后在某些阶段可以不停止用户线程，一边回收垃圾，一边处理请求，来减少每次垃圾回收时 Stop The Word的时间</p>
</li>
<li><p>中间也做了很多的优化（ dirty card标记、可能中途触发 minor gca等等，在我理解下，这些都提供了CMS的相关参数配置</p>
</li>
<li><p>CMS垃圾回收器设计目的：</p>
<ul>
<li>为了避免「老年代 GC」出现「长时间」的卡顿（Stop The World）</li>
</ul>
</li>
<li><p>CMS垃圾回收器回收过程：</p>
<ul>
<li>初始标记、并发标记、并发预处理、重新标记和并发清除。初始标记以及重新标记这两个阶段会Stop The World</li>
</ul>
</li>
<li><p>CMS垃圾回收器的弊端：</p>
<ul>
<li>会产生内存碎片&amp;&amp;需要空间预留：停顿时间是不可预知的</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KNqlDT_20211229164021.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>31、【对线面试官】G1垃圾收集器</title>
    <url>/posts/e93a2b49/</url>
    <content><![CDATA[<h1 id="31、【对线面试官】G1垃圾收集器"><a href="#31、【对线面试官】G1垃圾收集器" class="headerlink" title="31、【对线面试官】G1垃圾收集器"></a>31、【对线面试官】G1垃圾收集器</h1><h2 id="要不这次来聊聊G1垃圾收集器？"><a href="#要不这次来聊聊G1垃圾收集器？" class="headerlink" title="要不这次来聊聊G1垃圾收集器？"></a>要不这次来聊聊G1垃圾收集器？</h2><ul>
<li><p>CMS垃圾收集器的升级</p>
</li>
<li><p>G1垃圾收集器可以给你设定一个你希望Stop The Word停顿时间，G1垃圾收集器会根据这个时间尽量满足你</p>
<ul>
<li><p>在前面我在介绍JM堆的时候，堆的内存分布是以「物理」空间进行隔离</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/qjMhU8_20211229164725.png"></p>
</li>
<li><p>在G1垃圾收集器的世界上，堆的划分不再是「物理」形式，而是以「逻辑」的形式进行划分</p>
</li>
<li><p>不过的「分代」概念在G1垃圾收集器的世界还是一样奏效的</p>
</li>
<li><p>比如说：新对象一般会分配到Eden区经过默认15次的 Minor GC新生代的对象如果还存活，会移交到老年代等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/SwXVef_20211229165004.png"></p>
</li>
<li><p>堆被划分了多个同等份的区域，在G1里每个区域叫做Region</p>
</li>
<li><p>G1中，还有一种叫 Humongous（大对象）区域，其实就是用来存储特别大的对象（大于 Region内存的一半）</p>
</li>
<li><p>一旦发现没有引用指向大对象，就可直接在年轻代的 Minor GC中被回收掉</p>
</li>
<li><p>之所以要将「堆空间」进行「细分」多个小的区域，是因为像以前的垃圾收集器都是对堆进行「物理」划分，如果堆空间（内存）大的时候，每次进行「垃圾回收」都需要对一整块大的区域进行回收，那收集的时间是不好控制的；而划分多个小区域之后，那对这些「小区域」回收就容易控制它的「收集时间」了</p>
</li>
</ul>
</li>
</ul>
<h2 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h2><ul>
<li><p>在G1收集器中，可以主要分为有Minor GC（ Young GC）和 Mixed GC，也有些特殊场景可能会发生 Full GC</p>
<ul>
<li><p>Minor GC</p>
<ul>
<li><p>G1的 Minor GC其实触发时机跟前面提到过的垃圾收集器都是一样的</p>
</li>
<li><p>等到Eden区满了之后，会触发 Minor GC。 Minor GCI同样也是会发生 Stop The World的</p>
</li>
<li><p>要补充说明的是：在G1的世界里，新生代和老年代所占堆的空间是没那么固定的（会动态根据「最大停顿时间」进行调整）</p>
</li>
<li><p>这块会给我们提供参数进行配置就好了</p>
</li>
<li><p>所以，动态地改变收集年轻代 Region的个数可以「控制」 Minor GCI的开销</p>
</li>
<li><p>Minor GC我认为可以简单分为为三个步骤：根扫描、更新&amp;&amp;处理RSet、复制对象</p>
<p>1）第一步应该很好理解，因为这跟之前CMS是类似的，可以理解为初始标记的过程</p>
<p>2）第二步就是处理RSet的信息并且扫描，将老年代对象持有年轻代对象的相关引用都加入到 GC Roots下，避免被回收掉</p>
<p>​        涉及到「Rset」的概念</p>
<p>​    （1）上ー次我们聊CMS回收过程的时候，同样讲到了 Minor GC，它是通过「卡表」（ cart table）来避免全表扫描老年代的对象</p>
<p>​    （2）因为 Minor GC是回收年轻代的对象，但如果老年代有对象引用着年轻代，那这些被老年代引用的对象也不能回收掉</p>
<p>​    （3）同样的，在G1也有这种问题（毕竟是Minor GC）。CMS是卡表，而G1解决「跨代引用」的问题的存储一般叫做RSet</p>
<p>​    （4）只要记住，RSet这种存储在每个 Region都会有，它记录着「其他 Region引用了当前 Regiong的对象关系」</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/FpUxzX_20211229170010.png"></p>
<p>​    （5）对于年轻代的 Region，它的RSet只保存了来自老年代的引用（因为年轻代的没必要存储啊，自己都要做 Minor GC了</p>
<p>​    （6）而对于老年代的 Region来说，它的RSet也只会保存老年代对它的引用（在G1垃圾收集器，老年代回收之前，都会先对年轻代进行回收，所以没必要保存年轻代的引用）</p>
<p>3）第三步：把扫描之后存活的对象往「空的 Survivor区」或者老年代」存放，其他的Eden区进行清除</p>
<p>​    （1）这里要提下的是，在G1还有另一个名词，叫做CSet</p>
<p>​    （2）它的全称是 Collection Set，保存了一次GC中「将执行垃圾回收」的 Region。CSet中的所有存活对象都会被转移到别的可用 Region上</p>
<p>​    （3）在 Minor GC的最后，会处理下软引用、弱引用、 JNI Weak等引用，结束收集</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><p>总结起来就是：扫描、处理跨 Region引用、收集至CSet、复制清除、处理引用</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/WZo9bF_20211229170433.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="MixedGC过程"><a href="#MixedGC过程" class="headerlink" title="MixedGC过程"></a>MixedGC过程</h2><ul>
<li>当堆空间的占用率达到一定阈值后会触发 Mixed GC（默认45%，由参数决定）</li>
<li>Mixed GC会依赖「全局并发标记」统计后的 Region数据</li>
<li>「全局并发标记」它的过程跟CMS非常类型，步骤大概是：初始标记（STW）、并发标记、最终标记（ST）以及清理（ST）<ul>
<li>说明： Mixed GC它一定会回收年轻代，并会采集部分老年代的Region进行回收的，所以它是一个混合GC</li>
<li>「初始标记」，<ul>
<li>这个过程是「共用」了 Minor GC的 Stop The World（Mixed GC一定会发生 Minor GC），复用了「扫描 GC Roots的操作</li>
<li>在这个过程中，老年代和新生代都会扫</li>
<li>总的来说，「初始标记」这个过程还是比较快的，毕竟没有追溯遍历嘛</li>
</ul>
</li>
<li>「并发标记」<ul>
<li>这个阶段不会 Stop The World，GC线程与用户线程一起执行，GC线程负责收集各个 Region的存活对象信息</li>
<li>从 GC Roots往下追溯，査找整个堆存活的对象，比较耗时</li>
</ul>
</li>
<li>「重新标记」<ul>
<li>跟CMS又一样，标记那些在「并发标记」阶段发生变化的对象</li>
<li>CMS在「重新标记」阶段，应该会重新扫描所有的线程栈和整个年轻代作为root,G1不是<ul>
<li>在G1中解決「并发标记」阶段导致引用变更的问题，使用的是SATB算法</li>
<li>可以简单理解为：在GC开始的时候，它为存活的对象做了一次「快照」</li>
<li>在「并发阶段」时，把每一次发生引用关系变化时旧的引用值给记下来</li>
<li>然后在「重新标记」阶段只扫描着块「发生过变化」的引用，看有没有对象还是存活的，加入到「 GC Roots」上</li>
<li>不过SATB算法有个小的问题，就是：如果在开始时，G1就认为它是活的，那就在此次GC中不会对它回收，即便可能在「并发阶段」上对象已经变为了垃圾。</li>
<li>所以，G1也有可能会存在「浮动垃圾」</li>
<li>但是总的来说，对于G1而言，问题不大（毕竟它不是追求一次把所有的垃圾都清除掉，而是注重 Stop The Worlde时间）</li>
</ul>
</li>
</ul>
</li>
<li>「清理」<ul>
<li>这个阶段也是会 Stop The World的，主要清点和重置标记状态，会根据「停顿预模型」（其实就是设定的停顿时间），来决定本次GC回收多少 Region</li>
<li>一般来说， Mixed GC会选定所有的年轻代 Region，部分「回收价值高」的老年代 Region（回收价值高其实就是垃圾多）进行采集</li>
<li>最后 Mixed GC进行清除还是通过「拷贝」&#x2F;「复制」的方式去干的</li>
<li>所以在G1中，一次回收未必是将所有的垃圾进行回收的，G1会依据停顿时间做出选择 Region数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么时候发生full-GC"><a href="#什么时候发生full-GC" class="headerlink" title="什么时候发生full GC"></a>什么时候发生full GC</h2><ul>
<li>如果在 Mixed GC中无法跟上用户线程分配内存的速度，导致老年代填满无法继续进行 Mixed GC，就又会降级到 serial oldGC来收集整个 GC heap</li>
<li>其实跟CMS是非常类似的都是因为空间不足</li>
<li>不过uGC这个场景相较于CMS还是很少的，毕竟G1没有像CMS「内存碎片」这种问题</li>
</ul>
<h2 id="G1垃圾收集器特点："><a href="#G1垃圾收集器特点：" class="headerlink" title="G1垃圾收集器特点："></a><strong>G1垃圾收集器特点</strong>：</h2><ul>
<li>从原来的「物理」分代，变成现在的「逻辑」分代，将堆内存「逻辑」划分为多个Region</li>
<li>使用CSet来存储可回收Region的集合</li>
<li>使用RSet来处理跨代引用的问题（注意：RSet不保留 年轻代相关的引用关系）</li>
<li>G1可简单分为：Minor GC 和Mixed GC以及Full GC</li>
<li>【Eden区满则触发】Minor GC 回收过程可简单分为：(STW) 扫描 GC Roots、更新&amp;&amp;处理Rset、复制清除</li>
<li>全局并发标记的过程跟CMS过程差不多：初始标记（STW）、并发标记、最终标记（STW）以及清理（STW）</li>
<li>【整堆空间占一定比例则触发】Mixed GC 依赖「全局并发标记」，得到CSet(可回收Region)，就进行「复制清除」</li>
<li>使用SATB算法来处理「并发标记」阶段对象引用存在变更的问题</li>
<li><strong>亮点&amp;&amp;重点</strong>：提供可停顿时间参数供用户设置（<strong>G1会尽量满足该停顿时间来调整 GC时回收Region的数量</strong>）</li>
<li>R大描述G1原理的时候，他提到：从宏观的角度看G1，主要分为两块「<strong>全局并发标记</strong>」和「<strong>拷贝存活对象</strong>」</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>32、【对线面试官】如何实现幂等和去重？</title>
    <url>/posts/b8eb8241/</url>
    <content><![CDATA[<h1 id="如何实现去重和幂等"><a href="#如何实现去重和幂等" class="headerlink" title="如何实现去重和幂等"></a>如何实现去重和幂等</h1><h2 id="去重与幂等"><a href="#去重与幂等" class="headerlink" title="去重与幂等"></a>去重与幂等</h2><ul>
<li>区别<ul>
<li>「去重」是对请求或者消息在「一定时间内」进行去重「N次」</li>
<li>「幂等」则是保证请求或消息在「任意时间内」进行处理，都需要保证它的结果是一致</li>
</ul>
</li>
<li>以项目举例，我维护的「消息管理平台」是有「去重」的功能的：「5分钟相同内容消息去重」「1小时内模板去重」「一天内渠道达到N次阈值去重」.</li>
<li>再次强调下「幂等」和「去重」的本质：「唯一Key」+「存储」</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>不同的业务场景，唯一Key是不一样的，由业务決定</li>
<li>存储选择挺多的，比如「本地缓存」&#x2F;「 Redis」&#x2F;「 MYSQL」&#x2F;「 Hbase」等等，具体选取什么，也跟业务有关</li>
<li>比如说，在「消息管理平台」这个场景下，我存储选择的「 Redis」（读写性能优越）， Redis也有「过期时间」方便解决「一定时间内」的问题</li>
<li>而唯一Key，自然就是根据不同的业务构建不同的。</li>
<li>比如说「5分钟相同内容消息去重」，我直接MD5请求参数作为唯一Key。「1小时模板去重」则是「模板ID+ userid」作为唯一Key，「ー天内渠道去重」则是「渠道ID+ userid」作为唯一Key.</li>
</ul>
<h2 id="提到了「去重」了，你听过布隆过滤器吗？"><a href="#提到了「去重」了，你听过布隆过滤器吗？" class="headerlink" title="提到了「去重」了，你听过布隆过滤器吗？"></a>提到了「去重」了，你听过布隆过滤器吗？</h2><ul>
<li>布隆过滤器的底层数据结构可以理解为bitmap， bitmap也可以简单理解为是一个数组，元素只存储0和1，所以它占用的空间相对较小</li>
<li>当一个元素要存入 bitmap时，其实是要去看存储到 bitmap的哪个位置，这时一般用的就是「哈希算法」，存进去的位置标记为1</li>
<li>标记为1的位置表示存在，标记为0的位置标示不存在</li>
<li>布隆过滤器是可以以较低的空间占用来判断元素是否存在进而用于去重，但是它也有对应的缺点</li>
<li>只要使用哈希算法离不开「哈希冲突」，导致有存在「误判」的情况</li>
<li>在布隆过滤器中，如果元素判定为存在，那该元素「未必」真实存在。如果元素判定为不存在，那就肯定是不存在</li>
<li>这应该不用我多解释了吧？（结合「哈希算法」和「标记为1的位置表示存在，标记为0的位置表示不存在」这两者就能得出上面结论）</li>
<li>布隆过滤器也不能「删除」元素（也是哈希算法的局限性，在布隆过滤器中是不能准确定位一个元素的）</li>
<li>如果要用的话，布隆过滤器的实现可以直接上 guava已经实现好的，不过这个是单机的</li>
<li>而分布式下的布隆过滤器，一般现在会用 Redis，但也不是每个公司都会部暑布隆过潓器的 Redis版（还是有局限，像我以前公司就没有）</li>
<li>所以，目前我负责的项目都是没有用布隆过滤器的</li>
</ul>
<h2 id="去重开销大"><a href="#去重开销大" class="headerlink" title="去重开销大"></a>去重开销大</h2><ul>
<li>如果「去重」开销比较大，可以考虑建立「多层过滤」的逻辑</li>
<li>比如，先看看『本地缓存』能不能过滤一部分，剩下「强校验」交由『远程存储』（常见的 Redis或者DB）进行二次过滤</li>
</ul>
<h2 id="kafka场景"><a href="#kafka场景" class="headerlink" title="kafka场景"></a>kafka场景</h2><ul>
<li>当时你说在处理订单时实现了 at least one+幂等</li>
<li>幂等处理时：前置过滤使用的是 Redis，强一致校验时使用的是DB唯一索引，也是为了提高性能，唯一Key好像就是「订单编号+订单状态」</li>
</ul>
<h2 id="方案的场景适用"><a href="#方案的场景适用" class="headerlink" title="方案的场景适用"></a>方案的场景适用</h2><ol>
<li>一般我们需要对数据强一致性校验，就直接上 MYSQL（DB），毕竟有事务的支持</li>
<li>「本地缓存」如果业务适合，那可以作为一个「前置」判断</li>
<li>Redis高性能读写，前置判断和后置均可</li>
<li>而 Hbasel则一般用于庞大数据量的场景下（ Redis内存太贵，DB不够灵活也不适合单表存大量数据）</li>
</ol>
<h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><ul>
<li>至于幂等，一般的方案下存储还是「Redis」和「数据库」</li>
<li>最最最最常见的就是数据库「唯一索」来实现幂等（我所负责的好几个项目都是用这个）</li>
<li>构建「唯一Key」是业务相关的事了（一般是用自己的业务ID进行拼接，生成一个有意义”的唯一Key</li>
<li>当然，也有用「 Redis」和「 MYSQL」实现分布式锁来实现幂等的（：）</li>
<li>但 Redis’分布式锁是不能完全保证安全的，而MNSL实现分布式锁（乐观锁和悲观锁），不过还是看业务吧，我是没用到过的</li>
<li>网上有很多实现「幂等」的方案，本质上都是围绕着「存储」和「唯一Key」做了些变种，然后取了个名字</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>33、【对线面试官】Redis主从架构</title>
    <url>/posts/63b182f/</url>
    <content><![CDATA[<h1 id="33、【对线面试官】Redis主从架构"><a href="#33、【对线面试官】Redis主从架构" class="headerlink" title="33、【对线面试官】Redis主从架构"></a>33、【对线面试官】Redis主从架构</h1><h2 id="要不你来讲讲你公司的Redis是什么架构的咯？"><a href="#要不你来讲讲你公司的Redis是什么架构的咯？" class="headerlink" title="要不你来讲讲你公司的Redis是什么架构的咯？"></a>要不你来讲讲你公司的Redis是什么架构的咯？</h2><ul>
<li>我前公司的Redis架构是「分片集群」，使用的是「Proxy」层来对Key进行分流到不同的Redis服务器上</li>
<li>支持动态扩容、故障恢复等等…</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/exJQS5_20211229222731.png"></p>
<h2 id="那你来聊下Proxy-层的架构和基本实现原理？"><a href="#那你来聊下Proxy-层的架构和基本实现原理？" class="headerlink" title="那你来聊下Proxy.层的架构和基本实现原理？"></a>那你来聊下Proxy.层的架构和基本实现原理？</h2><ul>
<li><p>抱歉，这块由中间件团队负责，具体我也没仔细看过</p>
</li>
<li><p>不过，我可以给你讲讲现有常见开源的Redis架构</p>
<ul>
<li><p>在之前提到了Redis有持久化机制，即便Redis重启了，可以依靠RDB或者AOF文件对数据进行重新加载</p>
</li>
<li><p>但在这时，只有一台Redis服务器存储着所有的数据，此时如果Redis服务器「暂时」没办法修复了，那依赖Redis的服务就没了</p>
</li>
<li><p>所以，为了Redis「高可用」，现在基本都会给Redis做「备份」：多启一台Redis服务器，形成「主从架构」</p>
</li>
<li><p>「从服务器」的数据由「主服务器」复制过去，主从服务器的数据是一致的</p>
</li>
<li><p>如果主服务器挂了，那可以「手动」把「从服务器」升级为「主服务器」，缩短不可用时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/jCY34w_20211229225726.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="那「主服务器」是如何把自身的数据「复制」给「从服务器」的呢？"><a href="#那「主服务器」是如何把自身的数据「复制」给「从服务器」的呢？" class="headerlink" title="那「主服务器」是如何把自身的数据「复制」给「从服务器」的呢？"></a>那「主服务器」是如何把自身的数据「复制」给「从服务器」的呢？</h2><ul>
<li>「复制」也叫「同步」，在Redis使用的是「PSYNC」命令进行同步，该命令有两种模型：完全重同步和部分重同步</li>
<li>可以简单理解为：如果是第一次「同步」，从服务器没有复制过任何的主服务器，或者从服务器要复制的主服务器跟上次复制的主服务器不一样，那就会采用「完全重同步」模式进行复制</li>
<li>如果只是由于网络中断，只是「短时间」断连，那就会采用「部分重同步」模式进行复制</li>
<li>（假如主从服务器的数据差距实在是过大了，还是会采用「完全重同步」模式进行复制）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/8nL2eT_20211229225855.png"></p>
<h2 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h2><ul>
<li><p>主服务器要复制数据到从服务器，首先是建立Socket「连接」，这个过程会干一些信息校验啊、身份校验啊等事情</p>
</li>
<li><p>然后从服务器就会发「PSYNC」命令给主服务器，要求同步（这时会带「服务器ID」RUNID和「复制进度」offset参数。如果从服务器是新的，那就没有）</p>
</li>
<li><p>主服务器发现这是一个新的从服务器（因为参数没带上来），就会采用「完全重同步」模式，并把「服务器ID」（runld）和「复制进度」（offset）发给从服务器，从服务器就会记下这些信息。</p>
</li>
<li><p>随后，主服务器会在后台生成RDB文件，通过前面建立好的连接发给从服务器从服务器收到RDB文件后，首先把自己的数据清空，然后对RDB文件进行加载恢复</p>
</li>
<li><p>这个过程中，主服务器也没闲着（继续接收着客户端的请求）</p>
</li>
<li><p>主服务器把生成RDB文件「之后修改的命令」会用「ouffer.」记录下来，等到从服务器加载完RDB之后，主服务器会把「buffer.」记录下的命令都发给从服务器</p>
</li>
<li><p>这样一来，主从服务器就达到了数据一致性了（复制过程是异步的，所以数据是『最终一致性』）</p>
</li>
</ul>
<h2 id="那「部分重同步」的过程呢？"><a href="#那「部分重同步」的过程呢？" class="headerlink" title="那「部分重同步」的过程呢？"></a>那「部分重同步」的过程呢？</h2><ul>
<li><p>嗯，其实就是靠「offset」来进行部分重同步。每次主服务器传播命令的时候，都会把「offset」给到从服务器</p>
</li>
<li><p>主服务器和从服务器都会将「offset」保存起来（如果两边的offset存在差异，那么说明主从服务器数据未完全同步）</p>
</li>
<li><p>从服务器断连之后进行重连，就会发「PSYNC」命令给主服务器，同样也会带着RUNID和offset（重连之后，这些信息还是存在的）</p>
</li>
<li><p>主服务器收到命令之后，看RUNID是否能对得上，对得上，说明这可能以前就同步过一部分了</p>
</li>
<li><p>接着检查该「offset在主服务器里还是否存在（主服务器记录主从服务器offset的信息用的是环形buffer，如果该ouffer）满了，会覆盖以前的记录。而记录客户端的修改命令用的是另一个buffer）</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/4mdp0i_20211229230139.png"></p>
</li>
<li><p>如果从backlog_buffer找到了，那就把从缺失的一部分offer开始，把对应的修改命令发给从服务器</p>
</li>
<li><p>如果从环形ouffer（backlog._buffer）没找到，那只能使用「完全重同步」模式再次进行主从复制了</p>
<ul>
<li><p>懂了，无非就是有个关联关系记录下来，只不过存储是环形（可能会造成覆盖）</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/oGR8JD_20211229230354.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="Redis主库如果挂了，你还是得「手动」将从库升级为主库啊？你知道有什么办法能做到「自动」进行故障恢复吗？"><a href="#Redis主库如果挂了，你还是得「手动」将从库升级为主库啊？你知道有什么办法能做到「自动」进行故障恢复吗？" class="headerlink" title="Redis主库如果挂了，你还是得「手动」将从库升级为主库啊？你知道有什么办法能做到「自动」进行故障恢复吗？"></a>Redis主库如果挂了，你还是得「手动」将从库升级为主库啊？你知道有什么办法能做到「自动」进行故障恢复吗？</h2><ul>
<li><p>哨兵</p>
<ul>
<li><p>「哨兵」干的事情主要就是：监控（监控主服务器的状态）、选主（主服务器挂了，在从服务器选出一个作为主服务器）、通知（故障发送消息给管理员）和配置（作为配置中心，提供当前主服务器的信息）</p>
</li>
<li><p>可以把「哨兵」当做是运行在「特殊」模式下的Redis服务器，为了「高可用」，哨兵也是集群架构的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/iPv3vB_20211229230508.png"></p>
</li>
<li><p>首先它需要跟Redis主从服务器创建对应的连接（获取它们的信息）</p>
</li>
<li><p>每个哨兵不断地用ping命令看主服务器有没有下线，如果主服务器在「配置时间」内没有正常响应，那当前哨兵就「主观」认为该主服务器下线了</p>
</li>
<li><p>其他「哨兵」同样也会ping该主服务器，如果「足够多」（还是看配置）的哨兵认为该主服务器已经下线，那就认为「客观下线」，这时就要对主服务器执行故障转移操作。</p>
</li>
<li><p>「哨兵」之间会选出一个「领头」，选出领头的规则也比较多，总的来说就是先到先得（哪个快，就选哪个）</p>
</li>
<li><p>由「领头哨兵」对已下线的主服务器进行故障转移</p>
<ul>
<li>过程<ul>
<li>首先要在「从服务器」上挑选出一个，来作为主服务器</li>
<li>（这里也挑选讲究，比如：从库的配置优先级、要判断哪个从服务器的复制offset最大、RunID大小、跟master断开连接的时长…）</li>
<li>然后，以前的从服务器都需要跟新的主服务器进行「主从复制」</li>
<li>已经下线的主服务器，再次重连的时候，需要让他成为新的主服务器的从服务器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="了解，我想问问，Redis在主从复制和故障转移的过程中会导致数据丢失吗"><a href="#了解，我想问问，Redis在主从复制和故障转移的过程中会导致数据丢失吗" class="headerlink" title="了解，我想问问，Redis在主从复制和故障转移的过程中会导致数据丢失吗"></a>了解，我想问问，Redis在主从复制和故障转移的过程中会导致数据丢失吗</h2><ul>
<li><p>会的</p>
<ul>
<li><p>1）从上面的「主从复制」流程来看，这个过程是异步的（在复制的过程中：主服务器会一直接收请求，然后把修改命令发给从服务器）</p>
</li>
<li><p>假如主服务器的命令还没发完给从服务器，自己就挂掉了。这时候想要让从服务器顶上主服务器，但从服务器的数据是不全的</p>
</li>
<li><p>2）还有另一种情况就是：有可能哨兵认为主服务器挂了，但真实是主服务器并没有挂（网络抖动），而哨兵已经选举了一台从服务器当做是主服务器了，此时「客户端」还没反应过来，还继续写向旧主服务器写数据</p>
</li>
<li><p>等到旧主服务器重连的时候，已经被纳入到新主服务器的从服务器了…所以，那段时间里，客户端写进旧主服务器的数据就丢了</p>
</li>
</ul>
</li>
<li><p>上面这两种情况（主从复制延迟&amp;&amp;脑裂），都可以通过配置来「尽可能」避免数据的丢失</p>
</li>
<li><p>（达到一定的阈值，直接禁止主服务器接收写请求，企图减少数据丢失的风险）</p>
</li>
</ul>
<h2 id="要不再来聊聊Redis分片集群？"><a href="#要不再来聊聊Redis分片集群？" class="headerlink" title="要不再来聊聊Redis分片集群？"></a>要不再来聊聊Redis分片集群？</h2><ul>
<li>分片集群就是往每个Redis服务器存储一部分数据，所有的Redis服务器数据加起来，才组成完整的数据（分布式）</li>
<li>要想组成分片集群，那就需要对key进行「路由」（分片）<ul>
<li>现在一般的路由方案有两种：「客户端路由」（SDK）和「服务端路由」（Proxy）</li>
<li>客户端路由的代表（Redis Cluster），服务端路由的代表（Codis）</li>
<li>区别？</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Redis实现高可用</strong>：</p>
<ul>
<li>AOF&#x2F;RDB持久化机制</li>
<li>主从架构（主服务器挂了，手动由从服务器顶上）</li>
<li>引入哨兵机制自动故障转义</li>
</ul>
<p><strong>主从复制原理</strong>：</p>
<ul>
<li>PSYNC命令两种模式：完全重同步、部分重同步</li>
<li>完全重同步：主从服务器建立连接、主服务器生成RDB文件发给从服务器、主服务器不阻塞（相关修改命令记录至buffer）、将修改命令发给从服务器</li>
<li>部分重同步：从服务器断线重连，发送RunId和offset给主服务器，主服务器判断offset和runId，将还未同步给从服务器的offset相关指令进行发送</li>
</ul>
<p><strong>哨兵机制</strong>：</p>
<ul>
<li>哨兵可以理解为特殊的Redis服务器，一般会组成哨兵集群</li>
<li>哨兵主要工作是监控、告警、配置以及选主</li>
<li>当主服务器发生故障时，会「选出」一台从服务器来顶上「客观下线」的服务器，由「领头哨兵」进行切换</li>
</ul>
<p><strong>数据丢失</strong>：</p>
<ul>
<li>Redis的主从复制和故障转移阶段都有可能发生数据丢失问题（通过配置尽可能避免）</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>34、【对线面试官】Redis分片集群</title>
    <url>/posts/f4ff0293/</url>
    <content><![CDATA[<h1 id="34、【对线面试官】Redis分片集群"><a href="#34、【对线面试官】Redis分片集群" class="headerlink" title="34、【对线面试官】Redis分片集群"></a>34、【对线面试官】Redis分片集群</h1><h2 id="要不接着上一次的话题呗？聊下Redis的分片集群，先聊Redis-Clusters好咯？"><a href="#要不接着上一次的话题呗？聊下Redis的分片集群，先聊Redis-Clusters好咯？" class="headerlink" title="要不接着上一次的话题呗？聊下Redis的分片集群，先聊Redis Clusters好咯？"></a>要不接着上一次的话题呗？聊下Redis的分片集群，先聊Redis Clusters好咯？</h2><ul>
<li><p>基础</p>
<ul>
<li><p>在前面聊Redisl的时候，提到的Redis都是「单实例」存储所有的数据</p>
</li>
<li><p>1.主从模式下实现读写分离的架构，可以让多个从服务器承载「读流量」，但面对「写流量」时，始终是只有主服务器在抗。</p>
</li>
<li><p>2.「纵向扩展」升级Redis服务器硬件能力，但升级至一定程度下，就不划算了。</p>
</li>
<li><p>纵向扩展意味着「大内存」，Redis：持久化时的”成本”会加大（Redis做RDB持久化，是全量的，fork子进程时有可能由于使用内存过大，导致主线程阻塞时间过长）</p>
</li>
<li><p>所以，「单实例」是有瓶颈的这里的。单实例我指的是：某台Redis服务器存储着某业务的所有数据</p>
</li>
<li><p>「纵向扩展」不行，就「横向扩展」呗。</p>
</li>
<li><p>用多个Redis实例来组成一个集群，按照一定的规则把数据「分发」到不同的Redis实例上。当集群所有的Redis实例的数据加起来，那这份数据就是全的</p>
</li>
<li><p>其实就是「分布式」的概念（：只不过，在Redis.里，好像叫「分片集群」的人比较多？</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/UjVuJE_20211230101518.png"></p>
</li>
<li><p>从前面就得知了，要「分布式存储」，就肯定避免不了对数据进行「分发」（也是路由的意思）</p>
</li>
<li><p>从Redis Clusteri讲起吧，它的「路由」是做在客户端的（SDK已经集成了路由转发的功能）</p>
</li>
<li><p>Redis Cluster）对数据的分发的逻辑中，涉及到「哈希槽」（Hash Solt）的概念</p>
</li>
<li><p>Redis Cluster默认一个集群有16384个哈希槽，这些哈希槽会分配到不同的Redis实例中</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/wG6xGm_20211230101625.png"></p>
</li>
<li><p>至于怎么「瓜分」，可以直接均分，也可以「手动」设置每个Redis实例的哈希槽，全由我们来决定</p>
</li>
<li><p>重要的是，我们要把这16384个都得瓜分完，不能有剩余！</p>
</li>
<li><p>当客户端有数据进行写入的时候，首先会对key按照CRC16算法计算出16bit的值（可以理解为就是做hash），然后得到的值对16384进行取模</p>
</li>
<li><p>取模之后，自然就得到其中一个哈希槽，然后就可以将数据插入到分配至该哈希槽的Redis实例中</p>
</li>
</ul>
</li>
</ul>
<h2 id="那问题就来了，现在客户端通过hash算法算出了哈希槽的位置，那客户端怎么知道这个哈希槽在哪台Redis实例上呢？"><a href="#那问题就来了，现在客户端通过hash算法算出了哈希槽的位置，那客户端怎么知道这个哈希槽在哪台Redis实例上呢？" class="headerlink" title="那问题就来了，现在客户端通过hash算法算出了哈希槽的位置，那客户端怎么知道这个哈希槽在哪台Redis实例上呢？"></a>那问题就来了，现在客户端通过hash算法算出了哈希槽的位置，那客户端怎么知道这个哈希槽在哪台Redis实例上呢？</h2><ul>
<li>是这样的，在集群的中每个Redis实例都会向其他实例「传播」自己所负责的哈希槽有哪些。这样一来，每台Redis实例就可以记录着「所有哈希槽与实例」的关系了</li>
<li>有了这个映射关系以后，客户端也会「缓存」一份到自己的本地上，那自然客户端就知道去哪个Redis实例上操作</li>
</ul>
<h2 id="那我又有问题了，在集群里也可以新增画者删除Redis：实例啊，这个怎么整？（扩容、缩容很常见的操作）"><a href="#那我又有问题了，在集群里也可以新增画者删除Redis：实例啊，这个怎么整？（扩容、缩容很常见的操作）" class="headerlink" title="那我又有问题了，在集群里也可以新增画者删除Redis：实例啊，这个怎么整？（扩容、缩容很常见的操作）"></a>那我又有问题了，在集群里也可以新增画者删除Redis：实例啊，这个怎么整？（扩容、缩容很常见的操作）</h2><ul>
<li>当集群删除或者新增Redis实例时，那总会有某Redis实例所负责的哈希槽关系会发生变化</li>
<li>发生变化的信息会通过消息发送至整个集群中，所有的Redis实例都会知道该变化，然后更新自己所保存的映射关系</li>
<li>但这时候，客户端其实是不感知的</li>
<li>所以，当客户端请求时某Key时，还是会请求到「原来」的Redis实例上。</li>
<li>而原来的Redis实例会返回「noved」命令，告诉客户端应该要去新的Redis：实例上去请求啦</li>
<li>客户端接收到「moved」命令之后，就知道去新的Redis实例请求了，并且更新客户端自身「哈希槽与实例之间的映射关系」</li>
<li>总结起来就是：数据迁移完毕后被响应，客户端会收到「moved」命令，并且会更新本地缓存</li>
<li>那数据还没完全迁移完呢？</li>
<li>如果数据还没完全迁移完，那这时候会返回客户端「ask」命令。也是让客户端去请求新的Redis实例，但客户端这时候不会更新本地缓存</li>
</ul>
<h2 id="那你知道为什么哈希槽是16384个吗？"><a href="#那你知道为什么哈希槽是16384个吗？" class="headerlink" title="那你知道为什么哈希槽是16384个吗？"></a>那你知道为什么哈希槽是16384个吗？</h2><ul>
<li>嗯，这个。是这样的，Redis：实例之间「通讯」会相互交换「槽信息」，那如果槽过多（意味着网络包会变大），网络包变大，那是不是就意味着会「过度占用」网络的带宽</li>
<li>另外一块是，Redis作者认为集群在一般情况下是不会超过1000个实例</li>
<li>那就取了16384个，即可以将数据合理打散至Redis：集群中的不同实例，又不会在交换数据时导致带宽占用过多</li>
</ul>
<h2 id="那你知道为什么对数据进行分区在Redis中用的是「哈希槽」这种方式吗？而不是一致性哈希算法"><a href="#那你知道为什么对数据进行分区在Redis中用的是「哈希槽」这种方式吗？而不是一致性哈希算法" class="headerlink" title="那你知道为什么对数据进行分区在Redis中用的是「哈希槽」这种方式吗？而不是一致性哈希算法"></a>那你知道为什么对数据进行分区在Redis中用的是「哈希槽」这种方式吗？而不是一致性哈希算法</h2><ul>
<li>在我理解下，一致性哈希算法就是有个「哈希环」，当客户端请求时，会对Key进行hash，确定在哈希环上的位置，然后顺时针往后找，找到的第一个节点</li>
<li>一致性哈希算法比「传统固定取模」的好处就是：如果集群中需要新增或删除某实例，只会影响一小部分的数据</li>
<li>但如果在集群中新增或者删除实例，在一致性哈希算法下，就得知道是「哪一部分数据」受到影响了，需要进行对受影响的数据进行迁移</li>
<li>而哈希槽的方式，我们通过上面已经可以发现：在集群中的每个实例都能拿到槽位相关的信息（去中心化）</li>
<li>当客户端对key进行hash运算之后，如果发现请求的实例没有相关的数据，实例会返回「重定向」命令告诉客户端应该去哪儿请求</li>
<li>集群的扩容、缩容都是以「哈希槽」作为基本单位进行操作，总的来说就是「实现」会更加简单（简洁，高效，有弹性）</li>
<li>过程大概就是把部分槽进行重新分配，然后迁移槽中的数据即可，不会影响到集群中某个实例的所有数据。</li>
</ul>
<h2 id="那你了解「服务端路由」的大致原理吗？"><a href="#那你了解「服务端路由」的大致原理吗？" class="headerlink" title="那你了解「服务端路由」的大致原理吗？"></a>那你了解「服务端路由」的大致原理吗？</h2><ul>
<li><p>嗯，服务端路由一般指的就是，有个代理层专门对接客户端的请求，然后再转发到Redis集群进行处理</p>
</li>
<li><p>上次最后面试的时候，也提到了，现在比较流行的是Codis</p>
</li>
<li><p>它与Redis Clusteri最大的区别就是，Redis Cluster是直连Redis实例的，而Codis则客户端直连Proxy，再由Proxy进行分发到不同的Redis实例进行处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/5iNRXA_20211230102232.png"></p>
</li>
<li><p>在Codis对Key路由的方案跟Redis Cluster很类似，Codis初始化出1024个哈希槽，然后分配到不同的Redis服务器中</p>
</li>
<li><p>哈希槽与Redis实例的映射关系由Zookeeper进行存储和管理，Proxy会通过CodisDashBoard得到最新的映射关系，并缓存在本地上</p>
</li>
</ul>
<h2 id="那如果我要扩容Codis-Redis实例的流程是怎么样的？"><a href="#那如果我要扩容Codis-Redis实例的流程是怎么样的？" class="headerlink" title="那如果我要扩容Codis Redis实例的流程是怎么样的？"></a>那如果我要扩容Codis Redis实例的流程是怎么样的？</h2><ul>
<li>简单来说就是：把新的Redis：实例加入到集群中，然后把部分数据迁移到新的实例上</li>
<li>大概的过程就是：<ul>
<li>1.「原实例」某一个Solt的部分数据发送给「目标实例」</li>
<li>2.「目标实例」收到数据后，给「原实例」返回ack</li>
<li>3.「原实例」收到ack之后，在本地删除掉刚刚给「目标实例」的数据</li>
<li>4.不断循环1、2、3步骤，直至整个solt迁移完毕</li>
</ul>
</li>
<li>Codis和Redis Cluster迁移的步骤都差不多的</li>
<li>不过Codis：是支持「异步迁移」的，针对上面的步骤2，「原实例」发送数据后，不等待「目标实例」返回ack，就可以继续接收客户端的请求</li>
<li>未迁移完的数据标记为「只读」，就不会影响到数据的一致性</li>
<li>如果对迁移中的数据存在「写操作」，那会让客户端进行「重试」，最后会写到「目标实例」上</li>
<li>还有就是，针对bigkey，异步迁移采用了「拆分指令」的方式进行迁移，比如有个set元素有10000个，那「原实例」可能就发送10000条命令给「目标实例」，而不是一整个bigkey一次性迁移（因为大对象容易造成阻塞）</li>
</ul>
<h2 id="Redis-Cluster和Codis的总体区别"><a href="#Redis-Cluster和Codis的总体区别" class="headerlink" title="Redis Cluster和Codis的总体区别"></a>Redis Cluster和Codis的总体区别</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/EArvDs_20211230102555.png"></p>
<h2 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h2><ul>
<li>说白了就是，如果集群Redis实例存在变动，由于Redis实例之间会「通讯」</li>
<li>所以等到客户端请求时，Redis实例总会知道客户端所要请求的数据在哪个Redis实例上</li>
<li>如果已经迁移完毕了，那就返回「move」命令告诉客户端应该去找哪个Redis实例要数据，并且客户端应该更新自己的缓存（映射关系）</li>
<li>如果正在迁移中，那就返回「ack」命令告诉客户端应该去找哪个Redis实例要数据</li>
</ul>
<h2 id="总结2"><a href="#总结2" class="headerlink" title="总结2"></a>总结2</h2><p><strong>分片集群诞生理由</strong>：写性能在高并发下会遇到瓶颈&amp;&amp;无法无限地纵向扩展（不划算）</p>
<p><strong>分片集群</strong>：需要解决「数据路由」和「数据迁移」的问题</p>
<p><strong>Redis Cluster数据路由</strong>：</p>
<ul>
<li>Redis Cluster默认一个集群有16384个哈希槽，哈希槽会被分配到Redis集群中的实例中</li>
<li>Redis集群的实例会相互「通讯」，交互自己所负责哈希槽信息（最终每个实例都有完整的映射关系）</li>
<li>当客户端请求时，使用CRC16算法算出Hash值并模以16384，自然就能得到哈希槽进而得到所对应的Redis实例位置</li>
</ul>
<p><strong>为什么16384个哈希槽</strong>：16384个既能让Redis实例分配到的数据相对均匀，又不会影响Redis实例之间交互槽信息产生严重的网络性能开销问题</p>
<p><strong>Redis Cluster 为什么使用哈希槽，而非一致性哈希算法</strong>：哈希槽实现相对简单高效，每次扩缩容只需要动对应Solt（槽）的数据，一般不会动整个Redis实例</p>
<p><strong>Codis数据路由</strong>：默认分配1024个哈希槽，映射相关信息会被保存至Zookeeper集群。Proxy会缓存一份至本地，Redis集群实例发生变化时，DashBoard更新Zookeeper和Proxy的映射信息</p>
<p><strong>Redis Cluster和Codis数据迁移</strong>：Redis Cluster支持同步迁移，Codis支持同步迁移&amp;&amp;异步迁移</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>35、【对线面试官】系统需求多变时，如何设计</title>
    <url>/posts/89b0310a/</url>
    <content><![CDATA[<h1 id="35、【对线面试官】系统需求多变时，如何设计"><a href="#35、【对线面试官】系统需求多变时，如何设计" class="headerlink" title="35、【对线面试官】系统需求多变时，如何设计"></a>35、【对线面试官】系统需求多变时，如何设计</h1><h2 id="我现在有个系统会根据请求的入参，做出不同动作。但是，这块不同的动作很有可能是会发生需求变动的，这块系统你会怎么样设计？"><a href="#我现在有个系统会根据请求的入参，做出不同动作。但是，这块不同的动作很有可能是会发生需求变动的，这块系统你会怎么样设计？" class="headerlink" title="我现在有个系统会根据请求的入参，做出不同动作。但是，这块不同的动作很有可能是会发生需求变动的，这块系统你会怎么样设计？"></a>我现在有个系统会根据请求的入参，做出不同动作。但是，这块不同的动作很有可能是会发生需求变动的，这块系统你会怎么样设计？</h2><h2 id="实际的例子：现在有多个第三方渠道，系统需要对各种渠道进行订单归因"><a href="#实际的例子：现在有多个第三方渠道，系统需要对各种渠道进行订单归因" class="headerlink" title="实际的例子：现在有多个第三方渠道，系统需要对各种渠道进行订单归因"></a>实际的例子：现在有多个第三方渠道，系统需要对各种渠道进行订单归因</h2><h2 id="但是归因的逻辑很有可能会发生变化，不同的渠道归因的逻辑也不太一样，此时系统里的逻辑相对比较复杂"><a href="#但是归因的逻辑很有可能会发生变化，不同的渠道归因的逻辑也不太一样，此时系统里的逻辑相对比较复杂" class="headerlink" title="但是归因的逻辑很有可能会发生变化，不同的渠道归因的逻辑也不太一样，此时系统里的逻辑相对比较复杂"></a>但是归因的逻辑很有可能会发生变化，不同的渠道归因的逻辑也不太一样，此时系统里的逻辑相对比较复杂</h2><h2 id="如果让你优化一下，你会怎么设计？"><a href="#如果让你优化一下，你会怎么设计？" class="headerlink" title="如果让你优化一下，你会怎么设计？"></a>如果让你优化一下，你会怎么设计？</h2><ul>
<li><p>问题转化</p>
<ul>
<li>归根到底，就是处理的逻辑相对复杂，if else的判断太多了</li>
<li>虽然新的需求来了，都可以添加if else进行解决</li>
<li>但你想要的就是，系统的可扩展性和可维护性更强</li>
<li>想要我这边出一个方案，来解决类似的问题</li>
</ul>
</li>
<li><p>回答</p>
<ul>
<li><p>在这之前，一般上网搜如何解决if else，大多数都说是策略模式</p>
</li>
<li><p>但是举的例子我又没感同身受，很多时候看完就过去了</p>
</li>
<li><p>实际上，在项目里边，用策略模式还是蛮多的，可能无意间就已经用上了（毕竟面向接口编程嘛）</p>
</li>
<li><p>而我认为，策略模式不是解决if else的关键</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/HPysDw_20211230104621.png"></p>
</li>
<li><p>这个问题，我的项目里的做法是：责任链模式</p>
<ul>
<li><p>把每个流程单独抽取成一个Process（可以理解为一个模块或节点），然后请求都会塞进Context中</p>
</li>
<li><p>比如，之前维护过一个项目，也是类似于不同的渠道走不同的逻辑</p>
</li>
<li><p>我们这边的做法是：抽取相关的逻辑到Process中，为不同的渠道分配不同的责任链</p>
</li>
<li><p>比如渠道A的责任链是：WhiteListProcess-&gt;DataAssembleProcess-&gt;ChannelAProcess-&gt;SendProcess</p>
</li>
<li><p>而渠道B的责任链是：WhiteListProcess-&gt;DataAssembleProcess-&gt;ChannelBProcess-&gt;SendProcess</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/3IQouH_20211230104740.png"></p>
</li>
<li><p>在责任链基础之上，又可以在代码里内嵌「脚本」</p>
</li>
<li><p>比如在SendProcess上，内置发送消息的脚本（脚本可以选择不同的运营商进行发送消息）。有了「脚本」以后，那就可以做到对逻辑的改动不需要重启就可以生效。</p>
</li>
<li><p>有人把这一套东西叫做「规则引擎」</p>
</li>
<li><p>比如，规则引擎中比较出名的实现框架「Drools」就可以做到类似的事</p>
</li>
<li><p>把易改动的逻辑写在「脚本」上（至少我们认为，脚本和我们的应用真实逻辑是分离）</p>
</li>
<li><p>（脚本我这里指的是规则集，它可以是Drools的dsl，也可以是Groovy，也可以是aviator等等）</p>
</li>
<li><p>在我之前的公司，使用的是Groovyl脚本</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="具体怎么做的"><a href="#具体怎么做的" class="headerlink" title="具体怎么做的"></a>具体怎么做的</h2><ul>
<li><p>大致的实现逻辑就是：有专门后台对脚本进行管理，然后会把脚本写到「分布式配置中心」（实时刷新），客户端监听「分布式配置中心」所存储的脚本是否有改动</p>
</li>
<li><p>如果存在改动，则通过Groovy类加载器重新编译并加载脚本，最后放到Spring容器对外使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/Kpog15_20211230104940.png"></p>
</li>
<li><p>我目前所负责的系统就是这样处理多变以及需求变更频繁的业务（责任链+规则引擎）</p>
</li>
<li><p>不过据我了解，我们的玩法业务在实现上在「责任链」多做了些事情（所谓的可配置化）</p>
</li>
<li><p>「责任链」不再从代码里编写，而是下沉到平台去做「服务编排」，就是由程序员去「服务编排后台」上配置信息（配置责任链的每一个节点）</p>
</li>
<li><p>在业务系统里使用「服务编排」的客户端，请求时只要传入「服务编排」的ID，就可以按「服务编排」的流程执行代码</p>
</li>
<li><p>这样做的好处就是：业务链是在后台配置的，不用在系统业务上维护链，灵活性更高（写好的责任链节点可以随意组合）</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/30jP6P_20211230105053.png"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到这道题之后，其实我当时答得不太行（当时只是简单说了下责任链和脚本）</p>
<p>于是面试题发给前同事A，让他给我出出意见，同事A给我回答的内容是：「<strong>抽象，模块化，配置化</strong>」</p>
<p>光看这几个词，他说得也没错，但我理解不了。让他具体点，他也不展开了</p>
<p>于是，我又厚着脸皮去找别的前同事B，得出的回答是：</p>
<ul>
<li>「<strong>是否可以做成配置化、动态替换、插件式、不需要人去开发</strong>」</li>
<li>「<strong>规则引擎</strong>」</li>
</ul>
<p>当我问他，什么是「规则引擎」时，反手就被教育了，<strong>问我到底这两年学了什么，这都不懂，这也太菜了</strong>。</p>
<p>有了”方向”以后，我花了点时间去搜了下「<strong>规则引擎</strong>」的资料，顺便入门了下「Drools」，发现这玩意不就类似于我之前在公司用的Groovy脚本平台</p>
<p>（当时还在纳闷想为啥那后台的名字叫做规则平台）…</p>
<p>于是又去简单翻了下我们的Groovy脚本平台是怎么实现这套东西的</p>
<p>「服务编排」这块之前在公司里因为项目的缘故，自己也没接入过，但一直听有其他的团队在用，顺便也简单看了下代码（：</p>
<p>后来再去找同事B时，他说现在自己公司用的是「<strong>流程引擎</strong>」，画图就ok了</p>
<p><strong>其实，搞了半天，还是写if else 舒服!</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>36、【对线面试官】设计模式</title>
    <url>/posts/2b7e87b2/</url>
    <content><![CDATA[<h1 id="36、【对线面试官】设计模式"><a href="#36、【对线面试官】设计模式" class="headerlink" title="36、【对线面试官】设计模式"></a>36、【对线面试官】设计模式</h1><h2 id="熟悉哪些常见的设计模式？"><a href="#熟悉哪些常见的设计模式？" class="headerlink" title="熟悉哪些常见的设计模式？"></a>熟悉哪些常见的设计模式？</h2><ul>
<li>常见的工厂模式、代理模式、模板方法模式、责任链模式、单例模式、包装设计模式、策略模式等都是有所了解的</li>
<li>项目手写代码用得比较多的，一般就模板方法模式、责任链模式、策略模式、单例模式吧</li>
<li>像工厂模式、代理模式这种，手写倒是不多，但毕竟Java后端一般环境下都用Spring嘛，所以还是比较熟悉的</li>
</ul>
<h2 id="手写单例模式"><a href="#手写单例模式" class="headerlink" title="手写单例模式"></a>手写单例模式</h2><ul>
<li>单例模式一般会有好几种写法<ul>
<li>饿汉式、简单懒汉式（在方法声明时加锁）、DCL双重检验加锁（进阶懒汉式）、静态内部类（优雅懒汉式）、枚举</li>
<li>所谓「饿汉式」指的就是还没被用到，就直接初始化了对象。所谓「懒汉式」指的就是等用到的时候，才进行初始化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DCL懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="comment">//第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton1 singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123; <span class="comment">//线程1，2，3到达这里</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton1.class)&#123;<span class="comment">//线程1到这里开始继续往下执行，线程2，3等待</span></span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;<span class="comment">//线程1到这里发现instance为空，继续执行if代码块</span></span><br><span class="line">                    <span class="comment">//执行晚后退出同步区域，然后线程2进入同步代码块，如果在这里不再加一次判断</span></span><br><span class="line">                    <span class="comment">//就会造成instance再次实例化</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">                    <span class="comment">//new Singleton1();可以分解为3行伪代码</span></span><br><span class="line">                    <span class="comment">//1、memory = allocate() //分配内存</span></span><br><span class="line">                    <span class="comment">//2、ctorInstanc(memory) //初始化对象</span></span><br><span class="line">                    <span class="comment">//3.调用构造函数，</span></span><br><span class="line">                    <span class="comment">//4.返回地址给引用。而cpu为了优化程序，可能会进行指令重排序，打乱这3，4这几个步骤，导致实例内存还没分配，就被使用了。</span></span><br><span class="line">                    <span class="comment">//线程A和线程B举例。线程A执行到new Singleton()，开始初始化实例对象，由于存在指令重排序，这次new操作，先把引用赋值了，还没有执行构造函数。</span></span><br><span class="line">                    <span class="comment">//这时时间片结束了，切换到线程B执行，线程B调用new Singleton()方法，发现引用不等于null，就直接返回引用地址了，然后线程B执行了一些操作，就可能导致线程B使用了还没有被初始化的变量。</span></span><br><span class="line">                    <span class="comment">//volatile防止重排序导致实例化未完成，就将对象赋值使用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型是线程安全的，并且只会装载一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton3 instance;</span><br><span class="line"></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Singleton4</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        SingletonEnum()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.SINGLETON.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="那你们用的哪种比较多？"><a href="#那你们用的哪种比较多？" class="headerlink" title="那你们用的哪种比较多？"></a>那你们用的哪种比较多？</h2><ul>
<li>一般我们项目里用静态内部类的方式实现单例会比较多（如果没有Springl的环境下），代码简洁易读</li>
<li>如果有Spring环境，那还是直接交由Spring容器管理会比较方便（Spring默认就是单例的）</li>
<li>枚举一般我们就用它来做「标识」吧，而DCL这种方式也有同学会在项目里写（在一些源码里也能看到其身影），但总体太不利于阅读和理解</li>
<li>总的来说，用哪一种都可以的，关键我觉得要看团队的代码风格吧（保持一致就行），即便都用「饿汉式」也没啥大的问题（现在内存也没那么稀缺，我认为可读性比较重要）</li>
</ul>
<h2 id="我看你在DCL的单例代码上，写了volatile修饰嘛？为什么呢？"><a href="#我看你在DCL的单例代码上，写了volatile修饰嘛？为什么呢？" class="headerlink" title="我看你在DCL的单例代码上，写了volatile修饰嘛？为什么呢？"></a>我看你在DCL的单例代码上，写了volatile修饰嘛？为什么呢？</h2><ul>
<li>指令是有可能乱序执行的（编译器优化导致乱序、CPU缓存架构导致乱序、CPU原生重排导致乱序）</li>
<li>在代码new Object的时候，不是一条原子的指令，它会由几个步骤组成，在这过程中，就可能会发生指令重排的问题，而volatile这个关键字就可以避免指令重排的发生。</li>
</ul>
<h2 id="那你说下你在项目里用到的设计模式吧？"><a href="#那你说下你在项目里用到的设计模式吧？" class="headerlink" title="那你说下你在项目里用到的设计模式吧？"></a>那你说下你在项目里用到的设计模式吧？</h2><ul>
<li><p>嗯，比如说，我这边在处理请求的时候，会用到责任链模式进行处理（减免if else并且让项目结构更加清晰）</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/X77vb4_20211230110546.png"></p>
<ul>
<li>在处理公共逻辑时，会使用模板方法模式进行抽象，具体不同的逻辑会由不同的实现类处理（每种消息发送前都需要经过文案校验，所以可以把文案校验的逻辑写在抽象类上）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/wEKBZr_20211230110629.png"></p>
</li>
<li><p>代理模式手写的机会比较少（因为项目一般有Spring：环境，直接用Spring的AOP代理就好了）</p>
<ul>
<li><p>我之前使用过AOP把「监控客户端」封装以「注解」的方式进行使用（不用以硬编码的方式来进行监控，只要有注解就行）</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/gF5mCF_20211230110735.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="那你能聊聊Spring使用到的常见设计模嘛？"><a href="#那你能聊聊Spring使用到的常见设计模嘛？" class="headerlink" title="那你能聊聊Spring使用到的常见设计模嘛？"></a>那你能聊聊Spring使用到的常见设计模嘛？</h2><ul>
<li>比如，Spring IOC容器可以理解为应用了「工厂模式」（通过ApplicationContext或者BeanFactory去获取对象）</li>
<li>Spring的对象默认都是单例的，所以肯定是用了「单例模式」（源码里对单例的实现是用的DCL来实现单例）</li>
<li>Spring AOP的底层原理就是用了「代理模式」，实现可能是JDK动态代理，也可能是CGLIB动态代理</li>
<li>Spring有很多地方都用了「模板方法模式」，比如事务管理器（AbstractPlatformTransactionManager),getTransaction定义了框架，其中很多都由子类实现</li>
<li>Spring的事件驱动模型用了「观察者模式」，具体实现就是ApplicationContextEvent、ApplicationListener</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>37、【对线面试官】JVM调优</title>
    <url>/posts/53284982/</url>
    <content><![CDATA[<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="今天要不来聊聊JVM调优相关的吧？你曾经在生产环境下有过调优JVM的经历吗？"><a href="#今天要不来聊聊JVM调优相关的吧？你曾经在生产环境下有过调优JVM的经历吗？" class="headerlink" title="今天要不来聊聊JVM调优相关的吧？你曾经在生产环境下有过调优JVM的经历吗？"></a>今天要不来聊聊JVM调优相关的吧？你曾经在生产环境下有过调优JVM的经历吗？</h2><ul>
<li><p>没有</p>
</li>
<li><p>嗯.是这样的，我们一般优化系统的思路是这样的</p>
<ul>
<li><p>1.一般来说关系型数据库是先到瓶颈，首先排查是否为数据库的问题</p>
<ul>
<li>（这个过程中就需要评估自己建的索引是否合理、是否需要引入分布式缓存是否需要分库分表等等）</li>
</ul>
</li>
<li><p>2.然后，我们会考虑是否需要扩容（横向和纵向都会考虑）</p>
<ul>
<li>（这个过程中我们会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题）</li>
</ul>
</li>
<li><p>3.接着，应用代码层面上排查并优化</p>
<ul>
<li>扩容是不能无止境的，里头里外都是钱阿，这个过程中我们会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过并行的方式处理某些请求）</li>
</ul>
</li>
<li><p>4.再接着，JVM层面上排查并优化</p>
</li>
<li><p>审视完代码之后，这个过程我们观察JVM是否存在多次GC问题等等）</p>
</li>
<li><p>5.最后，网络和操作系统层面排查</p>
<ul>
<li>（这个过程查看内存CPU&#x2F;网络&#x2F;硬盘读写指标是否正常等等）</li>
</ul>
</li>
</ul>
</li>
<li><p>绝大多数情况下，到第三步就结束了，    一般经过「运维团队」给我们设置的JVM和机器上的参数，已经满足绝大多数的需求了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/1iVqn7_20211230111504.png" alt="调优顺序"></p>
</li>
<li><p>之前有过其他团队在「大促」发现接口处理超时的问题，那吋候查各种监控怀疑是 FULL GC频率稍大所导致的</p>
<ul>
<li>第一想法不是说去调节各种JVM参数来进行优化，而是直接加机器</li>
<li>（用最粗暴的方法，解决问题是最简单的，扩容）</li>
<li>不过，我是学过JM相关的调优命令和思路的。</li>
<li>在我的理解下，调优JVM其实就是在「理解」JM内存结构以及各种垃圾收集器前提下，结合自己的现有的业务来「调整参数」，使自己的应用能够正常稳定运行</li>
</ul>
</li>
<li><p>jvm调优</p>
<ul>
<li><p>一般调优JVM我们认为会有几种指标可以参考：『吞吐量』、『停顿时间』和垃圾回收频率』</p>
</li>
<li><p>基于这些指标，我们就有可能需要调整</p>
<ul>
<li>1.内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、 Survivor占多少、晋升老年代的条件等等<ul>
<li>比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、- XX： Survivorratio：伊甸区和幸存区的比例等等</li>
<li>按经验来说：IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</li>
</ul>
</li>
<li>2.垃圾回收器（选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数）<ul>
<li>比如（-XX：+UseG1GC：指定JVM使用的垃圾回收器为G1、- XX： Maxgcpause Miliis：设置目标停顿时间、-XX:InitiatingHeapoccupancypercent：当整个堆内存使用达到一定比例，全局并发标记阶段就会被启动等等）</li>
<li>没错，这些都是因地制宜，具体问题具体分析（前提是得懂JVM的各种基础知识，基础知识都不懂，谈何调优）</li>
<li>在大多数场景下，JWM已经能够达到「开箱即用」</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/aGMnp8_20211230111916.png" alt="调优"></p>
</li>
<li><p>一般我们是「遇到问题」之后才进行调优的，而遇到问题后需要利用各种的「工具」进行排查</p>
<ul>
<li>1.通过ps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥</li>
<li>2.通过stat命令査看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况</li>
<li>3.通过jnfo命令来查看和调整Java进程的「运行参数」</li>
<li>4.通过imap命令来査看Java进程的「内存信息」。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT（Memory Analyzer tool内存解析工具）把文件进行分析</li>
<li>5.通过 stack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题</li>
<li>6.还有近期比较热门的 Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。这也是我这边常用的排查和分析工具</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/pKXHUi_20211230112100.png" alt="监控工具"></p>
</li>
</ul>
<h2 id="之前聊JVM的时候，你也提到过在「解释」阶段，会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器（JIT）。我想问问，你了解JVM的JT优化技术嘛？"><a href="#之前聊JVM的时候，你也提到过在「解释」阶段，会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器（JIT）。我想问问，你了解JVM的JT优化技术嘛？" class="headerlink" title="之前聊JVM的时候，你也提到过在「解释」阶段，会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器（JIT）。我想问问，你了解JVM的JT优化技术嘛？"></a>之前聊JVM的时候，你也提到过在「解释」阶段，会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器（JIT）。我想问问，你了解JVM的JT优化技术嘛？</h2><ul>
<li><p>JT优化技术比较出名的有两种：方法内联和逃逸分析</p>
<ul>
<li>所谓方法内联就是把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用<ul>
<li>因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来定的性能损耗，所以「方法内联」的优化可以提高一定的性能</li>
<li>在JVM中也有相关的参数给予我们指定(-XX: Maxfreainlinesize-xx: Maxinliresize等等）</li>
</ul>
</li>
<li>而「逃逸分析」则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化</li>
</ul>
</li>
<li><p>下面我举几个可优化的例子（思路）</p>
<p>1.锁消除（同步忽略）：该对象只在方法內部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉</p>
<p>2.栈上分配：该对象只会在方法內部被访问，直接将对象分配在「栈」中（Java默认是将对象分配在「堆」中，是需要通过JM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）</p>
<p>3.标量替换分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/dQHEF8_20211230112436.png" alt="JIT常见优化"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>38、【对线面试官】HTTP</title>
    <url>/posts/561aa315/</url>
    <content><![CDATA[<h1 id="今天要不来聊聊HTTP吧"><a href="#今天要不来聊聊HTTP吧" class="headerlink" title="今天要不来聊聊HTTP吧"></a>今天要不来聊聊HTTP吧</h1><h2 id="今天要不来聊聊HTTP吧？"><a href="#今天要不来聊聊HTTP吧？" class="headerlink" title="今天要不来聊聊HTTP吧？"></a>今天要不来聊聊HTTP吧？</h2><ul>
<li>HTTP「协议」是客户端和服务器「交互」的一种通迅的格式<ul>
<li>所谓的「协议」实际上就是双方约定好的「格式」，让双方都能看得懂的东西而已</li>
<li>所谓的交互实际上就是「请求」和「响应」</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/KF4FUG_20211230112604.png"></p>
<h2 id="那你知道HTTP各个版本之间的区别吗？"><a href="#那你知道HTTP各个版本之间的区别吗？" class="headerlink" title="那你知道HTTP各个版本之间的区别吗？"></a>那你知道HTTP各个版本之间的区别吗？</h2><ul>
<li>HTP1.0默认是短连接，每次与服务器交互，都需要新开一个连接</li>
<li>HTTP1.1版本最主要的是「默认持久连接」。只要客户端服务端没有断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>其次就是「断点续传」（ Chunked transfer-coding）。利用HTTP消息头使用分块传输编码，将实体主体分块进行传输</li>
<li>HTTP&#x2F;2不再以文本的方式传输，采用「二进制分帧层」，对头部进行了「压缩」，支持「流控」，最主要就是HTTP&#x2F;2是支持「多路复用」的（通过单一的TCP连接「并行」发起多个的请求和响应消息）</li>
<li>HTTP&#x2F;3跟前面版本最大的区别就是：HTTP1.x和HTTP&#x2F;2底层都是TCP，而HTTP&#x2F;3底层是UDP。使用HTTP&#x2F;3能够減少RTT「往返时延」（TCP三次握手，TLS握手）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/8se2HT_20211230113041.png"></p>
<h2 id="嗯，稍微打断下。我知道HTTP1-1版本有个管线化（-pipelining）理论，但默认是关闭的。管线化这个跟HTTP-x2F-2的「多路复用」是很类似的，它们有什么区别呀？"><a href="#嗯，稍微打断下。我知道HTTP1-1版本有个管线化（-pipelining）理论，但默认是关闭的。管线化这个跟HTTP-x2F-2的「多路复用」是很类似的，它们有什么区别呀？" class="headerlink" title="嗯，稍微打断下。我知道HTTP1.1版本有个管线化（ pipelining）理论，但默认是关闭的。管线化这个跟HTTP&#x2F;2的「多路复用」是很类似的，它们有什么区别呀？"></a>嗯，稍微打断下。我知道HTTP1.1版本有个管线化（ pipelining）理论，但默认是关闭的。管线化这个跟HTTP&#x2F;2的「多路复用」是很类似的，它们有什么区别呀？</h2><ul>
<li><p>HTTP1.1提出的「管线化」只能「串行」（一个响应必须完全返回后，下个请求才会开始传输）</p>
</li>
<li><p>HTTP&#x2F;2多路复用则是利用「分帧」数据流，把HTTP协议分解为「互不依赖」的帧（为每个帧「标序」发送，接收回来的时候按序重组），进而可以「乱序」发送避免「一定程度上」的队首阻塞问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/MC43LZ_20211230112912.png"></p>
</li>
<li><p>但是，无论是HTTP1.1还是HTTP&#x2F;2，respanel响应的「处理顺序」总是需要跟request请求顺序保持一致的。假如某个请求的 response响应慢了，还是同样会有阻塞的问题</p>
</li>
<li><p>这受限于HTTP底层的传输协议是TCP，没办法完全解決「线头阻塞」的问题</p>
</li>
</ul>
<h2 id="那你了解HTPS的过程吗？"><a href="#那你了解HTPS的过程吗？" class="headerlink" title="那你了解HTPS的过程吗？"></a>那你了解HTPS的过程吗？</h2><ul>
<li><p>对于HTTPS，我的理解下：就是「安全」的HTTP协议（客户端与服务端的传输链路中进行加密）</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/pOPVGJ_20211230113132.png"></p>
</li>
<li><p>HTPS首先要解決的是：认证的问题</p>
<ul>
<li>客户端是需要确切地知道服务端是不是「真实」，所以在HTPS中会有一个角色：CA（公信机构）</li>
<li>服务端在使用HTTPSI前，需要去认证的CA机构申请一份「数字证书」。数字证书里包含有证书持有者、证书有效期「服务器公钥」等信息</li>
<li>CA机构也有自己的一份公私钥，在发布数字证书之前，会用自己的「私钥」对这份数字证书进行加密</li>
<li>等到客户端请求服务器的时候，服务端返回证书给客户端。客户端用CA的公钥对证书解密（因为CA是公信机构，会内置到浏览器或操作系统中，所以客户端会有公钥）。这个时候，客户端会判断这个「证书是否可信有无被簒改」</li>
<li>私钥加密，公钥解密我们叫做「数字签名」（这种方式可以查看有无被簒改）</li>
<li>到这里，就解决了「认证」的问题，至少客户端能保证是在跟「真实的服务器」进行通信。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/D1hA0I_20211230113315.png"></p>
</li>
<li><p>保密问题</p>
<ul>
<li>客户端与服务器的通讯内容在传输中不会泄露给第三方</li>
<li>客户端从CA拿到数字证书后，就能拿到服务端的公钥</li>
<li>客户端生成一个Key作为「对称加密」的秘钥，用服务端的「公钥加密」传给服务端</li>
<li>服务端用自己的「私钥解密」客户端的数据，得到对称加密的秘钥</li>
<li>之后客户端与服务端就可以使用「对称加密的秘钥」愉快地发送和接收消息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/oU2mh1_20211230113435.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>3、【对线面试官】Java NIO</title>
    <url>/posts/d38e357c/</url>
    <content><![CDATA[<h1 id="3、【对线面试官】Java-NIO"><a href="#3、【对线面试官】Java-NIO" class="headerlink" title="3、【对线面试官】Java NIO"></a>3、【对线面试官】Java NIO</h1><h2 id="这次咱们就来聊聊Java的NIO呗？你对NIO有多少了解？"><a href="#这次咱们就来聊聊Java的NIO呗？你对NIO有多少了解？" class="headerlink" title="这次咱们就来聊聊Java的NIO呗？你对NIO有多少了解？"></a>这次咱们就来聊聊Java的NIO呗？你对NIO有多少了解？</h2><ol>
<li>嗯，我对Java NIO还是有一定的了解的，NIO是JDK1.4开始有的，其目的是为了提高速度。NIO翻译成no-blockingo或者newio都无所谓啦，反正都说得通</li>
</ol>
<h2 id="在真实项目中写过NIO相关"><a href="#在真实项目中写过NIO相关" class="headerlink" title="在真实项目中写过NIO相关"></a>在真实项目中写过NIO相关</h2><ol>
<li>这块在我所负责的系统中，一般用不上N10，要不我跟你讲讲NIO相关的知识点呗？</li>
</ol>
<h2 id="可以吧，你先来讲讲NIO和传统IO有什么区别吧"><a href="#可以吧，你先来讲讲NIO和传统IO有什么区别吧" class="headerlink" title="可以吧，你先来讲讲NIO和传统IO有什么区别吧"></a>可以吧，你先来讲讲NIO和传统IO有什么区别吧</h2><ol>
<li>传统IO是一次一个字节地处理数据，NIO是以块（缓冲区）的形式处理数据。最主要的是，NIO可以实现非阻塞，而传统IO只能是阻塞的。</li>
<li>IO的实际场景是文件IO和网络IO，NIO 在网络IO场景下提升就尤其明显了。</li>
<li>在Java NIO有三个核心部分组成。分别是Buffer（缓冲区）、Channel（管道）以及Selector（选择器）</li>
<li>可以简单的理解为：Buffer是存储数据的地方，Channel是运输数据的载体，而Selector用于检查多个Channel的状态变更情况，</li>
</ol>
<h2 id="有写过相关的Demo代码吗？"><a href="#有写过相关的Demo代码吗？" class="headerlink" title="有写过相关的Demo代码吗？"></a>有写过相关的Demo代码吗？</h2><ol>
<li><p>我曾经写过一个NIO Demo，面试官可以看看。</p>
</li>
<li><p>大概的实现就是：服务端接收图片后保存，能够通知客户端已经收到图片。而客户端发送图片给客户端，并接收服务端的响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoBlockServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.切换成非阻塞模式</span></span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 绑定连接</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.1将通道注册到选择器上，指定接收“监听通道”事件</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收事件就绪</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8. 获取客户端的链接</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8.1 切换成非阻塞状态</span></span><br><span class="line">                    client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件)</span></span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123; <span class="comment">// 读事件就绪</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9. 获取当前选择器读就绪状态的通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9.1读取数据</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建)</span></span><br><span class="line">                    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;2.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (client.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在读之前都要切换成读模式</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line"></span><br><span class="line">                        outChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读完切换成写模式，能让管道继续读取文件的数据</span></span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoBlockClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1切换成非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2获取选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3将通道注册到选择器中，获取服务端返回的数据</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 发送一张图片给服务端吧</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;X:\\Users\\ozc\\Desktop\\面试造火箭\\1.png&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.读取本地文件(图片)，发送到服务器</span></span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在读之前都要切换成读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line"></span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读完切换成写模式，能让管道继续读取文件的数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8. 读事件就绪</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8.1得到对应的通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(responseBuffer);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 切换读模式</span></span><br><span class="line">                        responseBuffer.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(responseBuffer.array(), <span class="number">0</span>, readBytes));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="就考考相关的概念原理呗"><a href="#就考考相关的概念原理呗" class="headerlink" title="就考考相关的概念原理呗"></a>就考考相关的概念原理呗</h2><h3 id="你知道IO模型有几种吗"><a href="#你知道IO模型有几种吗" class="headerlink" title="你知道IO模型有几种吗"></a>你知道IO模型有几种吗</h3><ol>
<li>在Unix下IO模型分别有：阻塞IO、非阻塞IO、IO复用、信号驱动以及异步I&#x2F;0。在开发中碰得最多的就是阻塞I0、非阻塞IO以及IO复用。</li>
</ol>
<h3 id="来重点讲讲-O复用模型吧"><a href="#来重点讲讲-O复用模型吧" class="headerlink" title="来重点讲讲|O复用模型吧"></a>来重点讲讲|O复用模型吧</h3><ol>
<li>我就以Linux系统为例好了，我们都知道Linux对文件的操作实际上就是通过文件描述符（fd）</li>
<li>1O复用模型指的就是：通过一个进程监听多个文件描述符，一旦某个文件描述符准备就绪，就去通知程序做相对应的处理</li>
<li>这种以通知的方式，优势并不是对于单个连接能处理得更快，而是在于它能处理更多的连接。</li>
<li>在Linux下IO复用模型用的函数有select&#x2F;poll和epoll</li>
</ol>
<h3 id="那你来讲讲这select和epll函数的区别呗？"><a href="#那你来讲讲这select和epll函数的区别呗？" class="headerlink" title="那你来讲讲这select和epll函数的区别呗？"></a>那你来讲讲这select和epll函数的区别呗？</h3><ul>
<li><p>select</p>
<ol>
<li>select函数它支持最大的连接数是1024或 2048，因为在select函数下要传入fd_set参数，这个fd_set的大小要么1024或2048（其实就看操作系统的位数）</li>
<li>fd_set就是bitmap的数据结构，可以简单理解为只要位为0，那说明还没数据到缓冲区，只要位为1，那说明数据已经到缓冲区。</li>
<li>而select函数做的就是每次将fd_set遍历，判断标志位有没有发现变化，如果有变化则通知程序做中断处理。</li>
</ol>
</li>
<li><p>epoll</p>
<ol>
<li>epoll是在Linux2.6内核正式提出，完善了select的一些缺点。</li>
<li>它定义了epoll_event结构体来处理，不存在最大连接数的限制。</li>
<li>并且它不像select函数每次把所有的文件描述符（fd）都遍历，简单理解就是epoll把就绪的文件描述符（fd）专门维护了一块空间，每次从就绪列表里边拿就好了，不再进行对所有文件描述符（fd）进行遍历。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="嗯，了解了，另外你知道什么叫做零拷贝吗？"><a href="#嗯，了解了，另外你知道什么叫做零拷贝吗？" class="headerlink" title="嗯，了解了，另外你知道什么叫做零拷贝吗？"></a>嗯，了解了，另外你知道什么叫做零拷贝吗？</h3><ol>
<li>知道的。我们以读操作为例，假设用户程序发起一次读请求。</li>
<li>其实会调用read相关的「系统函数」，然后会从用户态切换到内核态，随后CPU会告诉DMA去磁盘把数据拷贝到内核空间。</li>
<li>等到「内核缓冲区」真正有数据之后，CPU会把「内核缓存区」数据拷贝到「用户缓冲区」，最终用户程序才能获取到。</li>
<li>稍微解释一下上面的意思~</li>
<li>为了保证内核的安全，操作系统将虚拟空间划分为「用户空间」和「内核空间」，所以在读系统数据的时候会有状态切换</li>
<li>因为应用程序不能直接去读取硬盘的数据。从上面描述可知读写需要依赖「内核缓冲区」</li>
<li>一次读操作会让DMA拷贝（direct memory access 直接内存拷贝，不使用cpu）将磁盘数据拷贝到内核缓冲区，CPU将内核缓冲区数据拷贝到用户缓冲区。</li>
<li>所谓的零拷贝就是将「CPU将内核缓冲区数据拷贝到用户缓冲区」这次CPU拷贝给省去，来提高效率和性能</li>
<li>常见的零拷贝技术有mmap（内核缓冲区与用户缓冲区的共享） 、sendfile（系统底层函数支持）。</li>
<li>零拷贝可以提高数据传输的性能，这块在Kafka等框架也有相关的实践。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>5、【对线面试官】多线程基础</title>
    <url>/posts/986aa405/</url>
    <content><![CDATA[<h1 id="5、【对线面试官】多线程基础"><a href="#5、【对线面试官】多线程基础" class="headerlink" title="5、【对线面试官】多线程基础"></a>5、【对线面试官】多线程基础</h1><h2 id="今天要不来聊聊Java反射？你对Java反射了解多少？"><a href="#今天要不来聊聊Java反射？你对Java反射了解多少？" class="headerlink" title="今天要不来聊聊Java反射？你对Java反射了解多少？"></a>今天要不来聊聊Java反射？你对Java反射了解多少？</h2><ol>
<li>嗯，Java反射在JavaSE基础中还是很重要的。</li>
<li>简单来说，反射就是Java可以给我们在运行时获取类的信息<br>在初学的时候可能看不懂、又或是学不太会反射，因为初学的时候往往给的例子都是用反射创建对象，用反射去获取对象上的方法&#x2F;属性什么的，感觉没多大用</li>
<li>但毕竟我已经不是以前的我了，跟以前的看法就不一样了。</li>
<li>理解反射重点就在于理解什么是「运行时」，为什么我们要在「运行时」获取类的信息</li>
<li>在当时学注解的时候，我们可以发现注解的生命周期有三个枚举值（当时我还告诉过面试官你呢~）</li>
<li>分别是SOURCE、CLASS和RUNTIME，其实一样的，RUNTIME就是对标着运行时</li>
<li>我们都知道：我们在编译器写的代码是j ava文件，经过javac编译会变成.class文件，class文件会被JVM装载运行（这里就是真正运行着我们所写的代码（虽然是被编译过的），也就所谓的运行时。</li>
</ol>
<h2 id="嗯，你说了那么多，就讲述了什么是运行时，还是快点进入重点吧"><a href="#嗯，你说了那么多，就讲述了什么是运行时，还是快点进入重点吧" class="headerlink" title="嗯，你说了那么多，就讲述了什么是运行时，还是快点进入重点吧"></a>嗯，你说了那么多，就讲述了什么是运行时，还是快点进入重点吧</h2><ol>
<li>在运行时获取类的信息，其实就是为了让我们所写的代码更具有「通用性」和「灵活性」</li>
<li>要理解反射，需要抛开我们日常写的业务代码。以更高的维度或者说是抽象的思维去看待我们所写的“工具”</li>
<li>所谓的“工具”：在单个系统使用叫做“Utils”、被多个系统使用打成jar包叫做“组件”、组件继续发展壮大就叫做“框架”</li>
<li>一个好用的“工具”是需要兼容各种情况的。</li>
<li>你肯定是不知道用该“工具“的用户传入的是什么对象，但你需要帮他们得到需要的结果。</li>
<li>例如SpringMVC你在方法上写上对象，传入的参数就会帮你封装到对象上</li>
<li>Mybatis可以让我们只写接口，不写实现类，就可以执行SQL</li>
<li>你在类上加上@Component注解，Sprin g就帮你创建对象</li>
<li>这些统统都有反射的身影：约定大于配置，配置大于硬编码。</li>
<li>通过”约定“使用姿势，使用反射在运行时获取相应的信息（毕竟作为一个”工具“是真的不知道你是怎么用的），实现代码功能的「通用性」和「灵活性」</li>
</ol>
<h2 id="结合之前说的泛型，想问下：你应该知道泛型是会擦除的，那为什么反射能获取到泛型的信息呢？"><a href="#结合之前说的泛型，想问下：你应该知道泛型是会擦除的，那为什么反射能获取到泛型的信息呢？" class="headerlink" title="结合之前说的泛型，想问下：你应该知道泛型是会擦除的，那为什么反射能获取到泛型的信息呢？"></a>结合之前说的泛型，想问下：你应该知道泛型是会擦除的，那为什么反射能获取到泛型的信息呢？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类，定义泛型&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass();</span><br><span class="line">        <span class="type">ParameterizedType</span>  <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) clazz.getGenericSuperclass(); </span><br><span class="line">        clazz = (Class) pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BaseDao&lt;User&gt; userDao = <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果输出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.entity.User</span><br></pre></td></tr></table></figure>

<ol>
<li>嗯，这个问题我在学习的时候也想过</li>
<li>其实是这样的，可以理解为泛型擦除是有范围的，定义在类上的泛型信息是不会被擦除的。</li>
<li>Java编译器仍在class文件以Signature 属性的方式保留了泛型信息</li>
<li>Type作为顶级接口，Type下还有几种类型，比如TypeVariable、 ParameterizedT ype、 WildCardType、 GenericArrayType、以及Class。通过这些接口我们就可以在运行时获取泛型相关的信息。</li>
</ol>
<h2 id="你了解动态代理吗？"><a href="#你了解动态代理吗？" class="headerlink" title="你了解动态代理吗？"></a>你了解动态代理吗？</h2><ol>
<li>嗯，了解的。动态代理其实就是代理模式的一种，代理模式是设计模式之一。</li>
<li>代理模型有静态代理和动态代理。静态代理需要自己写代理类，实现对应的接口，比较麻烦。</li>
<li>在Java中，动态代理常见的又有两种实现方式：JDK动态代理和CGLIB代理</li>
<li>JDK动态代理其实就是运用了反射的机制，而CGLIB代理则用的是利用ASM框架，通过修改其字节码生成子类来处理。</li>
<li>JDK动态代理会帮我们实现接口的方法，通过invokeHandler对所需要的方法进行增强。</li>
<li>动态代理这一技术在实际或者框架原理中是非常常见的</li>
<li>像上面所讲的Mybatis不用写实现类，只写接口就可以执行SQL，又或是SpringAOP等等好用的技术，实际上用的就是动态代理。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>5、【对线面试官】多线程基础</title>
    <url>/posts/986aa405/</url>
    <content><![CDATA[<h1 id="5、【对线面试官】多线程基础"><a href="#5、【对线面试官】多线程基础" class="headerlink" title="5、【对线面试官】多线程基础"></a>5、【对线面试官】多线程基础</h1><h2 id="首先你来讲讲进程和线程的区别吧？"><a href="#首先你来讲讲进程和线程的区别吧？" class="headerlink" title="首先你来讲讲进程和线程的区别吧？"></a>首先你来讲讲进程和线程的区别吧？</h2><ol>
<li>进程是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源</li>
<li>进程实现多处理机环境下的进程调度，分派，切换时，都需要花费较大的时间和空间开销</li>
<li>为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理，所以有了线程，线程取代了进程了调度的基本功能</li>
<li>简单来说，进程作为资源分配的基本单位，线程作为资源调度的基本单位</li>
</ol>
<h2 id="那我们为什么要用多线程呢？你平时工作中用得多吗？"><a href="#那我们为什么要用多线程呢？你平时工作中用得多吗？" class="headerlink" title="那我们为什么要用多线程呢？你平时工作中用得多吗？"></a>那我们为什么要用多线程呢？你平时工作中用得多吗？</h2><ol>
<li>使用多线程最主要的原因是提高系统的资源利用率。</li>
<li>现在CPU基本都是多核的，如果你只用单线程，那就是只用到了一个核心，其他的核心就相当于空闲在那里了。</li>
<li>在平时工作中多线程是随时都可见的。</li>
<li>比如说，我们系统Web服务器用的是Tomcat，Tomcat处理每一个请求都会从线程连接池里边用一个线程去处理。</li>
<li>又比如说，我们用连接数据库会用对应的连接池Druid&#x2F;C3P0&#x2F;DBCP等等</li>
<li>等等这些都用了多线程的。</li>
<li>上面这些框架已经帮我们屏蔽掉「手写」多线程的问题</li>
</ol>
<h3 id="嗯，了解，那你实际开发中有用过吗？"><a href="#嗯，了解，那你实际开发中有用过吗？" class="headerlink" title="嗯，了解，那你实际开发中有用过吗？"></a>嗯，了解，那你实际开发中有用过吗？</h3><ol>
<li><p>当然有了，在我所负责的系统也会用到多线程的。</p>
</li>
<li><p>比如说，现在要跑一个定时任务，该任务的链路执行时间和过程都非常长，我这边就用一个线程池将该定时任务的请求进行处理。</p>
</li>
<li><p>这样做的好处就是可以及时返回结果给调用方，能够提高系统的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求直接交给线程池来处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(PushParam pushParam)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    pushServiceThreadExecutor.submit(() -&gt; &#123;</span><br><span class="line">      handler(pushParam);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;pushServiceThreadExecutor error, exception&#123;&#125;:&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有就是我的系统中用了很多生产者与消费者模式，会用多个线程去消费队列的消息，来提高并发度</p>
</li>
</ol>
<h2 id="你如果在项目中用到了多线程，那肯定得考虑线程安全的问题的吧"><a href="#你如果在项目中用到了多线程，那肯定得考虑线程安全的问题的吧" class="headerlink" title="你如果在项目中用到了多线程，那肯定得考虑线程安全的问题的吧"></a>你如果在项目中用到了多线程，那肯定得考虑线程安全的问题的吧</h2><ol>
<li>在我的理解下，在Java世界里边，所谓线程安全就是多个线程去执行某类，这个类始终能表现出正确的行为，那么这个类就是线程安全的。</li>
<li>比如我有一个count变量，在service方法不断的累加这个count变量。</li>
<li>假设相同的条件下，count变量每次执行的结果都是相同，那我们就可以说是线程安全的干</li>
<li>显然下面的代码肯定不是线程安全的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCountingServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        ++count;</span><br><span class="line">        <span class="comment">// To something else...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="那你平时是怎么解决，或者怎么思考线程安全问题的呢？"><a href="#那你平时是怎么解决，或者怎么思考线程安全问题的呢？" class="headerlink" title="那你平时是怎么解决，或者怎么思考线程安全问题的呢？"></a>那你平时是怎么解决，或者怎么思考线程安全问题的呢？</h2><ol>
<li>其实大部分时间我们在代码里边都没有显式去处理线程安全问题，因为这大部分都由框架所做了。</li>
<li>正如上面提到的Tomcat、Druid、SpringMVC等等。</li>
<li>很多时候，我们判断是否要处理线程安全问题，就看有没有多个线程同时访问一个共享变量。</li>
<li>像SpringMVC这种，我们日常开发时，不涉及到操作同一个成员变量，那我们就很少需要考虑线程安全问题。</li>
<li>我个人解决线程安全问题的思路有以下：<ul>
<li>能不能保证操作的原子性，考虑atomi c包下的类够不够我们使用。</li>
<li>能不能保证操作的可见性，考虑volatil e关键字够不够我们使用</li>
<li>如果涉及到对线程的控制（比如一次能使用多少个线程，当前线程触发的条件是否依赖其他线程的结果），考虑CountDownLatch&#x2F;Semaphore等等。</li>
<li>如果是集合，考虑java.util.concurrent 包下的集合类。</li>
<li>如果synchronized无法满足，考虑lock 包下的类</li>
</ul>
</li>
<li>总的来说，就是先判断有没有线程安全问题，如果存在则根据具体的情况去判断使用什么方式去处理线程安全的问题。</li>
<li>虽然synchronized很牛逼，但无脑使用synchronized会影响我们程序的性能的。</li>
</ol>
<h2 id="死锁你了解吗？什么情况会造成死锁？要是你能给我讲清楚死锁，我就录取你了"><a href="#死锁你了解吗？什么情况会造成死锁？要是你能给我讲清楚死锁，我就录取你了" class="headerlink" title="死锁你了解吗？什么情况会造成死锁？要是你能给我讲清楚死锁，我就录取你了"></a>死锁你了解吗？什么情况会造成死锁？要是你能给我讲清楚死锁，我就录取你了</h2><ol>
<li>要是你录取我，我就给你讲清楚死锁</li>
<li>造成死锁的原因可以简单概括为：当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源。</li>
<li>避免死锁的方式一般有以下方案：<ul>
<li>固定加锁的顺序，比如我们可以使用Hash值的大小来确定加锁的先后</li>
<li>尽可能缩减加锁的范围，等到操作共享变量的时候才加锁。</li>
<li>使用可释放的定时锁（一段时间申请不到锁的权限了，直接释放掉）</li>
</ul>
</li>
</ol>
<h2 id="价值体现"><a href="#价值体现" class="headerlink" title="价值体现"></a>价值体现</h2><p>嗯，其实我想问，就是我要是..去到贵公司是做什么内容？还有就是..</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>6、【对线面试官】CAS</title>
    <url>/posts/759e745e/</url>
    <content><![CDATA[<h1 id="6、【对线面试官】CAS"><a href="#6、【对线面试官】CAS" class="headerlink" title="6、【对线面试官】CAS"></a>6、【对线面试官】CAS</h1><h2 id="今天我们来聊聊CAS吧？你对CAS了解多少？"><a href="#今天我们来聊聊CAS吧？你对CAS了解多少？" class="headerlink" title="今天我们来聊聊CAS吧？你对CAS了解多少？"></a>今天我们来聊聊CAS吧？你对CAS了解多少？</h2><ol>
<li>CAS的全称为compare and swap，比较并交换</li>
<li>虽然翻译过来是「比较并交换」，但它是一个原子性的操作，对应到CPU指令为cmpxchg</li>
<li>cpu指令你都知道？-&gt;这没什么，都是背的。</li>
<li>回到CAS上吧，CAS的操作其实非常简单。</li>
<li>CAS有三个操作数：当前值A、内存值V、要修改的新值B</li>
<li>假设当前值A跟内存值V相等，那就将内存值V改成B</li>
<li>假设当前值A跟内存值V不相等，要么就重试，要么就放弃更新</li>
<li>将当前值与内存值进行对比，判断是否有被修改过，这就是CAS的核心</li>
</ol>
<h2 id="确实，那为什么要用CAS呢？"><a href="#确实，那为什么要用CAS呢？" class="headerlink" title="确实，那为什么要用CAS呢？"></a>确实，那为什么要用CAS呢？</h2><ol>
<li>嗯，要讲到CAS就不得不说synchronized锁了，它是Java锁..然后..</li>
<li>ok，其实就是synchronized锁每次只会让一个线程去操作共享资源</li>
<li>而CAS相当于没有加锁，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断能否修改成功</li>
<li>在很多的情况下会synchronized锁要高效很多</li>
<li>比如，对一个值进行累加，就没必要使用synchronized锁，使用juc包下的Atomic类就足以。</li>
</ol>
<h2 id="了解，那你知道CAS会有什么缺点吗？"><a href="#了解，那你知道CAS会有什么缺点吗？" class="headerlink" title="了解，那你知道CAS会有什么缺点吗？"></a>了解，那你知道CAS会有什么缺点吗？</h2><ol>
<li>CAS有个缺点就是会带来ABA的问题</li>
<li>从CAS更新的时候，我们可以发现它只比对当前值和内存值是否相等，这会带来个问题，下面我举例说明下：</li>
<li>假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10。</li>
<li>等到线程A拿到执行权时，因为当前值和内存值是一致的，线程A是可以修改的！</li>
<li>站在线程A的角度来说，这个值是从未被修改的（：</li>
<li>这是不合理的，因为我们从上帝的角度来看，这个变量已经被线程B和线程C修改过了。</li>
<li>这就是所谓的ABA问题</li>
<li>要解决ABA的问题，Java也提供了AtomicStampedReference类供我们用，说白了就是加了个版本，比对的就是内存值+版本是否一致</li>
</ol>
<h2 id="阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）"><a href="#阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）" class="headerlink" title="阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）"></a>阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）</h2><ol>
<li>AtomicLong做累加的时候实际上就是多个线程操作同一个目标资源</li>
<li>在高并发时，只有一个线程是执行成功的，其他的线程都会失败，不断自旋（重试），自旋会成为瓶颈</li>
<li>而LongAdder的思想就是把要操作的目标资源「分散」到数组Cell中</li>
<li>每个线程对自己的Cell变量的value进行原子操作，大大降低了失败的次数</li>
<li>这就是为什么在高并发场景下，推荐使用LongAdder的原因</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>7、【对线面试官】synchronized</title>
    <url>/posts/844cde9b/</url>
    <content><![CDATA[<h1 id="7、【对线面试官】synchronized"><a href="#7、【对线面试官】synchronized" class="headerlink" title="7、【对线面试官】synchronized"></a>7、【对线面试官】synchronized</h1><h2 id="今天我们来聊聊synchronized吧？"><a href="#今天我们来聊聊synchronized吧？" class="headerlink" title="今天我们来聊聊synchronized吧？"></a>今天我们来聊聊synchronized吧？</h2><ol>
<li>synchronized是一种互斥锁，一次只能允许一个线程进入被锁住的代码块</li>
<li>synchronized是Java的一个关键字，它能够将代码块&#x2F;方法锁起来</li>
<li>如果synchronized修饰的是实例方法，对应的锁则是对象实例</li>
<li>如果synchronized修饰的是静态方法，对应的锁则是当前类的Class实例</li>
<li>如果synchronized修饰的是代码块，对应的锁则是传入synchronized的对象实例</li>
</ol>
<h2 id="嗯，要不你来讲讲synchronized的原理呗？"><a href="#嗯，要不你来讲讲synchronized的原理呗？" class="headerlink" title="嗯，要不你来讲讲synchronized的原理呗？"></a>嗯，要不你来讲讲synchronized的原理呗？</h2><ol>
<li>通过反编译可以发现</li>
<li>当修饰方法时，编译器会生成ACC_SYNCHRONIZED关键字用来标识</li>
<li>当修饰代码块时，会依赖monitorenter和monitorexit指令</li>
<li>但前面已经说了，无论synchronized修饰的是方法还是代码块，对应的锁都是一个实例（对象）</li>
<li>在内存中，对象一般由三部分组成，分别是对象头、对象实际数据和对齐填充</li>
<li>重点在于对象头，对象头又由几部分组成，但我们重点关注对象头Mark Word的信息就好了</li>
<li>Mark Word会记录对象关于锁的信息</li>
<li>又因为每个对象都会有一个与之对应的monitor对象，monitor对象中存储着当前持有锁的线程以及等待锁的线程队列</li>
<li>了解Mark Word和monitor对象是理解synchronized原理的前提</li>
</ol>
<h2 id="嗯，听说synchronized锁在JDK1-6之后做了很多的优化，这块你了解多少呢？"><a href="#嗯，听说synchronized锁在JDK1-6之后做了很多的优化，这块你了解多少呢？" class="headerlink" title="嗯，听说synchronized锁在JDK1.6之后做了很多的优化，这块你了解多少呢？"></a>嗯，听说synchronized锁在JDK1.6之后做了很多的优化，这块你了解多少呢？</h2><ol>
<li>其实是这样的，在JDK1.6之前是重量级锁，线程进入同步代码块&#x2F;方法时</li>
<li>monitor对象就会把当前进入线程的Id进行存储，设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中</li>
<li>它加锁是依赖底层操作系统的mutex相关指令实现，所以会有用户态和内核态之间的切换，性能损耗十分明显</li>
<li>而JDK1.6以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，就没有切换的消耗</li>
<li>所以，Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</li>
</ol>
<h3 id="简单来说说偏向锁、轻量级锁和重量级锁吧"><a href="#简单来说说偏向锁、轻量级锁和重量级锁吧" class="headerlink" title="简单来说说偏向锁、轻量级锁和重量级锁吧"></a>简单来说说偏向锁、轻量级锁和重量级锁吧</h3><ol>
<li>偏向锁指的就是JVM会认为只有某个线程才会执行同步代码（没有竞争的环境）</li>
<li>所以在Mark Word会直接记录线程ID，只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码</li>
<li>如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码</li>
<li>如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为轻量级锁。</li>
<li>在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，LockRecord会把 Mark Word的信息拷贝进去，且有个Owner指针指向加锁的对象由由</li>
<li>线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的LockRecord，假设CAS修改成功，则获取得到轻量级锁</li>
<li>假设修改失败，则自旋（重试），自旋一定次数后，则升级为重量级锁</li>
<li>简单总结一下<ul>
<li>synchronized锁原来只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗十分明显</li>
<li>重量级锁用到monitor对象而偏向锁则在Mark Word记录线程ID进行比对、轻量级锁则是拷贝Mark Word到Lock Record，用CAS+自旋的方式获取。</li>
</ul>
</li>
<li>引入了偏向锁和轻量级锁，就是为了在不同的使用场景使用不同的锁，进而提高效率。<br>锁只有升级，没有降级<ul>
<li>只有一个线程进入临界区，偏向锁</li>
<li>多个线程交替进入临界区，轻量级锁</li>
<li>多线程同时进入临界区，重量级锁</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>8、【对线面试官】AQS &amp; ReentrantLock</title>
    <url>/posts/3c567306/</url>
    <content><![CDATA[<h1 id="8、【对线面试官】AQS-amp-ReentrantLock"><a href="#8、【对线面试官】AQS-amp-ReentrantLock" class="headerlink" title="8、【对线面试官】AQS &amp; ReentrantLock"></a>8、【对线面试官】AQS &amp; ReentrantLock</h1><h2 id="今天我们来聊聊lock锁吧？"><a href="#今天我们来聊聊lock锁吧？" class="headerlink" title="今天我们来聊聊lock锁吧？"></a>今天我们来聊聊lock锁吧？</h2><h2 id="你知道什么叫做公平和非公平锁吗"><a href="#你知道什么叫做公平和非公平锁吗" class="headerlink" title="你知道什么叫做公平和非公平锁吗"></a>你知道什么叫做公平和非公平锁吗</h2><ol>
<li>公平锁指的就是：在竞争环境下，先到临界区的线程比后到的线程一定更快地获取得到锁</li>
<li>那非公平就很好理解了：先到临界区的线程未必比后到的线程更快地获取得到锁</li>
</ol>
<h2 id="如果让你实现的话，你怎么实现公平和非公平锁？"><a href="#如果让你实现的话，你怎么实现公平和非公平锁？" class="headerlink" title="如果让你实现的话，你怎么实现公平和非公平锁？"></a>如果让你实现的话，你怎么实现公平和非公平锁？</h2><ol>
<li>公平锁可以把竞争的线程放在一个先进先出的队列上</li>
<li>只要持有锁的线程执行完了，唤醒队列的下一个线程去获取锁就好了</li>
<li>非公平锁的概念上面已经提到了：后到的线程可能比前到临界区的线程获取得到锁</li>
<li>那实现也很简单，线程先尝试能不能获取得到锁，如果获取得到锁了就执行同步代码了</li>
<li>如果获取不到锁，那就再把这个线程放到队列呗</li>
<li>所以公平和非公平的区别就是：线程执行同步代码块时，是否会去尝试获取锁。</li>
<li>如果会尝试获取锁，那就是非公平的。如果不会尝试获取锁，直接进队列，再等待唤醒，那就是公平的。</li>
</ol>
<h2 id="为什么要进队列呢？线程一直尝试获取锁不就行了么？"><a href="#为什么要进队列呢？线程一直尝试获取锁不就行了么？" class="headerlink" title="为什么要进队列呢？线程一直尝试获取锁不就行了么？"></a>为什么要进队列呢？线程一直尝试获取锁不就行了么？</h2><ol>
<li>一直尝试获取锁，专业点就叫做自旋，需要耗费资源的。</li>
<li>多个线程一直在自旋，而且大多数都是竞争失败的，哪有人会这样实现的</li>
<li>不会吧，不会吧，你不会就是这样实现的吧</li>
</ol>
<h2 id="那上次面试所问的synchronized锁是公平的还是非公平的？"><a href="#那上次面试所问的synchronized锁是公平的还是非公平的？" class="headerlink" title="那上次面试所问的synchronized锁是公平的还是非公平的？"></a>那上次面试所问的synchronized锁是公平的还是非公平的？</h2><ol>
<li>非公平的。</li>
<li>偏向锁很好理解，如果当前线程ID与markword存储的不相等，则CAS尝试更换线程ID，CAS成功就获取得到锁了</li>
<li>CAS失败则升级为轻量级锁</li>
<li>轻量级锁实际上也是通过CAS来抢占锁资源（只不过多了拷贝Mark Word到Lock Record的过程）</li>
<li>抢占成功到锁就归属给该线程了，但自旋失败一定次数后升级重量级锁</li>
<li>重量级锁通过monitor对象中的队列存储线程，但线程进入队列前，还是会先尝试获取得到锁，如果能获取不到才进入线程等待队列中</li>
<li>综上所述，synchronized无论处理哪种锁，都是先尝试获取，获取不到才升级||放到队列上的，所以是非公平的</li>
</ol>
<h2 id="嗯，讲得挺仔细的。AQS你了解吗？"><a href="#嗯，讲得挺仔细的。AQS你了解吗？" class="headerlink" title="嗯，讲得挺仔细的。AQS你了解吗？"></a>嗯，讲得挺仔细的。AQS你了解吗？</h2><ol>
<li>嗯嗯，AQS全称叫做AbstractQueuedSynchronizer</li>
<li>是可以给我们实现锁的一个 「框架」，内部实现的关键就是维护了一个先进先出的队列以及state状态变量</li>
<li>先进先出队列存储的载体叫做Node节点，该节点标识着当前的状态值、是独占还是共享模式以及它的前驱和后继节点等等信息</li>
<li>简单理解就是：AQS定义了模板，具体实现由各个子类完成。</li>
<li>总体的流程可以总结为：会把需要等待的线程以Node的形式放到这个先进先出的队列上，state变量则表示为当前锁的状态。</li>
<li>像ReentrantLock、 ReentrantReadWrite Lock、 CountDownLatch、 Semaphore 这些常用的实现类都是基于AQS实现的</li>
<li>AQS支持两种模式：独占（锁只会被一个线程独占）和共享（多个线程可同时执行）</li>
</ol>
<h2 id="你以ReentrantLock来讲讲加锁和解锁的过程呗"><a href="#你以ReentrantLock来讲讲加锁和解锁的过程呗" class="headerlink" title="你以ReentrantLock来讲讲加锁和解锁的过程呗"></a>你以ReentrantLock来讲讲加锁和解锁的过程呗</h2><ul>
<li>以非公平锁为了，我们在外界调用lock方法的时候，源码是这样实现的<ol>
<li>CAS尝试获取锁，获取成功则可以执行同步代码</li>
<li>CAS获取失败，则调用acquire方法acquire方法实际上就是AQS的模板方法</li>
<li>acquire首先会调用子类的tryAcquire 方法（又回到了ReentrantLock中）</li>
<li>tryAcquire方法实际上会判断当前的state是否等于0，等于0说明没有线程持有锁，则又尝试CAS直接获取锁</li>
<li>如果CAS获取成功，则可以执行同步代码</li>
<li>如果CAS获取失败，那判断当前线程是否就持有锁，如果是持有的锁，那更新state的值，获取得到锁（这里其实就是处理可重入的逻辑）</li>
<li>CAS失败&amp;&amp;非重入的情况，则回到try Acquire方法执行「入队列」的操作</li>
<li>将节点入队列之后，会判断「前驱节点」是不是头节点，如果是头结点又会用CAS尝试获取锁</li>
<li>如果是「前驱节点」是头节点并获取得到锁，则把当前节点设置为头结点，并且将前驱节点置空（实际上就是原有的头节点已经释放锁了）</li>
<li>没获取得到锁，则判断前驱节点的状态是否为SIGNAL，如果不是，则找到合法的前驱节点，并使用CAS将状态设置为SIGNAL</li>
<li>最后调用park将当前线程挂起</li>
</ol>
</li>
</ul>
<h2 id="你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。"><a href="#你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。" class="headerlink" title="你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。"></a>你说了一大堆，麻烦使用压缩算法压缩下加锁的过程。</h2><p>压缩后：当线程CAS获取锁失败，将当前线程入队列，把前驱节点状态设置为SIGNAL状态，并将自己挂起。</p>
<h2 id="为什么要设置前驱节点为-SIGNAL状态，有啥用？"><a href="#为什么要设置前驱节点为-SIGNAL状态，有啥用？" class="headerlink" title="为什么要设置前驱节点为 SIGNAL状态，有啥用？"></a>为什么要设置前驱节点为 SIGNAL状态，有啥用？</h2><ol>
<li>其实就是表示后继节点需要被唤醒,你咋啥都不知道啊？跟你沟通有点烦.我先把解锁的过程说下吧<ul>
<li>外界调用unlock方法时，实际上会调用AQS的release方法，而release方法会调用子类tryRelease方法（又回到了ReentrantLock中）</li>
<li>tryRelease会把state一直减（锁重入可使state&gt;1），直至到0，说明当前线程已经把锁释放了</li>
<li>随后从队尾往前找节点状态需要&lt;0，并离头节点最近的节点进行唤醒</li>
</ul>
</li>
<li>唤醒之后，被唤醒的线程则尝试使用CAS获取锁，假设获取锁得到则把头节点给干掉，把自己设置为头节点成</li>
<li>解锁的逻辑非常简单哈</li>
<li>压缩一下：把state置0，唤醒头结点下一个合法的节点，被唤醒的节点线程自然就会去获取锁</li>
<li>回到上一个问题，为什么要设置前驱节点为SIGNAL状态</li>
<li>其实归终结底就是为了判断节点的状态，去做些处理。</li>
<li>Node中节点的状态有4种，分别是：CA NCELLED(1)、 SIGNAL(-1)、 CONDITI ON（-2）、 PROPAGATE（-3）和0。</li>
<li>在ReentrantLock解锁的时候，会判断节点的状态是否小于0，小于等于0才说明需要被唤醒</li>
<li>另外一提的是：公平锁的实现与非公平锁是很像的，只不过在获取锁时不会直接尝试使用CAS来获取锁。</li>
<li>只有当队列没节点并且state为0时才会去获取锁，不然都会把当前线程放到队列中</li>
</ol>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/eK7qe3_20211027174549.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>9、【对线面试官】线程池</title>
    <url>/posts/ac3dc3bf/</url>
    <content><![CDATA[<h1 id="9、【对线面试官】线程池"><a href="#9、【对线面试官】线程池" class="headerlink" title="9、【对线面试官】线程池"></a>9、【对线面试官】线程池</h1><h2 id="今天来聊聊线程池呗，你对Java线程池了解多少？"><a href="#今天来聊聊线程池呗，你对Java线程池了解多少？" class="headerlink" title="今天来聊聊线程池呗，你对Java线程池了解多少？"></a>今天来聊聊线程池呗，你对Java线程池了解多少？</h2><h2 id="或者换个问法：为什么需要线程池？"><a href="#或者换个问法：为什么需要线程池？" class="headerlink" title="或者换个问法：为什么需要线程池？"></a>或者换个问法：为什么需要线程池？</h2><ol>
<li>JVM在HotSpot的线程模型下，Java线程会一对一映射为内核线程</li>
<li>这意味着，在Java中每次创建以及回收线程都会去内核创建以及回收</li>
<li>这就有可能导致：创建和销毁线程所花费的时间和资源可能比处理的任务花费的时间和资源要更多</li>
<li>线程池的出现是为了提高线程的复用性以及固定线程的数量！！！</li>
</ol>
<h2 id="你在项目中用到了线程池吗？"><a href="#你在项目中用到了线程池吗？" class="headerlink" title="你在项目中用到了线程池吗？"></a>你在项目中用到了线程池吗？</h2><ol>
<li>嗯，用到的。我先说下背景吧</li>
<li>我所负责的项目是消息管理平台，提供其中一个功能就是：运营会圈定人群，然后群发消息</li>
<li>主要流程大致就是：创建模板-》定时-》群发消息-》用户收到消息</li>
<li>运营圈定的人群实际上在模板上只是一个ID，我这边要通过ID去获取到HDFS文件</li>
<li>对HDFS文件进行遍历，然后继续往下发</li>
<li>「接收到定时任务，再对HDFS进行遍历」这里的处理，我用的就是线程池处理</li>
</ol>
<h2 id="为什么选择用线程池呢？"><a href="#为什么选择用线程池呢？" class="headerlink" title="为什么选择用线程池呢？"></a>为什么选择用线程池呢？</h2><ol>
<li>HDFS遍历其实就是IO的操作，我把这个过程给异步化，为了提高系统的吞吐量，于是我这里用的线程池。</li>
<li>即便遍历HDFS出现问题，我这边都有完备的监控和告警可以及时发现。</li>
</ol>
<h2 id="那你是怎么用线程池的呢？用Executors去创建的吗？"><a href="#那你是怎么用线程池的呢？用Executors去创建的吗？" class="headerlink" title="那你是怎么用线程池的呢？用Executors去创建的吗？"></a>那你是怎么用线程池的呢？用Executors去创建的吗？</h2><ol>
<li>不是的，我这边用的ThreadPoolExecutor去创建线程池</li>
<li>其实看阿里巴巴开发手册就有提到，不要使用Executors去创建线程。</li>
<li>最主要的目的就是：使用ThreadPoolExecutor创建的线程你是更能了解线程池运行的规则，避免资源耗尽的风险</li>
<li>ThreadPoolExecutor在构造的时候有几个重要的参数，分别是：<br>corePoolSize （核心线程数量） 、maxim umPoolSize（最大线程数量）、keepAli veTime（线程空余时间） 、workQueue（阻塞队列）、handler（任务拒绝策略）</li>
<li>这几个参数应该很好理解哈，我就说下任务提交的流程，分别对应着几个参数的作用吧。<ul>
<li>首先会判断运行线程数是否小于corePoolSize，如果小于，则直接创建新的线程执行任务</li>
<li>如果大于corePoolSize，判断workQueue阻塞队列是否已满，如果还没满，则将任务放到阻塞队列中</li>
<li>如果workQueue阻塞队列已经满了，则判断当前线程数是否大于maximumPoolSize，如果没大于则创建新的线程执行任务</li>
<li>如果大于maximumPoolSize，则执行任务拒绝策略（具体就是你自己实现的handler)</li>
</ul>
</li>
<li>这里有个点需要注意下，就是workQueu e阻塞队列满了，但当前线程数小于maximumPoolSize，这时候会创建新的线程执行任务</li>
<li>源码就是这样实现的</li>
<li>不过一般我们都是将corePoolSize和maximumPoolSize设置相同数量</li>
<li>keepAliveTime指的就是，当前运行的线程数大于核心线程数了，只要空闲时间达到了，就会对线程进行回收</li>
</ol>
<h2 id="那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。"><a href="#那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。" class="headerlink" title="那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。"></a>那我再问一个问题，你创建线程池肯定会指定线程数的嘛，你这块是怎么考量的。</h2><ol>
<li>线程池指定线程数这块，首先要考量自己的业务是什么样的</li>
<li>是cpu密集型的还是io密集型的，假设运行应用的机器CPU核心数是N</li>
<li>那cpu密集型的可以先给到N+1，io密集型的可以给到2N去试试</li>
<li>上面这个只是一个常见的经验做法，具体究竟开多少线程，需要压测才能比较准确地定下来</li>
<li>线程不是说越大越好，在之前的面试我也提到过，多线程是为了充分利用CPU的资源</li>
<li>如果设置的线程过多，线程大量有上下文切换，这一部分也会带来系统的开销，这就得不偿失了</li>
</ol>
<h2 id="ThreadPoolExecutor你看过源码吗？"><a href="#ThreadPoolExecutor你看过源码吗？" class="headerlink" title="ThreadPoolExecutor你看过源码吗？"></a>ThreadPoolExecutor你看过源码吗？</h2><ol>
<li>看过的，其实上面说的ThreadPoolExecutor几个参数，在源码的顶部注释都有</li>
<li>在执行的时候，重点就在于它维护了一个ctl参数，这个ctl参数的用高3位表示线程池的状态，低29位来表示线程的数量</li>
<li>里边用到了大量的位运算符操作，具体细节我就忘了，但是流程还是上面所讲的</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官“谈谈Spring中都用到了那些设计模式”。</title>
    <url>/posts/eb551b6f/</url>
    <content><![CDATA[<h1 id="面试官-“谈谈Spring中都用到了那些设计模式-”。"><a href="#面试官-“谈谈Spring中都用到了那些设计模式-”。" class="headerlink" title="面试官:“谈谈Spring中都用到了那些设计模式?”。"></a>面试官:“谈谈Spring中都用到了那些设计模式?”。</h1><p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。</p>
<p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>
<h2 id="控制反转-IoC-和依赖注入-DI"><a href="#控制反转-IoC-和依赖注入-DI" class="headerlink" title="控制反转(IoC)和依赖注入(DI)"></a>控制反转(IoC)和依赖注入(DI)</h2><p><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwBuibJ4N5OTyAvJibFj8b7zhiaTcnFwmnfLqQQWwlWv2uNMZyiabexkUSuW24WAWAuL6cvzguu8JyYzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<center>ioc-patterns</center>

<p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>
<p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a> ，非常不错。</p>
<p><strong>控制翻转怎么理解呢?</strong> 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</p>
<p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>
<h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(</span><br><span class="line">                <span class="string">&quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloApplicationContext</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloApplicationContext) context.getBean(<span class="string">&quot;helloApplicationContext&quot;</span>);</span><br><span class="line">        obj.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml:<bean id="userService" class="top.snailclimb.UserService" scope="singleton"/>&#96;&#96;</li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ul>
<p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h2><h3 id="代理模式在-AOP-中的应用"><a href="#代理模式在-AOP-中的应用" class="headerlink" title="代理模式在 AOP 中的应用"></a>代理模式在 AOP 中的应用</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/16qDep_20210809142649.png" alt="图片"></p>
<center>SpringAOPProcess</center>

<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7MhBrj_20210809142855.png" alt="图片"></p>
<center>模板方法UML图</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="comment">//这是我们的模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">TemplateMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        PrimitiveOperation1();  </span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        PrimitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span>  <span class="title function_">PrimitiveOperation1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被子类实现的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation3</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateImpl</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3 id="Spring-事件驱动模型中的三种角色"><a href="#Spring-事件驱动模型中的三种角色" class="headerlink" title="Spring 事件驱动模型中的三种角色"></a>Spring 事件驱动模型中的三种角色</h3><h4 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h4><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/tKwbDY_20210809143054.png" alt="图片"></p>
<center>ApplicationEvent-Subclass</center>

<h4 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h4><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h4><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p>
<h3 id="Spring-的事件流程总结"><a href="#Spring-的事件流程总结" class="headerlink" title="Spring 的事件流程总结"></a>Spring 的事件流程总结</h3><ol>
<li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li>
<li>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoEvent</span><span class="params">(Object source,String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;DemoEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(DemoEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息是：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">DemoEvent</span>(<span class="built_in">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h3 id="spring-AOP中的适配器模式"><a href="#spring-AOP中的适配器模式" class="headerlink" title="spring AOP中的适配器模式"></a>spring AOP中的适配器模式</h3><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<h3 id="spring-MVC中的适配器模式"><a href="#spring-MVC中的适配器模式" class="headerlink" title="spring MVC中的适配器模式"></a>spring MVC中的适配器模式</h3><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p>
<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TRTmlJ_20210809143212.png" alt="图片"></p>
<center>
  装饰者模式示意图
</center>

<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 框架中用到了哪些设计模式：</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring技术内幕》</li>
<li><a href="https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/">https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/</a></li>
<li><a href="http://blog.yeamin.top/2018/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Spring%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/</a></li>
<li><a href="https://www.tutorialsteacher.com/ioc/inversion-of-control">https://www.tutorialsteacher.com/ioc/inversion-of-control</a></li>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></li>
<li><a href="https://juejin.im/post/5a8eb261f265da4e9e307230">https://juejin.im/post/5a8eb261f265da4e9e307230</a></li>
<li><a href="https://juejin.im/post/5ba28986f265da0abc2b6084">https://juejin.im/post/5ba28986f265da0abc2b6084</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
